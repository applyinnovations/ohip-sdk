/*
OPERA Cloud Export Configuration API

APIs catering to the managing export master data configuration. The exports feature in OPERA Cloud provides the ability to create and export data files, such as back office data, to third-party interfaces and receiving systems.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package expcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ExportApiService ExportApi service
type ExportApiService service

type ExportApiChangeExportSchedulesRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	hotelId string
	exportFileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	exportSchedulesToBeChanged *ChangeExportSchedulesByChainRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiChangeExportSchedulesRequest) Authorization(authorization string) ExportApiChangeExportSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiChangeExportSchedulesRequest) XAppKey(xAppKey string) ExportApiChangeExportSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiChangeExportSchedulesRequest) XHotelid(xHotelid string) ExportApiChangeExportSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing export schedules
func (r ExportApiChangeExportSchedulesRequest) ExportSchedulesToBeChanged(exportSchedulesToBeChanged ChangeExportSchedulesByChainRequest) ExportApiChangeExportSchedulesRequest {
	r.exportSchedulesToBeChanged = &exportSchedulesToBeChanged
	return r
}

// External system code.
func (r ExportApiChangeExportSchedulesRequest) XExternalsystem(xExternalsystem string) ExportApiChangeExportSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiChangeExportSchedulesRequest) AcceptLanguage(acceptLanguage string) ExportApiChangeExportSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiChangeExportSchedulesRequest) Execute() (*ExportSchedulesStatus, *http.Response, error) {
	return r.ApiService.ChangeExportSchedulesExecute(r)
}

/*
ChangeExportSchedules Operation to change export schedules.

Use this API to update export schedules for a specific property based on the hotelId, exportFileId, exportSchedulesToBeChanged. <p><strong>OperationId:</strong>changeExportSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @param exportFileId Unique ID of export file.
 @return ExportApiChangeExportSchedulesRequest
*/
func (a *ExportApiService) ChangeExportSchedules(ctx context.Context, hotelId string, exportFileId string) ExportApiChangeExportSchedulesRequest {
	return ExportApiChangeExportSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		exportFileId: exportFileId,
	}
}

// Execute executes the request
//  @return ExportSchedulesStatus
func (a *ExportApiService) ChangeExportSchedulesExecute(r ExportApiChangeExportSchedulesRequest) (*ExportSchedulesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportSchedulesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.ChangeExportSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exportSchedules/{exportFileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"exportFileId"+"}", url.PathEscape(parameterValueToString(r.exportFileId, "exportFileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.exportFileId) < 1 {
		return localVarReturnValue, nil, reportError("exportFileId must have at least 1 elements")
	}
	if strlen(r.exportFileId) > 2000 {
		return localVarReturnValue, nil, reportError("exportFileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exportSchedulesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiChangeExportSchedulesByChainRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	exportFileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	exportSchedulesToBeChanged *ChangeExportSchedulesByChainRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiChangeExportSchedulesByChainRequest) Authorization(authorization string) ExportApiChangeExportSchedulesByChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiChangeExportSchedulesByChainRequest) XAppKey(xAppKey string) ExportApiChangeExportSchedulesByChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiChangeExportSchedulesByChainRequest) XHotelid(xHotelid string) ExportApiChangeExportSchedulesByChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing export schedules
func (r ExportApiChangeExportSchedulesByChainRequest) ExportSchedulesToBeChanged(exportSchedulesToBeChanged ChangeExportSchedulesByChainRequest) ExportApiChangeExportSchedulesByChainRequest {
	r.exportSchedulesToBeChanged = &exportSchedulesToBeChanged
	return r
}

// External system code.
func (r ExportApiChangeExportSchedulesByChainRequest) XExternalsystem(xExternalsystem string) ExportApiChangeExportSchedulesByChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiChangeExportSchedulesByChainRequest) AcceptLanguage(acceptLanguage string) ExportApiChangeExportSchedulesByChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiChangeExportSchedulesByChainRequest) Execute() (*ExportSchedulesStatus, *http.Response, error) {
	return r.ApiService.ChangeExportSchedulesByChainExecute(r)
}

/*
ChangeExportSchedulesByChain Operation to change export schedules.

Use this API to update export schedules for all hotels in a chain based on the exportFileIdId and exportSchedulesToBeChanged. <p><strong>OperationId:</strong>changeExportSchedulesByChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exportFileId Unique ID of export file.
 @return ExportApiChangeExportSchedulesByChainRequest
*/
func (a *ExportApiService) ChangeExportSchedulesByChain(ctx context.Context, exportFileId string) ExportApiChangeExportSchedulesByChainRequest {
	return ExportApiChangeExportSchedulesByChainRequest{
		ApiService: a,
		ctx: ctx,
		exportFileId: exportFileId,
	}
}

// Execute executes the request
//  @return ExportSchedulesStatus
func (a *ExportApiService) ChangeExportSchedulesByChainExecute(r ExportApiChangeExportSchedulesByChainRequest) (*ExportSchedulesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportSchedulesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.ChangeExportSchedulesByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exportSchedules/{exportFileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"exportFileId"+"}", url.PathEscape(parameterValueToString(r.exportFileId, "exportFileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.exportFileId) < 1 {
		return localVarReturnValue, nil, reportError("exportFileId must have at least 1 elements")
	}
	if strlen(r.exportFileId) > 2000 {
		return localVarReturnValue, nil, reportError("exportFileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exportSchedulesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiDeleteExistingExportMappingsRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	exportMappingId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiDeleteExistingExportMappingsRequest) Authorization(authorization string) ExportApiDeleteExistingExportMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiDeleteExistingExportMappingsRequest) XAppKey(xAppKey string) ExportApiDeleteExistingExportMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiDeleteExistingExportMappingsRequest) XHotelid(xHotelid string) ExportApiDeleteExistingExportMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ExportApiDeleteExistingExportMappingsRequest) XExternalsystem(xExternalsystem string) ExportApiDeleteExistingExportMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiDeleteExistingExportMappingsRequest) AcceptLanguage(acceptLanguage string) ExportApiDeleteExistingExportMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiDeleteExistingExportMappingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteExistingExportMappingsExecute(r)
}

/*
DeleteExistingExportMappings Operation to remove export mappings.

Use this API to delete export mappings for a specific property based on the exportMappingId and the hotelId. <p><strong>OperationId:</strong>deleteExistingExportMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exportMappingId Export Mapping Id.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ExportApiDeleteExistingExportMappingsRequest
*/
func (a *ExportApiService) DeleteExistingExportMappings(ctx context.Context, exportMappingId string, hotelId string) ExportApiDeleteExistingExportMappingsRequest {
	return ExportApiDeleteExistingExportMappingsRequest{
		ApiService: a,
		ctx: ctx,
		exportMappingId: exportMappingId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ExportApiService) DeleteExistingExportMappingsExecute(r ExportApiDeleteExistingExportMappingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.DeleteExistingExportMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exportMappingId/{exportMappingId}/exportMappings"
	localVarPath = strings.Replace(localVarPath, "{"+"exportMappingId"+"}", url.PathEscape(parameterValueToString(r.exportMappingId, "exportMappingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.exportMappingId) < 1 {
		return localVarReturnValue, nil, reportError("exportMappingId must have at least 1 elements")
	}
	if strlen(r.exportMappingId) > 2000 {
		return localVarReturnValue, nil, reportError("exportMappingId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiDeleteExportMappingCodesRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	mappingTypeCode string
	exportMappingId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiDeleteExportMappingCodesRequest) Authorization(authorization string) ExportApiDeleteExportMappingCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiDeleteExportMappingCodesRequest) XAppKey(xAppKey string) ExportApiDeleteExportMappingCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiDeleteExportMappingCodesRequest) XHotelid(xHotelid string) ExportApiDeleteExportMappingCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ExportApiDeleteExportMappingCodesRequest) XExternalsystem(xExternalsystem string) ExportApiDeleteExportMappingCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiDeleteExportMappingCodesRequest) AcceptLanguage(acceptLanguage string) ExportApiDeleteExportMappingCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiDeleteExportMappingCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteExportMappingCodesExecute(r)
}

/*
DeleteExportMappingCodes Operation to remove export mapping codes.

 <p><strong>OperationId:</strong>deleteExportMappingCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mappingTypeCode Mapping Type Code.
 @param exportMappingId Export Mapping Id.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ExportApiDeleteExportMappingCodesRequest
*/
func (a *ExportApiService) DeleteExportMappingCodes(ctx context.Context, mappingTypeCode string, exportMappingId string, hotelId string) ExportApiDeleteExportMappingCodesRequest {
	return ExportApiDeleteExportMappingCodesRequest{
		ApiService: a,
		ctx: ctx,
		mappingTypeCode: mappingTypeCode,
		exportMappingId: exportMappingId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ExportApiService) DeleteExportMappingCodesExecute(r ExportApiDeleteExportMappingCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.DeleteExportMappingCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exportMappings/{exportMappingId}/mappingTypes/{mappingTypeCode}/exportMappingCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"mappingTypeCode"+"}", url.PathEscape(parameterValueToString(r.mappingTypeCode, "mappingTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"exportMappingId"+"}", url.PathEscape(parameterValueToString(r.exportMappingId, "exportMappingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.mappingTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("mappingTypeCode must have at least 1 elements")
	}
	if strlen(r.mappingTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("mappingTypeCode must have less than 2000 elements")
	}
	if strlen(r.exportMappingId) < 1 {
		return localVarReturnValue, nil, reportError("exportMappingId must have at least 1 elements")
	}
	if strlen(r.exportMappingId) > 2000 {
		return localVarReturnValue, nil, reportError("exportMappingId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiGetExportActivityLogRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	hotelId string
	activityType *string
	fromDate *string
	toDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	module *string
	parameterName *[]string
	parameterValue *[]string
	activityGroup *string
	searchText *string
	userByIds *[]int32
	userForIds *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

func (r ExportApiGetExportActivityLogRequest) ActivityType(activityType string) ExportApiGetExportActivityLogRequest {
	r.activityType = &activityType
	return r
}

// Search from date for the user activity log.
func (r ExportApiGetExportActivityLogRequest) FromDate(fromDate string) ExportApiGetExportActivityLogRequest {
	r.fromDate = &fromDate
	return r
}

// Search to date for the user activity log.
func (r ExportApiGetExportActivityLogRequest) ToDate(toDate string) ExportApiGetExportActivityLogRequest {
	r.toDate = &toDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiGetExportActivityLogRequest) Authorization(authorization string) ExportApiGetExportActivityLogRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiGetExportActivityLogRequest) XAppKey(xAppKey string) ExportApiGetExportActivityLogRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiGetExportActivityLogRequest) XHotelid(xHotelid string) ExportApiGetExportActivityLogRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ExportApiGetExportActivityLogRequest) Limit(limit int32) ExportApiGetExportActivityLogRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ExportApiGetExportActivityLogRequest) Offset(offset int32) ExportApiGetExportActivityLogRequest {
	r.offset = &offset
	return r
}

// Activity module.
func (r ExportApiGetExportActivityLogRequest) Module(module string) ExportApiGetExportActivityLogRequest {
	r.module = &module
	return r
}

// Name of the parameter.
func (r ExportApiGetExportActivityLogRequest) ParameterName(parameterName []string) ExportApiGetExportActivityLogRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ExportApiGetExportActivityLogRequest) ParameterValue(parameterValue []string) ExportApiGetExportActivityLogRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r ExportApiGetExportActivityLogRequest) ActivityGroup(activityGroup string) ExportApiGetExportActivityLogRequest {
	r.activityGroup = &activityGroup
	return r
}

// Search text for the user activity log.
func (r ExportApiGetExportActivityLogRequest) SearchText(searchText string) ExportApiGetExportActivityLogRequest {
	r.searchText = &searchText
	return r
}

func (r ExportApiGetExportActivityLogRequest) UserByIds(userByIds []int32) ExportApiGetExportActivityLogRequest {
	r.userByIds = &userByIds
	return r
}

func (r ExportApiGetExportActivityLogRequest) UserForIds(userForIds []int32) ExportApiGetExportActivityLogRequest {
	r.userForIds = &userForIds
	return r
}

// External system code.
func (r ExportApiGetExportActivityLogRequest) XExternalsystem(xExternalsystem string) ExportApiGetExportActivityLogRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiGetExportActivityLogRequest) AcceptLanguage(acceptLanguage string) ExportApiGetExportActivityLogRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiGetExportActivityLogRequest) Execute() (*ExportActivityLog, *http.Response, error) {
	return r.ApiService.GetExportActivityLogExecute(r)
}

/*
GetExportActivityLog Operation to fetch activity logs for Export Data.

Use this API to return activity logs for export data for a specific property based on search criteria such as hotelId, activityType, fromDate, toDate, limit, offset, module, parameterName, parameterValue, activityGroup, searchText, userByIds, userForIds.  <p><strong>OperationId:</strong>getExportActivityLog</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ExportApiGetExportActivityLogRequest
*/
func (a *ExportApiService) GetExportActivityLog(ctx context.Context, hotelId string) ExportApiGetExportActivityLogRequest {
	return ExportApiGetExportActivityLogRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ExportActivityLog
func (a *ExportApiService) GetExportActivityLogExecute(r ExportApiGetExportActivityLogRequest) (*ExportActivityLog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportActivityLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.GetExportActivityLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exportActivityLog"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", r.activityType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.module != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "module", r.module, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.activityGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityGroup", r.activityGroup, "")
	}
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "")
	}
	if r.userByIds != nil {
		t := *r.userByIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userByIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userByIds", t, "multi")
		}
	}
	if r.userForIds != nil {
		t := *r.userForIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userForIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userForIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiGetExportColumnsAndFunctionsRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchDbColumns *bool
	fetchOperaApis *bool
	fetchPrePostProcedures *bool
	dataSource *string
	exportFileId *string
	category *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiGetExportColumnsAndFunctionsRequest) Authorization(authorization string) ExportApiGetExportColumnsAndFunctionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiGetExportColumnsAndFunctionsRequest) XAppKey(xAppKey string) ExportApiGetExportColumnsAndFunctionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiGetExportColumnsAndFunctionsRequest) XHotelid(xHotelid string) ExportApiGetExportColumnsAndFunctionsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ExportApiGetExportColumnsAndFunctionsRequest) FetchDbColumns(fetchDbColumns bool) ExportApiGetExportColumnsAndFunctionsRequest {
	r.fetchDbColumns = &fetchDbColumns
	return r
}

func (r ExportApiGetExportColumnsAndFunctionsRequest) FetchOperaApis(fetchOperaApis bool) ExportApiGetExportColumnsAndFunctionsRequest {
	r.fetchOperaApis = &fetchOperaApis
	return r
}

func (r ExportApiGetExportColumnsAndFunctionsRequest) FetchPrePostProcedures(fetchPrePostProcedures bool) ExportApiGetExportColumnsAndFunctionsRequest {
	r.fetchPrePostProcedures = &fetchPrePostProcedures
	return r
}

// Data source for which we are supposed to get columns and pre post procedures
func (r ExportApiGetExportColumnsAndFunctionsRequest) DataSource(dataSource string) ExportApiGetExportColumnsAndFunctionsRequest {
	r.dataSource = &dataSource
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ExportApiGetExportColumnsAndFunctionsRequest) ExportFileId(exportFileId string) ExportApiGetExportColumnsAndFunctionsRequest {
	r.exportFileId = &exportFileId
	return r
}

// Enumeration of API Categories.
func (r ExportApiGetExportColumnsAndFunctionsRequest) Category(category string) ExportApiGetExportColumnsAndFunctionsRequest {
	r.category = &category
	return r
}

// External system code.
func (r ExportApiGetExportColumnsAndFunctionsRequest) XExternalsystem(xExternalsystem string) ExportApiGetExportColumnsAndFunctionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiGetExportColumnsAndFunctionsRequest) AcceptLanguage(acceptLanguage string) ExportApiGetExportColumnsAndFunctionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiGetExportColumnsAndFunctionsRequest) Execute() (*ExportColumnsAndFunctionsDetails, *http.Response, error) {
	return r.ApiService.GetExportColumnsAndFunctionsExecute(r)
}

/*
GetExportColumnsAndFunctions Operation to fetch export columns and functions.

Use this API to return export columns and functions based on search criteria such as fetchDbColumns, fetchOperaApis, fetchPrePostProcedures, dataSource, exportFileId, category. <p><strong>OperationId:</strong>getExportColumnsAndFunctions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExportApiGetExportColumnsAndFunctionsRequest
*/
func (a *ExportApiService) GetExportColumnsAndFunctions(ctx context.Context) ExportApiGetExportColumnsAndFunctionsRequest {
	return ExportApiGetExportColumnsAndFunctionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportColumnsAndFunctionsDetails
func (a *ExportApiService) GetExportColumnsAndFunctionsExecute(r ExportApiGetExportColumnsAndFunctionsRequest) (*ExportColumnsAndFunctionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportColumnsAndFunctionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.GetExportColumnsAndFunctions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/columnsAndFunctions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchDbColumns != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchDbColumns", r.fetchDbColumns, "")
	}
	if r.fetchOperaApis != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchOperaApis", r.fetchOperaApis, "")
	}
	if r.fetchPrePostProcedures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchPrePostProcedures", r.fetchPrePostProcedures, "")
	}
	if r.dataSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSource", r.dataSource, "")
	}
	if r.exportFileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportFileId", r.exportFileId, "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiGetExportMappingCodesRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	exportMappingTypeId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiGetExportMappingCodesRequest) Authorization(authorization string) ExportApiGetExportMappingCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiGetExportMappingCodesRequest) XAppKey(xAppKey string) ExportApiGetExportMappingCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiGetExportMappingCodesRequest) XHotelid(xHotelid string) ExportApiGetExportMappingCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ExportApiGetExportMappingCodesRequest) XExternalsystem(xExternalsystem string) ExportApiGetExportMappingCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiGetExportMappingCodesRequest) AcceptLanguage(acceptLanguage string) ExportApiGetExportMappingCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiGetExportMappingCodesRequest) Execute() (*FetchExportMappingCodes, *http.Response, error) {
	return r.ApiService.GetExportMappingCodesExecute(r)
}

/*
GetExportMappingCodes Operation to fetch export mapping codes.

 <p><strong>OperationId:</strong>getExportMappingCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exportMappingTypeId Export Mapping Type Id.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ExportApiGetExportMappingCodesRequest
*/
func (a *ExportApiService) GetExportMappingCodes(ctx context.Context, exportMappingTypeId string, hotelId string) ExportApiGetExportMappingCodesRequest {
	return ExportApiGetExportMappingCodesRequest{
		ApiService: a,
		ctx: ctx,
		exportMappingTypeId: exportMappingTypeId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchExportMappingCodes
func (a *ExportApiService) GetExportMappingCodesExecute(r ExportApiGetExportMappingCodesRequest) (*FetchExportMappingCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchExportMappingCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.GetExportMappingCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exportMappingTypes/{exportMappingTypeId}/exportMappingCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"exportMappingTypeId"+"}", url.PathEscape(parameterValueToString(r.exportMappingTypeId, "exportMappingTypeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.exportMappingTypeId) < 1 {
		return localVarReturnValue, nil, reportError("exportMappingTypeId must have at least 1 elements")
	}
	if strlen(r.exportMappingTypeId) > 2000 {
		return localVarReturnValue, nil, reportError("exportMappingTypeId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiGetExportMappingCodesToLinkRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	configType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiGetExportMappingCodesToLinkRequest) Authorization(authorization string) ExportApiGetExportMappingCodesToLinkRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiGetExportMappingCodesToLinkRequest) XAppKey(xAppKey string) ExportApiGetExportMappingCodesToLinkRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiGetExportMappingCodesToLinkRequest) XHotelid(xHotelid string) ExportApiGetExportMappingCodesToLinkRequest {
	r.xHotelid = &xHotelid
	return r
}

// The hotel code for the codes to fetch for linking.
func (r ExportApiGetExportMappingCodesToLinkRequest) Code(code string) ExportApiGetExportMappingCodesToLinkRequest {
	r.code = &code
	return r
}

// The hotel code for the codes to fetch for linking.
func (r ExportApiGetExportMappingCodesToLinkRequest) Description(description string) ExportApiGetExportMappingCodesToLinkRequest {
	r.description = &description
	return r
}

// External system code.
func (r ExportApiGetExportMappingCodesToLinkRequest) XExternalsystem(xExternalsystem string) ExportApiGetExportMappingCodesToLinkRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiGetExportMappingCodesToLinkRequest) AcceptLanguage(acceptLanguage string) ExportApiGetExportMappingCodesToLinkRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiGetExportMappingCodesToLinkRequest) Execute() (*ExportMappingCodesToLink, *http.Response, error) {
	return r.ApiService.GetExportMappingCodesToLinkExecute(r)
}

/*
GetExportMappingCodesToLink Operation to fetch export mapping codes to link.

 <p><strong>OperationId:</strong>getExportMappingCodesToLink</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configType Configuration Type.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ExportApiGetExportMappingCodesToLinkRequest
*/
func (a *ExportApiService) GetExportMappingCodesToLink(ctx context.Context, configType string, hotelId string) ExportApiGetExportMappingCodesToLinkRequest {
	return ExportApiGetExportMappingCodesToLinkRequest{
		ApiService: a,
		ctx: ctx,
		configType: configType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ExportMappingCodesToLink
func (a *ExportApiService) GetExportMappingCodesToLinkExecute(r ExportApiGetExportMappingCodesToLinkRequest) (*ExportMappingCodesToLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportMappingCodesToLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.GetExportMappingCodesToLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/configTypes/{configType}/exportMappingCodesToLink"
	localVarPath = strings.Replace(localVarPath, "{"+"configType"+"}", url.PathEscape(parameterValueToString(r.configType, "configType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configType) < 1 {
		return localVarReturnValue, nil, reportError("configType must have at least 1 elements")
	}
	if strlen(r.configType) > 2000 {
		return localVarReturnValue, nil, reportError("configType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiGetExportMappingLinkedCodesRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	codeToLink *string
	configType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiGetExportMappingLinkedCodesRequest) Authorization(authorization string) ExportApiGetExportMappingLinkedCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiGetExportMappingLinkedCodesRequest) XAppKey(xAppKey string) ExportApiGetExportMappingLinkedCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiGetExportMappingLinkedCodesRequest) XHotelid(xHotelid string) ExportApiGetExportMappingLinkedCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ExportApiGetExportMappingLinkedCodesRequest) Id(id string) ExportApiGetExportMappingLinkedCodesRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ExportApiGetExportMappingLinkedCodesRequest) IdExtension(idExtension int32) ExportApiGetExportMappingLinkedCodesRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ExportApiGetExportMappingLinkedCodesRequest) IdContext(idContext string) ExportApiGetExportMappingLinkedCodesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ExportApiGetExportMappingLinkedCodesRequest) Type_(type_ string) ExportApiGetExportMappingLinkedCodesRequest {
	r.type_ = &type_
	return r
}

// Linked code.
func (r ExportApiGetExportMappingLinkedCodesRequest) CodeToLink(codeToLink string) ExportApiGetExportMappingLinkedCodesRequest {
	r.codeToLink = &codeToLink
	return r
}

// Enumeration  of Types allowed for Export Mapping
func (r ExportApiGetExportMappingLinkedCodesRequest) ConfigType(configType string) ExportApiGetExportMappingLinkedCodesRequest {
	r.configType = &configType
	return r
}

// External system code.
func (r ExportApiGetExportMappingLinkedCodesRequest) XExternalsystem(xExternalsystem string) ExportApiGetExportMappingLinkedCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiGetExportMappingLinkedCodesRequest) AcceptLanguage(acceptLanguage string) ExportApiGetExportMappingLinkedCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiGetExportMappingLinkedCodesRequest) Execute() (*ExportMappingLinkedCodes, *http.Response, error) {
	return r.ApiService.GetExportMappingLinkedCodesExecute(r)
}

/*
GetExportMappingLinkedCodes Operation to fetch export mapping linked codes.

 <p><strong>OperationId:</strong>getExportMappingLinkedCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ExportApiGetExportMappingLinkedCodesRequest
*/
func (a *ExportApiService) GetExportMappingLinkedCodes(ctx context.Context, hotelId string) ExportApiGetExportMappingLinkedCodesRequest {
	return ExportApiGetExportMappingLinkedCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ExportMappingLinkedCodes
func (a *ExportApiService) GetExportMappingLinkedCodesExecute(r ExportApiGetExportMappingLinkedCodesRequest) (*ExportMappingLinkedCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportMappingLinkedCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.GetExportMappingLinkedCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exportMappings/linkedCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.codeToLink != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "codeToLink", r.codeToLink, "")
	}
	if r.configType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configType", r.configType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiGetExportMappingsRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	exportMappingConfigs *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiGetExportMappingsRequest) Authorization(authorization string) ExportApiGetExportMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiGetExportMappingsRequest) XAppKey(xAppKey string) ExportApiGetExportMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiGetExportMappingsRequest) XHotelid(xHotelid string) ExportApiGetExportMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Enumeration  of Types allowed for Export Mapping
func (r ExportApiGetExportMappingsRequest) ExportMappingConfigs(exportMappingConfigs []string) ExportApiGetExportMappingsRequest {
	r.exportMappingConfigs = &exportMappingConfigs
	return r
}

// External system code.
func (r ExportApiGetExportMappingsRequest) XExternalsystem(xExternalsystem string) ExportApiGetExportMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiGetExportMappingsRequest) AcceptLanguage(acceptLanguage string) ExportApiGetExportMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiGetExportMappingsRequest) Execute() (*FetchExportMappings, *http.Response, error) {
	return r.ApiService.GetExportMappingsExecute(r)
}

/*
GetExportMappings Operation to fetch export mappings.

 <p><strong>OperationId:</strong>getExportMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ExportApiGetExportMappingsRequest
*/
func (a *ExportApiService) GetExportMappings(ctx context.Context, hotelId string) ExportApiGetExportMappingsRequest {
	return ExportApiGetExportMappingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchExportMappings
func (a *ExportApiService) GetExportMappingsExecute(r ExportApiGetExportMappingsRequest) (*FetchExportMappings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchExportMappings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.GetExportMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exportMappings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.exportMappingConfigs != nil {
		t := *r.exportMappingConfigs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exportMappingConfigs", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exportMappingConfigs", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiGetExportMappingsByChainRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	exportMappingConfigs *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiGetExportMappingsByChainRequest) Authorization(authorization string) ExportApiGetExportMappingsByChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiGetExportMappingsByChainRequest) XAppKey(xAppKey string) ExportApiGetExportMappingsByChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiGetExportMappingsByChainRequest) XHotelid(xHotelid string) ExportApiGetExportMappingsByChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ExportApiGetExportMappingsByChainRequest) HotelId(hotelId string) ExportApiGetExportMappingsByChainRequest {
	r.hotelId = &hotelId
	return r
}

// Enumeration  of Types allowed for Export Mapping
func (r ExportApiGetExportMappingsByChainRequest) ExportMappingConfigs(exportMappingConfigs []string) ExportApiGetExportMappingsByChainRequest {
	r.exportMappingConfigs = &exportMappingConfigs
	return r
}

// External system code.
func (r ExportApiGetExportMappingsByChainRequest) XExternalsystem(xExternalsystem string) ExportApiGetExportMappingsByChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiGetExportMappingsByChainRequest) AcceptLanguage(acceptLanguage string) ExportApiGetExportMappingsByChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiGetExportMappingsByChainRequest) Execute() (*FetchExportMappings, *http.Response, error) {
	return r.ApiService.GetExportMappingsByChainExecute(r)
}

/*
GetExportMappingsByChain Operation to fetch export mappings by chain.

 <p><strong>OperationId:</strong>getExportMappingsByChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExportApiGetExportMappingsByChainRequest
*/
func (a *ExportApiService) GetExportMappingsByChain(ctx context.Context) ExportApiGetExportMappingsByChainRequest {
	return ExportApiGetExportMappingsByChainRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchExportMappings
func (a *ExportApiService) GetExportMappingsByChainExecute(r ExportApiGetExportMappingsByChainRequest) (*FetchExportMappings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchExportMappings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.GetExportMappingsByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exportMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.exportMappingConfigs != nil {
		t := *r.exportMappingConfigs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exportMappingConfigs", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exportMappingConfigs", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiGetExportSchedulesRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	timeZone *string
	exportFileId *string
	idExtension *int32
	idContext *string
	type_ *string
	exportGroup *string
	exportName *string
	startDate *string
	endDate *string
	frequency *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiGetExportSchedulesRequest) Authorization(authorization string) ExportApiGetExportSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiGetExportSchedulesRequest) XAppKey(xAppKey string) ExportApiGetExportSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiGetExportSchedulesRequest) XHotelid(xHotelid string) ExportApiGetExportSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Time zone hour and minute specified in the format TZH:TZM example:-05:00
func (r ExportApiGetExportSchedulesRequest) TimeZone(timeZone string) ExportApiGetExportSchedulesRequest {
	r.timeZone = &timeZone
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ExportApiGetExportSchedulesRequest) ExportFileId(exportFileId string) ExportApiGetExportSchedulesRequest {
	r.exportFileId = &exportFileId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ExportApiGetExportSchedulesRequest) IdExtension(idExtension int32) ExportApiGetExportSchedulesRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ExportApiGetExportSchedulesRequest) IdContext(idContext string) ExportApiGetExportSchedulesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ExportApiGetExportSchedulesRequest) Type_(type_ string) ExportApiGetExportSchedulesRequest {
	r.type_ = &type_
	return r
}

// Enumeration of export file groups.
func (r ExportApiGetExportSchedulesRequest) ExportGroup(exportGroup string) ExportApiGetExportSchedulesRequest {
	r.exportGroup = &exportGroup
	return r
}

// Export name to restrict export schedules
func (r ExportApiGetExportSchedulesRequest) ExportName(exportName string) ExportApiGetExportSchedulesRequest {
	r.exportName = &exportName
	return r
}

// Start Date to restrict export schedules
func (r ExportApiGetExportSchedulesRequest) StartDate(startDate string) ExportApiGetExportSchedulesRequest {
	r.startDate = &startDate
	return r
}

// End Date to restrict export schedules
func (r ExportApiGetExportSchedulesRequest) EndDate(endDate string) ExportApiGetExportSchedulesRequest {
	r.endDate = &endDate
	return r
}

// Frequency for which export schedules needs to be returned
func (r ExportApiGetExportSchedulesRequest) Frequency(frequency string) ExportApiGetExportSchedulesRequest {
	r.frequency = &frequency
	return r
}

// Indicates whether inactive schedules needs to be returned or not
func (r ExportApiGetExportSchedulesRequest) IncludeInactive(includeInactive bool) ExportApiGetExportSchedulesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ExportApiGetExportSchedulesRequest) XExternalsystem(xExternalsystem string) ExportApiGetExportSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiGetExportSchedulesRequest) AcceptLanguage(acceptLanguage string) ExportApiGetExportSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiGetExportSchedulesRequest) Execute() (*ExportSchedulesDetails, *http.Response, error) {
	return r.ApiService.GetExportSchedulesExecute(r)
}

/*
GetExportSchedules Operation to fetch export schedules.

Use this API to return export schedules for a specific property based on search criteria such as hotelId, timeZone, exportFileId, idExtension, idContext, type, exportGroup, exportName, startDate, endDate, frequency, includeInactive.  <p><strong>OperationId:</strong>getExportSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ExportApiGetExportSchedulesRequest
*/
func (a *ExportApiService) GetExportSchedules(ctx context.Context, hotelId string) ExportApiGetExportSchedulesRequest {
	return ExportApiGetExportSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ExportSchedulesDetails
func (a *ExportApiService) GetExportSchedulesExecute(r ExportApiGetExportSchedulesRequest) (*ExportSchedulesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportSchedulesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.GetExportSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exportSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.timeZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeZone", r.timeZone, "")
	}
	if r.exportFileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportFileId", r.exportFileId, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.exportGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportGroup", r.exportGroup, "")
	}
	if r.exportName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportName", r.exportName, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.frequency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "frequency", r.frequency, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiGetExportsAvailableRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchColumns *bool
	fetchDataSetup *bool
	fetchDestinationSetup *bool
	fetchGenerateConfiguration *bool
	limit *int32
	exportFileId *string
	idExtension *int32
	idContext *string
	type_ *string
	hotelIds *[]string
	fileGroup *string
	includeInactive *bool
	match *string
	includeComponents *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiGetExportsAvailableRequest) Authorization(authorization string) ExportApiGetExportsAvailableRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiGetExportsAvailableRequest) XAppKey(xAppKey string) ExportApiGetExportsAvailableRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiGetExportsAvailableRequest) XHotelid(xHotelid string) ExportApiGetExportsAvailableRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ExportApiGetExportsAvailableRequest) FetchColumns(fetchColumns bool) ExportApiGetExportsAvailableRequest {
	r.fetchColumns = &fetchColumns
	return r
}

func (r ExportApiGetExportsAvailableRequest) FetchDataSetup(fetchDataSetup bool) ExportApiGetExportsAvailableRequest {
	r.fetchDataSetup = &fetchDataSetup
	return r
}

func (r ExportApiGetExportsAvailableRequest) FetchDestinationSetup(fetchDestinationSetup bool) ExportApiGetExportsAvailableRequest {
	r.fetchDestinationSetup = &fetchDestinationSetup
	return r
}

func (r ExportApiGetExportsAvailableRequest) FetchGenerateConfiguration(fetchGenerateConfiguration bool) ExportApiGetExportsAvailableRequest {
	r.fetchGenerateConfiguration = &fetchGenerateConfiguration
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ExportApiGetExportsAvailableRequest) Limit(limit int32) ExportApiGetExportsAvailableRequest {
	r.limit = &limit
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ExportApiGetExportsAvailableRequest) ExportFileId(exportFileId string) ExportApiGetExportsAvailableRequest {
	r.exportFileId = &exportFileId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ExportApiGetExportsAvailableRequest) IdExtension(idExtension int32) ExportApiGetExportsAvailableRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ExportApiGetExportsAvailableRequest) IdContext(idContext string) ExportApiGetExportsAvailableRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ExportApiGetExportsAvailableRequest) Type_(type_ string) ExportApiGetExportsAvailableRequest {
	r.type_ = &type_
	return r
}

// Hotel code.
func (r ExportApiGetExportsAvailableRequest) HotelIds(hotelIds []string) ExportApiGetExportsAvailableRequest {
	r.hotelIds = &hotelIds
	return r
}

// Enumeration of export file groups.
func (r ExportApiGetExportsAvailableRequest) FileGroup(fileGroup string) ExportApiGetExportsAvailableRequest {
	r.fileGroup = &fileGroup
	return r
}

// Indicates whether inactive records should be returned.
func (r ExportApiGetExportsAvailableRequest) IncludeInactive(includeInactive bool) ExportApiGetExportsAvailableRequest {
	r.includeInactive = &includeInactive
	return r
}

func (r ExportApiGetExportsAvailableRequest) Match(match string) ExportApiGetExportsAvailableRequest {
	r.match = &match
	return r
}

// Indicate whether component exports should be included in the request.
func (r ExportApiGetExportsAvailableRequest) IncludeComponents(includeComponents bool) ExportApiGetExportsAvailableRequest {
	r.includeComponents = &includeComponents
	return r
}

// External system code.
func (r ExportApiGetExportsAvailableRequest) XExternalsystem(xExternalsystem string) ExportApiGetExportsAvailableRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiGetExportsAvailableRequest) AcceptLanguage(acceptLanguage string) ExportApiGetExportsAvailableRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiGetExportsAvailableRequest) Execute() (*ExportsAvailable, *http.Response, error) {
	return r.ApiService.GetExportsAvailableExecute(r)
}

/*
GetExportsAvailable Return available exports

Use this API to return available exports based on search criteria such as fetchColumns, fetchDataSetup, fetchDestinationSetup, fetchGenerateConfiguration, limit, exportFileId, idExtension, idContext, type, hotelIds, fileGroup, includeInactive, includeComponents. <p><strong>OperationId:</strong>getExportsAvailable</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExportApiGetExportsAvailableRequest
*/
func (a *ExportApiService) GetExportsAvailable(ctx context.Context) ExportApiGetExportsAvailableRequest {
	return ExportApiGetExportsAvailableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportsAvailable
func (a *ExportApiService) GetExportsAvailableExecute(r ExportApiGetExportsAvailableRequest) (*ExportsAvailable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportsAvailable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.GetExportsAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/availableExports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchColumns != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchColumns", r.fetchColumns, "")
	}
	if r.fetchDataSetup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchDataSetup", r.fetchDataSetup, "")
	}
	if r.fetchDestinationSetup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchDestinationSetup", r.fetchDestinationSetup, "")
	}
	if r.fetchGenerateConfiguration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchGenerateConfiguration", r.fetchGenerateConfiguration, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.exportFileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportFileId", r.exportFileId, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.fileGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fileGroup", r.fileGroup, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.match != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "match", r.match, "")
	}
	if r.includeComponents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeComponents", r.includeComponents, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiGetExportsGeneratedRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	exportFileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	exportDataId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiGetExportsGeneratedRequest) Authorization(authorization string) ExportApiGetExportsGeneratedRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiGetExportsGeneratedRequest) XAppKey(xAppKey string) ExportApiGetExportsGeneratedRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiGetExportsGeneratedRequest) XHotelid(xHotelid string) ExportApiGetExportsGeneratedRequest {
	r.xHotelid = &xHotelid
	return r
}

// Unique ID of export data.
func (r ExportApiGetExportsGeneratedRequest) ExportDataId(exportDataId string) ExportApiGetExportsGeneratedRequest {
	r.exportDataId = &exportDataId
	return r
}

// External system code.
func (r ExportApiGetExportsGeneratedRequest) XExternalsystem(xExternalsystem string) ExportApiGetExportsGeneratedRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiGetExportsGeneratedRequest) AcceptLanguage(acceptLanguage string) ExportApiGetExportsGeneratedRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiGetExportsGeneratedRequest) Execute() (*GeneratedExports, *http.Response, error) {
	return r.ApiService.GetExportsGeneratedExecute(r)
}

/*
GetExportsGenerated Operation to fetch exports generated.

 <p><strong>OperationId:</strong>getExportsGenerated</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exportFileId Unique ID of export file.
 @return ExportApiGetExportsGeneratedRequest
*/
func (a *ExportApiService) GetExportsGenerated(ctx context.Context, exportFileId string) ExportApiGetExportsGeneratedRequest {
	return ExportApiGetExportsGeneratedRequest{
		ApiService: a,
		ctx: ctx,
		exportFileId: exportFileId,
	}
}

// Execute executes the request
//  @return GeneratedExports
func (a *ExportApiService) GetExportsGeneratedExecute(r ExportApiGetExportsGeneratedRequest) (*GeneratedExports, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GeneratedExports
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.GetExportsGenerated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{exportFileId}/generatedExports"
	localVarPath = strings.Replace(localVarPath, "{"+"exportFileId"+"}", url.PathEscape(parameterValueToString(r.exportFileId, "exportFileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.exportFileId) < 1 {
		return localVarReturnValue, nil, reportError("exportFileId must have at least 1 elements")
	}
	if strlen(r.exportFileId) > 2000 {
		return localVarReturnValue, nil, reportError("exportFileId must have less than 2000 elements")
	}

	if r.exportDataId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportDataId", r.exportDataId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiPostExportMappingCodesRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	exportMappingCodes *PutExportMappingCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiPostExportMappingCodesRequest) Authorization(authorization string) ExportApiPostExportMappingCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiPostExportMappingCodesRequest) XAppKey(xAppKey string) ExportApiPostExportMappingCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiPostExportMappingCodesRequest) XHotelid(xHotelid string) ExportApiPostExportMappingCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create export mapping code for a given export.
func (r ExportApiPostExportMappingCodesRequest) ExportMappingCodes(exportMappingCodes PutExportMappingCodesRequest) ExportApiPostExportMappingCodesRequest {
	r.exportMappingCodes = &exportMappingCodes
	return r
}

// External system code.
func (r ExportApiPostExportMappingCodesRequest) XExternalsystem(xExternalsystem string) ExportApiPostExportMappingCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiPostExportMappingCodesRequest) AcceptLanguage(acceptLanguage string) ExportApiPostExportMappingCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiPostExportMappingCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostExportMappingCodesExecute(r)
}

/*
PostExportMappingCodes Operation to create export mapping codes.

 <p><strong>OperationId:</strong>postExportMappingCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExportApiPostExportMappingCodesRequest
*/
func (a *ExportApiService) PostExportMappingCodes(ctx context.Context) ExportApiPostExportMappingCodesRequest {
	return ExportApiPostExportMappingCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ExportApiService) PostExportMappingCodesExecute(r ExportApiPostExportMappingCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.PostExportMappingCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exportMappingCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exportMappingCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiPostExportMappingsRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	exportMappings *PutExportMappingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiPostExportMappingsRequest) Authorization(authorization string) ExportApiPostExportMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiPostExportMappingsRequest) XAppKey(xAppKey string) ExportApiPostExportMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiPostExportMappingsRequest) XHotelid(xHotelid string) ExportApiPostExportMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create export definitions for a given export.
func (r ExportApiPostExportMappingsRequest) ExportMappings(exportMappings PutExportMappingsRequest) ExportApiPostExportMappingsRequest {
	r.exportMappings = &exportMappings
	return r
}

// External system code.
func (r ExportApiPostExportMappingsRequest) XExternalsystem(xExternalsystem string) ExportApiPostExportMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiPostExportMappingsRequest) AcceptLanguage(acceptLanguage string) ExportApiPostExportMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiPostExportMappingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostExportMappingsExecute(r)
}

/*
PostExportMappings Operation to create export mappings.

 <p><strong>OperationId:</strong>postExportMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return ExportApiPostExportMappingsRequest
*/
func (a *ExportApiService) PostExportMappings(ctx context.Context, hotelId string) ExportApiPostExportMappingsRequest {
	return ExportApiPostExportMappingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ExportApiService) PostExportMappingsExecute(r ExportApiPostExportMappingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.PostExportMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exportMappings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exportMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiPostExportSchedulesRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	exportSchedulesCriteria *PostExportSchedulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiPostExportSchedulesRequest) Authorization(authorization string) ExportApiPostExportSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiPostExportSchedulesRequest) XAppKey(xAppKey string) ExportApiPostExportSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiPostExportSchedulesRequest) XHotelid(xHotelid string) ExportApiPostExportSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create export schedules
func (r ExportApiPostExportSchedulesRequest) ExportSchedulesCriteria(exportSchedulesCriteria PostExportSchedulesRequest) ExportApiPostExportSchedulesRequest {
	r.exportSchedulesCriteria = &exportSchedulesCriteria
	return r
}

// External system code.
func (r ExportApiPostExportSchedulesRequest) XExternalsystem(xExternalsystem string) ExportApiPostExportSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiPostExportSchedulesRequest) AcceptLanguage(acceptLanguage string) ExportApiPostExportSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiPostExportSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostExportSchedulesExecute(r)
}

/*
PostExportSchedules Operation to create export schedules.

Use this API to create export schedules. <p><strong>OperationId:</strong>postExportSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExportApiPostExportSchedulesRequest
*/
func (a *ExportApiService) PostExportSchedules(ctx context.Context) ExportApiPostExportSchedulesRequest {
	return ExportApiPostExportSchedulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ExportApiService) PostExportSchedulesExecute(r ExportApiPostExportSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.PostExportSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exportSchedules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exportSchedulesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiPutExportMappingCodesRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	exportMappingCodes *PutExportMappingCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiPutExportMappingCodesRequest) Authorization(authorization string) ExportApiPutExportMappingCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiPutExportMappingCodesRequest) XAppKey(xAppKey string) ExportApiPutExportMappingCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiPutExportMappingCodesRequest) XHotelid(xHotelid string) ExportApiPutExportMappingCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create export mapping code for a given export.
func (r ExportApiPutExportMappingCodesRequest) ExportMappingCodes(exportMappingCodes PutExportMappingCodesRequest) ExportApiPutExportMappingCodesRequest {
	r.exportMappingCodes = &exportMappingCodes
	return r
}

// External system code.
func (r ExportApiPutExportMappingCodesRequest) XExternalsystem(xExternalsystem string) ExportApiPutExportMappingCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiPutExportMappingCodesRequest) AcceptLanguage(acceptLanguage string) ExportApiPutExportMappingCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiPutExportMappingCodesRequest) Execute() (*ExportMappingCodesDetails, *http.Response, error) {
	return r.ApiService.PutExportMappingCodesExecute(r)
}

/*
PutExportMappingCodes Operation to update export mapping codes.

 <p><strong>OperationId:</strong>putExportMappingCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExportApiPutExportMappingCodesRequest
*/
func (a *ExportApiService) PutExportMappingCodes(ctx context.Context) ExportApiPutExportMappingCodesRequest {
	return ExportApiPutExportMappingCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportMappingCodesDetails
func (a *ExportApiService) PutExportMappingCodesExecute(r ExportApiPutExportMappingCodesRequest) (*ExportMappingCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportMappingCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.PutExportMappingCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exportMappingCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exportMappingCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiPutExportMappingLinkedTypesRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	exportMappingLinkedTypes *PutExportMappingLinkedTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiPutExportMappingLinkedTypesRequest) Authorization(authorization string) ExportApiPutExportMappingLinkedTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiPutExportMappingLinkedTypesRequest) XAppKey(xAppKey string) ExportApiPutExportMappingLinkedTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiPutExportMappingLinkedTypesRequest) XHotelid(xHotelid string) ExportApiPutExportMappingLinkedTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to fetch codes linked to export mapping codes.
func (r ExportApiPutExportMappingLinkedTypesRequest) ExportMappingLinkedTypes(exportMappingLinkedTypes PutExportMappingLinkedTypesRequest) ExportApiPutExportMappingLinkedTypesRequest {
	r.exportMappingLinkedTypes = &exportMappingLinkedTypes
	return r
}

// External system code.
func (r ExportApiPutExportMappingLinkedTypesRequest) XExternalsystem(xExternalsystem string) ExportApiPutExportMappingLinkedTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiPutExportMappingLinkedTypesRequest) AcceptLanguage(acceptLanguage string) ExportApiPutExportMappingLinkedTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiPutExportMappingLinkedTypesRequest) Execute() (*ExportMappingLinkedTypesDetails, *http.Response, error) {
	return r.ApiService.PutExportMappingLinkedTypesExecute(r)
}

/*
PutExportMappingLinkedTypes Operation to update export mapping linked types.

 <p><strong>OperationId:</strong>putExportMappingLinkedTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExportApiPutExportMappingLinkedTypesRequest
*/
func (a *ExportApiService) PutExportMappingLinkedTypes(ctx context.Context) ExportApiPutExportMappingLinkedTypesRequest {
	return ExportApiPutExportMappingLinkedTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportMappingLinkedTypesDetails
func (a *ExportApiService) PutExportMappingLinkedTypesExecute(r ExportApiPutExportMappingLinkedTypesRequest) (*ExportMappingLinkedTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportMappingLinkedTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.PutExportMappingLinkedTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exportMappingLinkedTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exportMappingLinkedTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiPutExportMappingsRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	exportMappings *PutExportMappingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiPutExportMappingsRequest) Authorization(authorization string) ExportApiPutExportMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiPutExportMappingsRequest) XAppKey(xAppKey string) ExportApiPutExportMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiPutExportMappingsRequest) XHotelid(xHotelid string) ExportApiPutExportMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create export definitions for a given export.
func (r ExportApiPutExportMappingsRequest) ExportMappings(exportMappings PutExportMappingsRequest) ExportApiPutExportMappingsRequest {
	r.exportMappings = &exportMappings
	return r
}

// External system code.
func (r ExportApiPutExportMappingsRequest) XExternalsystem(xExternalsystem string) ExportApiPutExportMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiPutExportMappingsRequest) AcceptLanguage(acceptLanguage string) ExportApiPutExportMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiPutExportMappingsRequest) Execute() (*ExportMappingsDetails, *http.Response, error) {
	return r.ApiService.PutExportMappingsExecute(r)
}

/*
PutExportMappings Operation to update export mappings.

 <p><strong>OperationId:</strong>putExportMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return ExportApiPutExportMappingsRequest
*/
func (a *ExportApiService) PutExportMappings(ctx context.Context, hotelId string) ExportApiPutExportMappingsRequest {
	return ExportApiPutExportMappingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ExportMappingsDetails
func (a *ExportApiService) PutExportMappingsExecute(r ExportApiPutExportMappingsRequest) (*ExportMappingsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportMappingsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.PutExportMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exportMappings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exportMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExportApiRemoveExportSchedulesRequest struct {
	ctx context.Context
	ApiService *ExportApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	jobNames *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExportApiRemoveExportSchedulesRequest) Authorization(authorization string) ExportApiRemoveExportSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ExportApiRemoveExportSchedulesRequest) XAppKey(xAppKey string) ExportApiRemoveExportSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExportApiRemoveExportSchedulesRequest) XHotelid(xHotelid string) ExportApiRemoveExportSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Unique name that identifies export schedule
func (r ExportApiRemoveExportSchedulesRequest) JobNames(jobNames []string) ExportApiRemoveExportSchedulesRequest {
	r.jobNames = &jobNames
	return r
}

// External system code.
func (r ExportApiRemoveExportSchedulesRequest) XExternalsystem(xExternalsystem string) ExportApiRemoveExportSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExportApiRemoveExportSchedulesRequest) AcceptLanguage(acceptLanguage string) ExportApiRemoveExportSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExportApiRemoveExportSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveExportSchedulesExecute(r)
}

/*
RemoveExportSchedules Operation to remove export schedules.

Use this API to delete export schedules based on the jobNames. <p><strong>OperationId:</strong>removeExportSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExportApiRemoveExportSchedulesRequest
*/
func (a *ExportApiService) RemoveExportSchedules(ctx context.Context) ExportApiRemoveExportSchedulesRequest {
	return ExportApiRemoveExportSchedulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ExportApiService) RemoveExportSchedulesExecute(r ExportApiRemoveExportSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExportApiService.RemoveExportSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exportSchedules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.jobNames != nil {
		t := *r.jobNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "jobNames", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "jobNames", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
