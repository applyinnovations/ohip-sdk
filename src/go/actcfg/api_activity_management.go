/*
OPERA Cloud Activity Management API

APIs to cater for Activity Configuration functionality in OPERA Cloud. In this module you can retrieve, create, update Activity configuration codes, for example create a new Activity Type.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package actcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ActivityManagementApiService ActivityManagementApi service
type ActivityManagementApiService service

type ActivityManagementApiCopyActivityTypesConfigRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activityTypesConfigCopy *CopyActivityTypesConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiCopyActivityTypesConfigRequest) Authorization(authorization string) ActivityManagementApiCopyActivityTypesConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiCopyActivityTypesConfigRequest) XAppKey(xAppKey string) ActivityManagementApiCopyActivityTypesConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiCopyActivityTypesConfigRequest) XHotelid(xHotelid string) ActivityManagementApiCopyActivityTypesConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ActivityManagementApiCopyActivityTypesConfigRequest) ActivityTypesConfigCopy(activityTypesConfigCopy CopyActivityTypesConfigRequest) ActivityManagementApiCopyActivityTypesConfigRequest {
	r.activityTypesConfigCopy = &activityTypesConfigCopy
	return r
}

// External system code.
func (r ActivityManagementApiCopyActivityTypesConfigRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiCopyActivityTypesConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiCopyActivityTypesConfigRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiCopyActivityTypesConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiCopyActivityTypesConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyActivityTypesConfigExecute(r)
}

/*
CopyActivityTypesConfig Copy Activity Types configuration codes

With this API you can select  existing Activity Type Codes from the source property and copy them to another (target) property. <p><strong>OperationId:</strong>copyActivityTypesConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the source hotel.
 @return ActivityManagementApiCopyActivityTypesConfigRequest
*/
func (a *ActivityManagementApiService) CopyActivityTypesConfig(ctx context.Context, hotelId string) ActivityManagementApiCopyActivityTypesConfigRequest {
	return ActivityManagementApiCopyActivityTypesConfigRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) CopyActivityTypesConfigExecute(r ActivityManagementApiCopyActivityTypesConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.CopyActivityTypesConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/copyActivityTypes/sourceHotel/{hotelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activityTypesConfigCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiCopyAutoTraceDefinitionsRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoTraceDefinitionCopy *CopyAutoTraceDefinitionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiCopyAutoTraceDefinitionsRequest) Authorization(authorization string) ActivityManagementApiCopyAutoTraceDefinitionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiCopyAutoTraceDefinitionsRequest) XAppKey(xAppKey string) ActivityManagementApiCopyAutoTraceDefinitionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiCopyAutoTraceDefinitionsRequest) XHotelid(xHotelid string) ActivityManagementApiCopyAutoTraceDefinitionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying trace definition.
func (r ActivityManagementApiCopyAutoTraceDefinitionsRequest) AutoTraceDefinitionCopy(autoTraceDefinitionCopy CopyAutoTraceDefinitionsRequest) ActivityManagementApiCopyAutoTraceDefinitionsRequest {
	r.autoTraceDefinitionCopy = &autoTraceDefinitionCopy
	return r
}

// External system code.
func (r ActivityManagementApiCopyAutoTraceDefinitionsRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiCopyAutoTraceDefinitionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiCopyAutoTraceDefinitionsRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiCopyAutoTraceDefinitionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiCopyAutoTraceDefinitionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyAutoTraceDefinitionsExecute(r)
}

/*
CopyAutoTraceDefinitions Copy an Auto Trace definition Code

Copy an existing auto trace definition code to another property. <p><strong>OperationId:</strong>copyAutoTraceDefinitions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ActivityManagementApiCopyAutoTraceDefinitionsRequest
*/
func (a *ActivityManagementApiService) CopyAutoTraceDefinitions(ctx context.Context, hotelId string) ActivityManagementApiCopyAutoTraceDefinitionsRequest {
	return ActivityManagementApiCopyAutoTraceDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) CopyAutoTraceDefinitionsExecute(r ActivityManagementApiCopyAutoTraceDefinitionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.CopyAutoTraceDefinitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/copyAutoTraceDefinitions/sourceHotel/{hotelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoTraceDefinitionCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiDeleteActivityResultsConfigRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	activityResultCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiDeleteActivityResultsConfigRequest) Authorization(authorization string) ActivityManagementApiDeleteActivityResultsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiDeleteActivityResultsConfigRequest) XAppKey(xAppKey string) ActivityManagementApiDeleteActivityResultsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiDeleteActivityResultsConfigRequest) XHotelid(xHotelid string) ActivityManagementApiDeleteActivityResultsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ActivityManagementApiDeleteActivityResultsConfigRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiDeleteActivityResultsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiDeleteActivityResultsConfigRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiDeleteActivityResultsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiDeleteActivityResultsConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivityResultsConfigExecute(r)
}

/*
DeleteActivityResultsConfig Delete an Activity results code

Delete an Activity Result Code from OPERA Cloud. <p><strong>OperationId:</strong>deleteActivityResultsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityResultCode Activity Result Code.
 @return ActivityManagementApiDeleteActivityResultsConfigRequest
*/
func (a *ActivityManagementApiService) DeleteActivityResultsConfig(ctx context.Context, activityResultCode string) ActivityManagementApiDeleteActivityResultsConfigRequest {
	return ActivityManagementApiDeleteActivityResultsConfigRequest{
		ApiService: a,
		ctx: ctx,
		activityResultCode: activityResultCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) DeleteActivityResultsConfigExecute(r ActivityManagementApiDeleteActivityResultsConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.DeleteActivityResultsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityResults/{activityResultCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityResultCode"+"}", url.PathEscape(parameterValueToString(r.activityResultCode, "activityResultCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityResultCode) < 1 {
		return localVarReturnValue, nil, reportError("activityResultCode must have at least 1 elements")
	}
	if strlen(r.activityResultCode) > 2000 {
		return localVarReturnValue, nil, reportError("activityResultCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiDeleteActivityTypesRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	activityTypeCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiDeleteActivityTypesRequest) Authorization(authorization string) ActivityManagementApiDeleteActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiDeleteActivityTypesRequest) XAppKey(xAppKey string) ActivityManagementApiDeleteActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiDeleteActivityTypesRequest) XHotelid(xHotelid string) ActivityManagementApiDeleteActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ActivityManagementApiDeleteActivityTypesRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiDeleteActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiDeleteActivityTypesRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiDeleteActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiDeleteActivityTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivityTypesExecute(r)
}

/*
DeleteActivityTypes Delete an Activity Type Code

This will delete an Activity Type Code from the properties configuration. <p><strong>OperationId:</strong>deleteActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityTypeCode Activity Type Code.
 @param hotelId Unique ID of hotel.
 @return ActivityManagementApiDeleteActivityTypesRequest
*/
func (a *ActivityManagementApiService) DeleteActivityTypes(ctx context.Context, activityTypeCode string, hotelId string) ActivityManagementApiDeleteActivityTypesRequest {
	return ActivityManagementApiDeleteActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
		activityTypeCode: activityTypeCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) DeleteActivityTypesExecute(r ActivityManagementApiDeleteActivityTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.DeleteActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activityTypes/{activityTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityTypeCode"+"}", url.PathEscape(parameterValueToString(r.activityTypeCode, "activityTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("activityTypeCode must have at least 1 elements")
	}
	if strlen(r.activityTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("activityTypeCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiDeleteAutoTraceCodesRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	autoTraceCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiDeleteAutoTraceCodesRequest) Authorization(authorization string) ActivityManagementApiDeleteAutoTraceCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiDeleteAutoTraceCodesRequest) XAppKey(xAppKey string) ActivityManagementApiDeleteAutoTraceCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiDeleteAutoTraceCodesRequest) XHotelid(xHotelid string) ActivityManagementApiDeleteAutoTraceCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ActivityManagementApiDeleteAutoTraceCodesRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiDeleteAutoTraceCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiDeleteAutoTraceCodesRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiDeleteAutoTraceCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiDeleteAutoTraceCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAutoTraceCodesExecute(r)
}

/*
DeleteAutoTraceCodes Delete an Auto Trace code

Delete an Auto trace code. <p><strong>OperationId:</strong>deleteAutoTraceCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param autoTraceCode Unique code of trace.
 @return ActivityManagementApiDeleteAutoTraceCodesRequest
*/
func (a *ActivityManagementApiService) DeleteAutoTraceCodes(ctx context.Context, autoTraceCode string) ActivityManagementApiDeleteAutoTraceCodesRequest {
	return ActivityManagementApiDeleteAutoTraceCodesRequest{
		ApiService: a,
		ctx: ctx,
		autoTraceCode: autoTraceCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) DeleteAutoTraceCodesExecute(r ActivityManagementApiDeleteAutoTraceCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.DeleteAutoTraceCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoTraceCodes/{autoTraceCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"autoTraceCode"+"}", url.PathEscape(parameterValueToString(r.autoTraceCode, "autoTraceCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.autoTraceCode) < 1 {
		return localVarReturnValue, nil, reportError("autoTraceCode must have at least 1 elements")
	}
	if strlen(r.autoTraceCode) > 2000 {
		return localVarReturnValue, nil, reportError("autoTraceCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiDeleteAutoTraceDefinitionsRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	autoTraceDefinitionId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiDeleteAutoTraceDefinitionsRequest) Authorization(authorization string) ActivityManagementApiDeleteAutoTraceDefinitionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiDeleteAutoTraceDefinitionsRequest) XAppKey(xAppKey string) ActivityManagementApiDeleteAutoTraceDefinitionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiDeleteAutoTraceDefinitionsRequest) XHotelid(xHotelid string) ActivityManagementApiDeleteAutoTraceDefinitionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ActivityManagementApiDeleteAutoTraceDefinitionsRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiDeleteAutoTraceDefinitionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiDeleteAutoTraceDefinitionsRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiDeleteAutoTraceDefinitionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiDeleteAutoTraceDefinitionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAutoTraceDefinitionsExecute(r)
}

/*
DeleteAutoTraceDefinitions Delete an Auto Trace definitions Code

Delete an Auto trace definition code. <p><strong>OperationId:</strong>deleteAutoTraceDefinitions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param autoTraceDefinitionId Unique ID of trace.
 @return ActivityManagementApiDeleteAutoTraceDefinitionsRequest
*/
func (a *ActivityManagementApiService) DeleteAutoTraceDefinitions(ctx context.Context, autoTraceDefinitionId string) ActivityManagementApiDeleteAutoTraceDefinitionsRequest {
	return ActivityManagementApiDeleteAutoTraceDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		autoTraceDefinitionId: autoTraceDefinitionId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) DeleteAutoTraceDefinitionsExecute(r ActivityManagementApiDeleteAutoTraceDefinitionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.DeleteAutoTraceDefinitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoTraceDefinitions/{autoTraceDefinitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"autoTraceDefinitionId"+"}", url.PathEscape(parameterValueToString(r.autoTraceDefinitionId, "autoTraceDefinitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.autoTraceDefinitionId) < 1 {
		return localVarReturnValue, nil, reportError("autoTraceDefinitionId must have at least 1 elements")
	}
	if strlen(r.autoTraceDefinitionId) > 2000 {
		return localVarReturnValue, nil, reportError("autoTraceDefinitionId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	autoTraceOwnerAssignmentID string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest) Authorization(authorization string) ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest) XAppKey(xAppKey string) ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest) XHotelid(xHotelid string) ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAutoTraceOwnerAssignmentsExecute(r)
}

/*
DeleteAutoTraceOwnerAssignments Delete an Auto Trace owner assignment 

Delete a Trace owner assignment configured for a property. <p><strong>OperationId:</strong>deleteAutoTraceOwnerAssignments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param autoTraceOwnerAssignmentID Unique ID of trace owner.
 @return ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest
*/
func (a *ActivityManagementApiService) DeleteAutoTraceOwnerAssignments(ctx context.Context, autoTraceOwnerAssignmentID string) ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest {
	return ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		autoTraceOwnerAssignmentID: autoTraceOwnerAssignmentID,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) DeleteAutoTraceOwnerAssignmentsExecute(r ActivityManagementApiDeleteAutoTraceOwnerAssignmentsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.DeleteAutoTraceOwnerAssignments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoTraceOwnerAssignments/{autoTraceOwnerAssignmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"autoTraceOwnerAssignmentID"+"}", url.PathEscape(parameterValueToString(r.autoTraceOwnerAssignmentID, "autoTraceOwnerAssignmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.autoTraceOwnerAssignmentID) < 1 {
		return localVarReturnValue, nil, reportError("autoTraceOwnerAssignmentID must have at least 1 elements")
	}
	if strlen(r.autoTraceOwnerAssignmentID) > 2000 {
		return localVarReturnValue, nil, reportError("autoTraceOwnerAssignmentID must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiGetActivityResultsConfigRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiGetActivityResultsConfigRequest) Authorization(authorization string) ActivityManagementApiGetActivityResultsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiGetActivityResultsConfigRequest) XAppKey(xAppKey string) ActivityManagementApiGetActivityResultsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiGetActivityResultsConfigRequest) XHotelid(xHotelid string) ActivityManagementApiGetActivityResultsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ActivityManagementApiGetActivityResultsConfigRequest) Limit(limit int32) ActivityManagementApiGetActivityResultsConfigRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ActivityManagementApiGetActivityResultsConfigRequest) Offset(offset int32) ActivityManagementApiGetActivityResultsConfigRequest {
	r.offset = &offset
	return r
}

// Determines wether to fetch inactive records or not.
func (r ActivityManagementApiGetActivityResultsConfigRequest) FetchInactive(fetchInactive bool) ActivityManagementApiGetActivityResultsConfigRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ActivityManagementApiGetActivityResultsConfigRequest) Codes(codes []string) ActivityManagementApiGetActivityResultsConfigRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ActivityManagementApiGetActivityResultsConfigRequest) WildCard(wildCard string) ActivityManagementApiGetActivityResultsConfigRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ActivityManagementApiGetActivityResultsConfigRequest) Description(description string) ActivityManagementApiGetActivityResultsConfigRequest {
	r.description = &description
	return r
}

// External system code.
func (r ActivityManagementApiGetActivityResultsConfigRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiGetActivityResultsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiGetActivityResultsConfigRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiGetActivityResultsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiGetActivityResultsConfigRequest) Execute() (*ActivityResultsConfigDetails, *http.Response, error) {
	return r.ApiService.GetActivityResultsConfigExecute(r)
}

/*
GetActivityResultsConfig Get all Configured Activity Result Codes 

Retrieve a list of all configured Activity Result codes and descriptions.  Activity Results appear on the Activities screen in the Results field after the Activity is completed.  And example could be Call Again - an activity is Completed but the result code as part of the completion is to Call Again. <p><strong>OperationId:</strong>getActivityResultsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivityManagementApiGetActivityResultsConfigRequest
*/
func (a *ActivityManagementApiService) GetActivityResultsConfig(ctx context.Context) ActivityManagementApiGetActivityResultsConfigRequest {
	return ActivityManagementApiGetActivityResultsConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActivityResultsConfigDetails
func (a *ActivityManagementApiService) GetActivityResultsConfigExecute(r ActivityManagementApiGetActivityResultsConfigRequest) (*ActivityResultsConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivityResultsConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.GetActivityResultsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityResults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiGetActivityTypesRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	activityType *[]string
	description *string
	inactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiGetActivityTypesRequest) Authorization(authorization string) ActivityManagementApiGetActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiGetActivityTypesRequest) XAppKey(xAppKey string) ActivityManagementApiGetActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiGetActivityTypesRequest) XHotelid(xHotelid string) ActivityManagementApiGetActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ActivityManagementApiGetActivityTypesRequest) Limit(limit int32) ActivityManagementApiGetActivityTypesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ActivityManagementApiGetActivityTypesRequest) Offset(offset int32) ActivityManagementApiGetActivityTypesRequest {
	r.offset = &offset
	return r
}

func (r ActivityManagementApiGetActivityTypesRequest) ActivityType(activityType []string) ActivityManagementApiGetActivityTypesRequest {
	r.activityType = &activityType
	return r
}

// Description for the activity type is to be searched for.
func (r ActivityManagementApiGetActivityTypesRequest) Description(description string) ActivityManagementApiGetActivityTypesRequest {
	r.description = &description
	return r
}

// Determines whether to fetch inactive records or not.
func (r ActivityManagementApiGetActivityTypesRequest) Inactive(inactive bool) ActivityManagementApiGetActivityTypesRequest {
	r.inactive = &inactive
	return r
}

// External system code.
func (r ActivityManagementApiGetActivityTypesRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiGetActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiGetActivityTypesRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiGetActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiGetActivityTypesRequest) Execute() (*ActivityTypesConfigDetails, *http.Response, error) {
	return r.ApiService.GetActivityTypesExecute(r)
}

/*
GetActivityTypes Get all Activity Type Codes

Retrieve all configured Activity types for a specified hotel. <p><strong>OperationId:</strong>getActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ActivityManagementApiGetActivityTypesRequest
*/
func (a *ActivityManagementApiService) GetActivityTypes(ctx context.Context, hotelId string) ActivityManagementApiGetActivityTypesRequest {
	return ActivityManagementApiGetActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ActivityTypesConfigDetails
func (a *ActivityManagementApiService) GetActivityTypesExecute(r ActivityManagementApiGetActivityTypesRequest) (*ActivityTypesConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivityTypesConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.GetActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activityTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.activityType != nil {
		t := *r.activityType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", t, "multi")
		}
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiGetAutoTraceCodesRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	codes *[]string
	autoTraceGroups *[]string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiGetAutoTraceCodesRequest) Authorization(authorization string) ActivityManagementApiGetAutoTraceCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiGetAutoTraceCodesRequest) XAppKey(xAppKey string) ActivityManagementApiGetAutoTraceCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiGetAutoTraceCodesRequest) XHotelid(xHotelid string) ActivityManagementApiGetAutoTraceCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ActivityManagementApiGetAutoTraceCodesRequest) Limit(limit int32) ActivityManagementApiGetAutoTraceCodesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ActivityManagementApiGetAutoTraceCodesRequest) Offset(offset int32) ActivityManagementApiGetAutoTraceCodesRequest {
	r.offset = &offset
	return r
}

func (r ActivityManagementApiGetAutoTraceCodesRequest) Codes(codes []string) ActivityManagementApiGetAutoTraceCodesRequest {
	r.codes = &codes
	return r
}

// A collection of supported list of Auto Trace Groups.
func (r ActivityManagementApiGetAutoTraceCodesRequest) AutoTraceGroups(autoTraceGroups []string) ActivityManagementApiGetAutoTraceCodesRequest {
	r.autoTraceGroups = &autoTraceGroups
	return r
}

// Description for the Trace Code to be searched for.
func (r ActivityManagementApiGetAutoTraceCodesRequest) Description(description string) ActivityManagementApiGetAutoTraceCodesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ActivityManagementApiGetAutoTraceCodesRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiGetAutoTraceCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiGetAutoTraceCodesRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiGetAutoTraceCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiGetAutoTraceCodesRequest) Execute() (*AutoTraceCodesDetails, *http.Response, error) {
	return r.ApiService.GetAutoTraceCodesExecute(r)
}

/*
GetAutoTraceCodes Get Auto Trace codes

Retrieve a list of all configured Auto Trace Codes for a property. <p><strong>OperationId:</strong>getAutoTraceCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivityManagementApiGetAutoTraceCodesRequest
*/
func (a *ActivityManagementApiService) GetAutoTraceCodes(ctx context.Context) ActivityManagementApiGetAutoTraceCodesRequest {
	return ActivityManagementApiGetAutoTraceCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AutoTraceCodesDetails
func (a *ActivityManagementApiService) GetAutoTraceCodesExecute(r ActivityManagementApiGetAutoTraceCodesRequest) (*AutoTraceCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoTraceCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.GetAutoTraceCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoTraceCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.autoTraceGroups != nil {
		t := *r.autoTraceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "autoTraceGroups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "autoTraceGroups", t, "multi")
		}
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiGetAutoTraceDefinitionsRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	codes *[]string
	autoTraceGroups *[]string
	inactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiGetAutoTraceDefinitionsRequest) Authorization(authorization string) ActivityManagementApiGetAutoTraceDefinitionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiGetAutoTraceDefinitionsRequest) XAppKey(xAppKey string) ActivityManagementApiGetAutoTraceDefinitionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiGetAutoTraceDefinitionsRequest) XHotelid(xHotelid string) ActivityManagementApiGetAutoTraceDefinitionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ActivityManagementApiGetAutoTraceDefinitionsRequest) Limit(limit int32) ActivityManagementApiGetAutoTraceDefinitionsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ActivityManagementApiGetAutoTraceDefinitionsRequest) Offset(offset int32) ActivityManagementApiGetAutoTraceDefinitionsRequest {
	r.offset = &offset
	return r
}

func (r ActivityManagementApiGetAutoTraceDefinitionsRequest) Codes(codes []string) ActivityManagementApiGetAutoTraceDefinitionsRequest {
	r.codes = &codes
	return r
}

// A collection of supported list of Auto Trace Groups.
func (r ActivityManagementApiGetAutoTraceDefinitionsRequest) AutoTraceGroups(autoTraceGroups []string) ActivityManagementApiGetAutoTraceDefinitionsRequest {
	r.autoTraceGroups = &autoTraceGroups
	return r
}

// Determines whether to fetch inactive records or not.
func (r ActivityManagementApiGetAutoTraceDefinitionsRequest) Inactive(inactive bool) ActivityManagementApiGetAutoTraceDefinitionsRequest {
	r.inactive = &inactive
	return r
}

// External system code.
func (r ActivityManagementApiGetAutoTraceDefinitionsRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiGetAutoTraceDefinitionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiGetAutoTraceDefinitionsRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiGetAutoTraceDefinitionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiGetAutoTraceDefinitionsRequest) Execute() (*AutoTraceDefinitionsDetails, *http.Response, error) {
	return r.ApiService.GetAutoTraceDefinitionsExecute(r)
}

/*
GetAutoTraceDefinitions Get a list of Auto Trace definition Codes

Get a list of all Auto trace definitions for a property. <p><strong>OperationId:</strong>getAutoTraceDefinitions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ActivityManagementApiGetAutoTraceDefinitionsRequest
*/
func (a *ActivityManagementApiService) GetAutoTraceDefinitions(ctx context.Context, hotelId string) ActivityManagementApiGetAutoTraceDefinitionsRequest {
	return ActivityManagementApiGetAutoTraceDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AutoTraceDefinitionsDetails
func (a *ActivityManagementApiService) GetAutoTraceDefinitionsExecute(r ActivityManagementApiGetAutoTraceDefinitionsRequest) (*AutoTraceDefinitionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoTraceDefinitionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.GetAutoTraceDefinitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoTraceDefinitions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.autoTraceGroups != nil {
		t := *r.autoTraceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "autoTraceGroups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "autoTraceGroups", t, "multi")
		}
	}
	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	codes *[]string
	traceOwnerCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest) Authorization(authorization string) ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest) XAppKey(xAppKey string) ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest) XHotelid(xHotelid string) ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest) Limit(limit int32) ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest) Offset(offset int32) ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest {
	r.offset = &offset
	return r
}

func (r ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest) Codes(codes []string) ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest {
	r.codes = &codes
	return r
}

func (r ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest) TraceOwnerCodes(traceOwnerCodes []string) ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest {
	r.traceOwnerCodes = &traceOwnerCodes
	return r
}

// External system code.
func (r ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest) Execute() (*AutoTraceOwnerAssignmentsDetails, *http.Response, error) {
	return r.ApiService.GetAutoTraceOwnerAssignmentsExecute(r)
}

/*
GetAutoTraceOwnerAssignments Get an Auto Trace owner mappings

This API will provide a list of all configured Auto Trace Owner Mappings.   <p><strong>OperationId:</strong>getAutoTraceOwnerAssignments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest
*/
func (a *ActivityManagementApiService) GetAutoTraceOwnerAssignments(ctx context.Context, hotelId string) ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest {
	return ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AutoTraceOwnerAssignmentsDetails
func (a *ActivityManagementApiService) GetAutoTraceOwnerAssignmentsExecute(r ActivityManagementApiGetAutoTraceOwnerAssignmentsRequest) (*AutoTraceOwnerAssignmentsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoTraceOwnerAssignmentsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.GetAutoTraceOwnerAssignments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoTraceOwnerAssignments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.traceOwnerCodes != nil {
		t := *r.traceOwnerCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "traceOwnerCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "traceOwnerCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiPostActivityResultsConfigRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	activityResultsConfigInfo *PostActivityResultsConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiPostActivityResultsConfigRequest) Authorization(authorization string) ActivityManagementApiPostActivityResultsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiPostActivityResultsConfigRequest) XAppKey(xAppKey string) ActivityManagementApiPostActivityResultsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiPostActivityResultsConfigRequest) XHotelid(xHotelid string) ActivityManagementApiPostActivityResultsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Activity Results Configuration.
func (r ActivityManagementApiPostActivityResultsConfigRequest) ActivityResultsConfigInfo(activityResultsConfigInfo PostActivityResultsConfigRequest) ActivityManagementApiPostActivityResultsConfigRequest {
	r.activityResultsConfigInfo = &activityResultsConfigInfo
	return r
}

// External system code.
func (r ActivityManagementApiPostActivityResultsConfigRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiPostActivityResultsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiPostActivityResultsConfigRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiPostActivityResultsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiPostActivityResultsConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostActivityResultsConfigExecute(r)
}

/*
PostActivityResultsConfig Create an Activity results code

Create a new Activity Results Code, for example SUCCESS, END, CALLAGAIN.  These codes are used when you complete an activity.  You need to specify an Activity Result Code as part of that completion process. <p><strong>OperationId:</strong>postActivityResultsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivityManagementApiPostActivityResultsConfigRequest
*/
func (a *ActivityManagementApiService) PostActivityResultsConfig(ctx context.Context) ActivityManagementApiPostActivityResultsConfigRequest {
	return ActivityManagementApiPostActivityResultsConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) PostActivityResultsConfigExecute(r ActivityManagementApiPostActivityResultsConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.PostActivityResultsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityResults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activityResultsConfigInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiPostActivityTypesRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activityTypesConfigInfo *PostActivityTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiPostActivityTypesRequest) Authorization(authorization string) ActivityManagementApiPostActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiPostActivityTypesRequest) XAppKey(xAppKey string) ActivityManagementApiPostActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiPostActivityTypesRequest) XHotelid(xHotelid string) ActivityManagementApiPostActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating activity types.
func (r ActivityManagementApiPostActivityTypesRequest) ActivityTypesConfigInfo(activityTypesConfigInfo PostActivityTypesRequest) ActivityManagementApiPostActivityTypesRequest {
	r.activityTypesConfigInfo = &activityTypesConfigInfo
	return r
}

// External system code.
func (r ActivityManagementApiPostActivityTypesRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiPostActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiPostActivityTypesRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiPostActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiPostActivityTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostActivityTypesExecute(r)
}

/*
PostActivityTypes Create a new Activity type in configuration

Create a new Activity Type for a specified hotel. Examples could be  MEETING, LUNCH, EXTMEETING. <p><strong>OperationId:</strong>postActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ActivityManagementApiPostActivityTypesRequest
*/
func (a *ActivityManagementApiService) PostActivityTypes(ctx context.Context, hotelId string) ActivityManagementApiPostActivityTypesRequest {
	return ActivityManagementApiPostActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) PostActivityTypesExecute(r ActivityManagementApiPostActivityTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.PostActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activityTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activityTypesConfigInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiPostAutoTraceCodesRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	autoTraceCodesInfo *PostAutoTraceCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiPostAutoTraceCodesRequest) Authorization(authorization string) ActivityManagementApiPostAutoTraceCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiPostAutoTraceCodesRequest) XAppKey(xAppKey string) ActivityManagementApiPostAutoTraceCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiPostAutoTraceCodesRequest) XHotelid(xHotelid string) ActivityManagementApiPostAutoTraceCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Auto Trace Codes.
func (r ActivityManagementApiPostAutoTraceCodesRequest) AutoTraceCodesInfo(autoTraceCodesInfo PostAutoTraceCodesRequest) ActivityManagementApiPostAutoTraceCodesRequest {
	r.autoTraceCodesInfo = &autoTraceCodesInfo
	return r
}

// External system code.
func (r ActivityManagementApiPostAutoTraceCodesRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiPostAutoTraceCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiPostAutoTraceCodesRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiPostAutoTraceCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiPostAutoTraceCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAutoTraceCodesExecute(r)
}

/*
PostAutoTraceCodes Create an Auto Trace code

Create an Auto trace code. <p><strong>OperationId:</strong>postAutoTraceCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivityManagementApiPostAutoTraceCodesRequest
*/
func (a *ActivityManagementApiService) PostAutoTraceCodes(ctx context.Context) ActivityManagementApiPostAutoTraceCodesRequest {
	return ActivityManagementApiPostAutoTraceCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) PostAutoTraceCodesExecute(r ActivityManagementApiPostAutoTraceCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.PostAutoTraceCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoTraceCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoTraceCodesInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiPostAutoTraceDefinitionsRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoTraceDefinitionsInfo *PostAutoTraceDefinitionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiPostAutoTraceDefinitionsRequest) Authorization(authorization string) ActivityManagementApiPostAutoTraceDefinitionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiPostAutoTraceDefinitionsRequest) XAppKey(xAppKey string) ActivityManagementApiPostAutoTraceDefinitionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiPostAutoTraceDefinitionsRequest) XHotelid(xHotelid string) ActivityManagementApiPostAutoTraceDefinitionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Auto Trace Definitions.
func (r ActivityManagementApiPostAutoTraceDefinitionsRequest) AutoTraceDefinitionsInfo(autoTraceDefinitionsInfo PostAutoTraceDefinitionsRequest) ActivityManagementApiPostAutoTraceDefinitionsRequest {
	r.autoTraceDefinitionsInfo = &autoTraceDefinitionsInfo
	return r
}

// External system code.
func (r ActivityManagementApiPostAutoTraceDefinitionsRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiPostAutoTraceDefinitionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiPostAutoTraceDefinitionsRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiPostAutoTraceDefinitionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiPostAutoTraceDefinitionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAutoTraceDefinitionsExecute(r)
}

/*
PostAutoTraceDefinitions Create an Auto Trace Definition Code

Create a new Auto Trace Definition code for a specified property. <p><strong>OperationId:</strong>postAutoTraceDefinitions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ActivityManagementApiPostAutoTraceDefinitionsRequest
*/
func (a *ActivityManagementApiService) PostAutoTraceDefinitions(ctx context.Context, hotelId string) ActivityManagementApiPostAutoTraceDefinitionsRequest {
	return ActivityManagementApiPostAutoTraceDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) PostAutoTraceDefinitionsExecute(r ActivityManagementApiPostAutoTraceDefinitionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.PostAutoTraceDefinitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoTraceDefinitions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoTraceDefinitionsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoTraceOwnerAssignmentsInfo *PostAutoTraceOwnerAssignmentsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest) Authorization(authorization string) ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest) XAppKey(xAppKey string) ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest) XHotelid(xHotelid string) ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating trace owner assignments.
func (r ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest) AutoTraceOwnerAssignmentsInfo(autoTraceOwnerAssignmentsInfo PostAutoTraceOwnerAssignmentsRequest) ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest {
	r.autoTraceOwnerAssignmentsInfo = &autoTraceOwnerAssignmentsInfo
	return r
}

// External system code.
func (r ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAutoTraceOwnerAssignmentsExecute(r)
}

/*
PostAutoTraceOwnerAssignments Create an Auto Trace owner assignment

You can create Auto traces so that activities are created automatically under certain configured conditions. You first need a Trace code configured, and then using this API you can link the Owner code and Trace Code to a Trace Group (account, contact, activity, or block). <p><strong>OperationId:</strong>postAutoTraceOwnerAssignments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest
*/
func (a *ActivityManagementApiService) PostAutoTraceOwnerAssignments(ctx context.Context, hotelId string) ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest {
	return ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) PostAutoTraceOwnerAssignmentsExecute(r ActivityManagementApiPostAutoTraceOwnerAssignmentsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.PostAutoTraceOwnerAssignments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoTraceOwnerAssignments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoTraceOwnerAssignmentsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiPutActivityResultsConfigRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	activityResultCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	activityResultsConfigInfo *PostActivityResultsConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiPutActivityResultsConfigRequest) Authorization(authorization string) ActivityManagementApiPutActivityResultsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiPutActivityResultsConfigRequest) XAppKey(xAppKey string) ActivityManagementApiPutActivityResultsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiPutActivityResultsConfigRequest) XHotelid(xHotelid string) ActivityManagementApiPutActivityResultsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activity Results Configuration.
func (r ActivityManagementApiPutActivityResultsConfigRequest) ActivityResultsConfigInfo(activityResultsConfigInfo PostActivityResultsConfigRequest) ActivityManagementApiPutActivityResultsConfigRequest {
	r.activityResultsConfigInfo = &activityResultsConfigInfo
	return r
}

// External system code.
func (r ActivityManagementApiPutActivityResultsConfigRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiPutActivityResultsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiPutActivityResultsConfigRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiPutActivityResultsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiPutActivityResultsConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutActivityResultsConfigExecute(r)
}

/*
PutActivityResultsConfig Change an Activity Result Code

Change or update details of an existing Activity Results Code. <p><strong>OperationId:</strong>putActivityResultsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityResultCode Activity Result Code.
 @return ActivityManagementApiPutActivityResultsConfigRequest
*/
func (a *ActivityManagementApiService) PutActivityResultsConfig(ctx context.Context, activityResultCode string) ActivityManagementApiPutActivityResultsConfigRequest {
	return ActivityManagementApiPutActivityResultsConfigRequest{
		ApiService: a,
		ctx: ctx,
		activityResultCode: activityResultCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) PutActivityResultsConfigExecute(r ActivityManagementApiPutActivityResultsConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.PutActivityResultsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityResults/{activityResultCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityResultCode"+"}", url.PathEscape(parameterValueToString(r.activityResultCode, "activityResultCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityResultCode) < 1 {
		return localVarReturnValue, nil, reportError("activityResultCode must have at least 1 elements")
	}
	if strlen(r.activityResultCode) > 2000 {
		return localVarReturnValue, nil, reportError("activityResultCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activityResultsConfigInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiPutActivityTypesRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	activityTypeCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activityTypesConfigInfo *PostActivityTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiPutActivityTypesRequest) Authorization(authorization string) ActivityManagementApiPutActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiPutActivityTypesRequest) XAppKey(xAppKey string) ActivityManagementApiPutActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiPutActivityTypesRequest) XHotelid(xHotelid string) ActivityManagementApiPutActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing activity types.
func (r ActivityManagementApiPutActivityTypesRequest) ActivityTypesConfigInfo(activityTypesConfigInfo PostActivityTypesRequest) ActivityManagementApiPutActivityTypesRequest {
	r.activityTypesConfigInfo = &activityTypesConfigInfo
	return r
}

// External system code.
func (r ActivityManagementApiPutActivityTypesRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiPutActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiPutActivityTypesRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiPutActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiPutActivityTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutActivityTypesExecute(r)
}

/*
PutActivityTypes Update Activity Types

Change or update details of an existing Activity Type for a property. <p><strong>OperationId:</strong>putActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityTypeCode Activity Type Code.
 @param hotelId Unique ID of hotel.
 @return ActivityManagementApiPutActivityTypesRequest
*/
func (a *ActivityManagementApiService) PutActivityTypes(ctx context.Context, activityTypeCode string, hotelId string) ActivityManagementApiPutActivityTypesRequest {
	return ActivityManagementApiPutActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
		activityTypeCode: activityTypeCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) PutActivityTypesExecute(r ActivityManagementApiPutActivityTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.PutActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activityTypes/{activityTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityTypeCode"+"}", url.PathEscape(parameterValueToString(r.activityTypeCode, "activityTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("activityTypeCode must have at least 1 elements")
	}
	if strlen(r.activityTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("activityTypeCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activityTypesConfigInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiPutAutoTraceCodesRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	autoTraceCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoTraceCodesInfo *PostAutoTraceCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiPutAutoTraceCodesRequest) Authorization(authorization string) ActivityManagementApiPutAutoTraceCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiPutAutoTraceCodesRequest) XAppKey(xAppKey string) ActivityManagementApiPutAutoTraceCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiPutAutoTraceCodesRequest) XHotelid(xHotelid string) ActivityManagementApiPutAutoTraceCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Auto Trace Codes.
func (r ActivityManagementApiPutAutoTraceCodesRequest) AutoTraceCodesInfo(autoTraceCodesInfo PostAutoTraceCodesRequest) ActivityManagementApiPutAutoTraceCodesRequest {
	r.autoTraceCodesInfo = &autoTraceCodesInfo
	return r
}

// External system code.
func (r ActivityManagementApiPutAutoTraceCodesRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiPutAutoTraceCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiPutAutoTraceCodesRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiPutAutoTraceCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiPutAutoTraceCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAutoTraceCodesExecute(r)
}

/*
PutAutoTraceCodes Change an Auto Trace code

Update an Auto Trace Code. <p><strong>OperationId:</strong>putAutoTraceCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param autoTraceCode Unique code of trace.
 @return ActivityManagementApiPutAutoTraceCodesRequest
*/
func (a *ActivityManagementApiService) PutAutoTraceCodes(ctx context.Context, autoTraceCode string) ActivityManagementApiPutAutoTraceCodesRequest {
	return ActivityManagementApiPutAutoTraceCodesRequest{
		ApiService: a,
		ctx: ctx,
		autoTraceCode: autoTraceCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityManagementApiService) PutAutoTraceCodesExecute(r ActivityManagementApiPutAutoTraceCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.PutAutoTraceCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoTraceCodes/{autoTraceCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"autoTraceCode"+"}", url.PathEscape(parameterValueToString(r.autoTraceCode, "autoTraceCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.autoTraceCode) < 1 {
		return localVarReturnValue, nil, reportError("autoTraceCode must have at least 1 elements")
	}
	if strlen(r.autoTraceCode) > 2000 {
		return localVarReturnValue, nil, reportError("autoTraceCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoTraceCodesInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiPutAutoTraceDefinitionsRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	autoTraceDefinitionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoTraceDefinitionsInfo *PostAutoTraceDefinitionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiPutAutoTraceDefinitionsRequest) Authorization(authorization string) ActivityManagementApiPutAutoTraceDefinitionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiPutAutoTraceDefinitionsRequest) XAppKey(xAppKey string) ActivityManagementApiPutAutoTraceDefinitionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiPutAutoTraceDefinitionsRequest) XHotelid(xHotelid string) ActivityManagementApiPutAutoTraceDefinitionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Auto Trace Definitions.
func (r ActivityManagementApiPutAutoTraceDefinitionsRequest) AutoTraceDefinitionsInfo(autoTraceDefinitionsInfo PostAutoTraceDefinitionsRequest) ActivityManagementApiPutAutoTraceDefinitionsRequest {
	r.autoTraceDefinitionsInfo = &autoTraceDefinitionsInfo
	return r
}

// External system code.
func (r ActivityManagementApiPutAutoTraceDefinitionsRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiPutAutoTraceDefinitionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiPutAutoTraceDefinitionsRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiPutAutoTraceDefinitionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiPutAutoTraceDefinitionsRequest) Execute() (*AutoTraceDefinitionsStatus, *http.Response, error) {
	return r.ApiService.PutAutoTraceDefinitionsExecute(r)
}

/*
PutAutoTraceDefinitions Change an Auto Trace definition Code

Change an Auto Trace Definition code for a specified property. <p><strong>OperationId:</strong>putAutoTraceDefinitions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param autoTraceDefinitionId Unique ID of trace.
 @param hotelId Unique ID of hotel.
 @return ActivityManagementApiPutAutoTraceDefinitionsRequest
*/
func (a *ActivityManagementApiService) PutAutoTraceDefinitions(ctx context.Context, autoTraceDefinitionId string, hotelId string) ActivityManagementApiPutAutoTraceDefinitionsRequest {
	return ActivityManagementApiPutAutoTraceDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
		autoTraceDefinitionId: autoTraceDefinitionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AutoTraceDefinitionsStatus
func (a *ActivityManagementApiService) PutAutoTraceDefinitionsExecute(r ActivityManagementApiPutAutoTraceDefinitionsRequest) (*AutoTraceDefinitionsStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoTraceDefinitionsStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.PutAutoTraceDefinitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoTraceDefinitions/{autoTraceDefinitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"autoTraceDefinitionId"+"}", url.PathEscape(parameterValueToString(r.autoTraceDefinitionId, "autoTraceDefinitionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.autoTraceDefinitionId) < 1 {
		return localVarReturnValue, nil, reportError("autoTraceDefinitionId must have at least 1 elements")
	}
	if strlen(r.autoTraceDefinitionId) > 2000 {
		return localVarReturnValue, nil, reportError("autoTraceDefinitionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoTraceDefinitionsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest struct {
	ctx context.Context
	ApiService *ActivityManagementApiService
	autoTraceOwnerAssignmentID string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoTraceOwnerAssignmentsInfo *PostAutoTraceOwnerAssignmentsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest) Authorization(authorization string) ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest) XAppKey(xAppKey string) ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest) XHotelid(xHotelid string) ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing trace owner assignments.
func (r ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest) AutoTraceOwnerAssignmentsInfo(autoTraceOwnerAssignmentsInfo PostAutoTraceOwnerAssignmentsRequest) ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest {
	r.autoTraceOwnerAssignmentsInfo = &autoTraceOwnerAssignmentsInfo
	return r
}

// External system code.
func (r ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest) XExternalsystem(xExternalsystem string) ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest) AcceptLanguage(acceptLanguage string) ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest) Execute() (*AutoTraceOwnerAssignmentsStatus, *http.Response, error) {
	return r.ApiService.PutAutoTraceOwnerAssignmentsExecute(r)
}

/*
PutAutoTraceOwnerAssignments Change Trace owner assignments

Change a Trace owner assignment configured for a property. <p><strong>OperationId:</strong>putAutoTraceOwnerAssignments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param autoTraceOwnerAssignmentID Unique ID of trace owner.
 @param hotelId Unique ID of hotel.
 @return ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest
*/
func (a *ActivityManagementApiService) PutAutoTraceOwnerAssignments(ctx context.Context, autoTraceOwnerAssignmentID string, hotelId string) ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest {
	return ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
		autoTraceOwnerAssignmentID: autoTraceOwnerAssignmentID,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AutoTraceOwnerAssignmentsStatus
func (a *ActivityManagementApiService) PutAutoTraceOwnerAssignmentsExecute(r ActivityManagementApiPutAutoTraceOwnerAssignmentsRequest) (*AutoTraceOwnerAssignmentsStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoTraceOwnerAssignmentsStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityManagementApiService.PutAutoTraceOwnerAssignments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoTraceOwnerAssignments/{autoTraceOwnerAssignmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"autoTraceOwnerAssignmentID"+"}", url.PathEscape(parameterValueToString(r.autoTraceOwnerAssignmentID, "autoTraceOwnerAssignmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.autoTraceOwnerAssignmentID) < 1 {
		return localVarReturnValue, nil, reportError("autoTraceOwnerAssignmentID must have at least 1 elements")
	}
	if strlen(r.autoTraceOwnerAssignmentID) > 2000 {
		return localVarReturnValue, nil, reportError("autoTraceOwnerAssignmentID must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoTraceOwnerAssignmentsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
