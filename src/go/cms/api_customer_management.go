/*
OPERA Cloud API for Customer Management Service

This API deals with the different aspect of the CustomerManagement.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cms

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// CustomerManagementApiService CustomerManagementApi service
type CustomerManagementApiService service

type CustomerManagementApiDeleteCalendarTaskRequest struct {
	ctx context.Context
	ApiService *CustomerManagementApiService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementApiDeleteCalendarTaskRequest) Authorization(authorization string) CustomerManagementApiDeleteCalendarTaskRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementApiDeleteCalendarTaskRequest) XAppKey(xAppKey string) CustomerManagementApiDeleteCalendarTaskRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementApiDeleteCalendarTaskRequest) XHotelid(xHotelid string) CustomerManagementApiDeleteCalendarTaskRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CustomerManagementApiDeleteCalendarTaskRequest) XExternalsystem(xExternalsystem string) CustomerManagementApiDeleteCalendarTaskRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementApiDeleteCalendarTaskRequest) AcceptLanguage(acceptLanguage string) CustomerManagementApiDeleteCalendarTaskRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementApiDeleteCalendarTaskRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCalendarTaskExecute(r)
}

/*
DeleteCalendarTask Delete a Calendar Task

This API will allow you to delete a Calendar Task. <p><strong>OperationId:</strong>deleteCalendarTask</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId
 @param hotelId
 @return CustomerManagementApiDeleteCalendarTaskRequest
*/
func (a *CustomerManagementApiService) DeleteCalendarTask(ctx context.Context, activityId string, hotelId string) CustomerManagementApiDeleteCalendarTaskRequest {
	return CustomerManagementApiDeleteCalendarTaskRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CustomerManagementApiService) DeleteCalendarTaskExecute(r CustomerManagementApiDeleteCalendarTaskRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementApiService.DeleteCalendarTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}/task"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementApiDeleteCalendarTaskAttachmentRequest struct {
	ctx context.Context
	ApiService *CustomerManagementApiService
	linkedToId *string
	attachId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementApiDeleteCalendarTaskAttachmentRequest) LinkedToId(linkedToId string) CustomerManagementApiDeleteCalendarTaskAttachmentRequest {
	r.linkedToId = &linkedToId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementApiDeleteCalendarTaskAttachmentRequest) AttachId(attachId string) CustomerManagementApiDeleteCalendarTaskAttachmentRequest {
	r.attachId = &attachId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementApiDeleteCalendarTaskAttachmentRequest) Authorization(authorization string) CustomerManagementApiDeleteCalendarTaskAttachmentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementApiDeleteCalendarTaskAttachmentRequest) XAppKey(xAppKey string) CustomerManagementApiDeleteCalendarTaskAttachmentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementApiDeleteCalendarTaskAttachmentRequest) XHotelid(xHotelid string) CustomerManagementApiDeleteCalendarTaskAttachmentRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CustomerManagementApiDeleteCalendarTaskAttachmentRequest) XExternalsystem(xExternalsystem string) CustomerManagementApiDeleteCalendarTaskAttachmentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementApiDeleteCalendarTaskAttachmentRequest) AcceptLanguage(acceptLanguage string) CustomerManagementApiDeleteCalendarTaskAttachmentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementApiDeleteCalendarTaskAttachmentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCalendarTaskAttachmentExecute(r)
}

/*
DeleteCalendarTaskAttachment Delete a Calendar Task attachment 

Delete an attachment associated with the calendar task <p><strong>OperationId:</strong>deleteCalendarTaskAttachment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerManagementApiDeleteCalendarTaskAttachmentRequest
*/
func (a *CustomerManagementApiService) DeleteCalendarTaskAttachment(ctx context.Context) CustomerManagementApiDeleteCalendarTaskAttachmentRequest {
	return CustomerManagementApiDeleteCalendarTaskAttachmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CustomerManagementApiService) DeleteCalendarTaskAttachmentExecute(r CustomerManagementApiDeleteCalendarTaskAttachmentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementApiService.DeleteCalendarTaskAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities/tasks/attachment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "linkedToId", r.linkedToId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "attachId", r.attachId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementApiDeleteTrackItItemsRequest struct {
	ctx context.Context
	ApiService *CustomerManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	trackItId *[]string
	trackItIdContext *[]string
	trackItIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementApiDeleteTrackItItemsRequest) Authorization(authorization string) CustomerManagementApiDeleteTrackItItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementApiDeleteTrackItItemsRequest) XAppKey(xAppKey string) CustomerManagementApiDeleteTrackItItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementApiDeleteTrackItItemsRequest) XHotelid(xHotelid string) CustomerManagementApiDeleteTrackItItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementApiDeleteTrackItItemsRequest) TrackItId(trackItId []string) CustomerManagementApiDeleteTrackItItemsRequest {
	r.trackItId = &trackItId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementApiDeleteTrackItItemsRequest) TrackItIdContext(trackItIdContext []string) CustomerManagementApiDeleteTrackItItemsRequest {
	r.trackItIdContext = &trackItIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementApiDeleteTrackItItemsRequest) TrackItIdType(trackItIdType []string) CustomerManagementApiDeleteTrackItItemsRequest {
	r.trackItIdType = &trackItIdType
	return r
}

// External system code.
func (r CustomerManagementApiDeleteTrackItItemsRequest) XExternalsystem(xExternalsystem string) CustomerManagementApiDeleteTrackItItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementApiDeleteTrackItItemsRequest) AcceptLanguage(acceptLanguage string) CustomerManagementApiDeleteTrackItItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementApiDeleteTrackItItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTrackItItemsExecute(r)
}

/*
DeleteTrackItItems Deletes track it items

Delete a Track It Item for a property. <p><strong>OperationId:</strong>deleteTrackItItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return CustomerManagementApiDeleteTrackItItemsRequest
*/
func (a *CustomerManagementApiService) DeleteTrackItItems(ctx context.Context, hotelId string) CustomerManagementApiDeleteTrackItItemsRequest {
	return CustomerManagementApiDeleteTrackItItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CustomerManagementApiService) DeleteTrackItItemsExecute(r CustomerManagementApiDeleteTrackItItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementApiService.DeleteTrackItItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.trackItId != nil {
		t := *r.trackItId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trackItId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trackItId", t, "multi")
		}
	}
	if r.trackItIdContext != nil {
		t := *r.trackItIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trackItIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trackItIdContext", t, "multi")
		}
	}
	if r.trackItIdType != nil {
		t := *r.trackItIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trackItIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trackItIdType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementApiGetCalendarTaskRequest struct {
	ctx context.Context
	ApiService *CustomerManagementApiService
	activityId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	idType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementApiGetCalendarTaskRequest) Authorization(authorization string) CustomerManagementApiGetCalendarTaskRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementApiGetCalendarTaskRequest) XAppKey(xAppKey string) CustomerManagementApiGetCalendarTaskRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementApiGetCalendarTaskRequest) XHotelid(xHotelid string) CustomerManagementApiGetCalendarTaskRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementApiGetCalendarTaskRequest) IdContext(idContext string) CustomerManagementApiGetCalendarTaskRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementApiGetCalendarTaskRequest) IdType(idType string) CustomerManagementApiGetCalendarTaskRequest {
	r.idType = &idType
	return r
}

// External system code.
func (r CustomerManagementApiGetCalendarTaskRequest) XExternalsystem(xExternalsystem string) CustomerManagementApiGetCalendarTaskRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementApiGetCalendarTaskRequest) AcceptLanguage(acceptLanguage string) CustomerManagementApiGetCalendarTaskRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementApiGetCalendarTaskRequest) Execute() (*CalendarTask, *http.Response, error) {
	return r.ApiService.GetCalendarTaskExecute(r)
}

/*
GetCalendarTask Get a Calendar Task

With this API you can get a Calendar Task. <p><strong>OperationId:</strong>getCalendarTask</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId
 @return CustomerManagementApiGetCalendarTaskRequest
*/
func (a *CustomerManagementApiService) GetCalendarTask(ctx context.Context, activityId string) CustomerManagementApiGetCalendarTaskRequest {
	return CustomerManagementApiGetCalendarTaskRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
	}
}

// Execute executes the request
//  @return CalendarTask
func (a *CustomerManagementApiService) GetCalendarTaskExecute(r CustomerManagementApiGetCalendarTaskRequest) (*CalendarTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CalendarTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementApiService.GetCalendarTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities/{activityId}/task"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementApiGetCalendarTaskAttachmentsRequest struct {
	ctx context.Context
	ApiService *CustomerManagementApiService
	taskId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	idType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementApiGetCalendarTaskAttachmentsRequest) Authorization(authorization string) CustomerManagementApiGetCalendarTaskAttachmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementApiGetCalendarTaskAttachmentsRequest) XAppKey(xAppKey string) CustomerManagementApiGetCalendarTaskAttachmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementApiGetCalendarTaskAttachmentsRequest) XHotelid(xHotelid string) CustomerManagementApiGetCalendarTaskAttachmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementApiGetCalendarTaskAttachmentsRequest) IdContext(idContext string) CustomerManagementApiGetCalendarTaskAttachmentsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementApiGetCalendarTaskAttachmentsRequest) IdType(idType string) CustomerManagementApiGetCalendarTaskAttachmentsRequest {
	r.idType = &idType
	return r
}

// External system code.
func (r CustomerManagementApiGetCalendarTaskAttachmentsRequest) XExternalsystem(xExternalsystem string) CustomerManagementApiGetCalendarTaskAttachmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementApiGetCalendarTaskAttachmentsRequest) AcceptLanguage(acceptLanguage string) CustomerManagementApiGetCalendarTaskAttachmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementApiGetCalendarTaskAttachmentsRequest) Execute() (*CalendarTaskAttachments, *http.Response, error) {
	return r.ApiService.GetCalendarTaskAttachmentsExecute(r)
}

/*
GetCalendarTaskAttachments Get calendar task attachments

Retrieve the attachments on a Calendar task. <p><strong>OperationId:</strong>getCalendarTaskAttachments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId
 @param hotelId
 @return CustomerManagementApiGetCalendarTaskAttachmentsRequest
*/
func (a *CustomerManagementApiService) GetCalendarTaskAttachments(ctx context.Context, taskId string, hotelId string) CustomerManagementApiGetCalendarTaskAttachmentsRequest {
	return CustomerManagementApiGetCalendarTaskAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CalendarTaskAttachments
func (a *CustomerManagementApiService) GetCalendarTaskAttachmentsExecute(r CustomerManagementApiGetCalendarTaskAttachmentsRequest) (*CalendarTaskAttachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CalendarTaskAttachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementApiService.GetCalendarTaskAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/tasks/{taskId}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taskId) < 1 {
		return localVarReturnValue, nil, reportError("taskId must have at least 1 elements")
	}
	if strlen(r.taskId) > 2000 {
		return localVarReturnValue, nil, reportError("taskId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementApiGetCalendarTasksRequest struct {
	ctx context.Context
	ApiService *CustomerManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	countSummary *bool
	taskSummary *bool
	hotelIds *[]string
	startDate *string
	endDate *string
	duration *string
	completionStatus *string
	priorityCodes *[]string
	classCodes *[]string
	typeCodes *[]string
	purpose *string
	taskOwner *string
	author *string
	accountId *string
	accountIdContext *string
	accountIdType *string
	contactId *string
	contactIdContext *string
	contactIdType *string
	blockId *string
	blockIdContext *string
	blockIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementApiGetCalendarTasksRequest) Authorization(authorization string) CustomerManagementApiGetCalendarTasksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementApiGetCalendarTasksRequest) XAppKey(xAppKey string) CustomerManagementApiGetCalendarTasksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementApiGetCalendarTasksRequest) XHotelid(xHotelid string) CustomerManagementApiGetCalendarTasksRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicator whether summary count will be retrieved or not.
func (r CustomerManagementApiGetCalendarTasksRequest) CountSummary(countSummary bool) CustomerManagementApiGetCalendarTasksRequest {
	r.countSummary = &countSummary
	return r
}

// Indicator whether task summary will be retrieved or not.
func (r CustomerManagementApiGetCalendarTasksRequest) TaskSummary(taskSummary bool) CustomerManagementApiGetCalendarTasksRequest {
	r.taskSummary = &taskSummary
	return r
}

// List of Hotel codes of calendar task.
func (r CustomerManagementApiGetCalendarTasksRequest) HotelIds(hotelIds []string) CustomerManagementApiGetCalendarTasksRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r CustomerManagementApiGetCalendarTasksRequest) StartDate(startDate string) CustomerManagementApiGetCalendarTasksRequest {
	r.startDate = &startDate
	return r
}

func (r CustomerManagementApiGetCalendarTasksRequest) EndDate(endDate string) CustomerManagementApiGetCalendarTasksRequest {
	r.endDate = &endDate
	return r
}

func (r CustomerManagementApiGetCalendarTasksRequest) Duration(duration string) CustomerManagementApiGetCalendarTasksRequest {
	r.duration = &duration
	return r
}

// Defines completion status codes of calendar task.
func (r CustomerManagementApiGetCalendarTasksRequest) CompletionStatus(completionStatus string) CustomerManagementApiGetCalendarTasksRequest {
	r.completionStatus = &completionStatus
	return r
}

// List of priority levels of calendar task.
func (r CustomerManagementApiGetCalendarTasksRequest) PriorityCodes(priorityCodes []string) CustomerManagementApiGetCalendarTasksRequest {
	r.priorityCodes = &priorityCodes
	return r
}

// Defines classification codes of calendar task.
func (r CustomerManagementApiGetCalendarTasksRequest) ClassCodes(classCodes []string) CustomerManagementApiGetCalendarTasksRequest {
	r.classCodes = &classCodes
	return r
}

// List of types of calendar task based on its classification.
func (r CustomerManagementApiGetCalendarTasksRequest) TypeCodes(typeCodes []string) CustomerManagementApiGetCalendarTasksRequest {
	r.typeCodes = &typeCodes
	return r
}

// Brief description and purpose of calendar task.
func (r CustomerManagementApiGetCalendarTasksRequest) Purpose(purpose string) CustomerManagementApiGetCalendarTasksRequest {
	r.purpose = &purpose
	return r
}

// Owner code of the person to whom the calendar task is assigned.
func (r CustomerManagementApiGetCalendarTasksRequest) TaskOwner(taskOwner string) CustomerManagementApiGetCalendarTasksRequest {
	r.taskOwner = &taskOwner
	return r
}

// Author of the calendar task.
func (r CustomerManagementApiGetCalendarTasksRequest) Author(author string) CustomerManagementApiGetCalendarTasksRequest {
	r.author = &author
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementApiGetCalendarTasksRequest) AccountId(accountId string) CustomerManagementApiGetCalendarTasksRequest {
	r.accountId = &accountId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementApiGetCalendarTasksRequest) AccountIdContext(accountIdContext string) CustomerManagementApiGetCalendarTasksRequest {
	r.accountIdContext = &accountIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementApiGetCalendarTasksRequest) AccountIdType(accountIdType string) CustomerManagementApiGetCalendarTasksRequest {
	r.accountIdType = &accountIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementApiGetCalendarTasksRequest) ContactId(contactId string) CustomerManagementApiGetCalendarTasksRequest {
	r.contactId = &contactId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementApiGetCalendarTasksRequest) ContactIdContext(contactIdContext string) CustomerManagementApiGetCalendarTasksRequest {
	r.contactIdContext = &contactIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementApiGetCalendarTasksRequest) ContactIdType(contactIdType string) CustomerManagementApiGetCalendarTasksRequest {
	r.contactIdType = &contactIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementApiGetCalendarTasksRequest) BlockId(blockId string) CustomerManagementApiGetCalendarTasksRequest {
	r.blockId = &blockId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementApiGetCalendarTasksRequest) BlockIdContext(blockIdContext string) CustomerManagementApiGetCalendarTasksRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementApiGetCalendarTasksRequest) BlockIdType(blockIdType string) CustomerManagementApiGetCalendarTasksRequest {
	r.blockIdType = &blockIdType
	return r
}

// External system code.
func (r CustomerManagementApiGetCalendarTasksRequest) XExternalsystem(xExternalsystem string) CustomerManagementApiGetCalendarTasksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementApiGetCalendarTasksRequest) AcceptLanguage(acceptLanguage string) CustomerManagementApiGetCalendarTasksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementApiGetCalendarTasksRequest) Execute() (*CalendarTasks, *http.Response, error) {
	return r.ApiService.GetCalendarTasksExecute(r)
}

/*
GetCalendarTasks Get Calendar Tasks

You can fetch a list of Calendar Tasks for with this API, for one or more properties. <p><strong>OperationId:</strong>getCalendarTasks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerManagementApiGetCalendarTasksRequest
*/
func (a *CustomerManagementApiService) GetCalendarTasks(ctx context.Context) CustomerManagementApiGetCalendarTasksRequest {
	return CustomerManagementApiGetCalendarTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CalendarTasks
func (a *CustomerManagementApiService) GetCalendarTasksExecute(r CustomerManagementApiGetCalendarTasksRequest) (*CalendarTasks, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CalendarTasks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementApiService.GetCalendarTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.countSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countSummary", r.countSummary, "")
	}
	if r.taskSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskSummary", r.taskSummary, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.completionStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completionStatus", r.completionStatus, "")
	}
	if r.priorityCodes != nil {
		t := *r.priorityCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priorityCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priorityCodes", t, "multi")
		}
	}
	if r.classCodes != nil {
		t := *r.classCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classCodes", t, "multi")
		}
	}
	if r.typeCodes != nil {
		t := *r.typeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "typeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "typeCodes", t, "multi")
		}
	}
	if r.purpose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purpose", r.purpose, "")
	}
	if r.taskOwner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskOwner", r.taskOwner, "")
	}
	if r.author != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "author", r.author, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	}
	if r.accountIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", r.accountIdContext, "")
	}
	if r.accountIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdType", r.accountIdType, "")
	}
	if r.contactId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactId", r.contactId, "")
	}
	if r.contactIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactIdContext", r.contactIdContext, "")
	}
	if r.contactIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactIdType", r.contactIdType, "")
	}
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	if r.blockIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", r.blockIdContext, "")
	}
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementApiGetTrackItItemsRequest struct {
	ctx context.Context
	ApiService *CustomerManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ticketId *string
	reservationId *string
	reservationIdContext *string
	reservationIdType *string
	givenName *string
	surname *string
	trackItGroups *[]string
	types *[]string
	locations *[]string
	actions *[]string
	actionStatuses *[]string
	appUserId *string
	appUserIdContext *string
	appUserIdType *string
	assignedStatuses *[]string
	room *string
	followUpDate *string
	createdOn *string
	createdByUserId *string
	createdByUserIdContext *string
	createdByUserIdType *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementApiGetTrackItItemsRequest) Authorization(authorization string) CustomerManagementApiGetTrackItItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementApiGetTrackItItemsRequest) XAppKey(xAppKey string) CustomerManagementApiGetTrackItItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementApiGetTrackItItemsRequest) XHotelid(xHotelid string) CustomerManagementApiGetTrackItItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Complete ticket number of the Track It item.
func (r CustomerManagementApiGetTrackItItemsRequest) TicketId(ticketId string) CustomerManagementApiGetTrackItItemsRequest {
	r.ticketId = &ticketId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementApiGetTrackItItemsRequest) ReservationId(reservationId string) CustomerManagementApiGetTrackItItemsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementApiGetTrackItItemsRequest) ReservationIdContext(reservationIdContext string) CustomerManagementApiGetTrackItItemsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementApiGetTrackItItemsRequest) ReservationIdType(reservationIdType string) CustomerManagementApiGetTrackItItemsRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Given name, first name or names.
func (r CustomerManagementApiGetTrackItItemsRequest) GivenName(givenName string) CustomerManagementApiGetTrackItItemsRequest {
	r.givenName = &givenName
	return r
}

// Family name, last name. May also be used for full name if the sending system does not have the ability to separate a full name into its parts, e.g. the surname element may be used to pass the full name.
func (r CustomerManagementApiGetTrackItItemsRequest) Surname(surname string) CustomerManagementApiGetTrackItItemsRequest {
	r.surname = &surname
	return r
}

// Group to which the Track It items belong.
func (r CustomerManagementApiGetTrackItItemsRequest) TrackItGroups(trackItGroups []string) CustomerManagementApiGetTrackItItemsRequest {
	r.trackItGroups = &trackItGroups
	return r
}

// Track It types based on the Track It group.
func (r CustomerManagementApiGetTrackItItemsRequest) Types(types []string) CustomerManagementApiGetTrackItItemsRequest {
	r.types = &types
	return r
}

// Locations for Track It location.
func (r CustomerManagementApiGetTrackItItemsRequest) Locations(locations []string) CustomerManagementApiGetTrackItItemsRequest {
	r.locations = &locations
	return r
}

// Track It actions based on Track It groups.
func (r CustomerManagementApiGetTrackItItemsRequest) Actions(actions []string) CustomerManagementApiGetTrackItItemsRequest {
	r.actions = &actions
	return r
}

// Action status of the Track It item(Open, Closed).
func (r CustomerManagementApiGetTrackItItemsRequest) ActionStatuses(actionStatuses []string) CustomerManagementApiGetTrackItItemsRequest {
	r.actionStatuses = &actionStatuses
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementApiGetTrackItItemsRequest) AppUserId(appUserId string) CustomerManagementApiGetTrackItItemsRequest {
	r.appUserId = &appUserId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementApiGetTrackItItemsRequest) AppUserIdContext(appUserIdContext string) CustomerManagementApiGetTrackItItemsRequest {
	r.appUserIdContext = &appUserIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementApiGetTrackItItemsRequest) AppUserIdType(appUserIdType string) CustomerManagementApiGetTrackItItemsRequest {
	r.appUserIdType = &appUserIdType
	return r
}

// Assignment status of the Track It item(Assigned, Unassigned).
func (r CustomerManagementApiGetTrackItItemsRequest) AssignedStatuses(assignedStatuses []string) CustomerManagementApiGetTrackItItemsRequest {
	r.assignedStatuses = &assignedStatuses
	return r
}

// Guest&#39;s room number if ticket associated with a reservation.
func (r CustomerManagementApiGetTrackItItemsRequest) Room(room string) CustomerManagementApiGetTrackItItemsRequest {
	r.room = &room
	return r
}

// Follow up date for the ticket.
func (r CustomerManagementApiGetTrackItItemsRequest) FollowUpDate(followUpDate string) CustomerManagementApiGetTrackItItemsRequest {
	r.followUpDate = &followUpDate
	return r
}

// Date when the ticket was created.
func (r CustomerManagementApiGetTrackItItemsRequest) CreatedOn(createdOn string) CustomerManagementApiGetTrackItItemsRequest {
	r.createdOn = &createdOn
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementApiGetTrackItItemsRequest) CreatedByUserId(createdByUserId string) CustomerManagementApiGetTrackItItemsRequest {
	r.createdByUserId = &createdByUserId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementApiGetTrackItItemsRequest) CreatedByUserIdContext(createdByUserIdContext string) CustomerManagementApiGetTrackItItemsRequest {
	r.createdByUserIdContext = &createdByUserIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementApiGetTrackItItemsRequest) CreatedByUserIdType(createdByUserIdType string) CustomerManagementApiGetTrackItItemsRequest {
	r.createdByUserIdType = &createdByUserIdType
	return r
}

// Description associated with the Track It item.
func (r CustomerManagementApiGetTrackItItemsRequest) Description(description string) CustomerManagementApiGetTrackItItemsRequest {
	r.description = &description
	return r
}

// External system code.
func (r CustomerManagementApiGetTrackItItemsRequest) XExternalsystem(xExternalsystem string) CustomerManagementApiGetTrackItItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementApiGetTrackItItemsRequest) AcceptLanguage(acceptLanguage string) CustomerManagementApiGetTrackItItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementApiGetTrackItItemsRequest) Execute() (*TrackItItems, *http.Response, error) {
	return r.ApiService.GetTrackItItemsExecute(r)
}

/*
GetTrackItItems Fetches track it items

Retrieve a list of all Track It Items for a property. <p><strong>OperationId:</strong>getTrackItItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return CustomerManagementApiGetTrackItItemsRequest
*/
func (a *CustomerManagementApiService) GetTrackItItems(ctx context.Context, hotelId string) CustomerManagementApiGetTrackItItemsRequest {
	return CustomerManagementApiGetTrackItItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TrackItItems
func (a *CustomerManagementApiService) GetTrackItItemsExecute(r CustomerManagementApiGetTrackItItemsRequest) (*TrackItItems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackItItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementApiService.GetTrackItItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.ticketId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketId", r.ticketId, "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
	}
	if r.trackItGroups != nil {
		t := *r.trackItGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trackItGroups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trackItGroups", t, "multi")
		}
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.locations != nil {
		t := *r.locations
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locations", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locations", t, "multi")
		}
	}
	if r.actions != nil {
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "multi")
		}
	}
	if r.actionStatuses != nil {
		t := *r.actionStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actionStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actionStatuses", t, "multi")
		}
	}
	if r.appUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appUserId", r.appUserId, "")
	}
	if r.appUserIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appUserIdContext", r.appUserIdContext, "")
	}
	if r.appUserIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appUserIdType", r.appUserIdType, "")
	}
	if r.assignedStatuses != nil {
		t := *r.assignedStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assignedStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assignedStatuses", t, "multi")
		}
	}
	if r.room != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "room", r.room, "")
	}
	if r.followUpDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpDate", r.followUpDate, "")
	}
	if r.createdOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOn", r.createdOn, "")
	}
	if r.createdByUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdByUserId", r.createdByUserId, "")
	}
	if r.createdByUserIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdByUserIdContext", r.createdByUserIdContext, "")
	}
	if r.createdByUserIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdByUserIdType", r.createdByUserIdType, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementApiPostCalendarTaskRequest struct {
	ctx context.Context
	ApiService *CustomerManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	calendarTask *PostCalendarTaskRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementApiPostCalendarTaskRequest) Authorization(authorization string) CustomerManagementApiPostCalendarTaskRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementApiPostCalendarTaskRequest) XAppKey(xAppKey string) CustomerManagementApiPostCalendarTaskRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementApiPostCalendarTaskRequest) XHotelid(xHotelid string) CustomerManagementApiPostCalendarTaskRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create calendar task.
func (r CustomerManagementApiPostCalendarTaskRequest) CalendarTask(calendarTask PostCalendarTaskRequest) CustomerManagementApiPostCalendarTaskRequest {
	r.calendarTask = &calendarTask
	return r
}

// External system code.
func (r CustomerManagementApiPostCalendarTaskRequest) XExternalsystem(xExternalsystem string) CustomerManagementApiPostCalendarTaskRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementApiPostCalendarTaskRequest) AcceptLanguage(acceptLanguage string) CustomerManagementApiPostCalendarTaskRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementApiPostCalendarTaskRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCalendarTaskExecute(r)
}

/*
PostCalendarTask Create Calendar Task

This API will allow you to create a new Calendar Task. <p><strong>OperationId:</strong>postCalendarTask</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return CustomerManagementApiPostCalendarTaskRequest
*/
func (a *CustomerManagementApiService) PostCalendarTask(ctx context.Context, hotelId string) CustomerManagementApiPostCalendarTaskRequest {
	return CustomerManagementApiPostCalendarTaskRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CustomerManagementApiService) PostCalendarTaskExecute(r CustomerManagementApiPostCalendarTaskRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementApiService.PostCalendarTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/task"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.calendarTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementApiPostTrackItItemsRequest struct {
	ctx context.Context
	ApiService *CustomerManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	trackItItems *PutTrackItItemsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementApiPostTrackItItemsRequest) Authorization(authorization string) CustomerManagementApiPostTrackItItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementApiPostTrackItItemsRequest) XAppKey(xAppKey string) CustomerManagementApiPostTrackItItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementApiPostTrackItItemsRequest) XHotelid(xHotelid string) CustomerManagementApiPostTrackItItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create Track It items.
func (r CustomerManagementApiPostTrackItItemsRequest) TrackItItems(trackItItems PutTrackItItemsRequest) CustomerManagementApiPostTrackItItemsRequest {
	r.trackItItems = &trackItItems
	return r
}

// External system code.
func (r CustomerManagementApiPostTrackItItemsRequest) XExternalsystem(xExternalsystem string) CustomerManagementApiPostTrackItItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementApiPostTrackItItemsRequest) AcceptLanguage(acceptLanguage string) CustomerManagementApiPostTrackItItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementApiPostTrackItItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTrackItItemsExecute(r)
}

/*
PostTrackItItems Creates track it items

Create a new Track It Item. Track It manages storage and delivery of guest luggage, parcels, vehicles (valet), and lost items.  They can optionally be linked to a reservation if related or an arrival, in-house or departure reservation. <p><strong>OperationId:</strong>postTrackItItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return CustomerManagementApiPostTrackItItemsRequest
*/
func (a *CustomerManagementApiService) PostTrackItItems(ctx context.Context, hotelId string) CustomerManagementApiPostTrackItItemsRequest {
	return CustomerManagementApiPostTrackItItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CustomerManagementApiService) PostTrackItItemsExecute(r CustomerManagementApiPostTrackItItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementApiService.PostTrackItItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.trackItItems
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementApiPutCalendarTaskRequest struct {
	ctx context.Context
	ApiService *CustomerManagementApiService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	calendarTask *PostCalendarTaskRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementApiPutCalendarTaskRequest) Authorization(authorization string) CustomerManagementApiPutCalendarTaskRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementApiPutCalendarTaskRequest) XAppKey(xAppKey string) CustomerManagementApiPutCalendarTaskRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementApiPutCalendarTaskRequest) XHotelid(xHotelid string) CustomerManagementApiPutCalendarTaskRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to update calendar task.
func (r CustomerManagementApiPutCalendarTaskRequest) CalendarTask(calendarTask PostCalendarTaskRequest) CustomerManagementApiPutCalendarTaskRequest {
	r.calendarTask = &calendarTask
	return r
}

// External system code.
func (r CustomerManagementApiPutCalendarTaskRequest) XExternalsystem(xExternalsystem string) CustomerManagementApiPutCalendarTaskRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementApiPutCalendarTaskRequest) AcceptLanguage(acceptLanguage string) CustomerManagementApiPutCalendarTaskRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementApiPutCalendarTaskRequest) Execute() (*CalendarTask, *http.Response, error) {
	return r.ApiService.PutCalendarTaskExecute(r)
}

/*
PutCalendarTask Update Calendar Task

This API will allow you to update an existing Calendar Task. <p><strong>OperationId:</strong>putCalendarTask</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId
 @param hotelId
 @return CustomerManagementApiPutCalendarTaskRequest
*/
func (a *CustomerManagementApiService) PutCalendarTask(ctx context.Context, activityId string, hotelId string) CustomerManagementApiPutCalendarTaskRequest {
	return CustomerManagementApiPutCalendarTaskRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CalendarTask
func (a *CustomerManagementApiService) PutCalendarTaskExecute(r CustomerManagementApiPutCalendarTaskRequest) (*CalendarTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CalendarTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementApiService.PutCalendarTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}/task"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.calendarTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementApiPutTrackItItemsRequest struct {
	ctx context.Context
	ApiService *CustomerManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	trackItItems *PutTrackItItemsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementApiPutTrackItItemsRequest) Authorization(authorization string) CustomerManagementApiPutTrackItItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementApiPutTrackItItemsRequest) XAppKey(xAppKey string) CustomerManagementApiPutTrackItItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementApiPutTrackItItemsRequest) XHotelid(xHotelid string) CustomerManagementApiPutTrackItItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to update Track It items.
func (r CustomerManagementApiPutTrackItItemsRequest) TrackItItems(trackItItems PutTrackItItemsRequest) CustomerManagementApiPutTrackItItemsRequest {
	r.trackItItems = &trackItItems
	return r
}

// External system code.
func (r CustomerManagementApiPutTrackItItemsRequest) XExternalsystem(xExternalsystem string) CustomerManagementApiPutTrackItItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementApiPutTrackItItemsRequest) AcceptLanguage(acceptLanguage string) CustomerManagementApiPutTrackItItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementApiPutTrackItItemsRequest) Execute() (*TrackItItems, *http.Response, error) {
	return r.ApiService.PutTrackItItemsExecute(r)
}

/*
PutTrackItItems Updates track it items

Update the details of a Track It Item for a property. <p><strong>OperationId:</strong>putTrackItItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return CustomerManagementApiPutTrackItItemsRequest
*/
func (a *CustomerManagementApiService) PutTrackItItems(ctx context.Context, hotelId string) CustomerManagementApiPutTrackItItemsRequest {
	return CustomerManagementApiPutTrackItItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TrackItItems
func (a *CustomerManagementApiService) PutTrackItItemsExecute(r CustomerManagementApiPutTrackItItemsRequest) (*TrackItItems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackItItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementApiService.PutTrackItItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.trackItItems
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
