/*
OPERA Cloud Sales Event Management API

APIs to cater for Event Management functionality in OPERA Cloud. <br /><br />The Events feature in OPERA Cloud is designed to manage any kind of catering activity. Events can be as simple as a one-hour reception or more complex, such as a three-day business meeting with meals, breaks, and specific meeting functionSpaceDetails with setupCode and resource requirements. Any group function can be an Event.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package evm

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// EventManagementApiService EventManagementApi service
type EventManagementApiService service

type EventManagementApiCateringEventsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringEventsBulkUpdate *CateringEventsBulkUpdateRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiCateringEventsBulkUpdateRequest) Authorization(authorization string) EventManagementApiCateringEventsBulkUpdateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiCateringEventsBulkUpdateRequest) XAppKey(xAppKey string) EventManagementApiCateringEventsBulkUpdateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiCateringEventsBulkUpdateRequest) XHotelid(xHotelid string) EventManagementApiCateringEventsBulkUpdateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object that will Change a list of events.
func (r EventManagementApiCateringEventsBulkUpdateRequest) CateringEventsBulkUpdate(cateringEventsBulkUpdate CateringEventsBulkUpdateRequest) EventManagementApiCateringEventsBulkUpdateRequest {
	r.cateringEventsBulkUpdate = &cateringEventsBulkUpdate
	return r
}

// External system code.
func (r EventManagementApiCateringEventsBulkUpdateRequest) XExternalsystem(xExternalsystem string) EventManagementApiCateringEventsBulkUpdateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiCateringEventsBulkUpdateRequest) AcceptLanguage(acceptLanguage string) EventManagementApiCateringEventsBulkUpdateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiCateringEventsBulkUpdateRequest) Execute() (*CateringEventsBulkUpdateStatus, *http.Response, error) {
	return r.ApiService.CateringEventsBulkUpdateExecute(r)
}

/*
CateringEventsBulkUpdate Update multiple catering events

You can use this API to update one/more catering events for the same block <p><strong>OperationId:</strong>cateringEventsBulkUpdate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EventManagementApiCateringEventsBulkUpdateRequest
*/
func (a *EventManagementApiService) CateringEventsBulkUpdate(ctx context.Context) EventManagementApiCateringEventsBulkUpdateRequest {
	return EventManagementApiCateringEventsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CateringEventsBulkUpdateStatus
func (a *EventManagementApiService) CateringEventsBulkUpdateExecute(r EventManagementApiCateringEventsBulkUpdateRequest) (*CateringEventsBulkUpdateStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringEventsBulkUpdateStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.CateringEventsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringEvents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringEventsBulkUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiChangeCateringPackageRevenueRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringPackageRevenue *ChangeCateringPackageRevenueRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiChangeCateringPackageRevenueRequest) Authorization(authorization string) EventManagementApiChangeCateringPackageRevenueRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiChangeCateringPackageRevenueRequest) XAppKey(xAppKey string) EventManagementApiChangeCateringPackageRevenueRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiChangeCateringPackageRevenueRequest) XHotelid(xHotelid string) EventManagementApiChangeCateringPackageRevenueRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing revenue details of the associated catering package.
func (r EventManagementApiChangeCateringPackageRevenueRequest) CateringPackageRevenue(cateringPackageRevenue ChangeCateringPackageRevenueRequest) EventManagementApiChangeCateringPackageRevenueRequest {
	r.cateringPackageRevenue = &cateringPackageRevenue
	return r
}

// External system code.
func (r EventManagementApiChangeCateringPackageRevenueRequest) XExternalsystem(xExternalsystem string) EventManagementApiChangeCateringPackageRevenueRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiChangeCateringPackageRevenueRequest) AcceptLanguage(acceptLanguage string) EventManagementApiChangeCateringPackageRevenueRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiChangeCateringPackageRevenueRequest) Execute() (*CateringPackageRevenue, *http.Response, error) {
	return r.ApiService.ChangeCateringPackageRevenueExecute(r)
}

/*
ChangeCateringPackageRevenue Update Catering package revenue

Update the catering package revenue on a block. <p><strong>OperationId:</strong>changeCateringPackageRevenue</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EventManagementApiChangeCateringPackageRevenueRequest
*/
func (a *EventManagementApiService) ChangeCateringPackageRevenue(ctx context.Context) EventManagementApiChangeCateringPackageRevenueRequest {
	return EventManagementApiChangeCateringPackageRevenueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CateringPackageRevenue
func (a *EventManagementApiService) ChangeCateringPackageRevenueExecute(r EventManagementApiChangeCateringPackageRevenueRequest) (*CateringPackageRevenue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringPackageRevenue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.ChangeCateringPackageRevenue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringPackagesRevenue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringPackageRevenue
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiChangeCateringPackagesRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringPackages *ChangeCateringPackagesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiChangeCateringPackagesRequest) Authorization(authorization string) EventManagementApiChangeCateringPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiChangeCateringPackagesRequest) XAppKey(xAppKey string) EventManagementApiChangeCateringPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiChangeCateringPackagesRequest) XHotelid(xHotelid string) EventManagementApiChangeCateringPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying details of associated catering packages.
func (r EventManagementApiChangeCateringPackagesRequest) CateringPackages(cateringPackages ChangeCateringPackagesRequest) EventManagementApiChangeCateringPackagesRequest {
	r.cateringPackages = &cateringPackages
	return r
}

// External system code.
func (r EventManagementApiChangeCateringPackagesRequest) XExternalsystem(xExternalsystem string) EventManagementApiChangeCateringPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiChangeCateringPackagesRequest) AcceptLanguage(acceptLanguage string) EventManagementApiChangeCateringPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiChangeCateringPackagesRequest) Execute() (*CateringPackages, *http.Response, error) {
	return r.ApiService.ChangeCateringPackagesExecute(r)
}

/*
ChangeCateringPackages Update a Catering packages

Update a Catering Package which already exists on the block. <p><strong>OperationId:</strong>changeCateringPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Unique ID of the block
 @return EventManagementApiChangeCateringPackagesRequest
*/
func (a *EventManagementApiService) ChangeCateringPackages(ctx context.Context, blockId string) EventManagementApiChangeCateringPackagesRequest {
	return EventManagementApiChangeCateringPackagesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return CateringPackages
func (a *EventManagementApiService) ChangeCateringPackagesExecute(r EventManagementApiChangeCateringPackagesRequest) (*CateringPackages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringPackages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.ChangeCateringPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/cateringPackages"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringPackages
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiChangeEventResourceByMenuRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	eventResource *ChangeEventResourceByMenuRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiChangeEventResourceByMenuRequest) Authorization(authorization string) EventManagementApiChangeEventResourceByMenuRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiChangeEventResourceByMenuRequest) XAppKey(xAppKey string) EventManagementApiChangeEventResourceByMenuRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiChangeEventResourceByMenuRequest) XHotelid(xHotelid string) EventManagementApiChangeEventResourceByMenuRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying event resource details.
func (r EventManagementApiChangeEventResourceByMenuRequest) EventResource(eventResource ChangeEventResourceByMenuRequest) EventManagementApiChangeEventResourceByMenuRequest {
	r.eventResource = &eventResource
	return r
}

// External system code.
func (r EventManagementApiChangeEventResourceByMenuRequest) XExternalsystem(xExternalsystem string) EventManagementApiChangeEventResourceByMenuRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiChangeEventResourceByMenuRequest) AcceptLanguage(acceptLanguage string) EventManagementApiChangeEventResourceByMenuRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiChangeEventResourceByMenuRequest) Execute() (*EventResource, *http.Response, error) {
	return r.ApiService.ChangeEventResourceByMenuExecute(r)
}

/*
ChangeEventResourceByMenu Update Event Resource 

Use this API to update the Event Resources by specifying the block ID, and event ID in the request. <p><strong>OperationId:</strong>changeEventResourceByMenu</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EventManagementApiChangeEventResourceByMenuRequest
*/
func (a *EventManagementApiService) ChangeEventResourceByMenu(ctx context.Context) EventManagementApiChangeEventResourceByMenuRequest {
	return EventManagementApiChangeEventResourceByMenuRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventResource
func (a *EventManagementApiService) ChangeEventResourceByMenuExecute(r EventManagementApiChangeEventResourceByMenuRequest) (*EventResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.ChangeEventResourceByMenu")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventResource"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eventResource
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiChangeEventsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	eventId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	event *ChangeEventsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiChangeEventsRequest) Authorization(authorization string) EventManagementApiChangeEventsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiChangeEventsRequest) XAppKey(xAppKey string) EventManagementApiChangeEventsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiChangeEventsRequest) XHotelid(xHotelid string) EventManagementApiChangeEventsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing event.
func (r EventManagementApiChangeEventsRequest) Event(event ChangeEventsRequest) EventManagementApiChangeEventsRequest {
	r.event = &event
	return r
}

// External system code.
func (r EventManagementApiChangeEventsRequest) XExternalsystem(xExternalsystem string) EventManagementApiChangeEventsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiChangeEventsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiChangeEventsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiChangeEventsRequest) Execute() (*Event, *http.Response, error) {
	return r.ApiService.ChangeEventsExecute(r)
}

/*
ChangeEvents Update an Event

You can use this API to update an existing Event by using the Event ID.  If you don't know the vent ID, use getEvents API to search for an event first. <p><strong>OperationId:</strong>changeEvents</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId Unique ID of the event
 @param hotelId Unique ID of a hotel
 @return EventManagementApiChangeEventsRequest
*/
func (a *EventManagementApiService) ChangeEvents(ctx context.Context, eventId string, hotelId string) EventManagementApiChangeEventsRequest {
	return EventManagementApiChangeEventsRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Event
func (a *EventManagementApiService) ChangeEventsExecute(r EventManagementApiChangeEventsRequest) (*Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.ChangeEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/events/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.event
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiChangeEventsResourcesRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	manageEventsResources *ChangeEventsResourcesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiChangeEventsResourcesRequest) Authorization(authorization string) EventManagementApiChangeEventsResourcesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiChangeEventsResourcesRequest) XAppKey(xAppKey string) EventManagementApiChangeEventsResourcesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiChangeEventsResourcesRequest) XHotelid(xHotelid string) EventManagementApiChangeEventsResourcesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for managing events resources.
func (r EventManagementApiChangeEventsResourcesRequest) ManageEventsResources(manageEventsResources ChangeEventsResourcesRequest) EventManagementApiChangeEventsResourcesRequest {
	r.manageEventsResources = &manageEventsResources
	return r
}

// External system code.
func (r EventManagementApiChangeEventsResourcesRequest) XExternalsystem(xExternalsystem string) EventManagementApiChangeEventsResourcesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiChangeEventsResourcesRequest) AcceptLanguage(acceptLanguage string) EventManagementApiChangeEventsResourcesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiChangeEventsResourcesRequest) Execute() (*ManageEventsResources, *http.Response, error) {
	return r.ApiService.ChangeEventsResourcesExecute(r)
}

/*
ChangeEventsResources Update Events Resources

Update the details of an existing event resource on an event in OPERA Cloud. <p><strong>OperationId:</strong>changeEventsResources</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return EventManagementApiChangeEventsResourcesRequest
*/
func (a *EventManagementApiService) ChangeEventsResources(ctx context.Context, hotelId string) EventManagementApiChangeEventsResourcesRequest {
	return EventManagementApiChangeEventsResourcesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ManageEventsResources
func (a *EventManagementApiService) ChangeEventsResourcesExecute(r EventManagementApiChangeEventsResourcesRequest) (*ManageEventsResources, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManageEventsResources
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.ChangeEventsResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/eventsResources"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.manageEventsResources
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiChangeEventsResourcesByChainRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	manageEventsResources *ChangeEventsResourcesByChainRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiChangeEventsResourcesByChainRequest) Authorization(authorization string) EventManagementApiChangeEventsResourcesByChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiChangeEventsResourcesByChainRequest) XAppKey(xAppKey string) EventManagementApiChangeEventsResourcesByChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiChangeEventsResourcesByChainRequest) XHotelid(xHotelid string) EventManagementApiChangeEventsResourcesByChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for managing events resources.
func (r EventManagementApiChangeEventsResourcesByChainRequest) ManageEventsResources(manageEventsResources ChangeEventsResourcesByChainRequest) EventManagementApiChangeEventsResourcesByChainRequest {
	r.manageEventsResources = &manageEventsResources
	return r
}

// External system code.
func (r EventManagementApiChangeEventsResourcesByChainRequest) XExternalsystem(xExternalsystem string) EventManagementApiChangeEventsResourcesByChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiChangeEventsResourcesByChainRequest) AcceptLanguage(acceptLanguage string) EventManagementApiChangeEventsResourcesByChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiChangeEventsResourcesByChainRequest) Execute() (*ManageEventsResources, *http.Response, error) {
	return r.ApiService.ChangeEventsResourcesByChainExecute(r)
}

/*
ChangeEventsResourcesByChain Update Events Resources by chain

Update the details of an existing event resource on an event in OPERA Cloud. <p><strong>OperationId:</strong>changeEventsResourcesByChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EventManagementApiChangeEventsResourcesByChainRequest
*/
func (a *EventManagementApiService) ChangeEventsResourcesByChain(ctx context.Context) EventManagementApiChangeEventsResourcesByChainRequest {
	return EventManagementApiChangeEventsResourcesByChainRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManageEventsResources
func (a *EventManagementApiService) ChangeEventsResourcesByChainExecute(r EventManagementApiChangeEventsResourcesByChainRequest) (*ManageEventsResources, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManageEventsResources
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.ChangeEventsResourcesByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventsResources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.manageEventsResources
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiCopyCateringEventsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyCateringEvents *CopyCateringEventsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiCopyCateringEventsRequest) Authorization(authorization string) EventManagementApiCopyCateringEventsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiCopyCateringEventsRequest) XAppKey(xAppKey string) EventManagementApiCopyCateringEventsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiCopyCateringEventsRequest) XHotelid(xHotelid string) EventManagementApiCopyCateringEventsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying events.
func (r EventManagementApiCopyCateringEventsRequest) CopyCateringEvents(copyCateringEvents CopyCateringEventsRequest) EventManagementApiCopyCateringEventsRequest {
	r.copyCateringEvents = &copyCateringEvents
	return r
}

// External system code.
func (r EventManagementApiCopyCateringEventsRequest) XExternalsystem(xExternalsystem string) EventManagementApiCopyCateringEventsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiCopyCateringEventsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiCopyCateringEventsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiCopyCateringEventsRequest) Execute() (*CopyCateringEventsResponse, *http.Response, error) {
	return r.ApiService.CopyCateringEventsExecute(r)
}

/*
CopyCateringEvents Copy Catering Event

Copy an existing catering event on a block to new dates on that block.  For example there is a catering Event called Lunch for 1st May, select this event, and copy it to a new date within the block date range.  This will result in a second catering event existing on this block.  You can choose to copy certain elements such as event notes, event resources and so on. <p><strong>OperationId:</strong>copyCateringEvents</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Unique ID of the block
 @param hotelId Unique ID of the hotel
 @return EventManagementApiCopyCateringEventsRequest
*/
func (a *EventManagementApiService) CopyCateringEvents(ctx context.Context, blockId string, hotelId string) EventManagementApiCopyCateringEventsRequest {
	return EventManagementApiCopyCateringEventsRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CopyCateringEventsResponse
func (a *EventManagementApiService) CopyCateringEventsExecute(r EventManagementApiCopyCateringEventsRequest) (*CopyCateringEventsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CopyCateringEventsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.CopyCateringEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/cateringEvents/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyCateringEvents
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiCopyCateringPackageRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	cateringpackageId string
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyCateringPackage *CopyCateringPackageRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiCopyCateringPackageRequest) Authorization(authorization string) EventManagementApiCopyCateringPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiCopyCateringPackageRequest) XAppKey(xAppKey string) EventManagementApiCopyCateringPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiCopyCateringPackageRequest) XHotelid(xHotelid string) EventManagementApiCopyCateringPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Copying Catering Package/Template to another block.
func (r EventManagementApiCopyCateringPackageRequest) CopyCateringPackage(copyCateringPackage CopyCateringPackageRequest) EventManagementApiCopyCateringPackageRequest {
	r.copyCateringPackage = &copyCateringPackage
	return r
}

// External system code.
func (r EventManagementApiCopyCateringPackageRequest) XExternalsystem(xExternalsystem string) EventManagementApiCopyCateringPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiCopyCateringPackageRequest) AcceptLanguage(acceptLanguage string) EventManagementApiCopyCateringPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiCopyCateringPackageRequest) Execute() (*CopyCateringPackageResponse, *http.Response, error) {
	return r.ApiService.CopyCateringPackageExecute(r)
}

/*
CopyCateringPackage Copy a Catering package

Use this API to copy an existing Catering Package one the block to another date on the same block. <p><strong>OperationId:</strong>copyCateringPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringpackageId Unique ID of the catering package
 @param blockId Unique ID of the block
 @return EventManagementApiCopyCateringPackageRequest
*/
func (a *EventManagementApiService) CopyCateringPackage(ctx context.Context, cateringpackageId string, blockId string) EventManagementApiCopyCateringPackageRequest {
	return EventManagementApiCopyCateringPackageRequest{
		ApiService: a,
		ctx: ctx,
		cateringpackageId: cateringpackageId,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return CopyCateringPackageResponse
func (a *EventManagementApiService) CopyCateringPackageExecute(r EventManagementApiCopyCateringPackageRequest) (*CopyCateringPackageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CopyCateringPackageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.CopyCateringPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/cateringPackages/{cateringpackageId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringpackageId"+"}", url.PathEscape(parameterValueToString(r.cateringpackageId, "cateringpackageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringpackageId) < 1 {
		return localVarReturnValue, nil, reportError("cateringpackageId must have at least 1 elements")
	}
	if strlen(r.cateringpackageId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringpackageId must have less than 2000 elements")
	}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyCateringPackage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiCopyEventResourcesRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	eventId string
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eventResources *CopyEventResourcesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiCopyEventResourcesRequest) Authorization(authorization string) EventManagementApiCopyEventResourcesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiCopyEventResourcesRequest) XAppKey(xAppKey string) EventManagementApiCopyEventResourcesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiCopyEventResourcesRequest) XHotelid(xHotelid string) EventManagementApiCopyEventResourcesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying event resources.
func (r EventManagementApiCopyEventResourcesRequest) EventResources(eventResources CopyEventResourcesRequest) EventManagementApiCopyEventResourcesRequest {
	r.eventResources = &eventResources
	return r
}

// External system code.
func (r EventManagementApiCopyEventResourcesRequest) XExternalsystem(xExternalsystem string) EventManagementApiCopyEventResourcesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiCopyEventResourcesRequest) AcceptLanguage(acceptLanguage string) EventManagementApiCopyEventResourcesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiCopyEventResourcesRequest) Execute() (*EventResourcesResponse, *http.Response, error) {
	return r.ApiService.CopyEventResourcesExecute(r)
}

/*
CopyEventResources Copy event resources

You can use this API to copy one/more existing event resources to one/more events for the same/different block. <p><strong>OperationId:</strong>copyEventResources</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId Unique ID of the event
 @param blockId Unique ID of the block
 @return EventManagementApiCopyEventResourcesRequest
*/
func (a *EventManagementApiService) CopyEventResources(ctx context.Context, eventId string, blockId string) EventManagementApiCopyEventResourcesRequest {
	return EventManagementApiCopyEventResourcesRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return EventResourcesResponse
func (a *EventManagementApiService) CopyEventResourcesExecute(r EventManagementApiCopyEventResourcesRequest) (*EventResourcesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventResourcesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.CopyEventResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/events/{eventId}/resources/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eventResources
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiDeleteCateringPackageRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	cateringPackageId string
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiDeleteCateringPackageRequest) Authorization(authorization string) EventManagementApiDeleteCateringPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiDeleteCateringPackageRequest) XAppKey(xAppKey string) EventManagementApiDeleteCateringPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiDeleteCateringPackageRequest) XHotelid(xHotelid string) EventManagementApiDeleteCateringPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r EventManagementApiDeleteCateringPackageRequest) XExternalsystem(xExternalsystem string) EventManagementApiDeleteCateringPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiDeleteCateringPackageRequest) AcceptLanguage(acceptLanguage string) EventManagementApiDeleteCateringPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiDeleteCateringPackageRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringPackageExecute(r)
}

/*
DeleteCateringPackage Delete Catering package

This allows you to remove an existing catering package from the Block <p><strong>OperationId:</strong>deleteCateringPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringPackageId Unique ID of the Catering Package
 @param blockId Unique ID of the block
 @param hotelId Unique ID of the hotel
 @return EventManagementApiDeleteCateringPackageRequest
*/
func (a *EventManagementApiService) DeleteCateringPackage(ctx context.Context, cateringPackageId string, blockId string, hotelId string) EventManagementApiDeleteCateringPackageRequest {
	return EventManagementApiDeleteCateringPackageRequest{
		ApiService: a,
		ctx: ctx,
		cateringPackageId: cateringPackageId,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *EventManagementApiService) DeleteCateringPackageExecute(r EventManagementApiDeleteCateringPackageRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.DeleteCateringPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/cateringPackages/{cateringPackageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringPackageId"+"}", url.PathEscape(parameterValueToString(r.cateringPackageId, "cateringPackageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringPackageId) < 1 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have at least 1 elements")
	}
	if strlen(r.cateringPackageId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have less than 2000 elements")
	}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiDeleteCateringPackageRevenueRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	cateringPackageEventId *string
	cateringPackageRevenueType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiDeleteCateringPackageRevenueRequest) Authorization(authorization string) EventManagementApiDeleteCateringPackageRevenueRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiDeleteCateringPackageRevenueRequest) XAppKey(xAppKey string) EventManagementApiDeleteCateringPackageRevenueRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiDeleteCateringPackageRevenueRequest) XHotelid(xHotelid string) EventManagementApiDeleteCateringPackageRevenueRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r EventManagementApiDeleteCateringPackageRevenueRequest) HotelId(hotelId string) EventManagementApiDeleteCateringPackageRevenueRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r EventManagementApiDeleteCateringPackageRevenueRequest) CateringPackageEventId(cateringPackageEventId string) EventManagementApiDeleteCateringPackageRevenueRequest {
	r.cateringPackageEventId = &cateringPackageEventId
	return r
}

// Revenue Type associated with the Catering Package Price Code.
func (r EventManagementApiDeleteCateringPackageRevenueRequest) CateringPackageRevenueType(cateringPackageRevenueType string) EventManagementApiDeleteCateringPackageRevenueRequest {
	r.cateringPackageRevenueType = &cateringPackageRevenueType
	return r
}

// External system code.
func (r EventManagementApiDeleteCateringPackageRevenueRequest) XExternalsystem(xExternalsystem string) EventManagementApiDeleteCateringPackageRevenueRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiDeleteCateringPackageRevenueRequest) AcceptLanguage(acceptLanguage string) EventManagementApiDeleteCateringPackageRevenueRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiDeleteCateringPackageRevenueRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringPackageRevenueExecute(r)
}

/*
DeleteCateringPackageRevenue Delete Catering package revenue

Delete the catering package revenue on a block. <p><strong>OperationId:</strong>deleteCateringPackageRevenue</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EventManagementApiDeleteCateringPackageRevenueRequest
*/
func (a *EventManagementApiService) DeleteCateringPackageRevenue(ctx context.Context) EventManagementApiDeleteCateringPackageRevenueRequest {
	return EventManagementApiDeleteCateringPackageRevenueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *EventManagementApiService) DeleteCateringPackageRevenueExecute(r EventManagementApiDeleteCateringPackageRevenueRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.DeleteCateringPackageRevenue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringPackagesRevenue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.cateringPackageEventId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringPackageEventId", r.cateringPackageEventId, "")
	}
	if r.cateringPackageRevenueType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringPackageRevenueType", r.cateringPackageRevenueType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiDeleteCateringPackagesRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	blockId string
	hotelId string
	cateringPackageId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r EventManagementApiDeleteCateringPackagesRequest) CateringPackageId(cateringPackageId []string) EventManagementApiDeleteCateringPackagesRequest {
	r.cateringPackageId = &cateringPackageId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiDeleteCateringPackagesRequest) Authorization(authorization string) EventManagementApiDeleteCateringPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiDeleteCateringPackagesRequest) XAppKey(xAppKey string) EventManagementApiDeleteCateringPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiDeleteCateringPackagesRequest) XHotelid(xHotelid string) EventManagementApiDeleteCateringPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r EventManagementApiDeleteCateringPackagesRequest) XExternalsystem(xExternalsystem string) EventManagementApiDeleteCateringPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiDeleteCateringPackagesRequest) AcceptLanguage(acceptLanguage string) EventManagementApiDeleteCateringPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiDeleteCateringPackagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringPackagesExecute(r)
}

/*
DeleteCateringPackages Delete one or more catering package(s)

This allows you to remove an existing catering package from the Block <p><strong>OperationId:</strong>deleteCateringPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Unique ID of the block
 @param hotelId Unique ID of the hotel
 @return EventManagementApiDeleteCateringPackagesRequest
*/
func (a *EventManagementApiService) DeleteCateringPackages(ctx context.Context, blockId string, hotelId string) EventManagementApiDeleteCateringPackagesRequest {
	return EventManagementApiDeleteCateringPackagesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *EventManagementApiService) DeleteCateringPackagesExecute(r EventManagementApiDeleteCateringPackagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.DeleteCateringPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/cateringPackages"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	{
		t := *r.cateringPackageId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cateringPackageId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cateringPackageId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiDeleteEventsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	eventId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeSubEvents *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiDeleteEventsRequest) Authorization(authorization string) EventManagementApiDeleteEventsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiDeleteEventsRequest) XAppKey(xAppKey string) EventManagementApiDeleteEventsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiDeleteEventsRequest) XHotelid(xHotelid string) EventManagementApiDeleteEventsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether to delete/inactive the sub event(s) of the master event.
func (r EventManagementApiDeleteEventsRequest) IncludeSubEvents(includeSubEvents bool) EventManagementApiDeleteEventsRequest {
	r.includeSubEvents = &includeSubEvents
	return r
}

// External system code.
func (r EventManagementApiDeleteEventsRequest) XExternalsystem(xExternalsystem string) EventManagementApiDeleteEventsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiDeleteEventsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiDeleteEventsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiDeleteEventsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteEventsExecute(r)
}

/*
DeleteEvents Delete an Event

This API will delete an existing event <p><strong>OperationId:</strong>deleteEvents</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId Unique ID of the event
 @param hotelId Unique ID of a hotel
 @return EventManagementApiDeleteEventsRequest
*/
func (a *EventManagementApiService) DeleteEvents(ctx context.Context, eventId string, hotelId string) EventManagementApiDeleteEventsRequest {
	return EventManagementApiDeleteEventsRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *EventManagementApiService) DeleteEventsExecute(r EventManagementApiDeleteEventsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.DeleteEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/events/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	if r.includeSubEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSubEvents", r.includeSubEvents, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetBlockPostingAccountReservationsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockId *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetBlockPostingAccountReservationsRequest) Authorization(authorization string) EventManagementApiGetBlockPostingAccountReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetBlockPostingAccountReservationsRequest) XAppKey(xAppKey string) EventManagementApiGetBlockPostingAccountReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetBlockPostingAccountReservationsRequest) XHotelid(xHotelid string) EventManagementApiGetBlockPostingAccountReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r EventManagementApiGetBlockPostingAccountReservationsRequest) BlockId(blockId []string) EventManagementApiGetBlockPostingAccountReservationsRequest {
	r.blockId = &blockId
	return r
}

// External system code.
func (r EventManagementApiGetBlockPostingAccountReservationsRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetBlockPostingAccountReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetBlockPostingAccountReservationsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetBlockPostingAccountReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetBlockPostingAccountReservationsRequest) Execute() (*BlockPostingAccountReservationsInfo, *http.Response, error) {
	return r.ApiService.GetBlockPostingAccountReservationsExecute(r)
}

/*
GetBlockPostingAccountReservations Get Catering Event postings

Retrieve the catering event posting on an event. <p><strong>OperationId:</strong>getBlockPostingAccountReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return EventManagementApiGetBlockPostingAccountReservationsRequest
*/
func (a *EventManagementApiService) GetBlockPostingAccountReservations(ctx context.Context, hotelId string) EventManagementApiGetBlockPostingAccountReservationsRequest {
	return EventManagementApiGetBlockPostingAccountReservationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockPostingAccountReservationsInfo
func (a *EventManagementApiService) GetBlockPostingAccountReservationsExecute(r EventManagementApiGetBlockPostingAccountReservationsRequest) (*BlockPostingAccountReservationsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockPostingAccountReservationsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetBlockPostingAccountReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fetchBlockPostingAccountReservations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetCateringEventChangesRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	fetchInstructions *string
	eventId *[]string
	eventIdContext *[]string
	eventIdType *[]string
	blockId *[]string
	blockIdContext *[]string
	blockIdType *[]string
	changeSource *[]string
	action *[]string
	resourceDescription *string
	fieldNameListCode *[]string
	userListCode *[]string
	eventDate *string
	eventEndDate *string
	eventStartDate *string
	priorStatus *string
	currentStatus *string
	revenueTypeListCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetCateringEventChangesRequest) Authorization(authorization string) EventManagementApiGetCateringEventChangesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetCateringEventChangesRequest) XAppKey(xAppKey string) EventManagementApiGetCateringEventChangesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetCateringEventChangesRequest) XHotelid(xHotelid string) EventManagementApiGetCateringEventChangesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r EventManagementApiGetCateringEventChangesRequest) Limit(limit int32) EventManagementApiGetCateringEventChangesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r EventManagementApiGetCateringEventChangesRequest) Offset(offset int32) EventManagementApiGetCateringEventChangesRequest {
	r.offset = &offset
	return r
}

// A collection of supported list of actions.
func (r EventManagementApiGetCateringEventChangesRequest) FetchInstructions(fetchInstructions string) EventManagementApiGetCateringEventChangesRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r EventManagementApiGetCateringEventChangesRequest) EventId(eventId []string) EventManagementApiGetCateringEventChangesRequest {
	r.eventId = &eventId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r EventManagementApiGetCateringEventChangesRequest) EventIdContext(eventIdContext []string) EventManagementApiGetCateringEventChangesRequest {
	r.eventIdContext = &eventIdContext
	return r
}

// A reference to the type of object defined by the UniqueID elementSpace. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r EventManagementApiGetCateringEventChangesRequest) EventIdType(eventIdType []string) EventManagementApiGetCateringEventChangesRequest {
	r.eventIdType = &eventIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r EventManagementApiGetCateringEventChangesRequest) BlockId(blockId []string) EventManagementApiGetCateringEventChangesRequest {
	r.blockId = &blockId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r EventManagementApiGetCateringEventChangesRequest) BlockIdContext(blockIdContext []string) EventManagementApiGetCateringEventChangesRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID elementSpace. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r EventManagementApiGetCateringEventChangesRequest) BlockIdType(blockIdType []string) EventManagementApiGetCateringEventChangesRequest {
	r.blockIdType = &blockIdType
	return r
}

// List of sources that can cause the event change
func (r EventManagementApiGetCateringEventChangesRequest) ChangeSource(changeSource []string) EventManagementApiGetCateringEventChangesRequest {
	r.changeSource = &changeSource
	return r
}

// A collection of supported list of actions.
func (r EventManagementApiGetCateringEventChangesRequest) Action(action []string) EventManagementApiGetCateringEventChangesRequest {
	r.action = &action
	return r
}

// Description of the Resource
func (r EventManagementApiGetCateringEventChangesRequest) ResourceDescription(resourceDescription string) EventManagementApiGetCateringEventChangesRequest {
	r.resourceDescription = &resourceDescription
	return r
}

func (r EventManagementApiGetCateringEventChangesRequest) FieldNameListCode(fieldNameListCode []string) EventManagementApiGetCateringEventChangesRequest {
	r.fieldNameListCode = &fieldNameListCode
	return r
}

func (r EventManagementApiGetCateringEventChangesRequest) UserListCode(userListCode []string) EventManagementApiGetCateringEventChangesRequest {
	r.userListCode = &userListCode
	return r
}

// Date of the Events whose details are fetched
func (r EventManagementApiGetCateringEventChangesRequest) EventDate(eventDate string) EventManagementApiGetCateringEventChangesRequest {
	r.eventDate = &eventDate
	return r
}

// The ending value of the date range.
func (r EventManagementApiGetCateringEventChangesRequest) EventEndDate(eventEndDate string) EventManagementApiGetCateringEventChangesRequest {
	r.eventEndDate = &eventEndDate
	return r
}

// The starting value of the date range.
func (r EventManagementApiGetCateringEventChangesRequest) EventStartDate(eventStartDate string) EventManagementApiGetCateringEventChangesRequest {
	r.eventStartDate = &eventStartDate
	return r
}

// Prior Status of the events whose details are fetched
func (r EventManagementApiGetCateringEventChangesRequest) PriorStatus(priorStatus string) EventManagementApiGetCateringEventChangesRequest {
	r.priorStatus = &priorStatus
	return r
}

// Current Status of the events whose details are fetched
func (r EventManagementApiGetCateringEventChangesRequest) CurrentStatus(currentStatus string) EventManagementApiGetCateringEventChangesRequest {
	r.currentStatus = &currentStatus
	return r
}

func (r EventManagementApiGetCateringEventChangesRequest) RevenueTypeListCode(revenueTypeListCode []string) EventManagementApiGetCateringEventChangesRequest {
	r.revenueTypeListCode = &revenueTypeListCode
	return r
}

// External system code.
func (r EventManagementApiGetCateringEventChangesRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetCateringEventChangesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetCateringEventChangesRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetCateringEventChangesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetCateringEventChangesRequest) Execute() (*CateringEventChanges, *http.Response, error) {
	return r.ApiService.GetCateringEventChangesExecute(r)
}

/*
GetCateringEventChanges Get Catering Event changes

Retrieve the catering event changes on an event. <p><strong>OperationId:</strong>getCateringEventChanges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return EventManagementApiGetCateringEventChangesRequest
*/
func (a *EventManagementApiService) GetCateringEventChanges(ctx context.Context, hotelId string) EventManagementApiGetCateringEventChangesRequest {
	return EventManagementApiGetCateringEventChangesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringEventChanges
func (a *EventManagementApiService) GetCateringEventChangesExecute(r EventManagementApiGetCateringEventChangesRequest) (*CateringEventChanges, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringEventChanges
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetCateringEventChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringEventChanges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.fetchInstructions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", r.fetchInstructions, "")
	}
	if r.eventId != nil {
		t := *r.eventId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", t, "multi")
		}
	}
	if r.eventIdContext != nil {
		t := *r.eventIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventIdContext", t, "multi")
		}
	}
	if r.eventIdType != nil {
		t := *r.eventIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventIdType", t, "multi")
		}
	}
	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
	}
	if r.blockIdContext != nil {
		t := *r.blockIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", t, "multi")
		}
	}
	if r.blockIdType != nil {
		t := *r.blockIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", t, "multi")
		}
	}
	if r.changeSource != nil {
		t := *r.changeSource
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "changeSource", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "changeSource", t, "multi")
		}
	}
	if r.action != nil {
		t := *r.action
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "action", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "action", t, "multi")
		}
	}
	if r.resourceDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceDescription", r.resourceDescription, "")
	}
	if r.fieldNameListCode != nil {
		t := *r.fieldNameListCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fieldNameListCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fieldNameListCode", t, "multi")
		}
	}
	if r.userListCode != nil {
		t := *r.userListCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userListCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userListCode", t, "multi")
		}
	}
	if r.eventDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventDate", r.eventDate, "")
	}
	if r.eventEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventEndDate", r.eventEndDate, "")
	}
	if r.eventStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventStartDate", r.eventStartDate, "")
	}
	if r.priorStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priorStatus", r.priorStatus, "")
	}
	if r.currentStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentStatus", r.currentStatus, "")
	}
	if r.revenueTypeListCode != nil {
		t := *r.revenueTypeListCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeListCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeListCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetCateringEventPostingsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	eventId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeSubEvents *bool
	blockId *[]string
	blockIdContext *[]string
	blockIdType *[]string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetCateringEventPostingsRequest) Authorization(authorization string) EventManagementApiGetCateringEventPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetCateringEventPostingsRequest) XAppKey(xAppKey string) EventManagementApiGetCateringEventPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetCateringEventPostingsRequest) XHotelid(xHotelid string) EventManagementApiGetCateringEventPostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether to delete/inactive the sub event(s) of the master event.
func (r EventManagementApiGetCateringEventPostingsRequest) IncludeSubEvents(includeSubEvents bool) EventManagementApiGetCateringEventPostingsRequest {
	r.includeSubEvents = &includeSubEvents
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r EventManagementApiGetCateringEventPostingsRequest) BlockId(blockId []string) EventManagementApiGetCateringEventPostingsRequest {
	r.blockId = &blockId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r EventManagementApiGetCateringEventPostingsRequest) BlockIdContext(blockIdContext []string) EventManagementApiGetCateringEventPostingsRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID elementSpace. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r EventManagementApiGetCateringEventPostingsRequest) BlockIdType(blockIdType []string) EventManagementApiGetCateringEventPostingsRequest {
	r.blockIdType = &blockIdType
	return r
}

// Instruction to fetch all eligible master events for the selected event
func (r EventManagementApiGetCateringEventPostingsRequest) FetchInstructions(fetchInstructions []string) EventManagementApiGetCateringEventPostingsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r EventManagementApiGetCateringEventPostingsRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetCateringEventPostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetCateringEventPostingsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetCateringEventPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetCateringEventPostingsRequest) Execute() (*CateringEventPostingsDetail, *http.Response, error) {
	return r.ApiService.GetCateringEventPostingsExecute(r)
}

/*
GetCateringEventPostings Get Catering Event postings

Retrieve the catering event posting on an event. <p><strong>OperationId:</strong>getCateringEventPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId
 @param hotelId Unique ID of the hotel
 @return EventManagementApiGetCateringEventPostingsRequest
*/
func (a *EventManagementApiService) GetCateringEventPostings(ctx context.Context, eventId string, hotelId string) EventManagementApiGetCateringEventPostingsRequest {
	return EventManagementApiGetCateringEventPostingsRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringEventPostingsDetail
func (a *EventManagementApiService) GetCateringEventPostingsExecute(r EventManagementApiGetCateringEventPostingsRequest) (*CateringEventPostingsDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringEventPostingsDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetCateringEventPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/events/{eventId}/cateringEventPostings"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeSubEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSubEvents", r.includeSubEvents, "")
	}
	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
	}
	if r.blockIdContext != nil {
		t := *r.blockIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", t, "multi")
		}
	}
	if r.blockIdType != nil {
		t := *r.blockIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", t, "multi")
		}
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetCateringPackageRevenueRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	cateringpackageId string
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	idExtension *int32
	blockIdContext *string
	blockIdType *string
	packageIdContext *string
	packageIdType *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetCateringPackageRevenueRequest) Authorization(authorization string) EventManagementApiGetCateringPackageRevenueRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetCateringPackageRevenueRequest) XAppKey(xAppKey string) EventManagementApiGetCateringPackageRevenueRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetCateringPackageRevenueRequest) XHotelid(xHotelid string) EventManagementApiGetCateringPackageRevenueRequest {
	r.xHotelid = &xHotelid
	return r
}

// Block hotel code.
func (r EventManagementApiGetCateringPackageRevenueRequest) HotelId(hotelId string) EventManagementApiGetCateringPackageRevenueRequest {
	r.hotelId = &hotelId
	return r
}

// Additional identifying value assigned by the creating system.
func (r EventManagementApiGetCateringPackageRevenueRequest) IdExtension(idExtension int32) EventManagementApiGetCateringPackageRevenueRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r EventManagementApiGetCateringPackageRevenueRequest) BlockIdContext(blockIdContext string) EventManagementApiGetCateringPackageRevenueRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID elementSpace. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r EventManagementApiGetCateringPackageRevenueRequest) BlockIdType(blockIdType string) EventManagementApiGetCateringPackageRevenueRequest {
	r.blockIdType = &blockIdType
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r EventManagementApiGetCateringPackageRevenueRequest) PackageIdContext(packageIdContext string) EventManagementApiGetCateringPackageRevenueRequest {
	r.packageIdContext = &packageIdContext
	return r
}

// A reference to the type of object defined by the UniqueID elementSpace. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r EventManagementApiGetCateringPackageRevenueRequest) PackageIdType(packageIdType string) EventManagementApiGetCateringPackageRevenueRequest {
	r.packageIdType = &packageIdType
	return r
}

// Fetch instructions that can be used in caterig Package Revenue maintenance.
func (r EventManagementApiGetCateringPackageRevenueRequest) FetchInstructions(fetchInstructions []string) EventManagementApiGetCateringPackageRevenueRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r EventManagementApiGetCateringPackageRevenueRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetCateringPackageRevenueRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetCateringPackageRevenueRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetCateringPackageRevenueRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetCateringPackageRevenueRequest) Execute() (*CateringPackageRevenue, *http.Response, error) {
	return r.ApiService.GetCateringPackageRevenueExecute(r)
}

/*
GetCateringPackageRevenue Get Catering package revenue

Retrieve catering package revenue on a block <p><strong>OperationId:</strong>getCateringPackageRevenue</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringpackageId Unique ID of the catering package
 @param blockId Unique ID of the block
 @return EventManagementApiGetCateringPackageRevenueRequest
*/
func (a *EventManagementApiService) GetCateringPackageRevenue(ctx context.Context, cateringpackageId string, blockId string) EventManagementApiGetCateringPackageRevenueRequest {
	return EventManagementApiGetCateringPackageRevenueRequest{
		ApiService: a,
		ctx: ctx,
		cateringpackageId: cateringpackageId,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return CateringPackageRevenue
func (a *EventManagementApiService) GetCateringPackageRevenueExecute(r EventManagementApiGetCateringPackageRevenueRequest) (*CateringPackageRevenue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringPackageRevenue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetCateringPackageRevenue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/cateringPackages/{cateringpackageId}/revenue"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringpackageId"+"}", url.PathEscape(parameterValueToString(r.cateringpackageId, "cateringpackageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringpackageId) < 1 {
		return localVarReturnValue, nil, reportError("cateringpackageId must have at least 1 elements")
	}
	if strlen(r.cateringpackageId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringpackageId must have less than 2000 elements")
	}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.blockIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", r.blockIdContext, "")
	}
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
	}
	if r.packageIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageIdContext", r.packageIdContext, "")
	}
	if r.packageIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageIdType", r.packageIdType, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetCateringPackagesRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	blockIdContext *string
	blockIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetCateringPackagesRequest) Authorization(authorization string) EventManagementApiGetCateringPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetCateringPackagesRequest) XAppKey(xAppKey string) EventManagementApiGetCateringPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetCateringPackagesRequest) XHotelid(xHotelid string) EventManagementApiGetCateringPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Block hotel code.
func (r EventManagementApiGetCateringPackagesRequest) HotelId(hotelId string) EventManagementApiGetCateringPackagesRequest {
	r.hotelId = &hotelId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r EventManagementApiGetCateringPackagesRequest) BlockIdContext(blockIdContext string) EventManagementApiGetCateringPackagesRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID elementSpace. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r EventManagementApiGetCateringPackagesRequest) BlockIdType(blockIdType string) EventManagementApiGetCateringPackagesRequest {
	r.blockIdType = &blockIdType
	return r
}

// External system code.
func (r EventManagementApiGetCateringPackagesRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetCateringPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetCateringPackagesRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetCateringPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetCateringPackagesRequest) Execute() (*CateringPackages, *http.Response, error) {
	return r.ApiService.GetCateringPackagesExecute(r)
}

/*
GetCateringPackages Get Catering packages 

Retrieve the cateringPackages on the block <p><strong>OperationId:</strong>getCateringPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Unique ID of the block
 @return EventManagementApiGetCateringPackagesRequest
*/
func (a *EventManagementApiService) GetCateringPackages(ctx context.Context, blockId string) EventManagementApiGetCateringPackagesRequest {
	return EventManagementApiGetCateringPackagesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return CateringPackages
func (a *EventManagementApiService) GetCateringPackagesExecute(r EventManagementApiGetCateringPackagesRequest) (*CateringPackages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringPackages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetCateringPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/cateringPackages"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.blockIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", r.blockIdContext, "")
	}
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetEventRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	eventId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetEventRequest) Authorization(authorization string) EventManagementApiGetEventRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetEventRequest) XAppKey(xAppKey string) EventManagementApiGetEventRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetEventRequest) XHotelid(xHotelid string) EventManagementApiGetEventRequest {
	r.xHotelid = &xHotelid
	return r
}

// Instruction to fetch all eligible master events for the selected event
func (r EventManagementApiGetEventRequest) FetchInstructions(fetchInstructions []string) EventManagementApiGetEventRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r EventManagementApiGetEventRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetEventRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetEventRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetEventRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetEventRequest) Execute() (*Event, *http.Response, error) {
	return r.ApiService.GetEventExecute(r)
}

/*
GetEvent Get an Event

This API will allow you to retrieve the details of one event by specifying the event ID in the path. Event details such as event type, event description, start date / time and end date time, attendees, function space, setup style, function space rate, and more  will be returned. You can also add fetch instructions to specify what additional event data, such as block information, revenue information, event notes, and master / sub event information you would like returned in the response. If you don&apos;t know the eventID, please use getEvents API to find the event and its respective eventID. <p><strong>OperationId:</strong>getEvent</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId Unique ID of the event
 @param hotelId Unique ID of a hotel
 @return EventManagementApiGetEventRequest
*/
func (a *EventManagementApiService) GetEvent(ctx context.Context, eventId string, hotelId string) EventManagementApiGetEventRequest {
	return EventManagementApiGetEventRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Event
func (a *EventManagementApiService) GetEventExecute(r EventManagementApiGetEventRequest) (*Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/events/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetEventCalendarRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eventEndDate *string
	includeHidden *bool
	includeOpportunities *bool
	showAvailableRooms *bool
	showReservations *bool
	isHotelSort *bool
	isSortDescending *bool
	pageIndex *int32
	recordsPerPage *int32
	sortingBy *string
	eventStartDate *string
	functionSpaceDetails *[]string
	status *[]string
	setupStyle *string
	location *string
	eventLabel *string
	spaceType *string
	areaMeasurement *string
	minimumArea *float32
	display *string
	from *int32
	to *int32
	friday *bool
	monday *bool
	saturday *bool
	sunday *bool
	thursday *bool
	tuesday *bool
	wednesday *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetEventCalendarRequest) Authorization(authorization string) EventManagementApiGetEventCalendarRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetEventCalendarRequest) XAppKey(xAppKey string) EventManagementApiGetEventCalendarRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetEventCalendarRequest) XHotelid(xHotelid string) EventManagementApiGetEventCalendarRequest {
	r.xHotelid = &xHotelid
	return r
}

// The ending value of the date range.
func (r EventManagementApiGetEventCalendarRequest) EventEndDate(eventEndDate string) EventManagementApiGetEventCalendarRequest {
	r.eventEndDate = &eventEndDate
	return r
}

func (r EventManagementApiGetEventCalendarRequest) IncludeHidden(includeHidden bool) EventManagementApiGetEventCalendarRequest {
	r.includeHidden = &includeHidden
	return r
}

// If set to true, the results will include opportunities. If this flag is not provided it will be considered false and exclude opportunities.
func (r EventManagementApiGetEventCalendarRequest) IncludeOpportunities(includeOpportunities bool) EventManagementApiGetEventCalendarRequest {
	r.includeOpportunities = &includeOpportunities
	return r
}

// Determines whether to fetch only available rooms(Spaces with NON-DEDUCT events) or not.
func (r EventManagementApiGetEventCalendarRequest) ShowAvailableRooms(showAvailableRooms bool) EventManagementApiGetEventCalendarRequest {
	r.showAvailableRooms = &showAvailableRooms
	return r
}

// Determines whether to fetch guest reservations or not.
func (r EventManagementApiGetEventCalendarRequest) ShowReservations(showReservations bool) EventManagementApiGetEventCalendarRequest {
	r.showReservations = &showReservations
	return r
}

func (r EventManagementApiGetEventCalendarRequest) IsHotelSort(isHotelSort bool) EventManagementApiGetEventCalendarRequest {
	r.isHotelSort = &isHotelSort
	return r
}

func (r EventManagementApiGetEventCalendarRequest) IsSortDescending(isSortDescending bool) EventManagementApiGetEventCalendarRequest {
	r.isSortDescending = &isSortDescending
	return r
}

// Page index to be retrieved.
func (r EventManagementApiGetEventCalendarRequest) PageIndex(pageIndex int32) EventManagementApiGetEventCalendarRequest {
	r.pageIndex = &pageIndex
	return r
}

func (r EventManagementApiGetEventCalendarRequest) RecordsPerPage(recordsPerPage int32) EventManagementApiGetEventCalendarRequest {
	r.recordsPerPage = &recordsPerPage
	return r
}

// A collection of supported sorting for Event Calendar Function Space.
func (r EventManagementApiGetEventCalendarRequest) SortingBy(sortingBy string) EventManagementApiGetEventCalendarRequest {
	r.sortingBy = &sortingBy
	return r
}

// The starting value of the date range.
func (r EventManagementApiGetEventCalendarRequest) EventStartDate(eventStartDate string) EventManagementApiGetEventCalendarRequest {
	r.eventStartDate = &eventStartDate
	return r
}

// Room filter for the events returned.
func (r EventManagementApiGetEventCalendarRequest) FunctionSpaceDetails(functionSpaceDetails []string) EventManagementApiGetEventCalendarRequest {
	r.functionSpaceDetails = &functionSpaceDetails
	return r
}

// Status filter for the events returned.
func (r EventManagementApiGetEventCalendarRequest) Status(status []string) EventManagementApiGetEventCalendarRequest {
	r.status = &status
	return r
}

// Setup Style filter for the events returned.
func (r EventManagementApiGetEventCalendarRequest) SetupStyle(setupStyle string) EventManagementApiGetEventCalendarRequest {
	r.setupStyle = &setupStyle
	return r
}

// Function space location filter for the events returned.
func (r EventManagementApiGetEventCalendarRequest) Location(location string) EventManagementApiGetEventCalendarRequest {
	r.location = &location
	return r
}

// Event Bar Label filter for the events returned.
func (r EventManagementApiGetEventCalendarRequest) EventLabel(eventLabel string) EventManagementApiGetEventCalendarRequest {
	r.eventLabel = &eventLabel
	return r
}

// Room type filter for the events returned.
func (r EventManagementApiGetEventCalendarRequest) SpaceType(spaceType string) EventManagementApiGetEventCalendarRequest {
	r.spaceType = &spaceType
	return r
}

// Determines the measuring unit.
func (r EventManagementApiGetEventCalendarRequest) AreaMeasurement(areaMeasurement string) EventManagementApiGetEventCalendarRequest {
	r.areaMeasurement = &areaMeasurement
	return r
}

func (r EventManagementApiGetEventCalendarRequest) MinimumArea(minimumArea float32) EventManagementApiGetEventCalendarRequest {
	r.minimumArea = &minimumArea
	return r
}

// Type of function space filter for the events returned. Possible values include Individual, Combo and All.
func (r EventManagementApiGetEventCalendarRequest) Display(display string) EventManagementApiGetEventCalendarRequest {
	r.display = &display
	return r
}

func (r EventManagementApiGetEventCalendarRequest) From(from int32) EventManagementApiGetEventCalendarRequest {
	r.from = &from
	return r
}

func (r EventManagementApiGetEventCalendarRequest) To(to int32) EventManagementApiGetEventCalendarRequest {
	r.to = &to
	return r
}

func (r EventManagementApiGetEventCalendarRequest) Friday(friday bool) EventManagementApiGetEventCalendarRequest {
	r.friday = &friday
	return r
}

func (r EventManagementApiGetEventCalendarRequest) Monday(monday bool) EventManagementApiGetEventCalendarRequest {
	r.monday = &monday
	return r
}

func (r EventManagementApiGetEventCalendarRequest) Saturday(saturday bool) EventManagementApiGetEventCalendarRequest {
	r.saturday = &saturday
	return r
}

func (r EventManagementApiGetEventCalendarRequest) Sunday(sunday bool) EventManagementApiGetEventCalendarRequest {
	r.sunday = &sunday
	return r
}

func (r EventManagementApiGetEventCalendarRequest) Thursday(thursday bool) EventManagementApiGetEventCalendarRequest {
	r.thursday = &thursday
	return r
}

func (r EventManagementApiGetEventCalendarRequest) Tuesday(tuesday bool) EventManagementApiGetEventCalendarRequest {
	r.tuesday = &tuesday
	return r
}

func (r EventManagementApiGetEventCalendarRequest) Wednesday(wednesday bool) EventManagementApiGetEventCalendarRequest {
	r.wednesday = &wednesday
	return r
}

// External system code.
func (r EventManagementApiGetEventCalendarRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetEventCalendarRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetEventCalendarRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetEventCalendarRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetEventCalendarRequest) Execute() (*EventCalendar, *http.Response, error) {
	return r.ApiService.GetEventCalendarExecute(r)
}

/*
GetEventCalendar Get the event calendar

You will be able to retrieve all events on the calendar for a specified property.  Narrow the results down by using the available parameters, such as Event Status, Event eventStartDate date, Location, Number of Attendees and so on. <p><strong>OperationId:</strong>getEventCalendar</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return EventManagementApiGetEventCalendarRequest
*/
func (a *EventManagementApiService) GetEventCalendar(ctx context.Context, hotelId string) EventManagementApiGetEventCalendarRequest {
	return EventManagementApiGetEventCalendarRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return EventCalendar
func (a *EventManagementApiService) GetEventCalendarExecute(r EventManagementApiGetEventCalendarRequest) (*EventCalendar, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetEventCalendar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/eventcalendar"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.eventEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventEndDate", r.eventEndDate, "")
	}
	if r.includeHidden != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeHidden", r.includeHidden, "")
	}
	if r.includeOpportunities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOpportunities", r.includeOpportunities, "")
	}
	if r.showAvailableRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showAvailableRooms", r.showAvailableRooms, "")
	}
	if r.showReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showReservations", r.showReservations, "")
	}
	if r.isHotelSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isHotelSort", r.isHotelSort, "")
	}
	if r.isSortDescending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSortDescending", r.isSortDescending, "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIndex", r.pageIndex, "")
	}
	if r.recordsPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recordsPerPage", r.recordsPerPage, "")
	}
	if r.sortingBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortingBy", r.sortingBy, "")
	}
	if r.eventStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventStartDate", r.eventStartDate, "")
	}
	if r.functionSpaceDetails != nil {
		t := *r.functionSpaceDetails
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceDetails", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceDetails", t, "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.setupStyle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "setupStyle", r.setupStyle, "")
	}
	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location", r.location, "")
	}
	if r.eventLabel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventLabel", r.eventLabel, "")
	}
	if r.spaceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spaceType", r.spaceType, "")
	}
	if r.areaMeasurement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaMeasurement", r.areaMeasurement, "")
	}
	if r.minimumArea != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minimumArea", r.minimumArea, "")
	}
	if r.display != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "display", r.display, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
	}
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
	}
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
	}
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
	}
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
	}
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
	}
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetEventCalendarMultipleHotelIdsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	eventEndDate *string
	includeHidden *bool
	includeOpportunities *bool
	showAvailableRooms *bool
	showReservations *bool
	isHotelSort *bool
	isSortDescending *bool
	pageIndex *int32
	recordsPerPage *int32
	sortingBy *string
	eventStartDate *string
	functionSpaceDetails *[]string
	status *[]string
	setupStyle *string
	location *string
	eventLabel *string
	spaceType *string
	areaMeasurement *string
	minimumArea *float32
	display *string
	from *int32
	to *int32
	friday *bool
	monday *bool
	saturday *bool
	sunday *bool
	thursday *bool
	tuesday *bool
	wednesday *bool
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) Authorization(authorization string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) XAppKey(xAppKey string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) XHotelid(xHotelid string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The ending value of the date range.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) EventEndDate(eventEndDate string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.eventEndDate = &eventEndDate
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) IncludeHidden(includeHidden bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.includeHidden = &includeHidden
	return r
}

// If set to true, the results will include opportunities. If this flag is not provided it will be considered false and exclude opportunities.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) IncludeOpportunities(includeOpportunities bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.includeOpportunities = &includeOpportunities
	return r
}

// Determines whether to fetch only available rooms(Spaces with NON-DEDUCT events) or not.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) ShowAvailableRooms(showAvailableRooms bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.showAvailableRooms = &showAvailableRooms
	return r
}

// Determines whether to fetch guest reservations or not.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) ShowReservations(showReservations bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.showReservations = &showReservations
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) IsHotelSort(isHotelSort bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.isHotelSort = &isHotelSort
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) IsSortDescending(isSortDescending bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.isSortDescending = &isSortDescending
	return r
}

// Page index to be retrieved.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) PageIndex(pageIndex int32) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.pageIndex = &pageIndex
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) RecordsPerPage(recordsPerPage int32) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.recordsPerPage = &recordsPerPage
	return r
}

// A collection of supported sorting for Event Calendar Function Space.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) SortingBy(sortingBy string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.sortingBy = &sortingBy
	return r
}

// The starting value of the date range.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) EventStartDate(eventStartDate string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.eventStartDate = &eventStartDate
	return r
}

// Room filter for the events returned.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) FunctionSpaceDetails(functionSpaceDetails []string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.functionSpaceDetails = &functionSpaceDetails
	return r
}

// Status filter for the events returned.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) Status(status []string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.status = &status
	return r
}

// Setup Style filter for the events returned.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) SetupStyle(setupStyle string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.setupStyle = &setupStyle
	return r
}

// Function space location filter for the events returned.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) Location(location string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.location = &location
	return r
}

// Event Bar Label filter for the events returned.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) EventLabel(eventLabel string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.eventLabel = &eventLabel
	return r
}

// Room type filter for the events returned.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) SpaceType(spaceType string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.spaceType = &spaceType
	return r
}

// Determines the measuring unit.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) AreaMeasurement(areaMeasurement string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.areaMeasurement = &areaMeasurement
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) MinimumArea(minimumArea float32) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.minimumArea = &minimumArea
	return r
}

// Type of function space filter for the events returned. Possible values include Individual, Combo and All.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) Display(display string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.display = &display
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) From(from int32) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.from = &from
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) To(to int32) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.to = &to
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) Friday(friday bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.friday = &friday
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) Monday(monday bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.monday = &monday
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) Saturday(saturday bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.saturday = &saturday
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) Sunday(sunday bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.sunday = &sunday
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) Thursday(thursday bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.thursday = &thursday
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) Tuesday(tuesday bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.tuesday = &tuesday
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) Wednesday(wednesday bool) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.wednesday = &wednesday
	return r
}

// Hotel code.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) HotelIds(hotelIds []string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) Execute() (*EventCalendar, *http.Response, error) {
	return r.ApiService.GetEventCalendarMultipleHotelIdsExecute(r)
}

/*
GetEventCalendarMultipleHotelIds Get the event calendar for Multiple Properties

You will be able to retrieve all events on the calendar for a specified property.  Narrow the results down by using the available parameters, such as Event Status, Event eventStartDate date, Location, Number of Attendees and so on. <p><strong>OperationId:</strong>getEventCalendarMultipleHotelIds</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EventManagementApiGetEventCalendarMultipleHotelIdsRequest
*/
func (a *EventManagementApiService) GetEventCalendarMultipleHotelIds(ctx context.Context) EventManagementApiGetEventCalendarMultipleHotelIdsRequest {
	return EventManagementApiGetEventCalendarMultipleHotelIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventCalendar
func (a *EventManagementApiService) GetEventCalendarMultipleHotelIdsExecute(r EventManagementApiGetEventCalendarMultipleHotelIdsRequest) (*EventCalendar, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetEventCalendarMultipleHotelIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventcalendar"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.eventEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventEndDate", r.eventEndDate, "")
	}
	if r.includeHidden != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeHidden", r.includeHidden, "")
	}
	if r.includeOpportunities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOpportunities", r.includeOpportunities, "")
	}
	if r.showAvailableRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showAvailableRooms", r.showAvailableRooms, "")
	}
	if r.showReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showReservations", r.showReservations, "")
	}
	if r.isHotelSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isHotelSort", r.isHotelSort, "")
	}
	if r.isSortDescending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSortDescending", r.isSortDescending, "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIndex", r.pageIndex, "")
	}
	if r.recordsPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recordsPerPage", r.recordsPerPage, "")
	}
	if r.sortingBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortingBy", r.sortingBy, "")
	}
	if r.eventStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventStartDate", r.eventStartDate, "")
	}
	if r.functionSpaceDetails != nil {
		t := *r.functionSpaceDetails
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceDetails", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceDetails", t, "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.setupStyle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "setupStyle", r.setupStyle, "")
	}
	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location", r.location, "")
	}
	if r.eventLabel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventLabel", r.eventLabel, "")
	}
	if r.spaceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spaceType", r.spaceType, "")
	}
	if r.areaMeasurement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaMeasurement", r.areaMeasurement, "")
	}
	if r.minimumArea != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minimumArea", r.minimumArea, "")
	}
	if r.display != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "display", r.display, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
	}
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
	}
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
	}
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
	}
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
	}
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
	}
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetEventItemSplitQuantityRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	eventId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eventPrimaryHotelId *string
	eventItemId *string
	eventEndDate *string
	eventStartDate *string
	itemId *string
	quantity *float32
	isExcludeNonDeduct *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetEventItemSplitQuantityRequest) Authorization(authorization string) EventManagementApiGetEventItemSplitQuantityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetEventItemSplitQuantityRequest) XAppKey(xAppKey string) EventManagementApiGetEventItemSplitQuantityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetEventItemSplitQuantityRequest) XHotelid(xHotelid string) EventManagementApiGetEventItemSplitQuantityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code where event will be organized.
func (r EventManagementApiGetEventItemSplitQuantityRequest) EventPrimaryHotelId(eventPrimaryHotelId string) EventManagementApiGetEventItemSplitQuantityRequest {
	r.eventPrimaryHotelId = &eventPrimaryHotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r EventManagementApiGetEventItemSplitQuantityRequest) EventItemId(eventItemId string) EventManagementApiGetEventItemSplitQuantityRequest {
	r.eventItemId = &eventItemId
	return r
}

// The ending value of the time span.
func (r EventManagementApiGetEventItemSplitQuantityRequest) EventEndDate(eventEndDate string) EventManagementApiGetEventItemSplitQuantityRequest {
	r.eventEndDate = &eventEndDate
	return r
}

// The starting value of the time span.
func (r EventManagementApiGetEventItemSplitQuantityRequest) EventStartDate(eventStartDate string) EventManagementApiGetEventItemSplitQuantityRequest {
	r.eventStartDate = &eventStartDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r EventManagementApiGetEventItemSplitQuantityRequest) ItemId(itemId string) EventManagementApiGetEventItemSplitQuantityRequest {
	r.itemId = &itemId
	return r
}

// The quantity of this item required by the event.
func (r EventManagementApiGetEventItemSplitQuantityRequest) Quantity(quantity float32) EventManagementApiGetEventItemSplitQuantityRequest {
	r.quantity = &quantity
	return r
}

// Flag to check if the Event Item is ExcludeNonDeduct
func (r EventManagementApiGetEventItemSplitQuantityRequest) IsExcludeNonDeduct(isExcludeNonDeduct bool) EventManagementApiGetEventItemSplitQuantityRequest {
	r.isExcludeNonDeduct = &isExcludeNonDeduct
	return r
}

// External system code.
func (r EventManagementApiGetEventItemSplitQuantityRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetEventItemSplitQuantityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetEventItemSplitQuantityRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetEventItemSplitQuantityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetEventItemSplitQuantityRequest) Execute() (*EventResource, *http.Response, error) {
	return r.ApiService.GetEventItemSplitQuantityExecute(r)
}

/*
GetEventItemSplitQuantity Get Event item split quantity

Retrieve the event item split quantity for an event. <p><strong>OperationId:</strong>getEventItemSplitQuantity</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId Unique ID of the event
 @return EventManagementApiGetEventItemSplitQuantityRequest
*/
func (a *EventManagementApiService) GetEventItemSplitQuantity(ctx context.Context, eventId string) EventManagementApiGetEventItemSplitQuantityRequest {
	return EventManagementApiGetEventItemSplitQuantityRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return EventResource
func (a *EventManagementApiService) GetEventItemSplitQuantityExecute(r EventManagementApiGetEventItemSplitQuantityRequest) (*EventResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetEventItemSplitQuantity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events/{eventId}/splitQuantity"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}

	if r.eventPrimaryHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventPrimaryHotelId", r.eventPrimaryHotelId, "")
	}
	if r.eventItemId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventItemId", r.eventItemId, "")
	}
	if r.eventEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventEndDate", r.eventEndDate, "")
	}
	if r.eventStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventStartDate", r.eventStartDate, "")
	}
	if r.itemId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemId", r.itemId, "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quantity", r.quantity, "")
	}
	if r.isExcludeNonDeduct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isExcludeNonDeduct", r.isExcludeNonDeduct, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetEventResourceByMenuRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	resourceId string
	eventId string
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	blockIdContext *string
	blockIdType *string
	eventIdContext *string
	eventIdType *string
	resourceIdContext *string
	resourceIdType *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetEventResourceByMenuRequest) Authorization(authorization string) EventManagementApiGetEventResourceByMenuRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetEventResourceByMenuRequest) XAppKey(xAppKey string) EventManagementApiGetEventResourceByMenuRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetEventResourceByMenuRequest) XHotelid(xHotelid string) EventManagementApiGetEventResourceByMenuRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code of the Resource.
func (r EventManagementApiGetEventResourceByMenuRequest) HotelId(hotelId string) EventManagementApiGetEventResourceByMenuRequest {
	r.hotelId = &hotelId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r EventManagementApiGetEventResourceByMenuRequest) BlockIdContext(blockIdContext string) EventManagementApiGetEventResourceByMenuRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID elementSpace. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r EventManagementApiGetEventResourceByMenuRequest) BlockIdType(blockIdType string) EventManagementApiGetEventResourceByMenuRequest {
	r.blockIdType = &blockIdType
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r EventManagementApiGetEventResourceByMenuRequest) EventIdContext(eventIdContext string) EventManagementApiGetEventResourceByMenuRequest {
	r.eventIdContext = &eventIdContext
	return r
}

// A reference to the type of object defined by the UniqueID elementSpace. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r EventManagementApiGetEventResourceByMenuRequest) EventIdType(eventIdType string) EventManagementApiGetEventResourceByMenuRequest {
	r.eventIdType = &eventIdType
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r EventManagementApiGetEventResourceByMenuRequest) ResourceIdContext(resourceIdContext string) EventManagementApiGetEventResourceByMenuRequest {
	r.resourceIdContext = &resourceIdContext
	return r
}

// A reference to the type of object defined by the UniqueID elementSpace. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r EventManagementApiGetEventResourceByMenuRequest) ResourceIdType(resourceIdType string) EventManagementApiGetEventResourceByMenuRequest {
	r.resourceIdType = &resourceIdType
	return r
}

// Fetch instructions that can be used in Event Resource maintenance.
func (r EventManagementApiGetEventResourceByMenuRequest) FetchInstructions(fetchInstructions []string) EventManagementApiGetEventResourceByMenuRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r EventManagementApiGetEventResourceByMenuRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetEventResourceByMenuRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetEventResourceByMenuRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetEventResourceByMenuRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetEventResourceByMenuRequest) Execute() (*EventResource, *http.Response, error) {
	return r.ApiService.GetEventResourceByMenuExecute(r)
}

/*
GetEventResourceByMenu Get Resources for an Event

Retrieve a resource that exist for an Event, using block ID, event ID and resource ID as parameters in the path  This will give you information on the quantity, expected revenue, discounts, notes, and so on for that resource. <p><strong>OperationId:</strong>getEventResourceByMenu</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resourceId Unique ID of the resource
 @param eventId Unique ID of the event
 @param blockId Unique ID of the block
 @return EventManagementApiGetEventResourceByMenuRequest
*/
func (a *EventManagementApiService) GetEventResourceByMenu(ctx context.Context, resourceId string, eventId string, blockId string) EventManagementApiGetEventResourceByMenuRequest {
	return EventManagementApiGetEventResourceByMenuRequest{
		ApiService: a,
		ctx: ctx,
		resourceId: resourceId,
		eventId: eventId,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return EventResource
func (a *EventManagementApiService) GetEventResourceByMenuExecute(r EventManagementApiGetEventResourceByMenuRequest) (*EventResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetEventResourceByMenu")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/events/{eventId}/resources/{resourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"resourceId"+"}", url.PathEscape(parameterValueToString(r.resourceId, "resourceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.resourceId) < 1 {
		return localVarReturnValue, nil, reportError("resourceId must have at least 1 elements")
	}
	if strlen(r.resourceId) > 2000 {
		return localVarReturnValue, nil, reportError("resourceId must have less than 2000 elements")
	}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.blockIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", r.blockIdContext, "")
	}
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
	}
	if r.eventIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventIdContext", r.eventIdContext, "")
	}
	if r.eventIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventIdType", r.eventIdType, "")
	}
	if r.resourceIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceIdContext", r.resourceIdContext, "")
	}
	if r.resourceIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceIdType", r.resourceIdType, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetEventsMultipleHotelsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	eventStartDate *string
	eventEndDate *string
	blockId *[]string
	eventId *[]string
	category *[]string
	name *[]string
	attachedProfileId *[]string
	blockName *string
	eventStatusCodes *[]string
	eventTypeCodes *[]string
	functionSpaceCodes *[]string
	includeInactive *bool
	includeAlternateEvents *bool
	includeOpportunities *bool
	includeSubEvents *bool
	cateringEventOrderBy *string
	fetchInstructions *[]string
	limit *int32
	offset *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetEventsMultipleHotelsRequest) Authorization(authorization string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetEventsMultipleHotelsRequest) XAppKey(xAppKey string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetEventsMultipleHotelsRequest) XHotelid(xHotelid string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// This is the Hotel Code of the Event
func (r EventManagementApiGetEventsMultipleHotelsRequest) HotelIds(hotelIds []string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.hotelIds = &hotelIds
	return r
}

// The starting value of the date range.
func (r EventManagementApiGetEventsMultipleHotelsRequest) EventStartDate(eventStartDate string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.eventStartDate = &eventStartDate
	return r
}

// The ending value of the date range.
func (r EventManagementApiGetEventsMultipleHotelsRequest) EventEndDate(eventEndDate string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.eventEndDate = &eventEndDate
	return r
}

// Block ID linked to the Catering Event
func (r EventManagementApiGetEventsMultipleHotelsRequest) BlockId(blockId []string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.blockId = &blockId
	return r
}

// Unique ID for the catering event
func (r EventManagementApiGetEventsMultipleHotelsRequest) EventId(eventId []string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.eventId = &eventId
	return r
}

// Simple type for block instructions to be used in requests for fetching blocks. Valid status values are Group, Source, TravelAgent, Contact, Company.
func (r EventManagementApiGetEventsMultipleHotelsRequest) Category(category []string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.category = &category
	return r
}

// Attached profile name
func (r EventManagementApiGetEventsMultipleHotelsRequest) Name(name []string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.name = &name
	return r
}

// A unique identifying numeric value assigned to a profile utilized to fetch events associated to blocks linked to the profile.
func (r EventManagementApiGetEventsMultipleHotelsRequest) AttachedProfileId(attachedProfileId []string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.attachedProfileId = &attachedProfileId
	return r
}

// Block Name.
func (r EventManagementApiGetEventsMultipleHotelsRequest) BlockName(blockName string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.blockName = &blockName
	return r
}

// Status Codes associated with the events to be fetched.
func (r EventManagementApiGetEventsMultipleHotelsRequest) EventStatusCodes(eventStatusCodes []string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.eventStatusCodes = &eventStatusCodes
	return r
}

// Event Type Codes associated with the events to be fetched.
func (r EventManagementApiGetEventsMultipleHotelsRequest) EventTypeCodes(eventTypeCodes []string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.eventTypeCodes = &eventTypeCodes
	return r
}

func (r EventManagementApiGetEventsMultipleHotelsRequest) FunctionSpaceCodes(functionSpaceCodes []string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.functionSpaceCodes = &functionSpaceCodes
	return r
}

// Indicates whether to include inactive events in search result.
func (r EventManagementApiGetEventsMultipleHotelsRequest) IncludeInactive(includeInactive bool) EventManagementApiGetEventsMultipleHotelsRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates whether to include the alternate events in the search result.
func (r EventManagementApiGetEventsMultipleHotelsRequest) IncludeAlternateEvents(includeAlternateEvents bool) EventManagementApiGetEventsMultipleHotelsRequest {
	r.includeAlternateEvents = &includeAlternateEvents
	return r
}

// If set to true, the results will include opportunities. If this flag is not provided it will be considered false and exclude opportunities.
func (r EventManagementApiGetEventsMultipleHotelsRequest) IncludeOpportunities(includeOpportunities bool) EventManagementApiGetEventsMultipleHotelsRequest {
	r.includeOpportunities = &includeOpportunities
	return r
}

// Indicates whether to include the sub events in the search result.
func (r EventManagementApiGetEventsMultipleHotelsRequest) IncludeSubEvents(includeSubEvents bool) EventManagementApiGetEventsMultipleHotelsRequest {
	r.includeSubEvents = &includeSubEvents
	return r
}

// A collection of supported list of order by for search catering events.
func (r EventManagementApiGetEventsMultipleHotelsRequest) CateringEventOrderBy(cateringEventOrderBy string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.cateringEventOrderBy = &cateringEventOrderBy
	return r
}

// Instructions to fetch details information about the selected event. The BlocksInfo fetch instructions will retain a limited amount of data for the associated block.  The Indicators instruction will provide a count.
func (r EventManagementApiGetEventsMultipleHotelsRequest) FetchInstructions(fetchInstructions []string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r EventManagementApiGetEventsMultipleHotelsRequest) Limit(limit int32) EventManagementApiGetEventsMultipleHotelsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r EventManagementApiGetEventsMultipleHotelsRequest) Offset(offset int32) EventManagementApiGetEventsMultipleHotelsRequest {
	r.offset = &offset
	return r
}

// External system code.
func (r EventManagementApiGetEventsMultipleHotelsRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetEventsMultipleHotelsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetEventsMultipleHotelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetEventsMultipleHotelsRequest) Execute() (*Events, *http.Response, error) {
	return r.ApiService.GetEventsMultipleHotelsExecute(r)
}

/*
GetEventsMultipleHotels Get Events 

This API fetches catering events for multiple hotels, based on search criteria such as dates, linked block, status, function space, and more. The data returned in the result contains, event type, description, dates and times, attendees, function space, setup style and more. <p><strong>OperationId:</strong>getEventsMultipleHotels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EventManagementApiGetEventsMultipleHotelsRequest
*/
func (a *EventManagementApiService) GetEventsMultipleHotels(ctx context.Context) EventManagementApiGetEventsMultipleHotelsRequest {
	return EventManagementApiGetEventsMultipleHotelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Events
func (a *EventManagementApiService) GetEventsMultipleHotelsExecute(r EventManagementApiGetEventsMultipleHotelsRequest) (*Events, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Events
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetEventsMultipleHotels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.eventStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventStartDate", r.eventStartDate, "")
	}
	if r.eventEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventEndDate", r.eventEndDate, "")
	}
	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
	}
	if r.eventId != nil {
		t := *r.eventId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", t, "multi")
		}
	}
	if r.category != nil {
		t := *r.category
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "category", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "category", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.attachedProfileId != nil {
		t := *r.attachedProfileId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", t, "multi")
		}
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.eventStatusCodes != nil {
		t := *r.eventStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventStatusCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventStatusCodes", t, "multi")
		}
	}
	if r.eventTypeCodes != nil {
		t := *r.eventTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", t, "multi")
		}
	}
	if r.functionSpaceCodes != nil {
		t := *r.functionSpaceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.includeAlternateEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAlternateEvents", r.includeAlternateEvents, "")
	}
	if r.includeOpportunities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOpportunities", r.includeOpportunities, "")
	}
	if r.includeSubEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSubEvents", r.includeSubEvents, "")
	}
	if r.cateringEventOrderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringEventOrderBy", r.cateringEventOrderBy, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetEventsOneHotelRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eventStartDate *string
	eventEndDate *string
	blockId *[]string
	eventId *[]string
	attachedProfileId *string
	blockName *string
	eventStatusCodes *[]string
	eventTypeCodes *[]string
	functionSpaceCodes *[]string
	includeInactive *bool
	includeAlternateEvents *bool
	includeOpportunities *bool
	includeSubEvents *bool
	cateringEventOrderBy *string
	fetchInstructions *[]string
	limit *int32
	offset *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetEventsOneHotelRequest) Authorization(authorization string) EventManagementApiGetEventsOneHotelRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetEventsOneHotelRequest) XAppKey(xAppKey string) EventManagementApiGetEventsOneHotelRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetEventsOneHotelRequest) XHotelid(xHotelid string) EventManagementApiGetEventsOneHotelRequest {
	r.xHotelid = &xHotelid
	return r
}

// The starting value of the date range.
func (r EventManagementApiGetEventsOneHotelRequest) EventStartDate(eventStartDate string) EventManagementApiGetEventsOneHotelRequest {
	r.eventStartDate = &eventStartDate
	return r
}

// The ending value of the date range.
func (r EventManagementApiGetEventsOneHotelRequest) EventEndDate(eventEndDate string) EventManagementApiGetEventsOneHotelRequest {
	r.eventEndDate = &eventEndDate
	return r
}

// Block ID linked to the Catering Event
func (r EventManagementApiGetEventsOneHotelRequest) BlockId(blockId []string) EventManagementApiGetEventsOneHotelRequest {
	r.blockId = &blockId
	return r
}

// Unique ID for the catering event
func (r EventManagementApiGetEventsOneHotelRequest) EventId(eventId []string) EventManagementApiGetEventsOneHotelRequest {
	r.eventId = &eventId
	return r
}

// A unique identifying numeric value assigned to a profile utilized to fetch events associated to blocks linked to the profile.
func (r EventManagementApiGetEventsOneHotelRequest) AttachedProfileId(attachedProfileId string) EventManagementApiGetEventsOneHotelRequest {
	r.attachedProfileId = &attachedProfileId
	return r
}

// Block Name.
func (r EventManagementApiGetEventsOneHotelRequest) BlockName(blockName string) EventManagementApiGetEventsOneHotelRequest {
	r.blockName = &blockName
	return r
}

// Status Codes associated with the events to be fetched.
func (r EventManagementApiGetEventsOneHotelRequest) EventStatusCodes(eventStatusCodes []string) EventManagementApiGetEventsOneHotelRequest {
	r.eventStatusCodes = &eventStatusCodes
	return r
}

// Event Type Codes associated with the events to be fetched.
func (r EventManagementApiGetEventsOneHotelRequest) EventTypeCodes(eventTypeCodes []string) EventManagementApiGetEventsOneHotelRequest {
	r.eventTypeCodes = &eventTypeCodes
	return r
}

func (r EventManagementApiGetEventsOneHotelRequest) FunctionSpaceCodes(functionSpaceCodes []string) EventManagementApiGetEventsOneHotelRequest {
	r.functionSpaceCodes = &functionSpaceCodes
	return r
}

// Indicates whether to include inactive events in search result.
func (r EventManagementApiGetEventsOneHotelRequest) IncludeInactive(includeInactive bool) EventManagementApiGetEventsOneHotelRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates whether to include the alternate events in the search result.
func (r EventManagementApiGetEventsOneHotelRequest) IncludeAlternateEvents(includeAlternateEvents bool) EventManagementApiGetEventsOneHotelRequest {
	r.includeAlternateEvents = &includeAlternateEvents
	return r
}

// If set to true, the results will include opportunities. If this flag is not provided it will be considered false and exclude opportunities.
func (r EventManagementApiGetEventsOneHotelRequest) IncludeOpportunities(includeOpportunities bool) EventManagementApiGetEventsOneHotelRequest {
	r.includeOpportunities = &includeOpportunities
	return r
}

// Indicates whether to include the sub events in the search result.
func (r EventManagementApiGetEventsOneHotelRequest) IncludeSubEvents(includeSubEvents bool) EventManagementApiGetEventsOneHotelRequest {
	r.includeSubEvents = &includeSubEvents
	return r
}

// A collection of supported list of order by for search catering events.
func (r EventManagementApiGetEventsOneHotelRequest) CateringEventOrderBy(cateringEventOrderBy string) EventManagementApiGetEventsOneHotelRequest {
	r.cateringEventOrderBy = &cateringEventOrderBy
	return r
}

// Instruction to fetch all eligible master events for the selected event
func (r EventManagementApiGetEventsOneHotelRequest) FetchInstructions(fetchInstructions []string) EventManagementApiGetEventsOneHotelRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r EventManagementApiGetEventsOneHotelRequest) Limit(limit int32) EventManagementApiGetEventsOneHotelRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r EventManagementApiGetEventsOneHotelRequest) Offset(offset int32) EventManagementApiGetEventsOneHotelRequest {
	r.offset = &offset
	return r
}

// External system code.
func (r EventManagementApiGetEventsOneHotelRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetEventsOneHotelRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetEventsOneHotelRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetEventsOneHotelRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetEventsOneHotelRequest) Execute() (*Events, *http.Response, error) {
	return r.ApiService.GetEventsOneHotelExecute(r)
}

/*
GetEventsOneHotel Get Events 

This API fetches catering events for a specific hotel, based on search criteria such as dates, linked block, status, function space, and more. The data returned in the result contains, event type, description, dates and times, attendees, function space, setup style and more. <p><strong>OperationId:</strong>getEventsOneHotel</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of a hotel
 @return EventManagementApiGetEventsOneHotelRequest
*/
func (a *EventManagementApiService) GetEventsOneHotel(ctx context.Context, hotelId string) EventManagementApiGetEventsOneHotelRequest {
	return EventManagementApiGetEventsOneHotelRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Events
func (a *EventManagementApiService) GetEventsOneHotelExecute(r EventManagementApiGetEventsOneHotelRequest) (*Events, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Events
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetEventsOneHotel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	if r.eventStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventStartDate", r.eventStartDate, "")
	}
	if r.eventEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventEndDate", r.eventEndDate, "")
	}
	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
	}
	if r.eventId != nil {
		t := *r.eventId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", t, "multi")
		}
	}
	if r.attachedProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", r.attachedProfileId, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.eventStatusCodes != nil {
		t := *r.eventStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventStatusCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventStatusCodes", t, "multi")
		}
	}
	if r.eventTypeCodes != nil {
		t := *r.eventTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", t, "multi")
		}
	}
	if r.functionSpaceCodes != nil {
		t := *r.functionSpaceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.includeAlternateEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAlternateEvents", r.includeAlternateEvents, "")
	}
	if r.includeOpportunities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOpportunities", r.includeOpportunities, "")
	}
	if r.includeSubEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSubEvents", r.includeSubEvents, "")
	}
	if r.cateringEventOrderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringEventOrderBy", r.cateringEventOrderBy, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetEventsResourcesRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockId *string
	eventIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetEventsResourcesRequest) Authorization(authorization string) EventManagementApiGetEventsResourcesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetEventsResourcesRequest) XAppKey(xAppKey string) EventManagementApiGetEventsResourcesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetEventsResourcesRequest) XHotelid(xHotelid string) EventManagementApiGetEventsResourcesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r EventManagementApiGetEventsResourcesRequest) BlockId(blockId string) EventManagementApiGetEventsResourcesRequest {
	r.blockId = &blockId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r EventManagementApiGetEventsResourcesRequest) EventIds(eventIds []string) EventManagementApiGetEventsResourcesRequest {
	r.eventIds = &eventIds
	return r
}

// External system code.
func (r EventManagementApiGetEventsResourcesRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetEventsResourcesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetEventsResourcesRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetEventsResourcesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetEventsResourcesRequest) Execute() (*EventsResources, *http.Response, error) {
	return r.ApiService.GetEventsResourcesExecute(r)
}

/*
GetEventsResources Get Event Resources

Event Resources are the items and menus the property provides as part of its events offerings. Use this API to retrieve the Event resources as per your requested parameters. <p><strong>OperationId:</strong>getEventsResources</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return EventManagementApiGetEventsResourcesRequest
*/
func (a *EventManagementApiService) GetEventsResources(ctx context.Context, hotelId string) EventManagementApiGetEventsResourcesRequest {
	return EventManagementApiGetEventsResourcesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return EventsResources
func (a *EventManagementApiService) GetEventsResourcesExecute(r EventManagementApiGetEventsResourcesRequest) (*EventsResources, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventsResources
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetEventsResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/eventsResources"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	if r.eventIds != nil {
		t := *r.eventIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetFunctionSpaceAvailabilityRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	checkInventory *bool
	eventEndDate *string
	limit *int32
	offset *int32
	physicalRoom *bool
	showForceAlternate *bool
	eventStartDate *string
	roomCodes *[]string
	roomType *string
	spaceType *string
	functionSpaceWildcard *string
	floorCodes *[]string
	locationCodes *[]string
	fetchInstructions *[]string
	functionSpaceSearchMode *string
	functionSpaceAdditionalSearchMode *string
	attendeesFrom *int32
	attendeesTo *int32
	areaFrom *float32
	areaTo *float32
	setupCodes *[]string
	masterRateCode *string
	amount *float32
	currencyCode *string
	masterSetupCode *string
	setupTime *int32
	setdownTime *int32
	resvNameId *float32
	eventTypeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) Authorization(authorization string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) XAppKey(xAppKey string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) XHotelid(xHotelid string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag that indicates if when quering for availability inventory should be checked or not.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) CheckInventory(checkInventory bool) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.checkInventory = &checkInventory
	return r
}

// The ending value of the time span.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) EventEndDate(eventEndDate string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.eventEndDate = &eventEndDate
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) Limit(limit int32) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) Offset(offset int32) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.offset = &offset
	return r
}

// Determines whether to fetch only physical meeting rooms or not.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) PhysicalRoom(physicalRoom bool) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.physicalRoom = &physicalRoom
	return r
}

// Flag that indicates if the result includes force alternate function spaces.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) ShowForceAlternate(showForceAlternate bool) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.showForceAlternate = &showForceAlternate
	return r
}

// The starting value of the time span.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) EventStartDate(eventStartDate string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.eventStartDate = &eventStartDate
	return r
}

func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) RoomCodes(roomCodes []string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.roomCodes = &roomCodes
	return r
}

// Room Type where function space belongs to
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) RoomType(roomType string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.roomType = &roomType
	return r
}

// Space Type where function space belongs to
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) SpaceType(spaceType string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.spaceType = &spaceType
	return r
}

// Wild search on Room Code and Function Name.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) FunctionSpaceWildcard(functionSpaceWildcard string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.functionSpaceWildcard = &functionSpaceWildcard
	return r
}

func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) FloorCodes(floorCodes []string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.floorCodes = &floorCodes
	return r
}

func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) LocationCodes(locationCodes []string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.locationCodes = &locationCodes
	return r
}

// Instruction to fetch only function space count.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) FetchInstructions(fetchInstructions []string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// A collection of prime search modes for fetching Function Space availability
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) FunctionSpaceSearchMode(functionSpaceSearchMode string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.functionSpaceSearchMode = &functionSpaceSearchMode
	return r
}

// A collection of additional search modes for fetching Function Space availability.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) FunctionSpaceAdditionalSearchMode(functionSpaceAdditionalSearchMode string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.functionSpaceAdditionalSearchMode = &functionSpaceAdditionalSearchMode
	return r
}

func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) AttendeesFrom(attendeesFrom int32) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.attendeesFrom = &attendeesFrom
	return r
}

func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) AttendeesTo(attendeesTo int32) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.attendeesTo = &attendeesTo
	return r
}

func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) AreaFrom(areaFrom float32) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.areaFrom = &areaFrom
	return r
}

func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) AreaTo(areaTo float32) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.areaTo = &areaTo
	return r
}

func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) SetupCodes(setupCodes []string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.setupCodes = &setupCodes
	return r
}

// Rate Code used by master function space.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) MasterRateCode(masterRateCode string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.masterRateCode = &masterRateCode
	return r
}

// A monetary amount.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) Amount(amount float32) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) CurrencyCode(currencyCode string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.currencyCode = &currencyCode
	return r
}

// Setup Code used by master function space.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) MasterSetupCode(masterSetupCode string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.masterSetupCode = &masterSetupCode
	return r
}

// Setup time in minutes.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) SetupTime(setupTime int32) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.setupTime = &setupTime
	return r
}

// Setdown time in minutes.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) SetdownTime(setdownTime int32) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.setdownTime = &setdownTime
	return r
}

// Internal ID of reservation, which currently holds the Function Space and which needs to be excluded while checking the Function Space availability
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) ResvNameId(resvNameId float32) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.resvNameId = &resvNameId
	return r
}

func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) EventTypeCodes(eventTypeCodes []string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.eventTypeCodes = &eventTypeCodes
	return r
}

// External system code.
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetFunctionSpaceAvailabilityRequest) Execute() (*FunctionSpaceAvailabilityDetails, *http.Response, error) {
	return r.ApiService.GetFunctionSpaceAvailabilityExecute(r)
}

/*
GetFunctionSpaceAvailability Get hotel's function space availability

Find the availability of a properties function space. <p><strong>OperationId:</strong>getFunctionSpaceAvailability</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return EventManagementApiGetFunctionSpaceAvailabilityRequest
*/
func (a *EventManagementApiService) GetFunctionSpaceAvailability(ctx context.Context, hotelId string) EventManagementApiGetFunctionSpaceAvailabilityRequest {
	return EventManagementApiGetFunctionSpaceAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FunctionSpaceAvailabilityDetails
func (a *EventManagementApiService) GetFunctionSpaceAvailabilityExecute(r EventManagementApiGetFunctionSpaceAvailabilityRequest) (*FunctionSpaceAvailabilityDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FunctionSpaceAvailabilityDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetFunctionSpaceAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/functionalSpace"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.checkInventory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkInventory", r.checkInventory, "")
	}
	if r.eventEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventEndDate", r.eventEndDate, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.physicalRoom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "physicalRoom", r.physicalRoom, "")
	}
	if r.showForceAlternate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showForceAlternate", r.showForceAlternate, "")
	}
	if r.eventStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventStartDate", r.eventStartDate, "")
	}
	if r.roomCodes != nil {
		t := *r.roomCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomCodes", t, "multi")
		}
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	if r.spaceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spaceType", r.spaceType, "")
	}
	if r.functionSpaceWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceWildcard", r.functionSpaceWildcard, "")
	}
	if r.floorCodes != nil {
		t := *r.floorCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "floorCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "floorCodes", t, "multi")
		}
	}
	if r.locationCodes != nil {
		t := *r.locationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locationCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locationCodes", t, "multi")
		}
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.functionSpaceSearchMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceSearchMode", r.functionSpaceSearchMode, "")
	}
	if r.functionSpaceAdditionalSearchMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceAdditionalSearchMode", r.functionSpaceAdditionalSearchMode, "")
	}
	if r.attendeesFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attendeesFrom", r.attendeesFrom, "")
	}
	if r.attendeesTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attendeesTo", r.attendeesTo, "")
	}
	if r.areaFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaFrom", r.areaFrom, "")
	}
	if r.areaTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaTo", r.areaTo, "")
	}
	if r.setupCodes != nil {
		t := *r.setupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "setupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "setupCodes", t, "multi")
		}
	}
	if r.masterRateCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "masterRateCode", r.masterRateCode, "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.masterSetupCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "masterSetupCode", r.masterSetupCode, "")
	}
	if r.setupTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "setupTime", r.setupTime, "")
	}
	if r.setdownTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "setdownTime", r.setdownTime, "")
	}
	if r.resvNameId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resvNameId", r.resvNameId, "")
	}
	if r.eventTypeCodes != nil {
		t := *r.eventTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetSharedFunctionSpaceEventsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	functionSpaceCode *string
	startDateTime *string
	endDateTime *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetSharedFunctionSpaceEventsRequest) Authorization(authorization string) EventManagementApiGetSharedFunctionSpaceEventsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetSharedFunctionSpaceEventsRequest) XAppKey(xAppKey string) EventManagementApiGetSharedFunctionSpaceEventsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetSharedFunctionSpaceEventsRequest) XHotelid(xHotelid string) EventManagementApiGetSharedFunctionSpaceEventsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Function space from which shared events will be fetched.
func (r EventManagementApiGetSharedFunctionSpaceEventsRequest) FunctionSpaceCode(functionSpaceCode string) EventManagementApiGetSharedFunctionSpaceEventsRequest {
	r.functionSpaceCode = &functionSpaceCode
	return r
}

func (r EventManagementApiGetSharedFunctionSpaceEventsRequest) StartDateTime(startDateTime string) EventManagementApiGetSharedFunctionSpaceEventsRequest {
	r.startDateTime = &startDateTime
	return r
}

func (r EventManagementApiGetSharedFunctionSpaceEventsRequest) EndDateTime(endDateTime string) EventManagementApiGetSharedFunctionSpaceEventsRequest {
	r.endDateTime = &endDateTime
	return r
}

// External system code.
func (r EventManagementApiGetSharedFunctionSpaceEventsRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetSharedFunctionSpaceEventsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetSharedFunctionSpaceEventsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetSharedFunctionSpaceEventsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetSharedFunctionSpaceEventsRequest) Execute() (*FunctionSpaceEvents, *http.Response, error) {
	return r.ApiService.GetSharedFunctionSpaceEventsExecute(r)
}

/*
GetSharedFunctionSpaceEvents Get shared function space events

This API will allow you to see if events are booked into the same space at the same or overlapping time. <p><strong>OperationId:</strong>getSharedFunctionSpaceEvents</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return EventManagementApiGetSharedFunctionSpaceEventsRequest
*/
func (a *EventManagementApiService) GetSharedFunctionSpaceEvents(ctx context.Context, hotelId string) EventManagementApiGetSharedFunctionSpaceEventsRequest {
	return EventManagementApiGetSharedFunctionSpaceEventsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FunctionSpaceEvents
func (a *EventManagementApiService) GetSharedFunctionSpaceEventsExecute(r EventManagementApiGetSharedFunctionSpaceEventsRequest) (*FunctionSpaceEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FunctionSpaceEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetSharedFunctionSpaceEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/functionalSpaceEvents"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.functionSpaceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceCode", r.functionSpaceCode, "")
	}
	if r.startDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDateTime", r.startDateTime, "")
	}
	if r.endDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDateTime", r.endDateTime, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiGetWaitlistedEventsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	functionSpaceCode *[]string
	accountName *string
	blockName *string
	blockId *string
	blockIdContext *string
	blockIdType *string
	startDateTime *string
	endDateTime *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiGetWaitlistedEventsRequest) Authorization(authorization string) EventManagementApiGetWaitlistedEventsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiGetWaitlistedEventsRequest) XAppKey(xAppKey string) EventManagementApiGetWaitlistedEventsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiGetWaitlistedEventsRequest) XHotelid(xHotelid string) EventManagementApiGetWaitlistedEventsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r EventManagementApiGetWaitlistedEventsRequest) FunctionSpaceCode(functionSpaceCode []string) EventManagementApiGetWaitlistedEventsRequest {
	r.functionSpaceCode = &functionSpaceCode
	return r
}

// Search a specific account&#39;s waitlisted events.
func (r EventManagementApiGetWaitlistedEventsRequest) AccountName(accountName string) EventManagementApiGetWaitlistedEventsRequest {
	r.accountName = &accountName
	return r
}

// Search a specific block&#39;s waitlisted events.
func (r EventManagementApiGetWaitlistedEventsRequest) BlockName(blockName string) EventManagementApiGetWaitlistedEventsRequest {
	r.blockName = &blockName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r EventManagementApiGetWaitlistedEventsRequest) BlockId(blockId string) EventManagementApiGetWaitlistedEventsRequest {
	r.blockId = &blockId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r EventManagementApiGetWaitlistedEventsRequest) BlockIdContext(blockIdContext string) EventManagementApiGetWaitlistedEventsRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID elementSpace. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r EventManagementApiGetWaitlistedEventsRequest) BlockIdType(blockIdType string) EventManagementApiGetWaitlistedEventsRequest {
	r.blockIdType = &blockIdType
	return r
}

func (r EventManagementApiGetWaitlistedEventsRequest) StartDateTime(startDateTime string) EventManagementApiGetWaitlistedEventsRequest {
	r.startDateTime = &startDateTime
	return r
}

func (r EventManagementApiGetWaitlistedEventsRequest) EndDateTime(endDateTime string) EventManagementApiGetWaitlistedEventsRequest {
	r.endDateTime = &endDateTime
	return r
}

// External system code.
func (r EventManagementApiGetWaitlistedEventsRequest) XExternalsystem(xExternalsystem string) EventManagementApiGetWaitlistedEventsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiGetWaitlistedEventsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiGetWaitlistedEventsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiGetWaitlistedEventsRequest) Execute() (*WaitlistedEvents, *http.Response, error) {
	return r.ApiService.GetWaitlistedEventsExecute(r)
}

/*
GetWaitlistedEvents Retreve Waitlisted Events 

Search for waitlisted events for a specified property.  You can narrow down the results by using filters in the request. <p><strong>OperationId:</strong>getWaitlistedEvents</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return EventManagementApiGetWaitlistedEventsRequest
*/
func (a *EventManagementApiService) GetWaitlistedEvents(ctx context.Context, hotelId string) EventManagementApiGetWaitlistedEventsRequest {
	return EventManagementApiGetWaitlistedEventsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return WaitlistedEvents
func (a *EventManagementApiService) GetWaitlistedEventsExecute(r EventManagementApiGetWaitlistedEventsRequest) (*WaitlistedEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WaitlistedEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetWaitlistedEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/waitListedEvents"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.functionSpaceCode != nil {
		t := *r.functionSpaceCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceCode", t, "multi")
		}
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	if r.blockIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", r.blockIdContext, "")
	}
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
	}
	if r.startDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDateTime", r.startDateTime, "")
	}
	if r.endDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDateTime", r.endDateTime, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiManageAlternateEventsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	manageAlternateEvents *ManageAlternateEventsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiManageAlternateEventsRequest) Authorization(authorization string) EventManagementApiManageAlternateEventsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiManageAlternateEventsRequest) XAppKey(xAppKey string) EventManagementApiManageAlternateEventsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiManageAlternateEventsRequest) XHotelid(xHotelid string) EventManagementApiManageAlternateEventsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for managing catering events those are alternate to other catering events.
func (r EventManagementApiManageAlternateEventsRequest) ManageAlternateEvents(manageAlternateEvents ManageAlternateEventsRequest) EventManagementApiManageAlternateEventsRequest {
	r.manageAlternateEvents = &manageAlternateEvents
	return r
}

// External system code.
func (r EventManagementApiManageAlternateEventsRequest) XExternalsystem(xExternalsystem string) EventManagementApiManageAlternateEventsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiManageAlternateEventsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiManageAlternateEventsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiManageAlternateEventsRequest) Execute() (*ManageAlternateEventsStatus, *http.Response, error) {
	return r.ApiService.ManageAlternateEventsExecute(r)
}

/*
ManageAlternateEvents Manage alternate events.

 <p><strong>OperationId:</strong>manageAlternateEvents</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EventManagementApiManageAlternateEventsRequest
*/
func (a *EventManagementApiService) ManageAlternateEvents(ctx context.Context) EventManagementApiManageAlternateEventsRequest {
	return EventManagementApiManageAlternateEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManageAlternateEventsStatus
func (a *EventManagementApiService) ManageAlternateEventsExecute(r EventManagementApiManageAlternateEventsRequest) (*ManageAlternateEventsStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManageAlternateEventsStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.ManageAlternateEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alternateEvents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.manageAlternateEvents
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiManageCateringEventPostingsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	eventId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringEventPostings *ManageCateringEventPostingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiManageCateringEventPostingsRequest) Authorization(authorization string) EventManagementApiManageCateringEventPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiManageCateringEventPostingsRequest) XAppKey(xAppKey string) EventManagementApiManageCateringEventPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiManageCateringEventPostingsRequest) XHotelid(xHotelid string) EventManagementApiManageCateringEventPostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for retrieving catering events postings.
func (r EventManagementApiManageCateringEventPostingsRequest) CateringEventPostings(cateringEventPostings ManageCateringEventPostingsRequest) EventManagementApiManageCateringEventPostingsRequest {
	r.cateringEventPostings = &cateringEventPostings
	return r
}

// External system code.
func (r EventManagementApiManageCateringEventPostingsRequest) XExternalsystem(xExternalsystem string) EventManagementApiManageCateringEventPostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiManageCateringEventPostingsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiManageCateringEventPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiManageCateringEventPostingsRequest) Execute() (*CateringEventPostings, *http.Response, error) {
	return r.ApiService.ManageCateringEventPostingsExecute(r)
}

/*
ManageCateringEventPostings Manage Catering Event postings

Update and manage the catering event changes on an event. <p><strong>OperationId:</strong>manageCateringEventPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId
 @param hotelId Unique ID of the hotel
 @return EventManagementApiManageCateringEventPostingsRequest
*/
func (a *EventManagementApiService) ManageCateringEventPostings(ctx context.Context, eventId string, hotelId string) EventManagementApiManageCateringEventPostingsRequest {
	return EventManagementApiManageCateringEventPostingsRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringEventPostings
func (a *EventManagementApiService) ManageCateringEventPostingsExecute(r EventManagementApiManageCateringEventPostingsRequest) (*CateringEventPostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringEventPostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.ManageCateringEventPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/events/{eventId}/cateringEventPostings"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringEventPostings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiManageWaitlistedEventsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	manageWaitlistedEvents *ManageWaitlistedEventsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiManageWaitlistedEventsRequest) Authorization(authorization string) EventManagementApiManageWaitlistedEventsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiManageWaitlistedEventsRequest) XAppKey(xAppKey string) EventManagementApiManageWaitlistedEventsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiManageWaitlistedEventsRequest) XHotelid(xHotelid string) EventManagementApiManageWaitlistedEventsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for managing waitlisted catering events.
func (r EventManagementApiManageWaitlistedEventsRequest) ManageWaitlistedEvents(manageWaitlistedEvents ManageWaitlistedEventsRequest) EventManagementApiManageWaitlistedEventsRequest {
	r.manageWaitlistedEvents = &manageWaitlistedEvents
	return r
}

// External system code.
func (r EventManagementApiManageWaitlistedEventsRequest) XExternalsystem(xExternalsystem string) EventManagementApiManageWaitlistedEventsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiManageWaitlistedEventsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiManageWaitlistedEventsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiManageWaitlistedEventsRequest) Execute() (*WaitlistedEvents, *http.Response, error) {
	return r.ApiService.ManageWaitlistedEventsExecute(r)
}

/*
ManageWaitlistedEvents Manage Waitlisted Events

You can update the waitlisted events such as changing priority of the events on the waitlist. <p><strong>OperationId:</strong>manageWaitlistedEvents</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return EventManagementApiManageWaitlistedEventsRequest
*/
func (a *EventManagementApiService) ManageWaitlistedEvents(ctx context.Context, hotelId string) EventManagementApiManageWaitlistedEventsRequest {
	return EventManagementApiManageWaitlistedEventsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return WaitlistedEvents
func (a *EventManagementApiService) ManageWaitlistedEventsExecute(r EventManagementApiManageWaitlistedEventsRequest) (*WaitlistedEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WaitlistedEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.ManageWaitlistedEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/waitListedEvents"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.manageWaitlistedEvents
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiMoveEventResourcesRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	eventId string
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eventResources *CopyEventResourcesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiMoveEventResourcesRequest) Authorization(authorization string) EventManagementApiMoveEventResourcesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiMoveEventResourcesRequest) XAppKey(xAppKey string) EventManagementApiMoveEventResourcesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiMoveEventResourcesRequest) XHotelid(xHotelid string) EventManagementApiMoveEventResourcesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for moving event resources.
func (r EventManagementApiMoveEventResourcesRequest) EventResources(eventResources CopyEventResourcesRequest) EventManagementApiMoveEventResourcesRequest {
	r.eventResources = &eventResources
	return r
}

// External system code.
func (r EventManagementApiMoveEventResourcesRequest) XExternalsystem(xExternalsystem string) EventManagementApiMoveEventResourcesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiMoveEventResourcesRequest) AcceptLanguage(acceptLanguage string) EventManagementApiMoveEventResourcesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiMoveEventResourcesRequest) Execute() (*EventResourcesResponse, *http.Response, error) {
	return r.ApiService.MoveEventResourcesExecute(r)
}

/*
MoveEventResources Move event resources

You can use this API to move one/more existing event resources to an event for the same/different block. <p><strong>OperationId:</strong>moveEventResources</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId Unique ID of the event
 @param blockId Unique ID of the block
 @return EventManagementApiMoveEventResourcesRequest
*/
func (a *EventManagementApiService) MoveEventResources(ctx context.Context, eventId string, blockId string) EventManagementApiMoveEventResourcesRequest {
	return EventManagementApiMoveEventResourcesRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return EventResourcesResponse
func (a *EventManagementApiService) MoveEventResourcesExecute(r EventManagementApiMoveEventResourcesRequest) (*EventResourcesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventResourcesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.MoveEventResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/events/{eventId}/resources/move"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eventResources
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiPostCateringPackageRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockCateringPackage *PostCateringPackageRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiPostCateringPackageRequest) Authorization(authorization string) EventManagementApiPostCateringPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiPostCateringPackageRequest) XAppKey(xAppKey string) EventManagementApiPostCateringPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiPostCateringPackageRequest) XHotelid(xHotelid string) EventManagementApiPostCateringPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for adding Catering Package/Template Events to block .
func (r EventManagementApiPostCateringPackageRequest) BlockCateringPackage(blockCateringPackage PostCateringPackageRequest) EventManagementApiPostCateringPackageRequest {
	r.blockCateringPackage = &blockCateringPackage
	return r
}

// External system code.
func (r EventManagementApiPostCateringPackageRequest) XExternalsystem(xExternalsystem string) EventManagementApiPostCateringPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiPostCateringPackageRequest) AcceptLanguage(acceptLanguage string) EventManagementApiPostCateringPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiPostCateringPackageRequest) Execute() (*BlockCateringPackageDetails, *http.Response, error) {
	return r.ApiService.PostCateringPackageExecute(r)
}

/*
PostCateringPackage Add catering packages to a block

Add an available catering package onto your block. <p><strong>OperationId:</strong>postCateringPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Unique ID of the block
 @return EventManagementApiPostCateringPackageRequest
*/
func (a *EventManagementApiService) PostCateringPackage(ctx context.Context, blockId string) EventManagementApiPostCateringPackageRequest {
	return EventManagementApiPostCateringPackageRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockCateringPackageDetails
func (a *EventManagementApiService) PostCateringPackageExecute(r EventManagementApiPostCateringPackageRequest) (*BlockCateringPackageDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockCateringPackageDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.PostCateringPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/cateringPackages"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockCateringPackage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiPostCateringPackageRevenueRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	cateringpackageId string
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringPackageRevenue *PostCateringPackageRevenueRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiPostCateringPackageRevenueRequest) Authorization(authorization string) EventManagementApiPostCateringPackageRevenueRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiPostCateringPackageRevenueRequest) XAppKey(xAppKey string) EventManagementApiPostCateringPackageRevenueRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiPostCateringPackageRevenueRequest) XHotelid(xHotelid string) EventManagementApiPostCateringPackageRevenueRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating revenue details of the associated catering package.
func (r EventManagementApiPostCateringPackageRevenueRequest) CateringPackageRevenue(cateringPackageRevenue PostCateringPackageRevenueRequest) EventManagementApiPostCateringPackageRevenueRequest {
	r.cateringPackageRevenue = &cateringPackageRevenue
	return r
}

// External system code.
func (r EventManagementApiPostCateringPackageRevenueRequest) XExternalsystem(xExternalsystem string) EventManagementApiPostCateringPackageRevenueRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiPostCateringPackageRevenueRequest) AcceptLanguage(acceptLanguage string) EventManagementApiPostCateringPackageRevenueRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiPostCateringPackageRevenueRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCateringPackageRevenueExecute(r)
}

/*
PostCateringPackageRevenue Add catering package revenue to a block

Add catering package revenue to a block <p><strong>OperationId:</strong>postCateringPackageRevenue</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringpackageId Unique ID of the catering package
 @param blockId Unique ID of the block
 @return EventManagementApiPostCateringPackageRevenueRequest
*/
func (a *EventManagementApiService) PostCateringPackageRevenue(ctx context.Context, cateringpackageId string, blockId string) EventManagementApiPostCateringPackageRevenueRequest {
	return EventManagementApiPostCateringPackageRevenueRequest{
		ApiService: a,
		ctx: ctx,
		cateringpackageId: cateringpackageId,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *EventManagementApiService) PostCateringPackageRevenueExecute(r EventManagementApiPostCateringPackageRevenueRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.PostCateringPackageRevenue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/cateringPackages/{cateringpackageId}/revenue"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringpackageId"+"}", url.PathEscape(parameterValueToString(r.cateringpackageId, "cateringpackageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringpackageId) < 1 {
		return localVarReturnValue, nil, reportError("cateringpackageId must have at least 1 elements")
	}
	if strlen(r.cateringpackageId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringpackageId must have less than 2000 elements")
	}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringPackageRevenue
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiPostEventsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	event *PostEventsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiPostEventsRequest) Authorization(authorization string) EventManagementApiPostEventsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiPostEventsRequest) XAppKey(xAppKey string) EventManagementApiPostEventsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiPostEventsRequest) XHotelid(xHotelid string) EventManagementApiPostEventsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new event.
func (r EventManagementApiPostEventsRequest) Event(event PostEventsRequest) EventManagementApiPostEventsRequest {
	r.event = &event
	return r
}

// External system code.
func (r EventManagementApiPostEventsRequest) XExternalsystem(xExternalsystem string) EventManagementApiPostEventsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiPostEventsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiPostEventsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiPostEventsRequest) Execute() (*Event, *http.Response, error) {
	return r.ApiService.PostEventsExecute(r)
}

/*
PostEvents Create an Event

This API allows the creation of a catering event with event type, description, start date / time. end date / time, attendees, function space, setup style, rate, and more. A catering event must always be linked to a block. It cannot exist on its own. <p><strong>OperationId:</strong>postEvents</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EventManagementApiPostEventsRequest
*/
func (a *EventManagementApiService) PostEvents(ctx context.Context) EventManagementApiPostEventsRequest {
	return EventManagementApiPostEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Event
func (a *EventManagementApiService) PostEventsExecute(r EventManagementApiPostEventsRequest) (*Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.PostEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.event
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiPostOpportunityEventsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	opportunityEvents *PostOpportunityEventsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiPostOpportunityEventsRequest) Authorization(authorization string) EventManagementApiPostOpportunityEventsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiPostOpportunityEventsRequest) XAppKey(xAppKey string) EventManagementApiPostOpportunityEventsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiPostOpportunityEventsRequest) XHotelid(xHotelid string) EventManagementApiPostOpportunityEventsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for adding Events for an Opportunity Block.
func (r EventManagementApiPostOpportunityEventsRequest) OpportunityEvents(opportunityEvents PostOpportunityEventsRequest) EventManagementApiPostOpportunityEventsRequest {
	r.opportunityEvents = &opportunityEvents
	return r
}

// External system code.
func (r EventManagementApiPostOpportunityEventsRequest) XExternalsystem(xExternalsystem string) EventManagementApiPostOpportunityEventsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiPostOpportunityEventsRequest) AcceptLanguage(acceptLanguage string) EventManagementApiPostOpportunityEventsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiPostOpportunityEventsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostOpportunityEventsExecute(r)
}

/*
PostOpportunityEvents Create Events for Opportunity Block

You can use this API to add Events for an Opportunity Block. <p><strong>OperationId:</strong>postOpportunityEvents</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EventManagementApiPostOpportunityEventsRequest
*/
func (a *EventManagementApiService) PostOpportunityEvents(ctx context.Context) EventManagementApiPostOpportunityEventsRequest {
	return EventManagementApiPostOpportunityEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *EventManagementApiService) PostOpportunityEventsExecute(r EventManagementApiPostOpportunityEventsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.PostOpportunityEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/opportunityEvents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.opportunityEvents
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EventManagementApiPostQuickInsertResourcesRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	quickInsertId string
	eventId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	quickInsertResources *PostQuickInsertResourcesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r EventManagementApiPostQuickInsertResourcesRequest) Authorization(authorization string) EventManagementApiPostQuickInsertResourcesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r EventManagementApiPostQuickInsertResourcesRequest) XAppKey(xAppKey string) EventManagementApiPostQuickInsertResourcesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r EventManagementApiPostQuickInsertResourcesRequest) XHotelid(xHotelid string) EventManagementApiPostQuickInsertResourcesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for quick insert of menu(s),item(s) or item template(s).
func (r EventManagementApiPostQuickInsertResourcesRequest) QuickInsertResources(quickInsertResources PostQuickInsertResourcesRequest) EventManagementApiPostQuickInsertResourcesRequest {
	r.quickInsertResources = &quickInsertResources
	return r
}

// External system code.
func (r EventManagementApiPostQuickInsertResourcesRequest) XExternalsystem(xExternalsystem string) EventManagementApiPostQuickInsertResourcesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r EventManagementApiPostQuickInsertResourcesRequest) AcceptLanguage(acceptLanguage string) EventManagementApiPostQuickInsertResourcesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r EventManagementApiPostQuickInsertResourcesRequest) Execute() (*QuickInsertResourceStatus, *http.Response, error) {
	return r.ApiService.PostQuickInsertResourcesExecute(r)
}

/*
PostQuickInsertResources Add Resource to an Event in a hotel by ID

Use this to add a configured resource to a Catering Event. The Catering Event ID and Quick Insert number of a Catering Menu or Miscellaneous Item or a Template name must be provided. <p><strong>OperationId:</strong>postQuickInsertResources</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quickInsertId Menu/Item quick insert ID or Item Template name
 @param eventId Unique ID of the event
 @param hotelId Unique ID of the hotel
 @return EventManagementApiPostQuickInsertResourcesRequest
*/
func (a *EventManagementApiService) PostQuickInsertResources(ctx context.Context, quickInsertId string, eventId string, hotelId string) EventManagementApiPostQuickInsertResourcesRequest {
	return EventManagementApiPostQuickInsertResourcesRequest{
		ApiService: a,
		ctx: ctx,
		quickInsertId: quickInsertId,
		eventId: eventId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return QuickInsertResourceStatus
func (a *EventManagementApiService) PostQuickInsertResourcesExecute(r EventManagementApiPostQuickInsertResourcesRequest) (*QuickInsertResourceStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickInsertResourceStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.PostQuickInsertResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/events/{eventId}/eventResources/{quickInsertId}"
	localVarPath = strings.Replace(localVarPath, "{"+"quickInsertId"+"}", url.PathEscape(parameterValueToString(r.quickInsertId, "quickInsertId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.quickInsertId) < 1 {
		return localVarReturnValue, nil, reportError("quickInsertId must have at least 1 elements")
	}
	if strlen(r.quickInsertId) > 2000 {
		return localVarReturnValue, nil, reportError("quickInsertId must have less than 2000 elements")
	}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.quickInsertResources
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
