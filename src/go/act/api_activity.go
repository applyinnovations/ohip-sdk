/*
OPERA Cloud Activity API

APIs to cater for Sales Activity functionality in OPERA Cloud. <br /><br /> Activities provide you with an account management tool for managing daily tasks such as appointments, sales calls, contact follow-up, and so on.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package act

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ActivityApiService ActivityApi service
type ActivityApiService service

type ActivityApiDeleteActivitiesRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activityIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiDeleteActivitiesRequest) Authorization(authorization string) ActivityApiDeleteActivitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiDeleteActivitiesRequest) XAppKey(xAppKey string) ActivityApiDeleteActivitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiDeleteActivitiesRequest) XHotelid(xHotelid string) ActivityApiDeleteActivitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiDeleteActivitiesRequest) ActivityIds(activityIds []string) ActivityApiDeleteActivitiesRequest {
	r.activityIds = &activityIds
	return r
}

// External system code.
func (r ActivityApiDeleteActivitiesRequest) XExternalsystem(xExternalsystem string) ActivityApiDeleteActivitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiDeleteActivitiesRequest) AcceptLanguage(acceptLanguage string) ActivityApiDeleteActivitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiDeleteActivitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivitiesExecute(r)
}

/*
DeleteActivities Delete activity in a hotel by ID

Use this API to mark an Activity as deleted.  You must know the OPERA Activity ID for this API. <p><strong>OperationId:</strong>deleteActivities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId Unique OPERA Activity ID which is used to find an Activity from OPERA. This ID is a primary identification of an Activity in OPERA.
 @param hotelId Unique ID of the hotel where activity is searched based on Activity ID.
 @return ActivityApiDeleteActivitiesRequest
*/
func (a *ActivityApiService) DeleteActivities(ctx context.Context, activityId string, hotelId string) ActivityApiDeleteActivitiesRequest {
	return ActivityApiDeleteActivitiesRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) DeleteActivitiesExecute(r ActivityApiDeleteActivitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.DeleteActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.activityIds != nil {
		t := *r.activityIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activityIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activityIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiDeleteActivitiesWithOutHotelIdRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	activityId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activityIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiDeleteActivitiesWithOutHotelIdRequest) Authorization(authorization string) ActivityApiDeleteActivitiesWithOutHotelIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiDeleteActivitiesWithOutHotelIdRequest) XAppKey(xAppKey string) ActivityApiDeleteActivitiesWithOutHotelIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiDeleteActivitiesWithOutHotelIdRequest) XHotelid(xHotelid string) ActivityApiDeleteActivitiesWithOutHotelIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiDeleteActivitiesWithOutHotelIdRequest) ActivityIds(activityIds []string) ActivityApiDeleteActivitiesWithOutHotelIdRequest {
	r.activityIds = &activityIds
	return r
}

// External system code.
func (r ActivityApiDeleteActivitiesWithOutHotelIdRequest) XExternalsystem(xExternalsystem string) ActivityApiDeleteActivitiesWithOutHotelIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiDeleteActivitiesWithOutHotelIdRequest) AcceptLanguage(acceptLanguage string) ActivityApiDeleteActivitiesWithOutHotelIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiDeleteActivitiesWithOutHotelIdRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivitiesWithOutHotelIdExecute(r)
}

/*
DeleteActivitiesWithOutHotelId Delete activity  by ID

Use this API to mark an Activity as deleted.  You must know the OPERA Activity ID for this API. <p><strong>OperationId:</strong>deleteActivitiesWithOutHotelId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId Unique OPERA Activity ID which is used to find an Activity from OPERA. This ID is a primary identification of an Activity in OPERA.
 @return ActivityApiDeleteActivitiesWithOutHotelIdRequest
*/
func (a *ActivityApiService) DeleteActivitiesWithOutHotelId(ctx context.Context, activityId string) ActivityApiDeleteActivitiesWithOutHotelIdRequest {
	return ActivityApiDeleteActivitiesWithOutHotelIdRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) DeleteActivitiesWithOutHotelIdExecute(r ActivityApiDeleteActivitiesWithOutHotelIdRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.DeleteActivitiesWithOutHotelId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities/{activityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}

	if r.activityIds != nil {
		t := *r.activityIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activityIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activityIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiDeleteActivityAttachmentRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	attachmentId string
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiDeleteActivityAttachmentRequest) Authorization(authorization string) ActivityApiDeleteActivityAttachmentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiDeleteActivityAttachmentRequest) XAppKey(xAppKey string) ActivityApiDeleteActivityAttachmentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiDeleteActivityAttachmentRequest) XHotelid(xHotelid string) ActivityApiDeleteActivityAttachmentRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ActivityApiDeleteActivityAttachmentRequest) XExternalsystem(xExternalsystem string) ActivityApiDeleteActivityAttachmentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiDeleteActivityAttachmentRequest) AcceptLanguage(acceptLanguage string) ActivityApiDeleteActivityAttachmentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiDeleteActivityAttachmentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivityAttachmentExecute(r)
}

/*
DeleteActivityAttachment Delete an attachment from an Activity

You can use this API to delete an attachment which exists on an activity in OPERA Cloud. <p><strong>OperationId:</strong>deleteActivityAttachment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attachmentId Attachment ID
 @param activityId Activity ID
 @param hotelId Unique OPERA Hotel code
 @return ActivityApiDeleteActivityAttachmentRequest
*/
func (a *ActivityApiService) DeleteActivityAttachment(ctx context.Context, attachmentId string, activityId string, hotelId string) ActivityApiDeleteActivityAttachmentRequest {
	return ActivityApiDeleteActivityAttachmentRequest{
		ApiService: a,
		ctx: ctx,
		attachmentId: attachmentId,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) DeleteActivityAttachmentExecute(r ActivityApiDeleteActivityAttachmentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.DeleteActivityAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}/attachments/{attachmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.attachmentId) < 1 {
		return localVarReturnValue, nil, reportError("attachmentId must have at least 1 elements")
	}
	if strlen(r.attachmentId) > 2000 {
		return localVarReturnValue, nil, reportError("attachmentId must have less than 2000 elements")
	}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	attachmentId string
	activityId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest) Authorization(authorization string) ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest) XAppKey(xAppKey string) ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest) XHotelid(xHotelid string) ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest) XExternalsystem(xExternalsystem string) ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest) AcceptLanguage(acceptLanguage string) ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivityAttachmentWithoutHotelIdExecute(r)
}

/*
DeleteActivityAttachmentWithoutHotelId Delete an attachment from an Activity

You can use this API to delete an attachment which exists on an activity in OPERA Cloud. <p><strong>OperationId:</strong>deleteActivityAttachmentWithoutHotelId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attachmentId Attachment ID
 @param activityId Activity ID
 @return ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest
*/
func (a *ActivityApiService) DeleteActivityAttachmentWithoutHotelId(ctx context.Context, attachmentId string, activityId string) ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest {
	return ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest{
		ApiService: a,
		ctx: ctx,
		attachmentId: attachmentId,
		activityId: activityId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) DeleteActivityAttachmentWithoutHotelIdExecute(r ActivityApiDeleteActivityAttachmentWithoutHotelIdRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.DeleteActivityAttachmentWithoutHotelId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities/{activityId}/attachments/{attachmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.attachmentId) < 1 {
		return localVarReturnValue, nil, reportError("attachmentId must have at least 1 elements")
	}
	if strlen(r.attachmentId) > 2000 {
		return localVarReturnValue, nil, reportError("attachmentId must have less than 2000 elements")
	}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiDeleteMultipleActivitiesRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	activityIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiDeleteMultipleActivitiesRequest) Authorization(authorization string) ActivityApiDeleteMultipleActivitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiDeleteMultipleActivitiesRequest) XAppKey(xAppKey string) ActivityApiDeleteMultipleActivitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiDeleteMultipleActivitiesRequest) XHotelid(xHotelid string) ActivityApiDeleteMultipleActivitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiDeleteMultipleActivitiesRequest) ActivityIds(activityIds []string) ActivityApiDeleteMultipleActivitiesRequest {
	r.activityIds = &activityIds
	return r
}

// External system code.
func (r ActivityApiDeleteMultipleActivitiesRequest) XExternalsystem(xExternalsystem string) ActivityApiDeleteMultipleActivitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiDeleteMultipleActivitiesRequest) AcceptLanguage(acceptLanguage string) ActivityApiDeleteMultipleActivitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiDeleteMultipleActivitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMultipleActivitiesExecute(r)
}

/*
DeleteMultipleActivities Delete activities

If you want to delete an activity, use this API.  You must know the activity ID for the request. <p><strong>OperationId:</strong>deleteMultipleActivities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivityApiDeleteMultipleActivitiesRequest
*/
func (a *ActivityApiService) DeleteMultipleActivities(ctx context.Context) ActivityApiDeleteMultipleActivitiesRequest {
	return ActivityApiDeleteMultipleActivitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) DeleteMultipleActivitiesExecute(r ActivityApiDeleteMultipleActivitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.DeleteMultipleActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.activityIds != nil {
		t := *r.activityIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activityIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activityIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetActivitiesRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	completed *bool
	highPriority *bool
	limit *int32
	offset *int32
	text *string
	hotelIds *[]string
	startDate *string
	endDate *string
	ownerCode *[]string
	activityClass *string
	activityType *[]string
	activityPurpose *string
	accountId *string
	contactId *string
	blockId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetActivitiesRequest) Authorization(authorization string) ActivityApiGetActivitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiGetActivitiesRequest) XAppKey(xAppKey string) ActivityApiGetActivitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetActivitiesRequest) XHotelid(xHotelid string) ActivityApiGetActivitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether the Activity is completed or not.
func (r ActivityApiGetActivitiesRequest) Completed(completed bool) ActivityApiGetActivitiesRequest {
	r.completed = &completed
	return r
}

// Indicates whether the Activity has high priority.
func (r ActivityApiGetActivitiesRequest) HighPriority(highPriority bool) ActivityApiGetActivitiesRequest {
	r.highPriority = &highPriority
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ActivityApiGetActivitiesRequest) Limit(limit int32) ActivityApiGetActivitiesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ActivityApiGetActivitiesRequest) Offset(offset int32) ActivityApiGetActivitiesRequest {
	r.offset = &offset
	return r
}

// Search string to be used for super search.
func (r ActivityApiGetActivitiesRequest) Text(text string) ActivityApiGetActivitiesRequest {
	r.text = &text
	return r
}

func (r ActivityApiGetActivitiesRequest) HotelIds(hotelIds []string) ActivityApiGetActivitiesRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ActivityApiGetActivitiesRequest) StartDate(startDate string) ActivityApiGetActivitiesRequest {
	r.startDate = &startDate
	return r
}

func (r ActivityApiGetActivitiesRequest) EndDate(endDate string) ActivityApiGetActivitiesRequest {
	r.endDate = &endDate
	return r
}

func (r ActivityApiGetActivitiesRequest) OwnerCode(ownerCode []string) ActivityApiGetActivitiesRequest {
	r.ownerCode = &ownerCode
	return r
}

// A collection of supported list of activity classes.
func (r ActivityApiGetActivitiesRequest) ActivityClass(activityClass string) ActivityApiGetActivitiesRequest {
	r.activityClass = &activityClass
	return r
}

func (r ActivityApiGetActivitiesRequest) ActivityType(activityType []string) ActivityApiGetActivitiesRequest {
	r.activityType = &activityType
	return r
}

// Purpose of the Activity.
func (r ActivityApiGetActivitiesRequest) ActivityPurpose(activityPurpose string) ActivityApiGetActivitiesRequest {
	r.activityPurpose = &activityPurpose
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetActivitiesRequest) AccountId(accountId string) ActivityApiGetActivitiesRequest {
	r.accountId = &accountId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetActivitiesRequest) ContactId(contactId string) ActivityApiGetActivitiesRequest {
	r.contactId = &contactId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetActivitiesRequest) BlockId(blockId string) ActivityApiGetActivitiesRequest {
	r.blockId = &blockId
	return r
}

// External system code.
func (r ActivityApiGetActivitiesRequest) XExternalsystem(xExternalsystem string) ActivityApiGetActivitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetActivitiesRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetActivitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetActivitiesRequest) Execute() (*ActivitiesInfo, *http.Response, error) {
	return r.ApiService.GetActivitiesExecute(r)
}

/*
GetActivities Get activities by hotel

You can use this API to retrieve multiple Activities for a hotel, you can narrow the results using different search criteria  <p><strong>OperationId:</strong>getActivities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId This is the Hotel Code of the Activity
 @return ActivityApiGetActivitiesRequest
*/
func (a *ActivityApiService) GetActivities(ctx context.Context, hotelId string) ActivityApiGetActivitiesRequest {
	return ActivityApiGetActivitiesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ActivitiesInfo
func (a *ActivityApiService) GetActivitiesExecute(r ActivityApiGetActivitiesRequest) (*ActivitiesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivitiesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.completed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed", r.completed, "")
	}
	if r.highPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highPriority", r.highPriority, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.ownerCode != nil {
		t := *r.ownerCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCode", t, "multi")
		}
	}
	if r.activityClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityClass", r.activityClass, "")
	}
	if r.activityType != nil {
		t := *r.activityType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", t, "multi")
		}
	}
	if r.activityPurpose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityPurpose", r.activityPurpose, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	}
	if r.contactId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactId", r.contactId, "")
	}
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetActivitiesByMultipleHotelIdsRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	completed *bool
	highPriority *bool
	limit *int32
	offset *int32
	text *string
	hotelIds *[]string
	startDate *string
	endDate *string
	ownerCode *[]string
	activityClass *string
	activityType *[]string
	activityPurpose *string
	accountId *string
	contactId *string
	blockId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) Authorization(authorization string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) XAppKey(xAppKey string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) XHotelid(xHotelid string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether the Activity is completed or not.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) Completed(completed bool) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.completed = &completed
	return r
}

// Indicates whether the Activity has high priority.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) HighPriority(highPriority bool) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.highPriority = &highPriority
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) Limit(limit int32) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) Offset(offset int32) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.offset = &offset
	return r
}

// Search string to be used for super search.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) Text(text string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.text = &text
	return r
}

func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) HotelIds(hotelIds []string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) StartDate(startDate string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.startDate = &startDate
	return r
}

func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) EndDate(endDate string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.endDate = &endDate
	return r
}

func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) OwnerCode(ownerCode []string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.ownerCode = &ownerCode
	return r
}

// A collection of supported list of activity classes.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) ActivityClass(activityClass string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.activityClass = &activityClass
	return r
}

func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) ActivityType(activityType []string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.activityType = &activityType
	return r
}

// Purpose of the Activity.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) ActivityPurpose(activityPurpose string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.activityPurpose = &activityPurpose
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) AccountId(accountId string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.accountId = &accountId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) ContactId(contactId string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.contactId = &contactId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) BlockId(blockId string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.blockId = &blockId
	return r
}

// External system code.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) XExternalsystem(xExternalsystem string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) Execute() (*ActivitiesInfo, *http.Response, error) {
	return r.ApiService.GetActivitiesByMultipleHotelIdsExecute(r)
}

/*
GetActivitiesByMultipleHotelIds Get activities

Use this API to retrieve activities for multiple hotels.  Results can be narrowed down by your search criteria in the request message. <p><strong>OperationId:</strong>getActivitiesByMultipleHotelIds</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivityApiGetActivitiesByMultipleHotelIdsRequest
*/
func (a *ActivityApiService) GetActivitiesByMultipleHotelIds(ctx context.Context) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	return ActivityApiGetActivitiesByMultipleHotelIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActivitiesInfo
func (a *ActivityApiService) GetActivitiesByMultipleHotelIdsExecute(r ActivityApiGetActivitiesByMultipleHotelIdsRequest) (*ActivitiesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivitiesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetActivitiesByMultipleHotelIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed", r.completed, "")
	}
	if r.highPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highPriority", r.highPriority, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.ownerCode != nil {
		t := *r.ownerCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCode", t, "multi")
		}
	}
	if r.activityClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityClass", r.activityClass, "")
	}
	if r.activityType != nil {
		t := *r.activityType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", t, "multi")
		}
	}
	if r.activityPurpose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityPurpose", r.activityPurpose, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	}
	if r.contactId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactId", r.contactId, "")
	}
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetActivityRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetActivityRequest) Authorization(authorization string) ActivityApiGetActivityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiGetActivityRequest) XAppKey(xAppKey string) ActivityApiGetActivityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetActivityRequest) XHotelid(xHotelid string) ActivityApiGetActivityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Instruction to fetch Activity&#39;s information, linked Block and Profile, Attachments and linked Activities.
func (r ActivityApiGetActivityRequest) FetchInstructions(fetchInstructions []string) ActivityApiGetActivityRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ActivityApiGetActivityRequest) XExternalsystem(xExternalsystem string) ActivityApiGetActivityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetActivityRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetActivityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetActivityRequest) Execute() (*Activity, *http.Response, error) {
	return r.ApiService.GetActivityExecute(r)
}

/*
GetActivity Get activity in a hotel by ID

You can use this API to retrieve an Activity for a hotel, using the OPERA Activity ID in the request. <p><strong>OperationId:</strong>getActivity</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId Unique OPERA Activity ID which is used to find an Activity from OPERA. This ID is a primary identification of an Activity in OPERA.
 @param hotelId Unique ID of the hotel where activity is searched based on Activity ID.
 @return ActivityApiGetActivityRequest
*/
func (a *ActivityApiService) GetActivity(ctx context.Context, activityId string, hotelId string) ActivityApiGetActivityRequest {
	return ActivityApiGetActivityRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Activity
func (a *ActivityApiService) GetActivityExecute(r ActivityApiGetActivityRequest) (*Activity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Activity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetActivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetActivityAttachmentsRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetActivityAttachmentsRequest) Authorization(authorization string) ActivityApiGetActivityAttachmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiGetActivityAttachmentsRequest) XAppKey(xAppKey string) ActivityApiGetActivityAttachmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetActivityAttachmentsRequest) XHotelid(xHotelid string) ActivityApiGetActivityAttachmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ActivityApiGetActivityAttachmentsRequest) XExternalsystem(xExternalsystem string) ActivityApiGetActivityAttachmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetActivityAttachmentsRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetActivityAttachmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetActivityAttachmentsRequest) Execute() (*ActivityAttachments, *http.Response, error) {
	return r.ApiService.GetActivityAttachmentsExecute(r)
}

/*
GetActivityAttachments Get Activity Attachments

You can use this API when you want to view the attachments on an existing activity. <p><strong>OperationId:</strong>getActivityAttachments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId Activity ID
 @param hotelId Unique OPERA Hotel code
 @return ActivityApiGetActivityAttachmentsRequest
*/
func (a *ActivityApiService) GetActivityAttachments(ctx context.Context, activityId string, hotelId string) ActivityApiGetActivityAttachmentsRequest {
	return ActivityApiGetActivityAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ActivityAttachments
func (a *ActivityApiService) GetActivityAttachmentsExecute(r ActivityApiGetActivityAttachmentsRequest) (*ActivityAttachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivityAttachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetActivityAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetActivityLogRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	module *string
	moduleParamsParameterName *[]string
	moduleParamsParameterValue *[]string
	activityGroup *string
	activityType *string
	fromDate *string
	toDate *string
	searchText *string
	userByIdUserIds *[]int32
	userForIdUserIds *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetActivityLogRequest) Authorization(authorization string) ActivityApiGetActivityLogRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiGetActivityLogRequest) XAppKey(xAppKey string) ActivityApiGetActivityLogRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetActivityLogRequest) XHotelid(xHotelid string) ActivityApiGetActivityLogRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ActivityApiGetActivityLogRequest) Limit(limit int32) ActivityApiGetActivityLogRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ActivityApiGetActivityLogRequest) Offset(offset int32) ActivityApiGetActivityLogRequest {
	r.offset = &offset
	return r
}

// Activity module.
func (r ActivityApiGetActivityLogRequest) Module(module string) ActivityApiGetActivityLogRequest {
	r.module = &module
	return r
}

// Name of the parameter.
func (r ActivityApiGetActivityLogRequest) ModuleParamsParameterName(moduleParamsParameterName []string) ActivityApiGetActivityLogRequest {
	r.moduleParamsParameterName = &moduleParamsParameterName
	return r
}

// Value of the parameter.
func (r ActivityApiGetActivityLogRequest) ModuleParamsParameterValue(moduleParamsParameterValue []string) ActivityApiGetActivityLogRequest {
	r.moduleParamsParameterValue = &moduleParamsParameterValue
	return r
}

func (r ActivityApiGetActivityLogRequest) ActivityGroup(activityGroup string) ActivityApiGetActivityLogRequest {
	r.activityGroup = &activityGroup
	return r
}

func (r ActivityApiGetActivityLogRequest) ActivityType(activityType string) ActivityApiGetActivityLogRequest {
	r.activityType = &activityType
	return r
}

// Search from date for the user activity log.
func (r ActivityApiGetActivityLogRequest) FromDate(fromDate string) ActivityApiGetActivityLogRequest {
	r.fromDate = &fromDate
	return r
}

// Search to date for the user activity log.
func (r ActivityApiGetActivityLogRequest) ToDate(toDate string) ActivityApiGetActivityLogRequest {
	r.toDate = &toDate
	return r
}

// Search text for the user activity log.
func (r ActivityApiGetActivityLogRequest) SearchText(searchText string) ActivityApiGetActivityLogRequest {
	r.searchText = &searchText
	return r
}

func (r ActivityApiGetActivityLogRequest) UserByIdUserIds(userByIdUserIds []int32) ActivityApiGetActivityLogRequest {
	r.userByIdUserIds = &userByIdUserIds
	return r
}

func (r ActivityApiGetActivityLogRequest) UserForIdUserIds(userForIdUserIds []int32) ActivityApiGetActivityLogRequest {
	r.userForIdUserIds = &userForIdUserIds
	return r
}

// External system code.
func (r ActivityApiGetActivityLogRequest) XExternalsystem(xExternalsystem string) ActivityApiGetActivityLogRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetActivityLogRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetActivityLogRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetActivityLogRequest) Execute() (*ActivityLog, *http.Response, error) {
	return r.ApiService.GetActivityLogExecute(r)
}

/*
GetActivityLog Get Activity Log

You can use this API to view the changes log for a specified Activity. <p><strong>OperationId:</strong>getActivityLog</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ActivityApiGetActivityLogRequest
*/
func (a *ActivityApiService) GetActivityLog(ctx context.Context, hotelId string) ActivityApiGetActivityLogRequest {
	return ActivityApiGetActivityLogRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ActivityLog
func (a *ActivityApiService) GetActivityLogExecute(r ActivityApiGetActivityLogRequest) (*ActivityLog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivityLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetActivityLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activityLog"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.module != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "module", r.module, "")
	}
	if r.moduleParamsParameterName != nil {
		t := *r.moduleParamsParameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "moduleParamsParameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "moduleParamsParameterName", t, "multi")
		}
	}
	if r.moduleParamsParameterValue != nil {
		t := *r.moduleParamsParameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "moduleParamsParameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "moduleParamsParameterValue", t, "multi")
		}
	}
	if r.activityGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityGroup", r.activityGroup, "")
	}
	if r.activityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", r.activityType, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
	}
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "")
	}
	if r.userByIdUserIds != nil {
		t := *r.userByIdUserIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userByIdUserIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userByIdUserIds", t, "multi")
		}
	}
	if r.userForIdUserIds != nil {
		t := *r.userForIdUserIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userForIdUserIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userForIdUserIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetActivityStatisticsRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reportStartDate *string
	activityTypeCodes *[]string
	ownerCodeList *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetActivityStatisticsRequest) Authorization(authorization string) ActivityApiGetActivityStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiGetActivityStatisticsRequest) XAppKey(xAppKey string) ActivityApiGetActivityStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetActivityStatisticsRequest) XHotelid(xHotelid string) ActivityApiGetActivityStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Start date of the report.
func (r ActivityApiGetActivityStatisticsRequest) ReportStartDate(reportStartDate string) ActivityApiGetActivityStatisticsRequest {
	r.reportStartDate = &reportStartDate
	return r
}

func (r ActivityApiGetActivityStatisticsRequest) ActivityTypeCodes(activityTypeCodes []string) ActivityApiGetActivityStatisticsRequest {
	r.activityTypeCodes = &activityTypeCodes
	return r
}

func (r ActivityApiGetActivityStatisticsRequest) OwnerCodeList(ownerCodeList []string) ActivityApiGetActivityStatisticsRequest {
	r.ownerCodeList = &ownerCodeList
	return r
}

// External system code.
func (r ActivityApiGetActivityStatisticsRequest) XExternalsystem(xExternalsystem string) ActivityApiGetActivityStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetActivityStatisticsRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetActivityStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetActivityStatisticsRequest) Execute() (*ActivityStatistics, *http.Response, error) {
	return r.ApiService.GetActivityStatisticsExecute(r)
}

/*
GetActivityStatistics Get Activity statistics

You can use this API to retrieve all statistics of activities. <p><strong>OperationId:</strong>getActivityStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ActivityApiGetActivityStatisticsRequest
*/
func (a *ActivityApiService) GetActivityStatistics(ctx context.Context, hotelId string) ActivityApiGetActivityStatisticsRequest {
	return ActivityApiGetActivityStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ActivityStatistics
func (a *ActivityApiService) GetActivityStatisticsExecute(r ActivityApiGetActivityStatisticsRequest) (*ActivityStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivityStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetActivityStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.reportStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportStartDate", r.reportStartDate, "")
	}
	if r.activityTypeCodes != nil {
		t := *r.activityTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activityTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activityTypeCodes", t, "multi")
		}
	}
	if r.ownerCodeList != nil {
		t := *r.ownerCodeList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCodeList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCodeList", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetActivityWithOutHotelIdRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	activityId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetActivityWithOutHotelIdRequest) Authorization(authorization string) ActivityApiGetActivityWithOutHotelIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiGetActivityWithOutHotelIdRequest) XAppKey(xAppKey string) ActivityApiGetActivityWithOutHotelIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetActivityWithOutHotelIdRequest) XHotelid(xHotelid string) ActivityApiGetActivityWithOutHotelIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Instruction to fetch Activity&#39;s information, linked Block and Profile, Attachments and linked Activities.
func (r ActivityApiGetActivityWithOutHotelIdRequest) FetchInstructions(fetchInstructions []string) ActivityApiGetActivityWithOutHotelIdRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ActivityApiGetActivityWithOutHotelIdRequest) XExternalsystem(xExternalsystem string) ActivityApiGetActivityWithOutHotelIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetActivityWithOutHotelIdRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetActivityWithOutHotelIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetActivityWithOutHotelIdRequest) Execute() (*Activity, *http.Response, error) {
	return r.ApiService.GetActivityWithOutHotelIdExecute(r)
}

/*
GetActivityWithOutHotelId Get activity by ID

You can use this API to retrieve an Activity, using the OPERA Activity ID in the request. <p><strong>OperationId:</strong>getActivityWithOutHotelId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId Unique OPERA Activity ID which is used to find an Activity from OPERA. This ID is a primary identification of an Activity in OPERA.
 @return ActivityApiGetActivityWithOutHotelIdRequest
*/
func (a *ActivityApiService) GetActivityWithOutHotelId(ctx context.Context, activityId string) ActivityApiGetActivityWithOutHotelIdRequest {
	return ActivityApiGetActivityWithOutHotelIdRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
	}
}

// Execute executes the request
//  @return Activity
func (a *ActivityApiService) GetActivityWithOutHotelIdExecute(r ActivityApiGetActivityWithOutHotelIdRequest) (*Activity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Activity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetActivityWithOutHotelId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities/{activityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetEmailsRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	code *[]string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	accountIdId *string
	accountIdIdExtension *int32
	accountIdIdContext *string
	accountIdType *string
	contactIdId *string
	contactIdIdExtension *int32
	contactIdIdContext *string
	contactIdType *string
	blockIdId *string
	blockIdIdExtension *int32
	blockIdIdContext *string
	blockIdType *string
	emailSubject *string
	senderLastName *string
	senderFirstName *string
	senderEmailAddress *string
	startDate *string
	endDate *string
	duration *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetEmailsRequest) Authorization(authorization string) ActivityApiGetEmailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiGetEmailsRequest) XAppKey(xAppKey string) ActivityApiGetEmailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetEmailsRequest) XHotelid(xHotelid string) ActivityApiGetEmailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ActivityApiGetEmailsRequest) Limit(limit int32) ActivityApiGetEmailsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ActivityApiGetEmailsRequest) Offset(offset int32) ActivityApiGetEmailsRequest {
	r.offset = &offset
	return r
}

func (r ActivityApiGetEmailsRequest) Code(code []string) ActivityApiGetEmailsRequest {
	r.code = &code
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetEmailsRequest) Id(id string) ActivityApiGetEmailsRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ActivityApiGetEmailsRequest) IdExtension(idExtension int32) ActivityApiGetEmailsRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ActivityApiGetEmailsRequest) IdContext(idContext string) ActivityApiGetEmailsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ActivityApiGetEmailsRequest) Type_(type_ string) ActivityApiGetEmailsRequest {
	r.type_ = &type_
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetEmailsRequest) AccountIdId(accountIdId string) ActivityApiGetEmailsRequest {
	r.accountIdId = &accountIdId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ActivityApiGetEmailsRequest) AccountIdIdExtension(accountIdIdExtension int32) ActivityApiGetEmailsRequest {
	r.accountIdIdExtension = &accountIdIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ActivityApiGetEmailsRequest) AccountIdIdContext(accountIdIdContext string) ActivityApiGetEmailsRequest {
	r.accountIdIdContext = &accountIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ActivityApiGetEmailsRequest) AccountIdType(accountIdType string) ActivityApiGetEmailsRequest {
	r.accountIdType = &accountIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetEmailsRequest) ContactIdId(contactIdId string) ActivityApiGetEmailsRequest {
	r.contactIdId = &contactIdId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ActivityApiGetEmailsRequest) ContactIdIdExtension(contactIdIdExtension int32) ActivityApiGetEmailsRequest {
	r.contactIdIdExtension = &contactIdIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ActivityApiGetEmailsRequest) ContactIdIdContext(contactIdIdContext string) ActivityApiGetEmailsRequest {
	r.contactIdIdContext = &contactIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ActivityApiGetEmailsRequest) ContactIdType(contactIdType string) ActivityApiGetEmailsRequest {
	r.contactIdType = &contactIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetEmailsRequest) BlockIdId(blockIdId string) ActivityApiGetEmailsRequest {
	r.blockIdId = &blockIdId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ActivityApiGetEmailsRequest) BlockIdIdExtension(blockIdIdExtension int32) ActivityApiGetEmailsRequest {
	r.blockIdIdExtension = &blockIdIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ActivityApiGetEmailsRequest) BlockIdIdContext(blockIdIdContext string) ActivityApiGetEmailsRequest {
	r.blockIdIdContext = &blockIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ActivityApiGetEmailsRequest) BlockIdType(blockIdType string) ActivityApiGetEmailsRequest {
	r.blockIdType = &blockIdType
	return r
}

// Subject of the email.
func (r ActivityApiGetEmailsRequest) EmailSubject(emailSubject string) ActivityApiGetEmailsRequest {
	r.emailSubject = &emailSubject
	return r
}

// Family name or last name of the Sender.
func (r ActivityApiGetEmailsRequest) SenderLastName(senderLastName string) ActivityApiGetEmailsRequest {
	r.senderLastName = &senderLastName
	return r
}

// Given name or first name of the Sender.
func (r ActivityApiGetEmailsRequest) SenderFirstName(senderFirstName string) ActivityApiGetEmailsRequest {
	r.senderFirstName = &senderFirstName
	return r
}

// Email address of the Sender.
func (r ActivityApiGetEmailsRequest) SenderEmailAddress(senderEmailAddress string) ActivityApiGetEmailsRequest {
	r.senderEmailAddress = &senderEmailAddress
	return r
}

func (r ActivityApiGetEmailsRequest) StartDate(startDate string) ActivityApiGetEmailsRequest {
	r.startDate = &startDate
	return r
}

func (r ActivityApiGetEmailsRequest) EndDate(endDate string) ActivityApiGetEmailsRequest {
	r.endDate = &endDate
	return r
}

func (r ActivityApiGetEmailsRequest) Duration(duration string) ActivityApiGetEmailsRequest {
	r.duration = &duration
	return r
}

// External system code.
func (r ActivityApiGetEmailsRequest) XExternalsystem(xExternalsystem string) ActivityApiGetEmailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetEmailsRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetEmailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetEmailsRequest) Execute() (*EmailsDetails, *http.Response, error) {
	return r.ApiService.GetEmailsExecute(r)
}

/*
GetEmails Get Emails

Use this API to retrieve emails which have been received from an external system and stored in OPERA. They are stored against accounts, contacts and blocks in OPERA. <p><strong>OperationId:</strong>getEmails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivityApiGetEmailsRequest
*/
func (a *ActivityApiService) GetEmails(ctx context.Context) ActivityApiGetEmailsRequest {
	return ActivityApiGetEmailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmailsDetails
func (a *ActivityApiService) GetEmailsExecute(r ActivityApiGetEmailsRequest) (*EmailsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmailsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetEmails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities/emails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.accountIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdId", r.accountIdId, "")
	}
	if r.accountIdIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdIdExtension", r.accountIdIdExtension, "")
	}
	if r.accountIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdIdContext", r.accountIdIdContext, "")
	}
	if r.accountIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdType", r.accountIdType, "")
	}
	if r.contactIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactIdId", r.contactIdId, "")
	}
	if r.contactIdIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactIdIdExtension", r.contactIdIdExtension, "")
	}
	if r.contactIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactIdIdContext", r.contactIdIdContext, "")
	}
	if r.contactIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactIdType", r.contactIdType, "")
	}
	if r.blockIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdId", r.blockIdId, "")
	}
	if r.blockIdIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdIdExtension", r.blockIdIdExtension, "")
	}
	if r.blockIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdIdContext", r.blockIdIdContext, "")
	}
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
	}
	if r.emailSubject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailSubject", r.emailSubject, "")
	}
	if r.senderLastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "senderLastName", r.senderLastName, "")
	}
	if r.senderFirstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "senderFirstName", r.senderFirstName, "")
	}
	if r.senderEmailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "senderEmailAddress", r.senderEmailAddress, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetRecentlyAccessedActivitiesRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetRecentlyAccessedActivitiesRequest) Authorization(authorization string) ActivityApiGetRecentlyAccessedActivitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiGetRecentlyAccessedActivitiesRequest) XAppKey(xAppKey string) ActivityApiGetRecentlyAccessedActivitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetRecentlyAccessedActivitiesRequest) XHotelid(xHotelid string) ActivityApiGetRecentlyAccessedActivitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ActivityApiGetRecentlyAccessedActivitiesRequest) XExternalsystem(xExternalsystem string) ActivityApiGetRecentlyAccessedActivitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetRecentlyAccessedActivitiesRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetRecentlyAccessedActivitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetRecentlyAccessedActivitiesRequest) Execute() (*RecentlyAccessedActivities, *http.Response, error) {
	return r.ApiService.GetRecentlyAccessedActivitiesExecute(r)
}

/*
GetRecentlyAccessedActivities Get recently accessed activities

This API allows you to retrieve a list of activities that have recently been accessed.   <p><strong>OperationId:</strong>getRecentlyAccessedActivities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ActivityApiGetRecentlyAccessedActivitiesRequest
*/
func (a *ActivityApiService) GetRecentlyAccessedActivities(ctx context.Context, hotelId string) ActivityApiGetRecentlyAccessedActivitiesRequest {
	return ActivityApiGetRecentlyAccessedActivitiesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RecentlyAccessedActivities
func (a *ActivityApiService) GetRecentlyAccessedActivitiesExecute(r ActivityApiGetRecentlyAccessedActivitiesRequest) (*RecentlyAccessedActivities, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RecentlyAccessedActivities
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetRecentlyAccessedActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/recentlyAccessedActivities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest) Authorization(authorization string) ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest) XAppKey(xAppKey string) ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest) XHotelid(xHotelid string) ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest) XExternalsystem(xExternalsystem string) ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest) Execute() (*RecentlyAccessedActivities, *http.Response, error) {
	return r.ApiService.GetRecentlyAccessedActivitiesWithOutHotelIdExecute(r)
}

/*
GetRecentlyAccessedActivitiesWithOutHotelId Get recently accessed activities

This API allows you to retrieve a list of activities that have recently been accessed.   <p><strong>OperationId:</strong>getRecentlyAccessedActivitiesWithOutHotelId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest
*/
func (a *ActivityApiService) GetRecentlyAccessedActivitiesWithOutHotelId(ctx context.Context) ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest {
	return ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RecentlyAccessedActivities
func (a *ActivityApiService) GetRecentlyAccessedActivitiesWithOutHotelIdExecute(r ActivityApiGetRecentlyAccessedActivitiesWithOutHotelIdRequest) (*RecentlyAccessedActivities, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RecentlyAccessedActivities
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetRecentlyAccessedActivitiesWithOutHotelId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recentlyAccessedActivities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiPostActivitiesRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activitiesInformation *PostActivitiesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiPostActivitiesRequest) Authorization(authorization string) ActivityApiPostActivitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiPostActivitiesRequest) XAppKey(xAppKey string) ActivityApiPostActivitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiPostActivitiesRequest) XHotelid(xHotelid string) ActivityApiPostActivitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Activities.
func (r ActivityApiPostActivitiesRequest) ActivitiesInformation(activitiesInformation PostActivitiesRequest) ActivityApiPostActivitiesRequest {
	r.activitiesInformation = &activitiesInformation
	return r
}

// External system code.
func (r ActivityApiPostActivitiesRequest) XExternalsystem(xExternalsystem string) ActivityApiPostActivitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiPostActivitiesRequest) AcceptLanguage(acceptLanguage string) ActivityApiPostActivitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiPostActivitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostActivitiesExecute(r)
}

/*
PostActivities Create activities in a hotel

Use postActivities to create a new activity for a hotel.  You would need to know the types of Activities a hotel accepts, such as Appointments, TODO.  Use ListOfValues API's to find the available types at a hotel. <p><strong>OperationId:</strong>postActivities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where activity is searched based on Activity ID.
 @return ActivityApiPostActivitiesRequest
*/
func (a *ActivityApiService) PostActivities(ctx context.Context, hotelId string) ActivityApiPostActivitiesRequest {
	return ActivityApiPostActivitiesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) PostActivitiesExecute(r ActivityApiPostActivitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.PostActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activitiesInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiPostLinkedActivitiesRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	linkedActivities *PostLinkedActivitiesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiPostLinkedActivitiesRequest) Authorization(authorization string) ActivityApiPostLinkedActivitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiPostLinkedActivitiesRequest) XAppKey(xAppKey string) ActivityApiPostLinkedActivitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiPostLinkedActivitiesRequest) XHotelid(xHotelid string) ActivityApiPostLinkedActivitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create linked activities for an activity.
func (r ActivityApiPostLinkedActivitiesRequest) LinkedActivities(linkedActivities PostLinkedActivitiesRequest) ActivityApiPostLinkedActivitiesRequest {
	r.linkedActivities = &linkedActivities
	return r
}

// External system code.
func (r ActivityApiPostLinkedActivitiesRequest) XExternalsystem(xExternalsystem string) ActivityApiPostLinkedActivitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiPostLinkedActivitiesRequest) AcceptLanguage(acceptLanguage string) ActivityApiPostLinkedActivitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiPostLinkedActivitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostLinkedActivitiesExecute(r)
}

/*
PostLinkedActivities Create linked activities in a hotel by ID

You can use this API to invite one or multiple owners to an activity. <p><strong>OperationId:</strong>postLinkedActivities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId Activity ID
 @param hotelId Unique OPERA Hotel code
 @return ActivityApiPostLinkedActivitiesRequest
*/
func (a *ActivityApiService) PostLinkedActivities(ctx context.Context, activityId string, hotelId string) ActivityApiPostLinkedActivitiesRequest {
	return ActivityApiPostLinkedActivitiesRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) PostLinkedActivitiesExecute(r ActivityApiPostLinkedActivitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.PostLinkedActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}/linkedActivities"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.linkedActivities
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiPostMultipleActivitiesCompletionRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	activitiesToChange *PostMultipleActivitiesCompletionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiPostMultipleActivitiesCompletionRequest) Authorization(authorization string) ActivityApiPostMultipleActivitiesCompletionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiPostMultipleActivitiesCompletionRequest) XAppKey(xAppKey string) ActivityApiPostMultipleActivitiesCompletionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiPostMultipleActivitiesCompletionRequest) XHotelid(xHotelid string) ActivityApiPostMultipleActivitiesCompletionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activities.
func (r ActivityApiPostMultipleActivitiesCompletionRequest) ActivitiesToChange(activitiesToChange PostMultipleActivitiesCompletionRequest) ActivityApiPostMultipleActivitiesCompletionRequest {
	r.activitiesToChange = &activitiesToChange
	return r
}

// External system code.
func (r ActivityApiPostMultipleActivitiesCompletionRequest) XExternalsystem(xExternalsystem string) ActivityApiPostMultipleActivitiesCompletionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiPostMultipleActivitiesCompletionRequest) AcceptLanguage(acceptLanguage string) ActivityApiPostMultipleActivitiesCompletionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiPostMultipleActivitiesCompletionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMultipleActivitiesCompletionExecute(r)
}

/*
PostMultipleActivitiesCompletion Complete activities

Use this API to mark multiple Activities as completed in 1 request.  You must know the OPERA Activity ID's for this API. <p><strong>OperationId:</strong>postMultipleActivitiesCompletion</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivityApiPostMultipleActivitiesCompletionRequest
*/
func (a *ActivityApiService) PostMultipleActivitiesCompletion(ctx context.Context) ActivityApiPostMultipleActivitiesCompletionRequest {
	return ActivityApiPostMultipleActivitiesCompletionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) PostMultipleActivitiesCompletionExecute(r ActivityApiPostMultipleActivitiesCompletionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.PostMultipleActivitiesCompletion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities/activitiesCompletion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activitiesToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiPostSingleActivityCompletionRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activitiesToChange *PostSingleActivityCompletionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiPostSingleActivityCompletionRequest) Authorization(authorization string) ActivityApiPostSingleActivityCompletionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiPostSingleActivityCompletionRequest) XAppKey(xAppKey string) ActivityApiPostSingleActivityCompletionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiPostSingleActivityCompletionRequest) XHotelid(xHotelid string) ActivityApiPostSingleActivityCompletionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activities.
func (r ActivityApiPostSingleActivityCompletionRequest) ActivitiesToChange(activitiesToChange PostSingleActivityCompletionRequest) ActivityApiPostSingleActivityCompletionRequest {
	r.activitiesToChange = &activitiesToChange
	return r
}

// External system code.
func (r ActivityApiPostSingleActivityCompletionRequest) XExternalsystem(xExternalsystem string) ActivityApiPostSingleActivityCompletionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiPostSingleActivityCompletionRequest) AcceptLanguage(acceptLanguage string) ActivityApiPostSingleActivityCompletionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiPostSingleActivityCompletionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostSingleActivityCompletionExecute(r)
}

/*
PostSingleActivityCompletion Complete activity in a hotel by ID

Use this API to mark one Activity as completed in 1 request.  You must know the OPERA Activity ID for this API. <p><strong>OperationId:</strong>postSingleActivityCompletion</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId Unique OPERA Activity ID which is used to find an Activity from OPERA. This ID is a primary identification of an Activity in OPERA.
 @param hotelId Unique ID of the hotel where activity is searched based on Activity ID.
 @return ActivityApiPostSingleActivityCompletionRequest
*/
func (a *ActivityApiService) PostSingleActivityCompletion(ctx context.Context, activityId string, hotelId string) ActivityApiPostSingleActivityCompletionRequest {
	return ActivityApiPostSingleActivityCompletionRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) PostSingleActivityCompletionExecute(r ActivityApiPostSingleActivityCompletionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.PostSingleActivityCompletion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}/activityCompletion"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activitiesToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiPutActivitiesRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activitiesToChange *PutActivitiesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiPutActivitiesRequest) Authorization(authorization string) ActivityApiPutActivitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ActivityApiPutActivitiesRequest) XAppKey(xAppKey string) ActivityApiPutActivitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiPutActivitiesRequest) XHotelid(xHotelid string) ActivityApiPutActivitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activities.
func (r ActivityApiPutActivitiesRequest) ActivitiesToChange(activitiesToChange PutActivitiesRequest) ActivityApiPutActivitiesRequest {
	r.activitiesToChange = &activitiesToChange
	return r
}

// External system code.
func (r ActivityApiPutActivitiesRequest) XExternalsystem(xExternalsystem string) ActivityApiPutActivitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiPutActivitiesRequest) AcceptLanguage(acceptLanguage string) ActivityApiPutActivitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiPutActivitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutActivitiesExecute(r)
}

/*
PutActivities Update activity in a hotel by ID

Use this to update an existing Activity for a hotel.  You must know the OPERA Activity ID for this API. <p><strong>OperationId:</strong>putActivities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId Unique OPERA Activity ID which is used to find an Activity from OPERA. This ID is a primary identification of an Activity in OPERA.
 @param hotelId Unique ID of the hotel where activity is searched based on Activity ID.
 @return ActivityApiPutActivitiesRequest
*/
func (a *ActivityApiService) PutActivities(ctx context.Context, activityId string, hotelId string) ActivityApiPutActivitiesRequest {
	return ActivityApiPutActivitiesRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) PutActivitiesExecute(r ActivityApiPutActivitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.PutActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activitiesToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
