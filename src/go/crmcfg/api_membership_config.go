/*
OPERA Cloud CRM Configuration API

APIs for Customer Relationship Management (profile) configuration, such as creating preferences, or address types.  It also includes Membership Configuration, where you can retrieve membership levels that are configured for a property, or create new membership enrollment codes.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package crmcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// MembershipConfigApiService MembershipConfigApi service
type MembershipConfigApiService service

type MembershipConfigApiDeleteMembershipAwardsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipAwardsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiDeleteMembershipAwardsRequest) Authorization(authorization string) MembershipConfigApiDeleteMembershipAwardsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiDeleteMembershipAwardsRequest) XAppKey(xAppKey string) MembershipConfigApiDeleteMembershipAwardsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiDeleteMembershipAwardsRequest) XHotelid(xHotelid string) MembershipConfigApiDeleteMembershipAwardsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Membership type for which awards are defined.
func (r MembershipConfigApiDeleteMembershipAwardsRequest) MembershipType(membershipType []string) MembershipConfigApiDeleteMembershipAwardsRequest {
	r.membershipType = &membershipType
	return r
}

// External system code.
func (r MembershipConfigApiDeleteMembershipAwardsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiDeleteMembershipAwardsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiDeleteMembershipAwardsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiDeleteMembershipAwardsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiDeleteMembershipAwardsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMembershipAwardsExecute(r)
}

/*
DeleteMembershipAwards Delete Membership Awards

You can use this API to delete Membership Awards. <p><strong>OperationId:</strong>deleteMembershipAwards</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipAwardsId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiDeleteMembershipAwardsRequest
*/
func (a *MembershipConfigApiService) DeleteMembershipAwards(ctx context.Context, membershipAwardsId string) MembershipConfigApiDeleteMembershipAwardsRequest {
	return MembershipConfigApiDeleteMembershipAwardsRequest{
		ApiService: a,
		ctx: ctx,
		membershipAwardsId: membershipAwardsId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) DeleteMembershipAwardsExecute(r MembershipConfigApiDeleteMembershipAwardsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.DeleteMembershipAwards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipAwards/{membershipAwardsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipAwardsId"+"}", url.PathEscape(parameterValueToString(r.membershipAwardsId, "membershipAwardsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipAwardsId) < 1 {
		return localVarReturnValue, nil, reportError("membershipAwardsId must have at least 1 elements")
	}
	if strlen(r.membershipAwardsId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipAwardsId must have less than 2000 elements")
	}

	if r.membershipType != nil {
		t := *r.membershipType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiDeleteMembershipBenefitProgramsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipBenefitProgramsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiDeleteMembershipBenefitProgramsRequest) Authorization(authorization string) MembershipConfigApiDeleteMembershipBenefitProgramsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiDeleteMembershipBenefitProgramsRequest) XAppKey(xAppKey string) MembershipConfigApiDeleteMembershipBenefitProgramsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiDeleteMembershipBenefitProgramsRequest) XHotelid(xHotelid string) MembershipConfigApiDeleteMembershipBenefitProgramsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Membership type
func (r MembershipConfigApiDeleteMembershipBenefitProgramsRequest) MembershipType(membershipType []string) MembershipConfigApiDeleteMembershipBenefitProgramsRequest {
	r.membershipType = &membershipType
	return r
}

// External system code.
func (r MembershipConfigApiDeleteMembershipBenefitProgramsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiDeleteMembershipBenefitProgramsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiDeleteMembershipBenefitProgramsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiDeleteMembershipBenefitProgramsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiDeleteMembershipBenefitProgramsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMembershipBenefitProgramsExecute(r)
}

/*
DeleteMembershipBenefitPrograms Delete Membership Benedict Program

This API will allow you to delete s Membership Benefit Programs of a Membership Type.  <p><strong>OperationId:</strong>deleteMembershipBenefitPrograms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipBenefitProgramsId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiDeleteMembershipBenefitProgramsRequest
*/
func (a *MembershipConfigApiService) DeleteMembershipBenefitPrograms(ctx context.Context, membershipBenefitProgramsId string) MembershipConfigApiDeleteMembershipBenefitProgramsRequest {
	return MembershipConfigApiDeleteMembershipBenefitProgramsRequest{
		ApiService: a,
		ctx: ctx,
		membershipBenefitProgramsId: membershipBenefitProgramsId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) DeleteMembershipBenefitProgramsExecute(r MembershipConfigApiDeleteMembershipBenefitProgramsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.DeleteMembershipBenefitPrograms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipBenefitPrograms/{membershipBenefitProgramsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipBenefitProgramsId"+"}", url.PathEscape(parameterValueToString(r.membershipBenefitProgramsId, "membershipBenefitProgramsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipBenefitProgramsId) < 1 {
		return localVarReturnValue, nil, reportError("membershipBenefitProgramsId must have at least 1 elements")
	}
	if strlen(r.membershipBenefitProgramsId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipBenefitProgramsId must have less than 2000 elements")
	}

	if r.membershipType != nil {
		t := *r.membershipType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiDeleteMembershipClassesRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipClassId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiDeleteMembershipClassesRequest) Authorization(authorization string) MembershipConfigApiDeleteMembershipClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiDeleteMembershipClassesRequest) XAppKey(xAppKey string) MembershipConfigApiDeleteMembershipClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiDeleteMembershipClassesRequest) XHotelid(xHotelid string) MembershipConfigApiDeleteMembershipClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r MembershipConfigApiDeleteMembershipClassesRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiDeleteMembershipClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiDeleteMembershipClassesRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiDeleteMembershipClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiDeleteMembershipClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMembershipClassesExecute(r)
}

/*
DeleteMembershipClasses Delete Membership classes

Delete an existing membership class. <p><strong>OperationId:</strong>deleteMembershipClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipClassId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiDeleteMembershipClassesRequest
*/
func (a *MembershipConfigApiService) DeleteMembershipClasses(ctx context.Context, membershipClassId string) MembershipConfigApiDeleteMembershipClassesRequest {
	return MembershipConfigApiDeleteMembershipClassesRequest{
		ApiService: a,
		ctx: ctx,
		membershipClassId: membershipClassId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) DeleteMembershipClassesExecute(r MembershipConfigApiDeleteMembershipClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.DeleteMembershipClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipClasses/{membershipClassId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipClassId"+"}", url.PathEscape(parameterValueToString(r.membershipClassId, "membershipClassId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipClassId) < 1 {
		return localVarReturnValue, nil, reportError("membershipClassId must have at least 1 elements")
	}
	if strlen(r.membershipClassId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipClassId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipEnrollmentGroupsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest) Authorization(authorization string) MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMembershipEnrollmentGroupsExecute(r)
}

/*
DeleteMembershipEnrollmentGroups Remove Membership enrollment groups

delete an existing membership group. <p><strong>OperationId:</strong>deleteMembershipEnrollmentGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipEnrollmentGroupsId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest
*/
func (a *MembershipConfigApiService) DeleteMembershipEnrollmentGroups(ctx context.Context, membershipEnrollmentGroupsId string) MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest {
	return MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest{
		ApiService: a,
		ctx: ctx,
		membershipEnrollmentGroupsId: membershipEnrollmentGroupsId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) DeleteMembershipEnrollmentGroupsExecute(r MembershipConfigApiDeleteMembershipEnrollmentGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.DeleteMembershipEnrollmentGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipEnrollmentGroups/{membershipEnrollmentGroupsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipEnrollmentGroupsId"+"}", url.PathEscape(parameterValueToString(r.membershipEnrollmentGroupsId, "membershipEnrollmentGroupsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipEnrollmentGroupsId) < 1 {
		return localVarReturnValue, nil, reportError("membershipEnrollmentGroupsId must have at least 1 elements")
	}
	if strlen(r.membershipEnrollmentGroupsId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipEnrollmentGroupsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiDeleteMembershipLevelsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipLevelsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	type_ *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiDeleteMembershipLevelsRequest) Authorization(authorization string) MembershipConfigApiDeleteMembershipLevelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiDeleteMembershipLevelsRequest) XAppKey(xAppKey string) MembershipConfigApiDeleteMembershipLevelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiDeleteMembershipLevelsRequest) XHotelid(xHotelid string) MembershipConfigApiDeleteMembershipLevelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Membership type
func (r MembershipConfigApiDeleteMembershipLevelsRequest) Type_(type_ []string) MembershipConfigApiDeleteMembershipLevelsRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r MembershipConfigApiDeleteMembershipLevelsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiDeleteMembershipLevelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiDeleteMembershipLevelsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiDeleteMembershipLevelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiDeleteMembershipLevelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMembershipLevelsExecute(r)
}

/*
DeleteMembershipLevels Delete Membership levels

You can use this API to delete Membership levels. <p><strong>OperationId:</strong>deleteMembershipLevels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipLevelsId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiDeleteMembershipLevelsRequest
*/
func (a *MembershipConfigApiService) DeleteMembershipLevels(ctx context.Context, membershipLevelsId string) MembershipConfigApiDeleteMembershipLevelsRequest {
	return MembershipConfigApiDeleteMembershipLevelsRequest{
		ApiService: a,
		ctx: ctx,
		membershipLevelsId: membershipLevelsId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) DeleteMembershipLevelsExecute(r MembershipConfigApiDeleteMembershipLevelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.DeleteMembershipLevels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipLevels/{membershipLevelsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipLevelsId"+"}", url.PathEscape(parameterValueToString(r.membershipLevelsId, "membershipLevelsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipLevelsId) < 1 {
		return localVarReturnValue, nil, reportError("membershipLevelsId must have at least 1 elements")
	}
	if strlen(r.membershipLevelsId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipLevelsId must have less than 2000 elements")
	}

	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiDeleteMembershipMarketGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipMarketGroupId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiDeleteMembershipMarketGroupsRequest) Authorization(authorization string) MembershipConfigApiDeleteMembershipMarketGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiDeleteMembershipMarketGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiDeleteMembershipMarketGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiDeleteMembershipMarketGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiDeleteMembershipMarketGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r MembershipConfigApiDeleteMembershipMarketGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiDeleteMembershipMarketGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiDeleteMembershipMarketGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiDeleteMembershipMarketGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiDeleteMembershipMarketGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMembershipMarketGroupsExecute(r)
}

/*
DeleteMembershipMarketGroups Delete Membership market groups

You can use this API to delete Membership market groups. <p><strong>OperationId:</strong>deleteMembershipMarketGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipMarketGroupId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiDeleteMembershipMarketGroupsRequest
*/
func (a *MembershipConfigApiService) DeleteMembershipMarketGroups(ctx context.Context, membershipMarketGroupId string) MembershipConfigApiDeleteMembershipMarketGroupsRequest {
	return MembershipConfigApiDeleteMembershipMarketGroupsRequest{
		ApiService: a,
		ctx: ctx,
		membershipMarketGroupId: membershipMarketGroupId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) DeleteMembershipMarketGroupsExecute(r MembershipConfigApiDeleteMembershipMarketGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.DeleteMembershipMarketGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipMarketGroups/{membershipMarketGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipMarketGroupId"+"}", url.PathEscape(parameterValueToString(r.membershipMarketGroupId, "membershipMarketGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipMarketGroupId) < 1 {
		return localVarReturnValue, nil, reportError("membershipMarketGroupId must have at least 1 elements")
	}
	if strlen(r.membershipMarketGroupId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipMarketGroupId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiDeleteMembershipPropertyGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipPropertyGroupsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiDeleteMembershipPropertyGroupsRequest) Authorization(authorization string) MembershipConfigApiDeleteMembershipPropertyGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiDeleteMembershipPropertyGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiDeleteMembershipPropertyGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiDeleteMembershipPropertyGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiDeleteMembershipPropertyGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r MembershipConfigApiDeleteMembershipPropertyGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiDeleteMembershipPropertyGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiDeleteMembershipPropertyGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiDeleteMembershipPropertyGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiDeleteMembershipPropertyGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMembershipPropertyGroupsExecute(r)
}

/*
DeleteMembershipPropertyGroups Delete Membership property groups

You can use this API to delete Membership property groups. <p><strong>OperationId:</strong>deleteMembershipPropertyGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipPropertyGroupsId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiDeleteMembershipPropertyGroupsRequest
*/
func (a *MembershipConfigApiService) DeleteMembershipPropertyGroups(ctx context.Context, membershipPropertyGroupsId string) MembershipConfigApiDeleteMembershipPropertyGroupsRequest {
	return MembershipConfigApiDeleteMembershipPropertyGroupsRequest{
		ApiService: a,
		ctx: ctx,
		membershipPropertyGroupsId: membershipPropertyGroupsId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) DeleteMembershipPropertyGroupsExecute(r MembershipConfigApiDeleteMembershipPropertyGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.DeleteMembershipPropertyGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipPropertyGroups/{membershipPropertyGroupsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipPropertyGroupsId"+"}", url.PathEscape(parameterValueToString(r.membershipPropertyGroupsId, "membershipPropertyGroupsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipPropertyGroupsId) < 1 {
		return localVarReturnValue, nil, reportError("membershipPropertyGroupsId must have at least 1 elements")
	}
	if strlen(r.membershipPropertyGroupsId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipPropertyGroupsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiDeleteMembershipRateGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipRateGroupId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiDeleteMembershipRateGroupsRequest) Authorization(authorization string) MembershipConfigApiDeleteMembershipRateGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiDeleteMembershipRateGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiDeleteMembershipRateGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiDeleteMembershipRateGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiDeleteMembershipRateGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r MembershipConfigApiDeleteMembershipRateGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiDeleteMembershipRateGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiDeleteMembershipRateGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiDeleteMembershipRateGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiDeleteMembershipRateGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMembershipRateGroupsExecute(r)
}

/*
DeleteMembershipRateGroups Delete Membership rate groups

You can use this API to delete Membership rate groups. <p><strong>OperationId:</strong>deleteMembershipRateGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipRateGroupId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiDeleteMembershipRateGroupsRequest
*/
func (a *MembershipConfigApiService) DeleteMembershipRateGroups(ctx context.Context, membershipRateGroupId string) MembershipConfigApiDeleteMembershipRateGroupsRequest {
	return MembershipConfigApiDeleteMembershipRateGroupsRequest{
		ApiService: a,
		ctx: ctx,
		membershipRateGroupId: membershipRateGroupId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) DeleteMembershipRateGroupsExecute(r MembershipConfigApiDeleteMembershipRateGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.DeleteMembershipRateGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipRateGroups/{membershipRateGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipRateGroupId"+"}", url.PathEscape(parameterValueToString(r.membershipRateGroupId, "membershipRateGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipRateGroupId) < 1 {
		return localVarReturnValue, nil, reportError("membershipRateGroupId must have at least 1 elements")
	}
	if strlen(r.membershipRateGroupId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipRateGroupId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiDeleteMembershipTypeRulesRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipTypeRulesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipPointsSequence *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiDeleteMembershipTypeRulesRequest) Authorization(authorization string) MembershipConfigApiDeleteMembershipTypeRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiDeleteMembershipTypeRulesRequest) XAppKey(xAppKey string) MembershipConfigApiDeleteMembershipTypeRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiDeleteMembershipTypeRulesRequest) XHotelid(xHotelid string) MembershipConfigApiDeleteMembershipTypeRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Sequence number of the membership type rule.
func (r MembershipConfigApiDeleteMembershipTypeRulesRequest) MembershipPointsSequence(membershipPointsSequence []int32) MembershipConfigApiDeleteMembershipTypeRulesRequest {
	r.membershipPointsSequence = &membershipPointsSequence
	return r
}

// External system code.
func (r MembershipConfigApiDeleteMembershipTypeRulesRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiDeleteMembershipTypeRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiDeleteMembershipTypeRulesRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiDeleteMembershipTypeRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiDeleteMembershipTypeRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMembershipTypeRulesExecute(r)
}

/*
DeleteMembershipTypeRules Delete Membership type rules

You can use this API to delete Membership type rules. <p><strong>OperationId:</strong>deleteMembershipTypeRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipTypeRulesId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiDeleteMembershipTypeRulesRequest
*/
func (a *MembershipConfigApiService) DeleteMembershipTypeRules(ctx context.Context, membershipTypeRulesId string) MembershipConfigApiDeleteMembershipTypeRulesRequest {
	return MembershipConfigApiDeleteMembershipTypeRulesRequest{
		ApiService: a,
		ctx: ctx,
		membershipTypeRulesId: membershipTypeRulesId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) DeleteMembershipTypeRulesExecute(r MembershipConfigApiDeleteMembershipTypeRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.DeleteMembershipTypeRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipTypeRules/{membershipTypeRulesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipTypeRulesId"+"}", url.PathEscape(parameterValueToString(r.membershipTypeRulesId, "membershipTypeRulesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipTypeRulesId) < 1 {
		return localVarReturnValue, nil, reportError("membershipTypeRulesId must have at least 1 elements")
	}
	if strlen(r.membershipTypeRulesId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipTypeRulesId must have less than 2000 elements")
	}

	if r.membershipPointsSequence != nil {
		t := *r.membershipPointsSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipPointsSequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipPointsSequence", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiDeleteMembershipTypesRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipTypeId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiDeleteMembershipTypesRequest) Authorization(authorization string) MembershipConfigApiDeleteMembershipTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiDeleteMembershipTypesRequest) XAppKey(xAppKey string) MembershipConfigApiDeleteMembershipTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiDeleteMembershipTypesRequest) XHotelid(xHotelid string) MembershipConfigApiDeleteMembershipTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r MembershipConfigApiDeleteMembershipTypesRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiDeleteMembershipTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiDeleteMembershipTypesRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiDeleteMembershipTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiDeleteMembershipTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMembershipTypesExecute(r)
}

/*
DeleteMembershipTypes Delete Membership type

Use this API to delete an existing Membership Type <p><strong>OperationId:</strong>deleteMembershipTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipTypeId Fetch membershipTypes values based on given membershipTypeId
 @return MembershipConfigApiDeleteMembershipTypesRequest
*/
func (a *MembershipConfigApiService) DeleteMembershipTypes(ctx context.Context, membershipTypeId string) MembershipConfigApiDeleteMembershipTypesRequest {
	return MembershipConfigApiDeleteMembershipTypesRequest{
		ApiService: a,
		ctx: ctx,
		membershipTypeId: membershipTypeId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) DeleteMembershipTypesExecute(r MembershipConfigApiDeleteMembershipTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.DeleteMembershipTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipTypes/{membershipTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipTypeId"+"}", url.PathEscape(parameterValueToString(r.membershipTypeId, "membershipTypeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipTypeId) < 1 {
		return localVarReturnValue, nil, reportError("membershipTypeId must have at least 1 elements")
	}
	if strlen(r.membershipTypeId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipTypeId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiGetMembershipAwardsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipType *string
	awardCodes *[]string
	wildCard *string
	description *string
	validForDate *string
	includeInactive *bool
	includeDetails *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiGetMembershipAwardsRequest) Authorization(authorization string) MembershipConfigApiGetMembershipAwardsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiGetMembershipAwardsRequest) XAppKey(xAppKey string) MembershipConfigApiGetMembershipAwardsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiGetMembershipAwardsRequest) XHotelid(xHotelid string) MembershipConfigApiGetMembershipAwardsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Membership type for which awards are defined.
func (r MembershipConfigApiGetMembershipAwardsRequest) MembershipType(membershipType string) MembershipConfigApiGetMembershipAwardsRequest {
	r.membershipType = &membershipType
	return r
}

// Codes to be searched.
func (r MembershipConfigApiGetMembershipAwardsRequest) AwardCodes(awardCodes []string) MembershipConfigApiGetMembershipAwardsRequest {
	r.awardCodes = &awardCodes
	return r
}

// Wildcard search on the code.
func (r MembershipConfigApiGetMembershipAwardsRequest) WildCard(wildCard string) MembershipConfigApiGetMembershipAwardsRequest {
	r.wildCard = &wildCard
	return r
}

// Description for the membership award.
func (r MembershipConfigApiGetMembershipAwardsRequest) Description(description string) MembershipConfigApiGetMembershipAwardsRequest {
	r.description = &description
	return r
}

// Date when membership award is valid.
func (r MembershipConfigApiGetMembershipAwardsRequest) ValidForDate(validForDate string) MembershipConfigApiGetMembershipAwardsRequest {
	r.validForDate = &validForDate
	return r
}

// Flag to decide whether or not to include inactive records in search result set.
func (r MembershipConfigApiGetMembershipAwardsRequest) IncludeInactive(includeInactive bool) MembershipConfigApiGetMembershipAwardsRequest {
	r.includeInactive = &includeInactive
	return r
}

// Fetch operation will return only Membership Award records by default. If Include Details is true, then it will return associated child records like Membership Award Rate/Product/Upgrade/FT as well.
func (r MembershipConfigApiGetMembershipAwardsRequest) IncludeDetails(includeDetails bool) MembershipConfigApiGetMembershipAwardsRequest {
	r.includeDetails = &includeDetails
	return r
}

// External system code.
func (r MembershipConfigApiGetMembershipAwardsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiGetMembershipAwardsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiGetMembershipAwardsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiGetMembershipAwardsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiGetMembershipAwardsRequest) Execute() (*MembershipAwardsInfo, *http.Response, error) {
	return r.ApiService.GetMembershipAwardsExecute(r)
}

/*
GetMembershipAwards Get Membership Awards

You can use this API to get Membership Awards. <p><strong>OperationId:</strong>getMembershipAwards</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiGetMembershipAwardsRequest
*/
func (a *MembershipConfigApiService) GetMembershipAwards(ctx context.Context) MembershipConfigApiGetMembershipAwardsRequest {
	return MembershipConfigApiGetMembershipAwardsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MembershipAwardsInfo
func (a *MembershipConfigApiService) GetMembershipAwardsExecute(r MembershipConfigApiGetMembershipAwardsRequest) (*MembershipAwardsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipAwardsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.GetMembershipAwards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipAwards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
	}
	if r.awardCodes != nil {
		t := *r.awardCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "awardCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "awardCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.validForDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validForDate", r.validForDate, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.includeDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDetails", r.includeDetails, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiGetMembershipBenefitProgramsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipType *string
	code *string
	end *string
	start *string
	minimumLevel *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiGetMembershipBenefitProgramsRequest) Authorization(authorization string) MembershipConfigApiGetMembershipBenefitProgramsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiGetMembershipBenefitProgramsRequest) XAppKey(xAppKey string) MembershipConfigApiGetMembershipBenefitProgramsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiGetMembershipBenefitProgramsRequest) XHotelid(xHotelid string) MembershipConfigApiGetMembershipBenefitProgramsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Membership type
func (r MembershipConfigApiGetMembershipBenefitProgramsRequest) MembershipType(membershipType string) MembershipConfigApiGetMembershipBenefitProgramsRequest {
	r.membershipType = &membershipType
	return r
}

// Benefit Code
func (r MembershipConfigApiGetMembershipBenefitProgramsRequest) Code(code string) MembershipConfigApiGetMembershipBenefitProgramsRequest {
	r.code = &code
	return r
}

// The ending value of the date range.
func (r MembershipConfigApiGetMembershipBenefitProgramsRequest) End(end string) MembershipConfigApiGetMembershipBenefitProgramsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r MembershipConfigApiGetMembershipBenefitProgramsRequest) Start(start string) MembershipConfigApiGetMembershipBenefitProgramsRequest {
	r.start = &start
	return r
}

// Min value for membership level. This is the minimum membership level member gets for enrolling into this program.
func (r MembershipConfigApiGetMembershipBenefitProgramsRequest) MinimumLevel(minimumLevel string) MembershipConfigApiGetMembershipBenefitProgramsRequest {
	r.minimumLevel = &minimumLevel
	return r
}

// Flag to decide whether or not to include inactive records in search result set.
func (r MembershipConfigApiGetMembershipBenefitProgramsRequest) IncludeInactive(includeInactive bool) MembershipConfigApiGetMembershipBenefitProgramsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r MembershipConfigApiGetMembershipBenefitProgramsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiGetMembershipBenefitProgramsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiGetMembershipBenefitProgramsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiGetMembershipBenefitProgramsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiGetMembershipBenefitProgramsRequest) Execute() (*MembershipBenefitProgramsInfo, *http.Response, error) {
	return r.ApiService.GetMembershipBenefitProgramsExecute(r)
}

/*
GetMembershipBenefitPrograms Retrieve a Membership Benefit Program

This API allows you to fetch Membership Benefit Programs of Membership Type. A Benefit Program is configurable for a Membership Type when OCIS or ORS license is active and Membership Type meets following criteria - primary central setup, not externally controlled and point calculation method is Manual Batch. <p><strong>OperationId:</strong>getMembershipBenefitPrograms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiGetMembershipBenefitProgramsRequest
*/
func (a *MembershipConfigApiService) GetMembershipBenefitPrograms(ctx context.Context) MembershipConfigApiGetMembershipBenefitProgramsRequest {
	return MembershipConfigApiGetMembershipBenefitProgramsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MembershipBenefitProgramsInfo
func (a *MembershipConfigApiService) GetMembershipBenefitProgramsExecute(r MembershipConfigApiGetMembershipBenefitProgramsRequest) (*MembershipBenefitProgramsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipBenefitProgramsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.GetMembershipBenefitPrograms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipBenefitPrograms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.minimumLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minimumLevel", r.minimumLevel, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiGetMembershipClassesRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiGetMembershipClassesRequest) Authorization(authorization string) MembershipConfigApiGetMembershipClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiGetMembershipClassesRequest) XAppKey(xAppKey string) MembershipConfigApiGetMembershipClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiGetMembershipClassesRequest) XHotelid(xHotelid string) MembershipConfigApiGetMembershipClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r MembershipConfigApiGetMembershipClassesRequest) FetchInactive(fetchInactive bool) MembershipConfigApiGetMembershipClassesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r MembershipConfigApiGetMembershipClassesRequest) Codes(codes []string) MembershipConfigApiGetMembershipClassesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r MembershipConfigApiGetMembershipClassesRequest) WildCard(wildCard string) MembershipConfigApiGetMembershipClassesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r MembershipConfigApiGetMembershipClassesRequest) Description(description string) MembershipConfigApiGetMembershipClassesRequest {
	r.description = &description
	return r
}

// External system code.
func (r MembershipConfigApiGetMembershipClassesRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiGetMembershipClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiGetMembershipClassesRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiGetMembershipClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiGetMembershipClassesRequest) Execute() (*MembershipClassesInfo, *http.Response, error) {
	return r.ApiService.GetMembershipClassesExecute(r)
}

/*
GetMembershipClasses Get Membership classes

Retrieve a list of membership classes that are configured. <p><strong>OperationId:</strong>getMembershipClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiGetMembershipClassesRequest
*/
func (a *MembershipConfigApiService) GetMembershipClasses(ctx context.Context) MembershipConfigApiGetMembershipClassesRequest {
	return MembershipConfigApiGetMembershipClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MembershipClassesInfo
func (a *MembershipConfigApiService) GetMembershipClassesExecute(r MembershipConfigApiGetMembershipClassesRequest) (*MembershipClassesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipClassesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.GetMembershipClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipClasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiGetMembershipEnrollmentGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	enrollmentCodes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiGetMembershipEnrollmentGroupsRequest) Authorization(authorization string) MembershipConfigApiGetMembershipEnrollmentGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiGetMembershipEnrollmentGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiGetMembershipEnrollmentGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiGetMembershipEnrollmentGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiGetMembershipEnrollmentGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r MembershipConfigApiGetMembershipEnrollmentGroupsRequest) Limit(limit int32) MembershipConfigApiGetMembershipEnrollmentGroupsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r MembershipConfigApiGetMembershipEnrollmentGroupsRequest) Offset(offset int32) MembershipConfigApiGetMembershipEnrollmentGroupsRequest {
	r.offset = &offset
	return r
}

// Codes to be searched.
func (r MembershipConfigApiGetMembershipEnrollmentGroupsRequest) EnrollmentCodes(enrollmentCodes []string) MembershipConfigApiGetMembershipEnrollmentGroupsRequest {
	r.enrollmentCodes = &enrollmentCodes
	return r
}

// Wildcard search on the code.
func (r MembershipConfigApiGetMembershipEnrollmentGroupsRequest) WildCard(wildCard string) MembershipConfigApiGetMembershipEnrollmentGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the enrollment group to be fetched.
func (r MembershipConfigApiGetMembershipEnrollmentGroupsRequest) Description(description string) MembershipConfigApiGetMembershipEnrollmentGroupsRequest {
	r.description = &description
	return r
}

// External system code.
func (r MembershipConfigApiGetMembershipEnrollmentGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiGetMembershipEnrollmentGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiGetMembershipEnrollmentGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiGetMembershipEnrollmentGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiGetMembershipEnrollmentGroupsRequest) Execute() (*MembershipEnrollmentGroupsInfo, *http.Response, error) {
	return r.ApiService.GetMembershipEnrollmentGroupsExecute(r)
}

/*
GetMembershipEnrollmentGroups Get Membership enrollment groups

Retrieve a list of membership Enrollment Groups that are configured. <p><strong>OperationId:</strong>getMembershipEnrollmentGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiGetMembershipEnrollmentGroupsRequest
*/
func (a *MembershipConfigApiService) GetMembershipEnrollmentGroups(ctx context.Context) MembershipConfigApiGetMembershipEnrollmentGroupsRequest {
	return MembershipConfigApiGetMembershipEnrollmentGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MembershipEnrollmentGroupsInfo
func (a *MembershipConfigApiService) GetMembershipEnrollmentGroupsExecute(r MembershipConfigApiGetMembershipEnrollmentGroupsRequest) (*MembershipEnrollmentGroupsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipEnrollmentGroupsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.GetMembershipEnrollmentGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipEnrollmentGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.enrollmentCodes != nil {
		t := *r.enrollmentCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enrollmentCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enrollmentCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiGetMembershipLevelsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipTypeCode *string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	includeFolioTexts *bool
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Type of membership that the levels belong to.
func (r MembershipConfigApiGetMembershipLevelsRequest) MembershipTypeCode(membershipTypeCode string) MembershipConfigApiGetMembershipLevelsRequest {
	r.membershipTypeCode = &membershipTypeCode
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiGetMembershipLevelsRequest) Authorization(authorization string) MembershipConfigApiGetMembershipLevelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiGetMembershipLevelsRequest) XAppKey(xAppKey string) MembershipConfigApiGetMembershipLevelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiGetMembershipLevelsRequest) XHotelid(xHotelid string) MembershipConfigApiGetMembershipLevelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Inactive flag - whether or not to display inactive records.
func (r MembershipConfigApiGetMembershipLevelsRequest) IncludeInactive(includeInactive bool) MembershipConfigApiGetMembershipLevelsRequest {
	r.includeInactive = &includeInactive
	return r
}

// Boolean flag to fetch membership type levels with/without folio text. &#39;True&#39; indicates including folio texts for corresponding membership type level.
func (r MembershipConfigApiGetMembershipLevelsRequest) IncludeFolioTexts(includeFolioTexts bool) MembershipConfigApiGetMembershipLevelsRequest {
	r.includeFolioTexts = &includeFolioTexts
	return r
}

func (r MembershipConfigApiGetMembershipLevelsRequest) HotelIds(hotelIds []string) MembershipConfigApiGetMembershipLevelsRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r MembershipConfigApiGetMembershipLevelsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiGetMembershipLevelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiGetMembershipLevelsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiGetMembershipLevelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiGetMembershipLevelsRequest) Execute() (*MembershipLevelsInfo, *http.Response, error) {
	return r.ApiService.GetMembershipLevelsExecute(r)
}

/*
GetMembershipLevels Get Membership levels

You can use this API to get Membership levels. <p><strong>OperationId:</strong>getMembershipLevels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiGetMembershipLevelsRequest
*/
func (a *MembershipConfigApiService) GetMembershipLevels(ctx context.Context) MembershipConfigApiGetMembershipLevelsRequest {
	return MembershipConfigApiGetMembershipLevelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MembershipLevelsInfo
func (a *MembershipConfigApiService) GetMembershipLevelsExecute(r MembershipConfigApiGetMembershipLevelsRequest) (*MembershipLevelsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipLevelsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.GetMembershipLevels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipLevels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypeCode", r.membershipTypeCode, "")
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.includeFolioTexts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFolioTexts", r.includeFolioTexts, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiGetMembershipMarketGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiGetMembershipMarketGroupsRequest) Authorization(authorization string) MembershipConfigApiGetMembershipMarketGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiGetMembershipMarketGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiGetMembershipMarketGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiGetMembershipMarketGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiGetMembershipMarketGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r MembershipConfigApiGetMembershipMarketGroupsRequest) FetchInactive(fetchInactive bool) MembershipConfigApiGetMembershipMarketGroupsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r MembershipConfigApiGetMembershipMarketGroupsRequest) Codes(codes []string) MembershipConfigApiGetMembershipMarketGroupsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r MembershipConfigApiGetMembershipMarketGroupsRequest) WildCard(wildCard string) MembershipConfigApiGetMembershipMarketGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r MembershipConfigApiGetMembershipMarketGroupsRequest) Description(description string) MembershipConfigApiGetMembershipMarketGroupsRequest {
	r.description = &description
	return r
}

// External system code.
func (r MembershipConfigApiGetMembershipMarketGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiGetMembershipMarketGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiGetMembershipMarketGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiGetMembershipMarketGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiGetMembershipMarketGroupsRequest) Execute() (*MembershipMarketGroupsInfo, *http.Response, error) {
	return r.ApiService.GetMembershipMarketGroupsExecute(r)
}

/*
GetMembershipMarketGroups Get Membership market groups

You can use this API to get Membership market groups. <p><strong>OperationId:</strong>getMembershipMarketGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiGetMembershipMarketGroupsRequest
*/
func (a *MembershipConfigApiService) GetMembershipMarketGroups(ctx context.Context) MembershipConfigApiGetMembershipMarketGroupsRequest {
	return MembershipConfigApiGetMembershipMarketGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MembershipMarketGroupsInfo
func (a *MembershipConfigApiService) GetMembershipMarketGroupsExecute(r MembershipConfigApiGetMembershipMarketGroupsRequest) (*MembershipMarketGroupsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipMarketGroupsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.GetMembershipMarketGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipMarketGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiGetMembershipPropertyGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiGetMembershipPropertyGroupsRequest) Authorization(authorization string) MembershipConfigApiGetMembershipPropertyGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiGetMembershipPropertyGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiGetMembershipPropertyGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiGetMembershipPropertyGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiGetMembershipPropertyGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r MembershipConfigApiGetMembershipPropertyGroupsRequest) FetchInactive(fetchInactive bool) MembershipConfigApiGetMembershipPropertyGroupsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r MembershipConfigApiGetMembershipPropertyGroupsRequest) Codes(codes []string) MembershipConfigApiGetMembershipPropertyGroupsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r MembershipConfigApiGetMembershipPropertyGroupsRequest) WildCard(wildCard string) MembershipConfigApiGetMembershipPropertyGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r MembershipConfigApiGetMembershipPropertyGroupsRequest) Description(description string) MembershipConfigApiGetMembershipPropertyGroupsRequest {
	r.description = &description
	return r
}

// External system code.
func (r MembershipConfigApiGetMembershipPropertyGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiGetMembershipPropertyGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiGetMembershipPropertyGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiGetMembershipPropertyGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiGetMembershipPropertyGroupsRequest) Execute() (*MembershipPropertyGroupsInfo, *http.Response, error) {
	return r.ApiService.GetMembershipPropertyGroupsExecute(r)
}

/*
GetMembershipPropertyGroups Get Membership property groups

You can use this API to get Membership property groups. <p><strong>OperationId:</strong>getMembershipPropertyGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiGetMembershipPropertyGroupsRequest
*/
func (a *MembershipConfigApiService) GetMembershipPropertyGroups(ctx context.Context) MembershipConfigApiGetMembershipPropertyGroupsRequest {
	return MembershipConfigApiGetMembershipPropertyGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MembershipPropertyGroupsInfo
func (a *MembershipConfigApiService) GetMembershipPropertyGroupsExecute(r MembershipConfigApiGetMembershipPropertyGroupsRequest) (*MembershipPropertyGroupsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipPropertyGroupsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.GetMembershipPropertyGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipPropertyGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiGetMembershipRateGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiGetMembershipRateGroupsRequest) Authorization(authorization string) MembershipConfigApiGetMembershipRateGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiGetMembershipRateGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiGetMembershipRateGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiGetMembershipRateGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiGetMembershipRateGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r MembershipConfigApiGetMembershipRateGroupsRequest) FetchInactive(fetchInactive bool) MembershipConfigApiGetMembershipRateGroupsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r MembershipConfigApiGetMembershipRateGroupsRequest) Codes(codes []string) MembershipConfigApiGetMembershipRateGroupsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r MembershipConfigApiGetMembershipRateGroupsRequest) WildCard(wildCard string) MembershipConfigApiGetMembershipRateGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r MembershipConfigApiGetMembershipRateGroupsRequest) Description(description string) MembershipConfigApiGetMembershipRateGroupsRequest {
	r.description = &description
	return r
}

// External system code.
func (r MembershipConfigApiGetMembershipRateGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiGetMembershipRateGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiGetMembershipRateGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiGetMembershipRateGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiGetMembershipRateGroupsRequest) Execute() (*MembershipRateGroupsInfo, *http.Response, error) {
	return r.ApiService.GetMembershipRateGroupsExecute(r)
}

/*
GetMembershipRateGroups Get Membership rate groups

You can use this API to get Membership rate groups. <p><strong>OperationId:</strong>getMembershipRateGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiGetMembershipRateGroupsRequest
*/
func (a *MembershipConfigApiService) GetMembershipRateGroups(ctx context.Context) MembershipConfigApiGetMembershipRateGroupsRequest {
	return MembershipConfigApiGetMembershipRateGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MembershipRateGroupsInfo
func (a *MembershipConfigApiService) GetMembershipRateGroupsExecute(r MembershipConfigApiGetMembershipRateGroupsRequest) (*MembershipRateGroupsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipRateGroupsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.GetMembershipRateGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipRateGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiGetMembershipTypeRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipTypeId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipTypeCode *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiGetMembershipTypeRequest) Authorization(authorization string) MembershipConfigApiGetMembershipTypeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiGetMembershipTypeRequest) XAppKey(xAppKey string) MembershipConfigApiGetMembershipTypeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiGetMembershipTypeRequest) XHotelid(xHotelid string) MembershipConfigApiGetMembershipTypeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Membership type code.
func (r MembershipConfigApiGetMembershipTypeRequest) MembershipTypeCode(membershipTypeCode string) MembershipConfigApiGetMembershipTypeRequest {
	r.membershipTypeCode = &membershipTypeCode
	return r
}

// Membership levels.
func (r MembershipConfigApiGetMembershipTypeRequest) FetchInstructions(fetchInstructions []string) MembershipConfigApiGetMembershipTypeRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r MembershipConfigApiGetMembershipTypeRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiGetMembershipTypeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiGetMembershipTypeRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiGetMembershipTypeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiGetMembershipTypeRequest) Execute() (*MembershipTypesDetails, *http.Response, error) {
	return r.ApiService.GetMembershipTypeExecute(r)
}

/*
GetMembershipType Get a Membership type

Use this API to get a specific Membership Type and its details. <p><strong>OperationId:</strong>getMembershipType</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipTypeId Fetch membershipTypes values based on given membershipTypeId
 @return MembershipConfigApiGetMembershipTypeRequest
*/
func (a *MembershipConfigApiService) GetMembershipType(ctx context.Context, membershipTypeId string) MembershipConfigApiGetMembershipTypeRequest {
	return MembershipConfigApiGetMembershipTypeRequest{
		ApiService: a,
		ctx: ctx,
		membershipTypeId: membershipTypeId,
	}
}

// Execute executes the request
//  @return MembershipTypesDetails
func (a *MembershipConfigApiService) GetMembershipTypeExecute(r MembershipConfigApiGetMembershipTypeRequest) (*MembershipTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.GetMembershipType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipTypes/{membershipTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipTypeId"+"}", url.PathEscape(parameterValueToString(r.membershipTypeId, "membershipTypeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipTypeId) < 1 {
		return localVarReturnValue, nil, reportError("membershipTypeId must have at least 1 elements")
	}
	if strlen(r.membershipTypeId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipTypeId must have less than 2000 elements")
	}

	if r.membershipTypeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypeCode", r.membershipTypeCode, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiGetMembershipTypeRuleRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipTypeRulesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipType *string
	membershipPointsSequence *int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiGetMembershipTypeRuleRequest) Authorization(authorization string) MembershipConfigApiGetMembershipTypeRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiGetMembershipTypeRuleRequest) XAppKey(xAppKey string) MembershipConfigApiGetMembershipTypeRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiGetMembershipTypeRuleRequest) XHotelid(xHotelid string) MembershipConfigApiGetMembershipTypeRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Membership type of the Rule.
func (r MembershipConfigApiGetMembershipTypeRuleRequest) MembershipType(membershipType string) MembershipConfigApiGetMembershipTypeRuleRequest {
	r.membershipType = &membershipType
	return r
}

// Sequence number of the membership type rule.
func (r MembershipConfigApiGetMembershipTypeRuleRequest) MembershipPointsSequence(membershipPointsSequence int32) MembershipConfigApiGetMembershipTypeRuleRequest {
	r.membershipPointsSequence = &membershipPointsSequence
	return r
}

// To include type rule filters information.
func (r MembershipConfigApiGetMembershipTypeRuleRequest) FetchInstructions(fetchInstructions []string) MembershipConfigApiGetMembershipTypeRuleRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r MembershipConfigApiGetMembershipTypeRuleRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiGetMembershipTypeRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiGetMembershipTypeRuleRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiGetMembershipTypeRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiGetMembershipTypeRuleRequest) Execute() (*MembershipTypeRule, *http.Response, error) {
	return r.ApiService.GetMembershipTypeRuleExecute(r)
}

/*
GetMembershipTypeRule Get Membership type rule details

You can use this API to get Membership type rule details. <p><strong>OperationId:</strong>getMembershipTypeRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipTypeRulesId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiGetMembershipTypeRuleRequest
*/
func (a *MembershipConfigApiService) GetMembershipTypeRule(ctx context.Context, membershipTypeRulesId string) MembershipConfigApiGetMembershipTypeRuleRequest {
	return MembershipConfigApiGetMembershipTypeRuleRequest{
		ApiService: a,
		ctx: ctx,
		membershipTypeRulesId: membershipTypeRulesId,
	}
}

// Execute executes the request
//  @return MembershipTypeRule
func (a *MembershipConfigApiService) GetMembershipTypeRuleExecute(r MembershipConfigApiGetMembershipTypeRuleRequest) (*MembershipTypeRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipTypeRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.GetMembershipTypeRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipTypeRules/{membershipTypeRulesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipTypeRulesId"+"}", url.PathEscape(parameterValueToString(r.membershipTypeRulesId, "membershipTypeRulesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipTypeRulesId) < 1 {
		return localVarReturnValue, nil, reportError("membershipTypeRulesId must have at least 1 elements")
	}
	if strlen(r.membershipTypeRulesId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipTypeRulesId must have less than 2000 elements")
	}

	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
	}
	if r.membershipPointsSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipPointsSequence", r.membershipPointsSequence, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiGetMembershipTypeRulesRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipTypesCodes *[]string
	programType *string
	ruleCode *string
	ruleBasedOn *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiGetMembershipTypeRulesRequest) Authorization(authorization string) MembershipConfigApiGetMembershipTypeRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiGetMembershipTypeRulesRequest) XAppKey(xAppKey string) MembershipConfigApiGetMembershipTypeRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiGetMembershipTypeRulesRequest) XHotelid(xHotelid string) MembershipConfigApiGetMembershipTypeRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r MembershipConfigApiGetMembershipTypeRulesRequest) MembershipTypesCodes(membershipTypesCodes []string) MembershipConfigApiGetMembershipTypeRulesRequest {
	r.membershipTypesCodes = &membershipTypesCodes
	return r
}

// Membership Type/Program rule types.
func (r MembershipConfigApiGetMembershipTypeRulesRequest) ProgramType(programType string) MembershipConfigApiGetMembershipTypeRulesRequest {
	r.programType = &programType
	return r
}

// Rule code of the membership type rule.
func (r MembershipConfigApiGetMembershipTypeRulesRequest) RuleCode(ruleCode string) MembershipConfigApiGetMembershipTypeRulesRequest {
	r.ruleCode = &ruleCode
	return r
}

// Indicates Membership upgrades/downgrades to the next tier level uses RFM (Recency, Frequency, Monetary Value) score.
func (r MembershipConfigApiGetMembershipTypeRulesRequest) RuleBasedOn(ruleBasedOn string) MembershipConfigApiGetMembershipTypeRulesRequest {
	r.ruleBasedOn = &ruleBasedOn
	return r
}

// Indicates whether search includes inactive membership type rules.
func (r MembershipConfigApiGetMembershipTypeRulesRequest) IncludeInactive(includeInactive bool) MembershipConfigApiGetMembershipTypeRulesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r MembershipConfigApiGetMembershipTypeRulesRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiGetMembershipTypeRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiGetMembershipTypeRulesRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiGetMembershipTypeRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiGetMembershipTypeRulesRequest) Execute() (*MembershipTypeRulesInfo, *http.Response, error) {
	return r.ApiService.GetMembershipTypeRulesExecute(r)
}

/*
GetMembershipTypeRules Get Membership type rules

get Membership type rules based on criteria <p><strong>OperationId:</strong>getMembershipTypeRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiGetMembershipTypeRulesRequest
*/
func (a *MembershipConfigApiService) GetMembershipTypeRules(ctx context.Context) MembershipConfigApiGetMembershipTypeRulesRequest {
	return MembershipConfigApiGetMembershipTypeRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MembershipTypeRulesInfo
func (a *MembershipConfigApiService) GetMembershipTypeRulesExecute(r MembershipConfigApiGetMembershipTypeRulesRequest) (*MembershipTypeRulesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipTypeRulesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.GetMembershipTypeRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipTypeRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.membershipTypesCodes != nil {
		t := *r.membershipTypesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypesCodes", t, "multi")
		}
	}
	if r.programType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "programType", r.programType, "")
	}
	if r.ruleCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ruleCode", r.ruleCode, "")
	}
	if r.ruleBasedOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ruleBasedOn", r.ruleBasedOn, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiGetMembershipTypesRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	membershipTypesCodes *[]string
	membershipTypesWildCard *string
	membershipClassesCodes *[]string
	membershipClassesWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiGetMembershipTypesRequest) Authorization(authorization string) MembershipConfigApiGetMembershipTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiGetMembershipTypesRequest) XAppKey(xAppKey string) MembershipConfigApiGetMembershipTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiGetMembershipTypesRequest) XHotelid(xHotelid string) MembershipConfigApiGetMembershipTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Search criteria for fetching inactive memberships. When set to true, inactive records will be included.
func (r MembershipConfigApiGetMembershipTypesRequest) IncludeInactive(includeInactive bool) MembershipConfigApiGetMembershipTypesRequest {
	r.includeInactive = &includeInactive
	return r
}

// Codes to be searched.
func (r MembershipConfigApiGetMembershipTypesRequest) MembershipTypesCodes(membershipTypesCodes []string) MembershipConfigApiGetMembershipTypesRequest {
	r.membershipTypesCodes = &membershipTypesCodes
	return r
}

// Wildcard search on the code.
func (r MembershipConfigApiGetMembershipTypesRequest) MembershipTypesWildCard(membershipTypesWildCard string) MembershipConfigApiGetMembershipTypesRequest {
	r.membershipTypesWildCard = &membershipTypesWildCard
	return r
}

// Codes to be searched.
func (r MembershipConfigApiGetMembershipTypesRequest) MembershipClassesCodes(membershipClassesCodes []string) MembershipConfigApiGetMembershipTypesRequest {
	r.membershipClassesCodes = &membershipClassesCodes
	return r
}

// Wildcard search on the code.
func (r MembershipConfigApiGetMembershipTypesRequest) MembershipClassesWildCard(membershipClassesWildCard string) MembershipConfigApiGetMembershipTypesRequest {
	r.membershipClassesWildCard = &membershipClassesWildCard
	return r
}

// External system code.
func (r MembershipConfigApiGetMembershipTypesRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiGetMembershipTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiGetMembershipTypesRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiGetMembershipTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiGetMembershipTypesRequest) Execute() (*MembershipTypes, *http.Response, error) {
	return r.ApiService.GetMembershipTypesExecute(r)
}

/*
GetMembershipTypes Get membership types

Membership types enable you to identify, organize, and manage the membership programs on a profile. For example, your property might have a guest loyalty program that awards guests based on the amount of revenue generated or the number of stays per year. You would create a specific membership type for this program. This API will retrieve all configured Membership Types configured.<p><strong>OperationId:</strong>getMembershipTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiGetMembershipTypesRequest
*/
func (a *MembershipConfigApiService) GetMembershipTypes(ctx context.Context) MembershipConfigApiGetMembershipTypesRequest {
	return MembershipConfigApiGetMembershipTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MembershipTypes
func (a *MembershipConfigApiService) GetMembershipTypesExecute(r MembershipConfigApiGetMembershipTypesRequest) (*MembershipTypes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.GetMembershipTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.membershipTypesCodes != nil {
		t := *r.membershipTypesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypesCodes", t, "multi")
		}
	}
	if r.membershipTypesWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypesWildCard", r.membershipTypesWildCard, "")
	}
	if r.membershipClassesCodes != nil {
		t := *r.membershipClassesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipClassesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipClassesCodes", t, "multi")
		}
	}
	if r.membershipClassesWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipClassesWildCard", r.membershipClassesWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPostMembershipAwardsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipAwards *PostMembershipAwardsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPostMembershipAwardsRequest) Authorization(authorization string) MembershipConfigApiPostMembershipAwardsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPostMembershipAwardsRequest) XAppKey(xAppKey string) MembershipConfigApiPostMembershipAwardsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPostMembershipAwardsRequest) XHotelid(xHotelid string) MembershipConfigApiPostMembershipAwardsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new membership awards.
func (r MembershipConfigApiPostMembershipAwardsRequest) MembershipAwards(membershipAwards PostMembershipAwardsRequest) MembershipConfigApiPostMembershipAwardsRequest {
	r.membershipAwards = &membershipAwards
	return r
}

// External system code.
func (r MembershipConfigApiPostMembershipAwardsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPostMembershipAwardsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPostMembershipAwardsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPostMembershipAwardsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPostMembershipAwardsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMembershipAwardsExecute(r)
}

/*
PostMembershipAwards Create Membership Awards

You can use this API to create Membership Awards. <p><strong>OperationId:</strong>postMembershipAwards</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiPostMembershipAwardsRequest
*/
func (a *MembershipConfigApiService) PostMembershipAwards(ctx context.Context) MembershipConfigApiPostMembershipAwardsRequest {
	return MembershipConfigApiPostMembershipAwardsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PostMembershipAwardsExecute(r MembershipConfigApiPostMembershipAwardsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PostMembershipAwards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipAwards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipAwards
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPostMembershipBenefitProgramsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipBenefitPrograms *PostMembershipBenefitProgramsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPostMembershipBenefitProgramsRequest) Authorization(authorization string) MembershipConfigApiPostMembershipBenefitProgramsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPostMembershipBenefitProgramsRequest) XAppKey(xAppKey string) MembershipConfigApiPostMembershipBenefitProgramsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPostMembershipBenefitProgramsRequest) XHotelid(xHotelid string) MembershipConfigApiPostMembershipBenefitProgramsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new membership benefit programs.
func (r MembershipConfigApiPostMembershipBenefitProgramsRequest) MembershipBenefitPrograms(membershipBenefitPrograms PostMembershipBenefitProgramsRequest) MembershipConfigApiPostMembershipBenefitProgramsRequest {
	r.membershipBenefitPrograms = &membershipBenefitPrograms
	return r
}

// External system code.
func (r MembershipConfigApiPostMembershipBenefitProgramsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPostMembershipBenefitProgramsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPostMembershipBenefitProgramsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPostMembershipBenefitProgramsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPostMembershipBenefitProgramsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMembershipBenefitProgramsExecute(r)
}

/*
PostMembershipBenefitPrograms Create Membership Benefit Program

This API is used to create Membership Benefit Programs of a Membership Type. A Benefit Program is configurable for a Membership Type when OCIS or ORS license is active and Membership Type meets following criteria  - primary  central setup,  not externally controlled and point calculation method is Manual Batch. <p><strong>OperationId:</strong>postMembershipBenefitPrograms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiPostMembershipBenefitProgramsRequest
*/
func (a *MembershipConfigApiService) PostMembershipBenefitPrograms(ctx context.Context) MembershipConfigApiPostMembershipBenefitProgramsRequest {
	return MembershipConfigApiPostMembershipBenefitProgramsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PostMembershipBenefitProgramsExecute(r MembershipConfigApiPostMembershipBenefitProgramsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PostMembershipBenefitPrograms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipBenefitPrograms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipBenefitPrograms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPostMembershipClassesRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipClasses *PostMembershipClassesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPostMembershipClassesRequest) Authorization(authorization string) MembershipConfigApiPostMembershipClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPostMembershipClassesRequest) XAppKey(xAppKey string) MembershipConfigApiPostMembershipClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPostMembershipClassesRequest) XHotelid(xHotelid string) MembershipConfigApiPostMembershipClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Membership Class
func (r MembershipConfigApiPostMembershipClassesRequest) MembershipClasses(membershipClasses PostMembershipClassesRequest) MembershipConfigApiPostMembershipClassesRequest {
	r.membershipClasses = &membershipClasses
	return r
}

// External system code.
func (r MembershipConfigApiPostMembershipClassesRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPostMembershipClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPostMembershipClassesRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPostMembershipClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPostMembershipClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMembershipClassesExecute(r)
}

/*
PostMembershipClasses Create Membership classes

Create a new membership class. <p><strong>OperationId:</strong>postMembershipClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiPostMembershipClassesRequest
*/
func (a *MembershipConfigApiService) PostMembershipClasses(ctx context.Context) MembershipConfigApiPostMembershipClassesRequest {
	return MembershipConfigApiPostMembershipClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PostMembershipClassesExecute(r MembershipConfigApiPostMembershipClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PostMembershipClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipClasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipClasses
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPostMembershipEnrollmentGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipEnrollmentGroups *PostMembershipEnrollmentGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPostMembershipEnrollmentGroupsRequest) Authorization(authorization string) MembershipConfigApiPostMembershipEnrollmentGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPostMembershipEnrollmentGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiPostMembershipEnrollmentGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPostMembershipEnrollmentGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiPostMembershipEnrollmentGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new membership enrollment groups.
func (r MembershipConfigApiPostMembershipEnrollmentGroupsRequest) MembershipEnrollmentGroups(membershipEnrollmentGroups PostMembershipEnrollmentGroupsRequest) MembershipConfigApiPostMembershipEnrollmentGroupsRequest {
	r.membershipEnrollmentGroups = &membershipEnrollmentGroups
	return r
}

// External system code.
func (r MembershipConfigApiPostMembershipEnrollmentGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPostMembershipEnrollmentGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPostMembershipEnrollmentGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPostMembershipEnrollmentGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPostMembershipEnrollmentGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMembershipEnrollmentGroupsExecute(r)
}

/*
PostMembershipEnrollmentGroups Create Membership enrollment groups

Create a new membership enrollment group. <p><strong>OperationId:</strong>postMembershipEnrollmentGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiPostMembershipEnrollmentGroupsRequest
*/
func (a *MembershipConfigApiService) PostMembershipEnrollmentGroups(ctx context.Context) MembershipConfigApiPostMembershipEnrollmentGroupsRequest {
	return MembershipConfigApiPostMembershipEnrollmentGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PostMembershipEnrollmentGroupsExecute(r MembershipConfigApiPostMembershipEnrollmentGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PostMembershipEnrollmentGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipEnrollmentGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipEnrollmentGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPostMembershipFolioTextsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipFolioTexts *PostMembershipFolioTextsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPostMembershipFolioTextsRequest) Authorization(authorization string) MembershipConfigApiPostMembershipFolioTextsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPostMembershipFolioTextsRequest) XAppKey(xAppKey string) MembershipConfigApiPostMembershipFolioTextsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPostMembershipFolioTextsRequest) XHotelid(xHotelid string) MembershipConfigApiPostMembershipFolioTextsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Collection of FolioTexts to be inserted at MembershipLevel.
func (r MembershipConfigApiPostMembershipFolioTextsRequest) MembershipFolioTexts(membershipFolioTexts PostMembershipFolioTextsRequest) MembershipConfigApiPostMembershipFolioTextsRequest {
	r.membershipFolioTexts = &membershipFolioTexts
	return r
}

// External system code.
func (r MembershipConfigApiPostMembershipFolioTextsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPostMembershipFolioTextsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPostMembershipFolioTextsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPostMembershipFolioTextsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPostMembershipFolioTextsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMembershipFolioTextsExecute(r)
}

/*
PostMembershipFolioTexts Set Membership folio texts

You can use this API to Set Membership folio texts. <p><strong>OperationId:</strong>postMembershipFolioTexts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiPostMembershipFolioTextsRequest
*/
func (a *MembershipConfigApiService) PostMembershipFolioTexts(ctx context.Context) MembershipConfigApiPostMembershipFolioTextsRequest {
	return MembershipConfigApiPostMembershipFolioTextsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PostMembershipFolioTextsExecute(r MembershipConfigApiPostMembershipFolioTextsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PostMembershipFolioTexts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipFolioTexts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipFolioTexts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPostMembershipLevelsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipLevels *PostMembershipLevelsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPostMembershipLevelsRequest) Authorization(authorization string) MembershipConfigApiPostMembershipLevelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPostMembershipLevelsRequest) XAppKey(xAppKey string) MembershipConfigApiPostMembershipLevelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPostMembershipLevelsRequest) XHotelid(xHotelid string) MembershipConfigApiPostMembershipLevelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new membership levels.
func (r MembershipConfigApiPostMembershipLevelsRequest) MembershipLevels(membershipLevels PostMembershipLevelsRequest) MembershipConfigApiPostMembershipLevelsRequest {
	r.membershipLevels = &membershipLevels
	return r
}

// External system code.
func (r MembershipConfigApiPostMembershipLevelsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPostMembershipLevelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPostMembershipLevelsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPostMembershipLevelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPostMembershipLevelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMembershipLevelsExecute(r)
}

/*
PostMembershipLevels Create Membership levels

You can use this API to create Membership levels. <p><strong>OperationId:</strong>postMembershipLevels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiPostMembershipLevelsRequest
*/
func (a *MembershipConfigApiService) PostMembershipLevels(ctx context.Context) MembershipConfigApiPostMembershipLevelsRequest {
	return MembershipConfigApiPostMembershipLevelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PostMembershipLevelsExecute(r MembershipConfigApiPostMembershipLevelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PostMembershipLevels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipLevels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipLevels
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPostMembershipMarketGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipMarketGroups *PostMembershipMarketGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPostMembershipMarketGroupsRequest) Authorization(authorization string) MembershipConfigApiPostMembershipMarketGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPostMembershipMarketGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiPostMembershipMarketGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPostMembershipMarketGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiPostMembershipMarketGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Membership Market Group Configurations.
func (r MembershipConfigApiPostMembershipMarketGroupsRequest) MembershipMarketGroups(membershipMarketGroups PostMembershipMarketGroupsRequest) MembershipConfigApiPostMembershipMarketGroupsRequest {
	r.membershipMarketGroups = &membershipMarketGroups
	return r
}

// External system code.
func (r MembershipConfigApiPostMembershipMarketGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPostMembershipMarketGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPostMembershipMarketGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPostMembershipMarketGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPostMembershipMarketGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMembershipMarketGroupsExecute(r)
}

/*
PostMembershipMarketGroups Create Membership market groups

You can use this API to create Membership market groups. <p><strong>OperationId:</strong>postMembershipMarketGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiPostMembershipMarketGroupsRequest
*/
func (a *MembershipConfigApiService) PostMembershipMarketGroups(ctx context.Context) MembershipConfigApiPostMembershipMarketGroupsRequest {
	return MembershipConfigApiPostMembershipMarketGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PostMembershipMarketGroupsExecute(r MembershipConfigApiPostMembershipMarketGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PostMembershipMarketGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipMarketGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipMarketGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPostMembershipPropertyGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipPropertyGroups *PostMembershipPropertyGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPostMembershipPropertyGroupsRequest) Authorization(authorization string) MembershipConfigApiPostMembershipPropertyGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPostMembershipPropertyGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiPostMembershipPropertyGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPostMembershipPropertyGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiPostMembershipPropertyGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Membership Property Groups Configurations.
func (r MembershipConfigApiPostMembershipPropertyGroupsRequest) MembershipPropertyGroups(membershipPropertyGroups PostMembershipPropertyGroupsRequest) MembershipConfigApiPostMembershipPropertyGroupsRequest {
	r.membershipPropertyGroups = &membershipPropertyGroups
	return r
}

// External system code.
func (r MembershipConfigApiPostMembershipPropertyGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPostMembershipPropertyGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPostMembershipPropertyGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPostMembershipPropertyGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPostMembershipPropertyGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMembershipPropertyGroupsExecute(r)
}

/*
PostMembershipPropertyGroups Create Membership property groups

You can use this API to create Membership property groups. <p><strong>OperationId:</strong>postMembershipPropertyGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiPostMembershipPropertyGroupsRequest
*/
func (a *MembershipConfigApiService) PostMembershipPropertyGroups(ctx context.Context) MembershipConfigApiPostMembershipPropertyGroupsRequest {
	return MembershipConfigApiPostMembershipPropertyGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PostMembershipPropertyGroupsExecute(r MembershipConfigApiPostMembershipPropertyGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PostMembershipPropertyGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipPropertyGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipPropertyGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPostMembershipRateGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipRateGroups *PostMembershipRateGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPostMembershipRateGroupsRequest) Authorization(authorization string) MembershipConfigApiPostMembershipRateGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPostMembershipRateGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiPostMembershipRateGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPostMembershipRateGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiPostMembershipRateGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Membership Rate Groups.
func (r MembershipConfigApiPostMembershipRateGroupsRequest) MembershipRateGroups(membershipRateGroups PostMembershipRateGroupsRequest) MembershipConfigApiPostMembershipRateGroupsRequest {
	r.membershipRateGroups = &membershipRateGroups
	return r
}

// External system code.
func (r MembershipConfigApiPostMembershipRateGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPostMembershipRateGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPostMembershipRateGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPostMembershipRateGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPostMembershipRateGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMembershipRateGroupsExecute(r)
}

/*
PostMembershipRateGroups Create Membership rate groups

You can use this API to create Membership rate groups. <p><strong>OperationId:</strong>postMembershipRateGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiPostMembershipRateGroupsRequest
*/
func (a *MembershipConfigApiService) PostMembershipRateGroups(ctx context.Context) MembershipConfigApiPostMembershipRateGroupsRequest {
	return MembershipConfigApiPostMembershipRateGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PostMembershipRateGroupsExecute(r MembershipConfigApiPostMembershipRateGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PostMembershipRateGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipRateGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipRateGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPostMembershipTypeRulesRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipTypeRules *PostMembershipTypeRulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPostMembershipTypeRulesRequest) Authorization(authorization string) MembershipConfigApiPostMembershipTypeRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPostMembershipTypeRulesRequest) XAppKey(xAppKey string) MembershipConfigApiPostMembershipTypeRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPostMembershipTypeRulesRequest) XHotelid(xHotelid string) MembershipConfigApiPostMembershipTypeRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new membership type rules.
func (r MembershipConfigApiPostMembershipTypeRulesRequest) MembershipTypeRules(membershipTypeRules PostMembershipTypeRulesRequest) MembershipConfigApiPostMembershipTypeRulesRequest {
	r.membershipTypeRules = &membershipTypeRules
	return r
}

// External system code.
func (r MembershipConfigApiPostMembershipTypeRulesRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPostMembershipTypeRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPostMembershipTypeRulesRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPostMembershipTypeRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPostMembershipTypeRulesRequest) Execute() (*MembershipTypeRulesDetails, *http.Response, error) {
	return r.ApiService.PostMembershipTypeRulesExecute(r)
}

/*
PostMembershipTypeRules Create Membership type rules

You can use this API to create Membership type rules. <p><strong>OperationId:</strong>postMembershipTypeRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiPostMembershipTypeRulesRequest
*/
func (a *MembershipConfigApiService) PostMembershipTypeRules(ctx context.Context) MembershipConfigApiPostMembershipTypeRulesRequest {
	return MembershipConfigApiPostMembershipTypeRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MembershipTypeRulesDetails
func (a *MembershipConfigApiService) PostMembershipTypeRulesExecute(r MembershipConfigApiPostMembershipTypeRulesRequest) (*MembershipTypeRulesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipTypeRulesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PostMembershipTypeRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipTypeRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipTypeRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPostMembershipTypesRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipTypes *PostMembershipTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPostMembershipTypesRequest) Authorization(authorization string) MembershipConfigApiPostMembershipTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPostMembershipTypesRequest) XAppKey(xAppKey string) MembershipConfigApiPostMembershipTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPostMembershipTypesRequest) XHotelid(xHotelid string) MembershipConfigApiPostMembershipTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create Membership types. Includes instructions for information which needs to be returned.
func (r MembershipConfigApiPostMembershipTypesRequest) MembershipTypes(membershipTypes PostMembershipTypesRequest) MembershipConfigApiPostMembershipTypesRequest {
	r.membershipTypes = &membershipTypes
	return r
}

// External system code.
func (r MembershipConfigApiPostMembershipTypesRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPostMembershipTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPostMembershipTypesRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPostMembershipTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPostMembershipTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMembershipTypesExecute(r)
}

/*
PostMembershipTypes Create Membership types

Membership types enable you to identify, organize, and manage the membership programs on a profile. For example, your property might have a guest loyalty program that awards guests based on the amount of revenue generated or the number of stays per year. You would create a specific membership type for this program. <p><strong>OperationId:</strong>postMembershipTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MembershipConfigApiPostMembershipTypesRequest
*/
func (a *MembershipConfigApiService) PostMembershipTypes(ctx context.Context) MembershipConfigApiPostMembershipTypesRequest {
	return MembershipConfigApiPostMembershipTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PostMembershipTypesExecute(r MembershipConfigApiPostMembershipTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PostMembershipTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPutMembershipAwardsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipAwardsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipAwards *PostMembershipAwardsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPutMembershipAwardsRequest) Authorization(authorization string) MembershipConfigApiPutMembershipAwardsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPutMembershipAwardsRequest) XAppKey(xAppKey string) MembershipConfigApiPutMembershipAwardsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPutMembershipAwardsRequest) XHotelid(xHotelid string) MembershipConfigApiPutMembershipAwardsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying membership awards.
func (r MembershipConfigApiPutMembershipAwardsRequest) MembershipAwards(membershipAwards PostMembershipAwardsRequest) MembershipConfigApiPutMembershipAwardsRequest {
	r.membershipAwards = &membershipAwards
	return r
}

// External system code.
func (r MembershipConfigApiPutMembershipAwardsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPutMembershipAwardsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPutMembershipAwardsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPutMembershipAwardsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPutMembershipAwardsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutMembershipAwardsExecute(r)
}

/*
PutMembershipAwards Change Membership Awards

You can use this API to change Membership Awards. <p><strong>OperationId:</strong>putMembershipAwards</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipAwardsId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiPutMembershipAwardsRequest
*/
func (a *MembershipConfigApiService) PutMembershipAwards(ctx context.Context, membershipAwardsId string) MembershipConfigApiPutMembershipAwardsRequest {
	return MembershipConfigApiPutMembershipAwardsRequest{
		ApiService: a,
		ctx: ctx,
		membershipAwardsId: membershipAwardsId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PutMembershipAwardsExecute(r MembershipConfigApiPutMembershipAwardsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PutMembershipAwards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipAwards/{membershipAwardsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipAwardsId"+"}", url.PathEscape(parameterValueToString(r.membershipAwardsId, "membershipAwardsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipAwardsId) < 1 {
		return localVarReturnValue, nil, reportError("membershipAwardsId must have at least 1 elements")
	}
	if strlen(r.membershipAwardsId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipAwardsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipAwards
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPutMembershipBenefitProgramsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipBenefitProgramsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipBenefitPrograms *PostMembershipBenefitProgramsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPutMembershipBenefitProgramsRequest) Authorization(authorization string) MembershipConfigApiPutMembershipBenefitProgramsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPutMembershipBenefitProgramsRequest) XAppKey(xAppKey string) MembershipConfigApiPutMembershipBenefitProgramsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPutMembershipBenefitProgramsRequest) XHotelid(xHotelid string) MembershipConfigApiPutMembershipBenefitProgramsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying membership benefit programs.
func (r MembershipConfigApiPutMembershipBenefitProgramsRequest) MembershipBenefitPrograms(membershipBenefitPrograms PostMembershipBenefitProgramsRequest) MembershipConfigApiPutMembershipBenefitProgramsRequest {
	r.membershipBenefitPrograms = &membershipBenefitPrograms
	return r
}

// External system code.
func (r MembershipConfigApiPutMembershipBenefitProgramsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPutMembershipBenefitProgramsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPutMembershipBenefitProgramsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPutMembershipBenefitProgramsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPutMembershipBenefitProgramsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutMembershipBenefitProgramsExecute(r)
}

/*
PutMembershipBenefitPrograms Change Membership Benefit Program

This API allows you to modify Membership Benefit Programs of Membership Type. A Benefit Program is configurable for a Membership Type when OCIS or ORS license is active and Membership Type meets following criteria  - primary central setup, not externally controlled and point calculation method is Manual Batch. <p><strong>OperationId:</strong>putMembershipBenefitPrograms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipBenefitProgramsId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiPutMembershipBenefitProgramsRequest
*/
func (a *MembershipConfigApiService) PutMembershipBenefitPrograms(ctx context.Context, membershipBenefitProgramsId string) MembershipConfigApiPutMembershipBenefitProgramsRequest {
	return MembershipConfigApiPutMembershipBenefitProgramsRequest{
		ApiService: a,
		ctx: ctx,
		membershipBenefitProgramsId: membershipBenefitProgramsId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PutMembershipBenefitProgramsExecute(r MembershipConfigApiPutMembershipBenefitProgramsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PutMembershipBenefitPrograms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipBenefitPrograms/{membershipBenefitProgramsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipBenefitProgramsId"+"}", url.PathEscape(parameterValueToString(r.membershipBenefitProgramsId, "membershipBenefitProgramsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipBenefitProgramsId) < 1 {
		return localVarReturnValue, nil, reportError("membershipBenefitProgramsId must have at least 1 elements")
	}
	if strlen(r.membershipBenefitProgramsId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipBenefitProgramsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipBenefitPrograms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPutMembershipClassesRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipClassId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipClasses *PostMembershipClassesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPutMembershipClassesRequest) Authorization(authorization string) MembershipConfigApiPutMembershipClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPutMembershipClassesRequest) XAppKey(xAppKey string) MembershipConfigApiPutMembershipClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPutMembershipClassesRequest) XHotelid(xHotelid string) MembershipConfigApiPutMembershipClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Membership Class.
func (r MembershipConfigApiPutMembershipClassesRequest) MembershipClasses(membershipClasses PostMembershipClassesRequest) MembershipConfigApiPutMembershipClassesRequest {
	r.membershipClasses = &membershipClasses
	return r
}

// External system code.
func (r MembershipConfigApiPutMembershipClassesRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPutMembershipClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPutMembershipClassesRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPutMembershipClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPutMembershipClassesRequest) Execute() (*MembershipClassesInfo, *http.Response, error) {
	return r.ApiService.PutMembershipClassesExecute(r)
}

/*
PutMembershipClasses Change Membership classes

Update an existing membership class <p><strong>OperationId:</strong>putMembershipClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipClassId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiPutMembershipClassesRequest
*/
func (a *MembershipConfigApiService) PutMembershipClasses(ctx context.Context, membershipClassId string) MembershipConfigApiPutMembershipClassesRequest {
	return MembershipConfigApiPutMembershipClassesRequest{
		ApiService: a,
		ctx: ctx,
		membershipClassId: membershipClassId,
	}
}

// Execute executes the request
//  @return MembershipClassesInfo
func (a *MembershipConfigApiService) PutMembershipClassesExecute(r MembershipConfigApiPutMembershipClassesRequest) (*MembershipClassesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipClassesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PutMembershipClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipClasses/{membershipClassId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipClassId"+"}", url.PathEscape(parameterValueToString(r.membershipClassId, "membershipClassId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipClassId) < 1 {
		return localVarReturnValue, nil, reportError("membershipClassId must have at least 1 elements")
	}
	if strlen(r.membershipClassId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipClassId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipClasses
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPutMembershipEnrollmentGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipEnrollmentGroupsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipEnrollmentGroups *PostMembershipEnrollmentGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPutMembershipEnrollmentGroupsRequest) Authorization(authorization string) MembershipConfigApiPutMembershipEnrollmentGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPutMembershipEnrollmentGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiPutMembershipEnrollmentGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPutMembershipEnrollmentGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiPutMembershipEnrollmentGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing new membership enrollment groups.
func (r MembershipConfigApiPutMembershipEnrollmentGroupsRequest) MembershipEnrollmentGroups(membershipEnrollmentGroups PostMembershipEnrollmentGroupsRequest) MembershipConfigApiPutMembershipEnrollmentGroupsRequest {
	r.membershipEnrollmentGroups = &membershipEnrollmentGroups
	return r
}

// External system code.
func (r MembershipConfigApiPutMembershipEnrollmentGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPutMembershipEnrollmentGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPutMembershipEnrollmentGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPutMembershipEnrollmentGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPutMembershipEnrollmentGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutMembershipEnrollmentGroupsExecute(r)
}

/*
PutMembershipEnrollmentGroups Change Membership enrollment groups

Update an existing membership group. <p><strong>OperationId:</strong>putMembershipEnrollmentGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipEnrollmentGroupsId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiPutMembershipEnrollmentGroupsRequest
*/
func (a *MembershipConfigApiService) PutMembershipEnrollmentGroups(ctx context.Context, membershipEnrollmentGroupsId string) MembershipConfigApiPutMembershipEnrollmentGroupsRequest {
	return MembershipConfigApiPutMembershipEnrollmentGroupsRequest{
		ApiService: a,
		ctx: ctx,
		membershipEnrollmentGroupsId: membershipEnrollmentGroupsId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PutMembershipEnrollmentGroupsExecute(r MembershipConfigApiPutMembershipEnrollmentGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PutMembershipEnrollmentGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipEnrollmentGroups/{membershipEnrollmentGroupsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipEnrollmentGroupsId"+"}", url.PathEscape(parameterValueToString(r.membershipEnrollmentGroupsId, "membershipEnrollmentGroupsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipEnrollmentGroupsId) < 1 {
		return localVarReturnValue, nil, reportError("membershipEnrollmentGroupsId must have at least 1 elements")
	}
	if strlen(r.membershipEnrollmentGroupsId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipEnrollmentGroupsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipEnrollmentGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPutMembershipLevelsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipLevelsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipLevels *PostMembershipLevelsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPutMembershipLevelsRequest) Authorization(authorization string) MembershipConfigApiPutMembershipLevelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPutMembershipLevelsRequest) XAppKey(xAppKey string) MembershipConfigApiPutMembershipLevelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPutMembershipLevelsRequest) XHotelid(xHotelid string) MembershipConfigApiPutMembershipLevelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying membership levels.
func (r MembershipConfigApiPutMembershipLevelsRequest) MembershipLevels(membershipLevels PostMembershipLevelsRequest) MembershipConfigApiPutMembershipLevelsRequest {
	r.membershipLevels = &membershipLevels
	return r
}

// External system code.
func (r MembershipConfigApiPutMembershipLevelsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPutMembershipLevelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPutMembershipLevelsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPutMembershipLevelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPutMembershipLevelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutMembershipLevelsExecute(r)
}

/*
PutMembershipLevels Change Membership levels

You can use this API to change Membership levels. <p><strong>OperationId:</strong>putMembershipLevels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipLevelsId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiPutMembershipLevelsRequest
*/
func (a *MembershipConfigApiService) PutMembershipLevels(ctx context.Context, membershipLevelsId string) MembershipConfigApiPutMembershipLevelsRequest {
	return MembershipConfigApiPutMembershipLevelsRequest{
		ApiService: a,
		ctx: ctx,
		membershipLevelsId: membershipLevelsId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PutMembershipLevelsExecute(r MembershipConfigApiPutMembershipLevelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PutMembershipLevels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipLevels/{membershipLevelsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipLevelsId"+"}", url.PathEscape(parameterValueToString(r.membershipLevelsId, "membershipLevelsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipLevelsId) < 1 {
		return localVarReturnValue, nil, reportError("membershipLevelsId must have at least 1 elements")
	}
	if strlen(r.membershipLevelsId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipLevelsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipLevels
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPutMembershipMarketGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipMarketGroupId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipMarketGroups *PostMembershipMarketGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPutMembershipMarketGroupsRequest) Authorization(authorization string) MembershipConfigApiPutMembershipMarketGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPutMembershipMarketGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiPutMembershipMarketGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPutMembershipMarketGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiPutMembershipMarketGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Membership Market Groups Configurations.
func (r MembershipConfigApiPutMembershipMarketGroupsRequest) MembershipMarketGroups(membershipMarketGroups PostMembershipMarketGroupsRequest) MembershipConfigApiPutMembershipMarketGroupsRequest {
	r.membershipMarketGroups = &membershipMarketGroups
	return r
}

// External system code.
func (r MembershipConfigApiPutMembershipMarketGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPutMembershipMarketGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPutMembershipMarketGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPutMembershipMarketGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPutMembershipMarketGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutMembershipMarketGroupsExecute(r)
}

/*
PutMembershipMarketGroups Change Membership market groups

You can use this API to change Membership market groups. <p><strong>OperationId:</strong>putMembershipMarketGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipMarketGroupId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiPutMembershipMarketGroupsRequest
*/
func (a *MembershipConfigApiService) PutMembershipMarketGroups(ctx context.Context, membershipMarketGroupId string) MembershipConfigApiPutMembershipMarketGroupsRequest {
	return MembershipConfigApiPutMembershipMarketGroupsRequest{
		ApiService: a,
		ctx: ctx,
		membershipMarketGroupId: membershipMarketGroupId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PutMembershipMarketGroupsExecute(r MembershipConfigApiPutMembershipMarketGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PutMembershipMarketGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipMarketGroups/{membershipMarketGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipMarketGroupId"+"}", url.PathEscape(parameterValueToString(r.membershipMarketGroupId, "membershipMarketGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipMarketGroupId) < 1 {
		return localVarReturnValue, nil, reportError("membershipMarketGroupId must have at least 1 elements")
	}
	if strlen(r.membershipMarketGroupId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipMarketGroupId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipMarketGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPutMembershipPropertyGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipPropertyGroupsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipPropertyGroups *PostMembershipPropertyGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPutMembershipPropertyGroupsRequest) Authorization(authorization string) MembershipConfigApiPutMembershipPropertyGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPutMembershipPropertyGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiPutMembershipPropertyGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPutMembershipPropertyGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiPutMembershipPropertyGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Membership Property Groups Configurations.
func (r MembershipConfigApiPutMembershipPropertyGroupsRequest) MembershipPropertyGroups(membershipPropertyGroups PostMembershipPropertyGroupsRequest) MembershipConfigApiPutMembershipPropertyGroupsRequest {
	r.membershipPropertyGroups = &membershipPropertyGroups
	return r
}

// External system code.
func (r MembershipConfigApiPutMembershipPropertyGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPutMembershipPropertyGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPutMembershipPropertyGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPutMembershipPropertyGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPutMembershipPropertyGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutMembershipPropertyGroupsExecute(r)
}

/*
PutMembershipPropertyGroups Change Membership property groups

You can use this API to change Membership property groups. <p><strong>OperationId:</strong>putMembershipPropertyGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipPropertyGroupsId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiPutMembershipPropertyGroupsRequest
*/
func (a *MembershipConfigApiService) PutMembershipPropertyGroups(ctx context.Context, membershipPropertyGroupsId string) MembershipConfigApiPutMembershipPropertyGroupsRequest {
	return MembershipConfigApiPutMembershipPropertyGroupsRequest{
		ApiService: a,
		ctx: ctx,
		membershipPropertyGroupsId: membershipPropertyGroupsId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PutMembershipPropertyGroupsExecute(r MembershipConfigApiPutMembershipPropertyGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PutMembershipPropertyGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipPropertyGroups/{membershipPropertyGroupsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipPropertyGroupsId"+"}", url.PathEscape(parameterValueToString(r.membershipPropertyGroupsId, "membershipPropertyGroupsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipPropertyGroupsId) < 1 {
		return localVarReturnValue, nil, reportError("membershipPropertyGroupsId must have at least 1 elements")
	}
	if strlen(r.membershipPropertyGroupsId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipPropertyGroupsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipPropertyGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPutMembershipRateGroupsRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipRateGroupId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipRateGroups *PostMembershipRateGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPutMembershipRateGroupsRequest) Authorization(authorization string) MembershipConfigApiPutMembershipRateGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPutMembershipRateGroupsRequest) XAppKey(xAppKey string) MembershipConfigApiPutMembershipRateGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPutMembershipRateGroupsRequest) XHotelid(xHotelid string) MembershipConfigApiPutMembershipRateGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying Membership Rate Groups.
func (r MembershipConfigApiPutMembershipRateGroupsRequest) MembershipRateGroups(membershipRateGroups PostMembershipRateGroupsRequest) MembershipConfigApiPutMembershipRateGroupsRequest {
	r.membershipRateGroups = &membershipRateGroups
	return r
}

// External system code.
func (r MembershipConfigApiPutMembershipRateGroupsRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPutMembershipRateGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPutMembershipRateGroupsRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPutMembershipRateGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPutMembershipRateGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutMembershipRateGroupsExecute(r)
}

/*
PutMembershipRateGroups Change Membership rate groups

You can use this API to change Membership rate groups. <p><strong>OperationId:</strong>putMembershipRateGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipRateGroupId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiPutMembershipRateGroupsRequest
*/
func (a *MembershipConfigApiService) PutMembershipRateGroups(ctx context.Context, membershipRateGroupId string) MembershipConfigApiPutMembershipRateGroupsRequest {
	return MembershipConfigApiPutMembershipRateGroupsRequest{
		ApiService: a,
		ctx: ctx,
		membershipRateGroupId: membershipRateGroupId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PutMembershipRateGroupsExecute(r MembershipConfigApiPutMembershipRateGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PutMembershipRateGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipRateGroups/{membershipRateGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipRateGroupId"+"}", url.PathEscape(parameterValueToString(r.membershipRateGroupId, "membershipRateGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipRateGroupId) < 1 {
		return localVarReturnValue, nil, reportError("membershipRateGroupId must have at least 1 elements")
	}
	if strlen(r.membershipRateGroupId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipRateGroupId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipRateGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPutMembershipTypeRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipTypeId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipTypeChangeInstructions *PutMembershipTypeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPutMembershipTypeRequest) Authorization(authorization string) MembershipConfigApiPutMembershipTypeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPutMembershipTypeRequest) XAppKey(xAppKey string) MembershipConfigApiPutMembershipTypeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPutMembershipTypeRequest) XHotelid(xHotelid string) MembershipConfigApiPutMembershipTypeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing membership type.
func (r MembershipConfigApiPutMembershipTypeRequest) MembershipTypeChangeInstructions(membershipTypeChangeInstructions PutMembershipTypeRequest) MembershipConfigApiPutMembershipTypeRequest {
	r.membershipTypeChangeInstructions = &membershipTypeChangeInstructions
	return r
}

// External system code.
func (r MembershipConfigApiPutMembershipTypeRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPutMembershipTypeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPutMembershipTypeRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPutMembershipTypeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPutMembershipTypeRequest) Execute() (*MembershipTypes, *http.Response, error) {
	return r.ApiService.PutMembershipTypeExecute(r)
}

/*
PutMembershipType Change Membership type

Use this API to update an existing Membership Type <p><strong>OperationId:</strong>putMembershipType</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipTypeId Fetch membershipTypes values based on given membershipTypeId
 @return MembershipConfigApiPutMembershipTypeRequest
*/
func (a *MembershipConfigApiService) PutMembershipType(ctx context.Context, membershipTypeId string) MembershipConfigApiPutMembershipTypeRequest {
	return MembershipConfigApiPutMembershipTypeRequest{
		ApiService: a,
		ctx: ctx,
		membershipTypeId: membershipTypeId,
	}
}

// Execute executes the request
//  @return MembershipTypes
func (a *MembershipConfigApiService) PutMembershipTypeExecute(r MembershipConfigApiPutMembershipTypeRequest) (*MembershipTypes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PutMembershipType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipTypes/{membershipTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipTypeId"+"}", url.PathEscape(parameterValueToString(r.membershipTypeId, "membershipTypeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipTypeId) < 1 {
		return localVarReturnValue, nil, reportError("membershipTypeId must have at least 1 elements")
	}
	if strlen(r.membershipTypeId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipTypeId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipTypeChangeInstructions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MembershipConfigApiPutMembershipTypeRulesRequest struct {
	ctx context.Context
	ApiService *MembershipConfigApiService
	membershipTypeRulesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipTypeRules *PostMembershipTypeRulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r MembershipConfigApiPutMembershipTypeRulesRequest) Authorization(authorization string) MembershipConfigApiPutMembershipTypeRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r MembershipConfigApiPutMembershipTypeRulesRequest) XAppKey(xAppKey string) MembershipConfigApiPutMembershipTypeRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r MembershipConfigApiPutMembershipTypeRulesRequest) XHotelid(xHotelid string) MembershipConfigApiPutMembershipTypeRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing membership type rules.
func (r MembershipConfigApiPutMembershipTypeRulesRequest) MembershipTypeRules(membershipTypeRules PostMembershipTypeRulesRequest) MembershipConfigApiPutMembershipTypeRulesRequest {
	r.membershipTypeRules = &membershipTypeRules
	return r
}

// External system code.
func (r MembershipConfigApiPutMembershipTypeRulesRequest) XExternalsystem(xExternalsystem string) MembershipConfigApiPutMembershipTypeRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r MembershipConfigApiPutMembershipTypeRulesRequest) AcceptLanguage(acceptLanguage string) MembershipConfigApiPutMembershipTypeRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r MembershipConfigApiPutMembershipTypeRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutMembershipTypeRulesExecute(r)
}

/*
PutMembershipTypeRules Change Membership type rules

You can use this API to change Membership type rules. <p><strong>OperationId:</strong>putMembershipTypeRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipTypeRulesId Fetch membershipClasses values based on given membershipClassId
 @return MembershipConfigApiPutMembershipTypeRulesRequest
*/
func (a *MembershipConfigApiService) PutMembershipTypeRules(ctx context.Context, membershipTypeRulesId string) MembershipConfigApiPutMembershipTypeRulesRequest {
	return MembershipConfigApiPutMembershipTypeRulesRequest{
		ApiService: a,
		ctx: ctx,
		membershipTypeRulesId: membershipTypeRulesId,
	}
}

// Execute executes the request
//  @return Status
func (a *MembershipConfigApiService) PutMembershipTypeRulesExecute(r MembershipConfigApiPutMembershipTypeRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembershipConfigApiService.PutMembershipTypeRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipTypeRules/{membershipTypeRulesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipTypeRulesId"+"}", url.PathEscape(parameterValueToString(r.membershipTypeRulesId, "membershipTypeRulesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipTypeRulesId) < 1 {
		return localVarReturnValue, nil, reportError("membershipTypeRulesId must have at least 1 elements")
	}
	if strlen(r.membershipTypeRulesId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipTypeRulesId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipTypeRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
