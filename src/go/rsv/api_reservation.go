/*
OPERA Cloud Reservation API

APIs to cater for Reservation functionality in OPERA Cloud. <br /><br />OPERA Cloud Reservations provides a complete set of capabilities for creating and updating reservations. Reservations are a central feature of OPERA Cloud. As a key source of information, the reservation specifies a guest&apos;s arrival date, departure date, room type, rate, packages, and many other details. It is also a gateway to dozens of other functions that contribute to the guest&apos;s experience.  All reservations in OPERA Cloud require a guest profile.<br /><br /> You can create profiles while booking a reservation. If a profile already exists, you can look it up (using getProfiles in the Customer Relationship Management module) and attach it to the reservation during the reservation booking process using the profileId.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rsv

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ReservationApiService ReservationApi service
type ReservationApiService service

type ReservationApiChangeReservationLocatorsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	locatorId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationLocatorsInfo *ChangeReservationLocatorsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiChangeReservationLocatorsRequest) Authorization(authorization string) ReservationApiChangeReservationLocatorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiChangeReservationLocatorsRequest) XAppKey(xAppKey string) ReservationApiChangeReservationLocatorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiChangeReservationLocatorsRequest) XHotelid(xHotelid string) ReservationApiChangeReservationLocatorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing hotel Notes for hotels.
func (r ReservationApiChangeReservationLocatorsRequest) ReservationLocatorsInfo(reservationLocatorsInfo ChangeReservationLocatorsRequest) ReservationApiChangeReservationLocatorsRequest {
	r.reservationLocatorsInfo = &reservationLocatorsInfo
	return r
}

// External system code.
func (r ReservationApiChangeReservationLocatorsRequest) XExternalsystem(xExternalsystem string) ReservationApiChangeReservationLocatorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiChangeReservationLocatorsRequest) AcceptLanguage(acceptLanguage string) ReservationApiChangeReservationLocatorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiChangeReservationLocatorsRequest) Execute() (*ReservationLocatorsStatus, *http.Response, error) {
	return r.ApiService.ChangeReservationLocatorsExecute(r)
}

/*
ChangeReservationLocators Change Reservation Guest Locators

Change a list of Guest Locater for a Reservation. <p><strong>OperationId:</strong>changeReservationLocators</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locatorId
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiChangeReservationLocatorsRequest
*/
func (a *ReservationApiService) ChangeReservationLocators(ctx context.Context, locatorId string, reservationId string, hotelId string) ReservationApiChangeReservationLocatorsRequest {
	return ReservationApiChangeReservationLocatorsRequest{
		ApiService: a,
		ctx: ctx,
		locatorId: locatorId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationLocatorsStatus
func (a *ReservationApiService) ChangeReservationLocatorsExecute(r ReservationApiChangeReservationLocatorsRequest) (*ReservationLocatorsStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationLocatorsStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.ChangeReservationLocators")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/guestLocators/{locatorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"locatorId"+"}", url.PathEscape(parameterValueToString(r.locatorId, "locatorId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.locatorId) < 1 {
		return localVarReturnValue, nil, reportError("locatorId must have at least 1 elements")
	}
	if strlen(r.locatorId) > 2000 {
		return localVarReturnValue, nil, reportError("locatorId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationLocatorsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteCancellationPolicyRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	policyId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiDeleteCancellationPolicyRequest) PolicyId(policyId string) ReservationApiDeleteCancellationPolicyRequest {
	r.policyId = &policyId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteCancellationPolicyRequest) Authorization(authorization string) ReservationApiDeleteCancellationPolicyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteCancellationPolicyRequest) XAppKey(xAppKey string) ReservationApiDeleteCancellationPolicyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteCancellationPolicyRequest) XHotelid(xHotelid string) ReservationApiDeleteCancellationPolicyRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteCancellationPolicyRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteCancellationPolicyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteCancellationPolicyRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteCancellationPolicyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteCancellationPolicyRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCancellationPolicyExecute(r)
}

/*
DeleteCancellationPolicy Delete a Cancellation policy

Delete an existing cancellation policy for a specific hotel. <p><strong>OperationId:</strong>deleteCancellationPolicy</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteCancellationPolicyRequest
*/
func (a *ReservationApiService) DeleteCancellationPolicy(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteCancellationPolicyRequest {
	return ReservationApiDeleteCancellationPolicyRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteCancellationPolicyExecute(r ReservationApiDeleteCancellationPolicyRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteCancellationPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/cancellationPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "policyId", r.policyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteDepositPolicyRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	policyId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiDeleteDepositPolicyRequest) PolicyId(policyId string) ReservationApiDeleteDepositPolicyRequest {
	r.policyId = &policyId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteDepositPolicyRequest) Authorization(authorization string) ReservationApiDeleteDepositPolicyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteDepositPolicyRequest) XAppKey(xAppKey string) ReservationApiDeleteDepositPolicyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteDepositPolicyRequest) XHotelid(xHotelid string) ReservationApiDeleteDepositPolicyRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteDepositPolicyRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteDepositPolicyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteDepositPolicyRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteDepositPolicyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteDepositPolicyRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteDepositPolicyExecute(r)
}

/*
DeleteDepositPolicy Delete deposit policy

Delete deposit policy for a property.   <p><strong>OperationId:</strong>deleteDepositPolicy</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteDepositPolicyRequest
*/
func (a *ReservationApiService) DeleteDepositPolicy(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteDepositPolicyRequest {
	return ReservationApiDeleteDepositPolicyRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteDepositPolicyExecute(r ReservationApiDeleteDepositPolicyRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteDepositPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "policyId", r.policyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteECouponsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eCouponId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteECouponsRequest) Authorization(authorization string) ReservationApiDeleteECouponsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteECouponsRequest) XAppKey(xAppKey string) ReservationApiDeleteECouponsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteECouponsRequest) XHotelid(xHotelid string) ReservationApiDeleteECouponsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiDeleteECouponsRequest) ECouponId(eCouponId string) ReservationApiDeleteECouponsRequest {
	r.eCouponId = &eCouponId
	return r
}

// External system code.
func (r ReservationApiDeleteECouponsRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteECouponsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteECouponsRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteECouponsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteECouponsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteECouponsExecute(r)
}

/*
DeleteECoupons Delete Reservation ECoupons

Delete the Reservation Ecoupons. <p><strong>OperationId:</strong>deleteECoupons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteECouponsRequest
*/
func (a *ReservationApiService) DeleteECoupons(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteECouponsRequest {
	return ReservationApiDeleteECouponsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteECouponsExecute(r ReservationApiDeleteECouponsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteECoupons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/eCoupons"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.eCouponId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eCouponId", r.eCouponId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteGuestMessagesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	guestMessageId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteGuestMessagesRequest) Authorization(authorization string) ReservationApiDeleteGuestMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteGuestMessagesRequest) XAppKey(xAppKey string) ReservationApiDeleteGuestMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteGuestMessagesRequest) XHotelid(xHotelid string) ReservationApiDeleteGuestMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteGuestMessagesRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteGuestMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteGuestMessagesRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteGuestMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteGuestMessagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteGuestMessagesExecute(r)
}

/*
DeleteGuestMessages Delete guest messages

Delete guest messages from a reservation. <p><strong>OperationId:</strong>deleteGuestMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guestMessageId Guest Message Id
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteGuestMessagesRequest
*/
func (a *ReservationApiService) DeleteGuestMessages(ctx context.Context, guestMessageId string, reservationId string, hotelId string) ReservationApiDeleteGuestMessagesRequest {
	return ReservationApiDeleteGuestMessagesRequest{
		ApiService: a,
		ctx: ctx,
		guestMessageId: guestMessageId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteGuestMessagesExecute(r ReservationApiDeleteGuestMessagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteGuestMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/guestMessages/{guestMessageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"guestMessageId"+"}", url.PathEscape(parameterValueToString(r.guestMessageId, "guestMessageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.guestMessageId) < 1 {
		return localVarReturnValue, nil, reportError("guestMessageId must have at least 1 elements")
	}
	if strlen(r.guestMessageId) > 2000 {
		return localVarReturnValue, nil, reportError("guestMessageId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteMasterAccountRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteMasterAccountRequest) Authorization(authorization string) ReservationApiDeleteMasterAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteMasterAccountRequest) XAppKey(xAppKey string) ReservationApiDeleteMasterAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteMasterAccountRequest) XHotelid(xHotelid string) ReservationApiDeleteMasterAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteMasterAccountRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteMasterAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteMasterAccountRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteMasterAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteMasterAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMasterAccountExecute(r)
}

/*
DeleteMasterAccount Cancel Master Account

Cancel Master account on a reservation. <p><strong>OperationId:</strong>deleteMasterAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteMasterAccountRequest
*/
func (a *ReservationApiService) DeleteMasterAccount(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteMasterAccountRequest {
	return ReservationApiDeleteMasterAccountRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteMasterAccountExecute(r ReservationApiDeleteMasterAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteMasterAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/masterAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeletePaymentMethodsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeletePaymentMethodsRequest) Authorization(authorization string) ReservationApiDeletePaymentMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeletePaymentMethodsRequest) XAppKey(xAppKey string) ReservationApiDeletePaymentMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeletePaymentMethodsRequest) XHotelid(xHotelid string) ReservationApiDeletePaymentMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeletePaymentMethodsRequest) XExternalsystem(xExternalsystem string) ReservationApiDeletePaymentMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeletePaymentMethodsRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeletePaymentMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeletePaymentMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePaymentMethodsExecute(r)
}

/*
DeletePaymentMethods Delete a payment method 

Use this API to delete a payment method from a reservation. <p><strong>OperationId:</strong>deletePaymentMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeletePaymentMethodsRequest
*/
func (a *ReservationApiService) DeletePaymentMethods(ctx context.Context, reservationId string, hotelId string) ReservationApiDeletePaymentMethodsRequest {
	return ReservationApiDeletePaymentMethodsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeletePaymentMethodsExecute(r ReservationApiDeletePaymentMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeletePaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/paymentMethods"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeletePreCheckInReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	resvIDExtension *int32
	arrivalTime *string
	roomNumber *string
	guestPreferredCurrency *string
	allowMobileViewFolio *bool
	paymentMethodDescription *[]string
	paymentMethodFolioView *[]int32
	paymentMethod *[]string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	cardId *string
	cardIdIDExtension *int32
	cardIdIDContext *string
	cardIdType *string
	currentAuthorizedAmount *float32
	authorizedAmountCurrencyCode *string
	approvalAmountNeeded *float32
	approvalAmountCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	authorizationRuleCode *int32
	authorizationRuleAmount *float32
	authorizationRuleCurrencyCode *string
	authorizationRulePercent *float32
	emailFolio *bool
	emailFolioID *string
	emailFolioIDExtension *int32
	emailFolioIDContext *string
	emailFolioIDType *string
	emailFolioCreateDateTime *string
	emailFolioCreatorID *string
	emailFolioEmailAddress *string
	emailFolioEmailFormat *string
	emailFolioLastModifierID *string
	emailFolioLastModifyDateTime *string
	emailFolioOrderSequence *float32
	emailFolioPrimaryInd *bool
	emailFolioPurgeDate *string
	emailFolioType *string
	emailFolioTypeDescription *string
	arrivalCarrierCode *string
	arrivalDateTime *string
	arrivalStationCode *string
	arrivalTransportCode *string
	arrivalTransportationReqd *bool
	arrivalType *string
	arrivalComments *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeletePreCheckInReservationRequest) Authorization(authorization string) ReservationApiDeletePreCheckInReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeletePreCheckInReservationRequest) XAppKey(xAppKey string) ReservationApiDeletePreCheckInReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeletePreCheckInReservationRequest) XHotelid(xHotelid string) ReservationApiDeletePreCheckInReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ReservationApiDeletePreCheckInReservationRequest) ResvIDExtension(resvIDExtension int32) ReservationApiDeletePreCheckInReservationRequest {
	r.resvIDExtension = &resvIDExtension
	return r
}

// The time at which the guest arrives at the hotel.
func (r ReservationApiDeletePreCheckInReservationRequest) ArrivalTime(arrivalTime string) ReservationApiDeletePreCheckInReservationRequest {
	r.arrivalTime = &arrivalTime
	return r
}

// Room Number to be assigned to the reservation.
func (r ReservationApiDeletePreCheckInReservationRequest) RoomNumber(roomNumber string) ReservationApiDeletePreCheckInReservationRequest {
	r.roomNumber = &roomNumber
	return r
}

// Currency code preferred by guest.
func (r ReservationApiDeletePreCheckInReservationRequest) GuestPreferredCurrency(guestPreferredCurrency string) ReservationApiDeletePreCheckInReservationRequest {
	r.guestPreferredCurrency = &guestPreferredCurrency
	return r
}

// Attribute AllowMobileViewFolio is set to true when the reservation is eligible for viewing folio using mobile device.
func (r ReservationApiDeletePreCheckInReservationRequest) AllowMobileViewFolio(allowMobileViewFolio bool) ReservationApiDeletePreCheckInReservationRequest {
	r.allowMobileViewFolio = &allowMobileViewFolio
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) PaymentMethodDescription(paymentMethodDescription []string) ReservationApiDeletePreCheckInReservationRequest {
	r.paymentMethodDescription = &paymentMethodDescription
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) PaymentMethodFolioView(paymentMethodFolioView []int32) ReservationApiDeletePreCheckInReservationRequest {
	r.paymentMethodFolioView = &paymentMethodFolioView
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) PaymentMethod(paymentMethod []string) ReservationApiDeletePreCheckInReservationRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Attach the credit card to profile.
func (r ReservationApiDeletePreCheckInReservationRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) ReservationApiDeletePreCheckInReservationRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) CardHolderName(cardHolderName string) ReservationApiDeletePreCheckInReservationRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) CardNumber(cardNumber string) ReservationApiDeletePreCheckInReservationRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) CardNumberLast4Digits(cardNumberLast4Digits string) ReservationApiDeletePreCheckInReservationRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) CardNumberMasked(cardNumberMasked string) ReservationApiDeletePreCheckInReservationRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r ReservationApiDeletePreCheckInReservationRequest) CardOrToken(cardOrToken string) ReservationApiDeletePreCheckInReservationRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r ReservationApiDeletePreCheckInReservationRequest) CardType(cardType string) ReservationApiDeletePreCheckInReservationRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r ReservationApiDeletePreCheckInReservationRequest) ExpirationDate(expirationDate string) ReservationApiDeletePreCheckInReservationRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) ExpirationDateExpired(expirationDateExpired bool) ReservationApiDeletePreCheckInReservationRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r ReservationApiDeletePreCheckInReservationRequest) ExpirationDateMasked(expirationDateMasked string) ReservationApiDeletePreCheckInReservationRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) Processing(processing string) ReservationApiDeletePreCheckInReservationRequest {
	r.processing = &processing
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) Swiped(swiped bool) ReservationApiDeletePreCheckInReservationRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r ReservationApiDeletePreCheckInReservationRequest) UserDefinedCardType(userDefinedCardType string) ReservationApiDeletePreCheckInReservationRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiDeletePreCheckInReservationRequest) CardId(cardId string) ReservationApiDeletePreCheckInReservationRequest {
	r.cardId = &cardId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ReservationApiDeletePreCheckInReservationRequest) CardIdIDExtension(cardIdIDExtension int32) ReservationApiDeletePreCheckInReservationRequest {
	r.cardIdIDExtension = &cardIdIDExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ReservationApiDeletePreCheckInReservationRequest) CardIdIDContext(cardIdIDContext string) ReservationApiDeletePreCheckInReservationRequest {
	r.cardIdIDContext = &cardIdIDContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiDeletePreCheckInReservationRequest) CardIdType(cardIdType string) ReservationApiDeletePreCheckInReservationRequest {
	r.cardIdType = &cardIdType
	return r
}

// A monetary amount.
func (r ReservationApiDeletePreCheckInReservationRequest) CurrentAuthorizedAmount(currentAuthorizedAmount float32) ReservationApiDeletePreCheckInReservationRequest {
	r.currentAuthorizedAmount = &currentAuthorizedAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ReservationApiDeletePreCheckInReservationRequest) AuthorizedAmountCurrencyCode(authorizedAmountCurrencyCode string) ReservationApiDeletePreCheckInReservationRequest {
	r.authorizedAmountCurrencyCode = &authorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ReservationApiDeletePreCheckInReservationRequest) ApprovalAmountNeeded(approvalAmountNeeded float32) ReservationApiDeletePreCheckInReservationRequest {
	r.approvalAmountNeeded = &approvalAmountNeeded
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ReservationApiDeletePreCheckInReservationRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) ReservationApiDeletePreCheckInReservationRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// A monetary amount.
func (r ReservationApiDeletePreCheckInReservationRequest) BalanceAmount(balanceAmount float32) ReservationApiDeletePreCheckInReservationRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ReservationApiDeletePreCheckInReservationRequest) BalanceCurrencyCode(balanceCurrencyCode string) ReservationApiDeletePreCheckInReservationRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// The authorization rule code.
func (r ReservationApiDeletePreCheckInReservationRequest) AuthorizationRuleCode(authorizationRuleCode int32) ReservationApiDeletePreCheckInReservationRequest {
	r.authorizationRuleCode = &authorizationRuleCode
	return r
}

// A monetary amount.
func (r ReservationApiDeletePreCheckInReservationRequest) AuthorizationRuleAmount(authorizationRuleAmount float32) ReservationApiDeletePreCheckInReservationRequest {
	r.authorizationRuleAmount = &authorizationRuleAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ReservationApiDeletePreCheckInReservationRequest) AuthorizationRuleCurrencyCode(authorizationRuleCurrencyCode string) ReservationApiDeletePreCheckInReservationRequest {
	r.authorizationRuleCurrencyCode = &authorizationRuleCurrencyCode
	return r
}

// A percentage value if the authorization rule is percentage based.
func (r ReservationApiDeletePreCheckInReservationRequest) AuthorizationRulePercent(authorizationRulePercent float32) ReservationApiDeletePreCheckInReservationRequest {
	r.authorizationRulePercent = &authorizationRulePercent
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolio(emailFolio bool) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolio = &emailFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioID(emailFolioID string) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioID = &emailFolioID
	return r
}

// Additional identifying value assigned by the creating system.
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioIDExtension(emailFolioIDExtension int32) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioIDExtension = &emailFolioIDExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioIDContext(emailFolioIDContext string) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioIDContext = &emailFolioIDContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioIDType(emailFolioIDType string) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioIDType = &emailFolioIDType
	return r
}

// Time stamp of the creation.
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioCreateDateTime(emailFolioCreateDateTime string) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioCreateDateTime = &emailFolioCreateDateTime
	return r
}

// ID of creator. The creator could be a software system identifier or an identifier of an employee resposible for the creation.
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioCreatorID(emailFolioCreatorID string) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioCreatorID = &emailFolioCreatorID
	return r
}

// Defines the e-mail address.
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioEmailAddress(emailFolioEmailAddress string) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioEmailAddress = &emailFolioEmailAddress
	return r
}

// Supported Email format.
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioEmailFormat(emailFolioEmailFormat string) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioEmailFormat = &emailFolioEmailFormat
	return r
}

// Identifies the last software system or person to modify a record.
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioLastModifierID(emailFolioLastModifierID string) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioLastModifierID = &emailFolioLastModifierID
	return r
}

// Time stamp of last modification.
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioLastModifyDateTime(emailFolioLastModifyDateTime string) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioLastModifyDateTime = &emailFolioLastModifyDateTime
	return r
}

// Display Order sequence.
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioOrderSequence(emailFolioOrderSequence float32) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioOrderSequence = &emailFolioOrderSequence
	return r
}

// When true, indicates a primary information.
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioPrimaryInd(emailFolioPrimaryInd bool) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioPrimaryInd = &emailFolioPrimaryInd
	return r
}

// Date an item will be purged from a database (e.g., from a live database to an archive).
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioPurgeDate(emailFolioPurgeDate string) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioPurgeDate = &emailFolioPurgeDate
	return r
}

// Defines the purpose of the e-mail address (e.g. personal, business, listserve).
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioType(emailFolioType string) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioType = &emailFolioType
	return r
}

// Describes the Type code
func (r ReservationApiDeletePreCheckInReservationRequest) EmailFolioTypeDescription(emailFolioTypeDescription string) ReservationApiDeletePreCheckInReservationRequest {
	r.emailFolioTypeDescription = &emailFolioTypeDescription
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) ArrivalCarrierCode(arrivalCarrierCode string) ReservationApiDeletePreCheckInReservationRequest {
	r.arrivalCarrierCode = &arrivalCarrierCode
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) ArrivalDateTime(arrivalDateTime string) ReservationApiDeletePreCheckInReservationRequest {
	r.arrivalDateTime = &arrivalDateTime
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) ArrivalStationCode(arrivalStationCode string) ReservationApiDeletePreCheckInReservationRequest {
	r.arrivalStationCode = &arrivalStationCode
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) ArrivalTransportCode(arrivalTransportCode string) ReservationApiDeletePreCheckInReservationRequest {
	r.arrivalTransportCode = &arrivalTransportCode
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) ArrivalTransportationReqd(arrivalTransportationReqd bool) ReservationApiDeletePreCheckInReservationRequest {
	r.arrivalTransportationReqd = &arrivalTransportationReqd
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) ArrivalType(arrivalType string) ReservationApiDeletePreCheckInReservationRequest {
	r.arrivalType = &arrivalType
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) ArrivalComments(arrivalComments string) ReservationApiDeletePreCheckInReservationRequest {
	r.arrivalComments = &arrivalComments
	return r
}

// External system code.
func (r ReservationApiDeletePreCheckInReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiDeletePreCheckInReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeletePreCheckInReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeletePreCheckInReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeletePreCheckInReservationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePreCheckInReservationExecute(r)
}

/*
DeletePreCheckInReservation Revert a PreCheckIn Reservation

This will cancel or rather revert the pre-checkin action for a guest's reservation. The reservation will return to DUEIN status. <p><strong>OperationId:</strong>deletePreCheckInReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeletePreCheckInReservationRequest
*/
func (a *ReservationApiService) DeletePreCheckInReservation(ctx context.Context, reservationId string, hotelId string) ReservationApiDeletePreCheckInReservationRequest {
	return ReservationApiDeletePreCheckInReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeletePreCheckInReservationExecute(r ReservationApiDeletePreCheckInReservationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeletePreCheckInReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/preCheckIn"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.resvIDExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resvIDExtension", r.resvIDExtension, "")
	}
	if r.arrivalTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalTime", r.arrivalTime, "")
	}
	if r.roomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumber", r.roomNumber, "")
	}
	if r.guestPreferredCurrency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestPreferredCurrency", r.guestPreferredCurrency, "")
	}
	if r.allowMobileViewFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowMobileViewFolio", r.allowMobileViewFolio, "")
	}
	if r.paymentMethodDescription != nil {
		t := *r.paymentMethodDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodDescription", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodDescription", t, "multi")
		}
	}
	if r.paymentMethodFolioView != nil {
		t := *r.paymentMethodFolioView
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodFolioView", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodFolioView", t, "multi")
		}
	}
	if r.paymentMethod != nil {
		t := *r.paymentMethod
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", t, "multi")
		}
	}
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
	}
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
	}
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
	}
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
	}
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
	}
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
	}
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
	}
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
	}
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
	}
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
	}
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
	}
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
	}
	if r.cardId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardId", r.cardId, "")
	}
	if r.cardIdIDExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdIDExtension", r.cardIdIDExtension, "")
	}
	if r.cardIdIDContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdIDContext", r.cardIdIDContext, "")
	}
	if r.cardIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdType", r.cardIdType, "")
	}
	if r.currentAuthorizedAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmount", r.currentAuthorizedAmount, "")
	}
	if r.authorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizedAmountCurrencyCode", r.authorizedAmountCurrencyCode, "")
	}
	if r.approvalAmountNeeded != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeeded", r.approvalAmountNeeded, "")
	}
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
	}
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
	}
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
	}
	if r.authorizationRuleCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizationRuleCode", r.authorizationRuleCode, "")
	}
	if r.authorizationRuleAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizationRuleAmount", r.authorizationRuleAmount, "")
	}
	if r.authorizationRuleCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizationRuleCurrencyCode", r.authorizationRuleCurrencyCode, "")
	}
	if r.authorizationRulePercent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizationRulePercent", r.authorizationRulePercent, "")
	}
	if r.emailFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolio", r.emailFolio, "")
	}
	if r.emailFolioID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioID", r.emailFolioID, "")
	}
	if r.emailFolioIDExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioIDExtension", r.emailFolioIDExtension, "")
	}
	if r.emailFolioIDContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioIDContext", r.emailFolioIDContext, "")
	}
	if r.emailFolioIDType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioIDType", r.emailFolioIDType, "")
	}
	if r.emailFolioCreateDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioCreateDateTime", r.emailFolioCreateDateTime, "")
	}
	if r.emailFolioCreatorID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioCreatorID", r.emailFolioCreatorID, "")
	}
	if r.emailFolioEmailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioEmailAddress", r.emailFolioEmailAddress, "")
	}
	if r.emailFolioEmailFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioEmailFormat", r.emailFolioEmailFormat, "")
	}
	if r.emailFolioLastModifierID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioLastModifierID", r.emailFolioLastModifierID, "")
	}
	if r.emailFolioLastModifyDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioLastModifyDateTime", r.emailFolioLastModifyDateTime, "")
	}
	if r.emailFolioOrderSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioOrderSequence", r.emailFolioOrderSequence, "")
	}
	if r.emailFolioPrimaryInd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioPrimaryInd", r.emailFolioPrimaryInd, "")
	}
	if r.emailFolioPurgeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioPurgeDate", r.emailFolioPurgeDate, "")
	}
	if r.emailFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioType", r.emailFolioType, "")
	}
	if r.emailFolioTypeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolioTypeDescription", r.emailFolioTypeDescription, "")
	}
	if r.arrivalCarrierCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalCarrierCode", r.arrivalCarrierCode, "")
	}
	if r.arrivalDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalDateTime", r.arrivalDateTime, "")
	}
	if r.arrivalStationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStationCode", r.arrivalStationCode, "")
	}
	if r.arrivalTransportCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalTransportCode", r.arrivalTransportCode, "")
	}
	if r.arrivalTransportationReqd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalTransportationReqd", r.arrivalTransportationReqd, "")
	}
	if r.arrivalType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalType", r.arrivalType, "")
	}
	if r.arrivalComments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalComments", r.arrivalComments, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteRefundTicketsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteRefundTicketsRequest) Authorization(authorization string) ReservationApiDeleteRefundTicketsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteRefundTicketsRequest) XAppKey(xAppKey string) ReservationApiDeleteRefundTicketsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteRefundTicketsRequest) XHotelid(xHotelid string) ReservationApiDeleteRefundTicketsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteRefundTicketsRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteRefundTicketsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteRefundTicketsRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteRefundTicketsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteRefundTicketsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRefundTicketsExecute(r)
}

/*
DeleteRefundTickets Refund Reservation tickets

You can use this API to refund Reservation tickets. <p><strong>OperationId:</strong>deleteRefundTickets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteRefundTicketsRequest
*/
func (a *ReservationApiService) DeleteRefundTickets(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteRefundTicketsRequest {
	return ReservationApiDeleteRefundTicketsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteRefundTicketsExecute(r ReservationApiDeleteRefundTicketsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteRefundTickets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/tickets/refund"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteReservationAttachmentRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	attachmentId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteReservationAttachmentRequest) Authorization(authorization string) ReservationApiDeleteReservationAttachmentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteReservationAttachmentRequest) XAppKey(xAppKey string) ReservationApiDeleteReservationAttachmentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteReservationAttachmentRequest) XHotelid(xHotelid string) ReservationApiDeleteReservationAttachmentRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteReservationAttachmentRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteReservationAttachmentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteReservationAttachmentRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteReservationAttachmentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteReservationAttachmentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationAttachmentExecute(r)
}

/*
DeleteReservationAttachment Delete Reservation attachments

Delete attachments from a Reservation. <p><strong>OperationId:</strong>deleteReservationAttachment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attachmentId Unique Id of the attachment to be deleted.
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteReservationAttachmentRequest
*/
func (a *ReservationApiService) DeleteReservationAttachment(ctx context.Context, attachmentId string, reservationId string, hotelId string) ReservationApiDeleteReservationAttachmentRequest {
	return ReservationApiDeleteReservationAttachmentRequest{
		ApiService: a,
		ctx: ctx,
		attachmentId: attachmentId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteReservationAttachmentExecute(r ReservationApiDeleteReservationAttachmentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteReservationAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/attachments/{attachmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.attachmentId) < 1 {
		return localVarReturnValue, nil, reportError("attachmentId must have at least 1 elements")
	}
	if strlen(r.attachmentId) > 2000 {
		return localVarReturnValue, nil, reportError("attachmentId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteReservationCertificateRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteReservationCertificateRequest) Authorization(authorization string) ReservationApiDeleteReservationCertificateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteReservationCertificateRequest) XAppKey(xAppKey string) ReservationApiDeleteReservationCertificateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteReservationCertificateRequest) XHotelid(xHotelid string) ReservationApiDeleteReservationCertificateRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteReservationCertificateRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteReservationCertificateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteReservationCertificateRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteReservationCertificateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteReservationCertificateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationCertificateExecute(r)
}

/*
DeleteReservationCertificate Detach Certificate

Remove a certification from a reservation. <p><strong>OperationId:</strong>deleteReservationCertificate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteReservationCertificateRequest
*/
func (a *ReservationApiService) DeleteReservationCertificate(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteReservationCertificateRequest {
	return ReservationApiDeleteReservationCertificateRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteReservationCertificateExecute(r ReservationApiDeleteReservationCertificateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteReservationCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/certificates"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteReservationLinksRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteReservationLinksRequest) Authorization(authorization string) ReservationApiDeleteReservationLinksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteReservationLinksRequest) XAppKey(xAppKey string) ReservationApiDeleteReservationLinksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteReservationLinksRequest) XHotelid(xHotelid string) ReservationApiDeleteReservationLinksRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteReservationLinksRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteReservationLinksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteReservationLinksRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteReservationLinksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteReservationLinksRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationLinksExecute(r)
}

/*
DeleteReservationLinks Remove Reservation Links

Use this API to unlink a reservation from its currently associated reservation. <p><strong>OperationId:</strong>deleteReservationLinks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteReservationLinksRequest
*/
func (a *ReservationApiService) DeleteReservationLinks(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteReservationLinksRequest {
	return ReservationApiDeleteReservationLinksRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteReservationLinksExecute(r ReservationApiDeleteReservationLinksRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteReservationLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/linkedReservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteReservationLinksByChainRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteReservationLinksByChainRequest) Authorization(authorization string) ReservationApiDeleteReservationLinksByChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteReservationLinksByChainRequest) XAppKey(xAppKey string) ReservationApiDeleteReservationLinksByChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteReservationLinksByChainRequest) XHotelid(xHotelid string) ReservationApiDeleteReservationLinksByChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteReservationLinksByChainRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteReservationLinksByChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteReservationLinksByChainRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteReservationLinksByChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteReservationLinksByChainRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationLinksByChainExecute(r)
}

/*
DeleteReservationLinksByChain Remove Reservation Links By Chain

Use this API to unlink a reservation from its currently associated reservation. <p><strong>OperationId:</strong>deleteReservationLinksByChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @return ReservationApiDeleteReservationLinksByChainRequest
*/
func (a *ReservationApiService) DeleteReservationLinksByChain(ctx context.Context, reservationId string) ReservationApiDeleteReservationLinksByChainRequest {
	return ReservationApiDeleteReservationLinksByChainRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteReservationLinksByChainExecute(r ReservationApiDeleteReservationLinksByChainRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteReservationLinksByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservations/linkedReservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteReservationLinksByExtIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteReservationLinksByExtIdRequest) Authorization(authorization string) ReservationApiDeleteReservationLinksByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteReservationLinksByExtIdRequest) XAppKey(xAppKey string) ReservationApiDeleteReservationLinksByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteReservationLinksByExtIdRequest) XHotelid(xHotelid string) ReservationApiDeleteReservationLinksByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteReservationLinksByExtIdRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteReservationLinksByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteReservationLinksByExtIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteReservationLinksByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteReservationLinksByExtIdRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationLinksByExtIdExecute(r)
}

/*
DeleteReservationLinksByExtId Remove Reservation Links

Use this API to unlink a reservation from its currently associated reservation. <p><strong>OperationId:</strong>deleteReservationLinksByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationExternalId External reservation ID.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteReservationLinksByExtIdRequest
*/
func (a *ReservationApiService) DeleteReservationLinksByExtId(ctx context.Context, reservationExternalId string, externalSystemCode string, hotelId string) ReservationApiDeleteReservationLinksByExtIdRequest {
	return ReservationApiDeleteReservationLinksByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationExternalId: reservationExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteReservationLinksByExtIdExecute(r ReservationApiDeleteReservationLinksByExtIdRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteReservationLinksByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/reservations/linkedReservations/{reservationExternalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationExternalId"+"}", url.PathEscape(parameterValueToString(r.reservationExternalId, "reservationExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationExternalId) < 1 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have at least 1 elements")
	}
	if strlen(r.reservationExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteReservationLocatorsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	locatorId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteReservationLocatorsRequest) Authorization(authorization string) ReservationApiDeleteReservationLocatorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteReservationLocatorsRequest) XAppKey(xAppKey string) ReservationApiDeleteReservationLocatorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteReservationLocatorsRequest) XHotelid(xHotelid string) ReservationApiDeleteReservationLocatorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteReservationLocatorsRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteReservationLocatorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteReservationLocatorsRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteReservationLocatorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteReservationLocatorsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationLocatorsExecute(r)
}

/*
DeleteReservationLocators Remove Reservation Locators

Delete a Guest Locater for a Reservation. <p><strong>OperationId:</strong>deleteReservationLocators</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locatorId
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteReservationLocatorsRequest
*/
func (a *ReservationApiService) DeleteReservationLocators(ctx context.Context, locatorId string, reservationId string, hotelId string) ReservationApiDeleteReservationLocatorsRequest {
	return ReservationApiDeleteReservationLocatorsRequest{
		ApiService: a,
		ctx: ctx,
		locatorId: locatorId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteReservationLocatorsExecute(r ReservationApiDeleteReservationLocatorsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteReservationLocators")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/guestLocators/{locatorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"locatorId"+"}", url.PathEscape(parameterValueToString(r.locatorId, "locatorId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.locatorId) < 1 {
		return localVarReturnValue, nil, reportError("locatorId must have at least 1 elements")
	}
	if strlen(r.locatorId) > 2000 {
		return localVarReturnValue, nil, reportError("locatorId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteReservationLockRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	lockHandle string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteReservationLockRequest) Authorization(authorization string) ReservationApiDeleteReservationLockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteReservationLockRequest) XAppKey(xAppKey string) ReservationApiDeleteReservationLockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteReservationLockRequest) XHotelid(xHotelid string) ReservationApiDeleteReservationLockRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteReservationLockRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteReservationLockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteReservationLockRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteReservationLockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteReservationLockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationLockExecute(r)
}

/*
DeleteReservationLock Release Reservation Lock

Release Reservation Lock. <p><strong>OperationId:</strong>deleteReservationLock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lockHandle Lock handle of the lock to be released.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteReservationLockRequest
*/
func (a *ReservationApiService) DeleteReservationLock(ctx context.Context, lockHandle string, hotelId string) ReservationApiDeleteReservationLockRequest {
	return ReservationApiDeleteReservationLockRequest{
		ApiService: a,
		ctx: ctx,
		lockHandle: lockHandle,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteReservationLockExecute(r ReservationApiDeleteReservationLockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteReservationLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/locks/{lockHandle}"
	localVarPath = strings.Replace(localVarPath, "{"+"lockHandle"+"}", url.PathEscape(parameterValueToString(r.lockHandle, "lockHandle")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.lockHandle) < 1 {
		return localVarReturnValue, nil, reportError("lockHandle must have at least 1 elements")
	}
	if strlen(r.lockHandle) > 2000 {
		return localVarReturnValue, nil, reportError("lockHandle must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteReservationMembershipRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteReservationMembershipRequest) Authorization(authorization string) ReservationApiDeleteReservationMembershipRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteReservationMembershipRequest) XAppKey(xAppKey string) ReservationApiDeleteReservationMembershipRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteReservationMembershipRequest) XHotelid(xHotelid string) ReservationApiDeleteReservationMembershipRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteReservationMembershipRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteReservationMembershipRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteReservationMembershipRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteReservationMembershipRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteReservationMembershipRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationMembershipExecute(r)
}

/*
DeleteReservationMembership Delete a Reservation membership

Delete a membership from an existing reservation. <p><strong>OperationId:</strong>deleteReservationMembership</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteReservationMembershipRequest
*/
func (a *ReservationApiService) DeleteReservationMembership(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteReservationMembershipRequest {
	return ReservationApiDeleteReservationMembershipRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteReservationMembershipExecute(r ReservationApiDeleteReservationMembershipRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteReservationMembership")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/memberships"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteReservationPackageRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteReservationPackageRequest) Authorization(authorization string) ReservationApiDeleteReservationPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteReservationPackageRequest) XAppKey(xAppKey string) ReservationApiDeleteReservationPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteReservationPackageRequest) XHotelid(xHotelid string) ReservationApiDeleteReservationPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteReservationPackageRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteReservationPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteReservationPackageRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteReservationPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteReservationPackageRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationPackageExecute(r)
}

/*
DeleteReservationPackage Delete a package from a Reservation

This API will allow you to delete packages from a reservation. <p><strong>OperationId:</strong>deleteReservationPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteReservationPackageRequest
*/
func (a *ReservationApiService) DeleteReservationPackage(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteReservationPackageRequest {
	return ReservationApiDeleteReservationPackageRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteReservationPackageExecute(r ReservationApiDeleteReservationPackageRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteReservationPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/packages"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteReservationPreferenceRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	preferenceCode string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteReservationPreferenceRequest) Authorization(authorization string) ReservationApiDeleteReservationPreferenceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteReservationPreferenceRequest) XAppKey(xAppKey string) ReservationApiDeleteReservationPreferenceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteReservationPreferenceRequest) XHotelid(xHotelid string) ReservationApiDeleteReservationPreferenceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteReservationPreferenceRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteReservationPreferenceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteReservationPreferenceRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteReservationPreferenceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteReservationPreferenceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationPreferenceExecute(r)
}

/*
DeleteReservationPreference Delete a Reservation Preference

You can use this API to remove a preference that exist on a reservation. <p><strong>OperationId:</strong>deleteReservationPreference</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param preferenceCode Preference Code
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteReservationPreferenceRequest
*/
func (a *ReservationApiService) DeleteReservationPreference(ctx context.Context, preferenceCode string, reservationId string, hotelId string) ReservationApiDeleteReservationPreferenceRequest {
	return ReservationApiDeleteReservationPreferenceRequest{
		ApiService: a,
		ctx: ctx,
		preferenceCode: preferenceCode,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteReservationPreferenceExecute(r ReservationApiDeleteReservationPreferenceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteReservationPreference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/preferences/{preferenceCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"preferenceCode"+"}", url.PathEscape(parameterValueToString(r.preferenceCode, "preferenceCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.preferenceCode) < 1 {
		return localVarReturnValue, nil, reportError("preferenceCode must have at least 1 elements")
	}
	if strlen(r.preferenceCode) > 2000 {
		return localVarReturnValue, nil, reportError("preferenceCode must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteReservedInventoryItemsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteReservedInventoryItemsRequest) Authorization(authorization string) ReservationApiDeleteReservedInventoryItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteReservedInventoryItemsRequest) XAppKey(xAppKey string) ReservationApiDeleteReservedInventoryItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteReservedInventoryItemsRequest) XHotelid(xHotelid string) ReservationApiDeleteReservedInventoryItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteReservedInventoryItemsRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteReservedInventoryItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteReservedInventoryItemsRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteReservedInventoryItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteReservedInventoryItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservedInventoryItemsExecute(r)
}

/*
DeleteReservedInventoryItems Delete Reserved Inventory Items

Delete the Inventory Items reserved for the Reservation. <p><strong>OperationId:</strong>deleteReservedInventoryItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteReservedInventoryItemsRequest
*/
func (a *ReservationApiService) DeleteReservedInventoryItems(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteReservedInventoryItemsRequest {
	return ReservationApiDeleteReservedInventoryItemsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteReservedInventoryItemsExecute(r ReservationApiDeleteReservedInventoryItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteReservedInventoryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/inventoryItems"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteRoutingInstructionsRequest) Authorization(authorization string) ReservationApiDeleteRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteRoutingInstructionsRequest) XAppKey(xAppKey string) ReservationApiDeleteRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteRoutingInstructionsRequest) XHotelid(xHotelid string) ReservationApiDeleteRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteRoutingInstructionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRoutingInstructionsExecute(r)
}

/*
DeleteRoutingInstructions Delete routing instructions

You can use this API to delete routing instructions from a reservation. <p><strong>OperationId:</strong>deleteRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteRoutingInstructionsRequest

Deprecated
*/
func (a *ReservationApiService) DeleteRoutingInstructions(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteRoutingInstructionsRequest {
	return ReservationApiDeleteRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *ReservationApiService) DeleteRoutingInstructionsExecute(r ReservationApiDeleteRoutingInstructionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteSellMessageConfigRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteSellMessageConfigRequest) Authorization(authorization string) ReservationApiDeleteSellMessageConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteSellMessageConfigRequest) XAppKey(xAppKey string) ReservationApiDeleteSellMessageConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteSellMessageConfigRequest) XHotelid(xHotelid string) ReservationApiDeleteSellMessageConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteSellMessageConfigRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteSellMessageConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteSellMessageConfigRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteSellMessageConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteSellMessageConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteSellMessageConfigExecute(r)
}

/*
DeleteSellMessageConfig Delete sell message

Delete an existing sell message configuration for a property. <p><strong>OperationId:</strong>deleteSellMessageConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteSellMessageConfigRequest
*/
func (a *ReservationApiService) DeleteSellMessageConfig(ctx context.Context, hotelId string) ReservationApiDeleteSellMessageConfigRequest {
	return ReservationApiDeleteSellMessageConfigRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteSellMessageConfigExecute(r ReservationApiDeleteSellMessageConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteSellMessageConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sellMessages/config"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteSellMessageConfigByChainRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	sellMessageConfigId *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteSellMessageConfigByChainRequest) Authorization(authorization string) ReservationApiDeleteSellMessageConfigByChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteSellMessageConfigByChainRequest) XAppKey(xAppKey string) ReservationApiDeleteSellMessageConfigByChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteSellMessageConfigByChainRequest) XHotelid(xHotelid string) ReservationApiDeleteSellMessageConfigByChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiDeleteSellMessageConfigByChainRequest) SellMessageConfigId(sellMessageConfigId []string) ReservationApiDeleteSellMessageConfigByChainRequest {
	r.sellMessageConfigId = &sellMessageConfigId
	return r
}

// External system code.
func (r ReservationApiDeleteSellMessageConfigByChainRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteSellMessageConfigByChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteSellMessageConfigByChainRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteSellMessageConfigByChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteSellMessageConfigByChainRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteSellMessageConfigByChainExecute(r)
}

/*
DeleteSellMessageConfigByChain Delete sell message by chain

Delete an existing sell message configuration. <p><strong>OperationId:</strong>deleteSellMessageConfigByChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationApiDeleteSellMessageConfigByChainRequest
*/
func (a *ReservationApiService) DeleteSellMessageConfigByChain(ctx context.Context) ReservationApiDeleteSellMessageConfigByChainRequest {
	return ReservationApiDeleteSellMessageConfigByChainRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteSellMessageConfigByChainExecute(r ReservationApiDeleteSellMessageConfigByChainRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteSellMessageConfigByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sellMessages/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sellMessageConfigId != nil {
		t := *r.sellMessageConfigId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sellMessageConfigId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sellMessageConfigId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteShareReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	overrideInventoryCheck *bool
	overrideMaxOccupancyCheck *bool
	overrideRateAvailabilityCheck *bool
	returnShareReservations *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteShareReservationRequest) Authorization(authorization string) ReservationApiDeleteShareReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteShareReservationRequest) XAppKey(xAppKey string) ReservationApiDeleteShareReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteShareReservationRequest) XHotelid(xHotelid string) ReservationApiDeleteShareReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicate to Override the Room Inventory Check if applicable.
func (r ReservationApiDeleteShareReservationRequest) OverrideInventoryCheck(overrideInventoryCheck bool) ReservationApiDeleteShareReservationRequest {
	r.overrideInventoryCheck = &overrideInventoryCheck
	return r
}

// Indicate to Override the check on Maximum Room Occupancy if applicable.
func (r ReservationApiDeleteShareReservationRequest) OverrideMaxOccupancyCheck(overrideMaxOccupancyCheck bool) ReservationApiDeleteShareReservationRequest {
	r.overrideMaxOccupancyCheck = &overrideMaxOccupancyCheck
	return r
}

// Indicate to Override the check on Maximum Room Occupancy if applicable.
func (r ReservationApiDeleteShareReservationRequest) OverrideRateAvailabilityCheck(overrideRateAvailabilityCheck bool) ReservationApiDeleteShareReservationRequest {
	r.overrideRateAvailabilityCheck = &overrideRateAvailabilityCheck
	return r
}

// After the break share operation, return the new list of Sharer Reservations.
func (r ReservationApiDeleteShareReservationRequest) ReturnShareReservations(returnShareReservations bool) ReservationApiDeleteShareReservationRequest {
	r.returnShareReservations = &returnShareReservations
	return r
}

// External system code.
func (r ReservationApiDeleteShareReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteShareReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteShareReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteShareReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteShareReservationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteShareReservationExecute(r)
}

/*
DeleteShareReservation Separate share Reservations

This API can be used to separate the share reservations. <p><strong>OperationId:</strong>deleteShareReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteShareReservationRequest
*/
func (a *ReservationApiService) DeleteShareReservation(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteShareReservationRequest {
	return ReservationApiDeleteShareReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteShareReservationExecute(r ReservationApiDeleteShareReservationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteShareReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/shares"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.overrideInventoryCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideInventoryCheck", r.overrideInventoryCheck, "")
	}
	if r.overrideMaxOccupancyCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideMaxOccupancyCheck", r.overrideMaxOccupancyCheck, "")
	}
	if r.overrideRateAvailabilityCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideRateAvailabilityCheck", r.overrideRateAvailabilityCheck, "")
	}
	if r.returnShareReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnShareReservations", r.returnShareReservations, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteShareReservationByExtIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	overrideInventoryCheck *bool
	overrideMaxOccupancyCheck *bool
	overrideRateAvailabilityCheck *bool
	returnShareReservations *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteShareReservationByExtIdRequest) Authorization(authorization string) ReservationApiDeleteShareReservationByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteShareReservationByExtIdRequest) XAppKey(xAppKey string) ReservationApiDeleteShareReservationByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteShareReservationByExtIdRequest) XHotelid(xHotelid string) ReservationApiDeleteShareReservationByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicate to Override the Room Inventory Check if applicable.
func (r ReservationApiDeleteShareReservationByExtIdRequest) OverrideInventoryCheck(overrideInventoryCheck bool) ReservationApiDeleteShareReservationByExtIdRequest {
	r.overrideInventoryCheck = &overrideInventoryCheck
	return r
}

// Indicate to Override the check on Maximum Room Occupancy if applicable.
func (r ReservationApiDeleteShareReservationByExtIdRequest) OverrideMaxOccupancyCheck(overrideMaxOccupancyCheck bool) ReservationApiDeleteShareReservationByExtIdRequest {
	r.overrideMaxOccupancyCheck = &overrideMaxOccupancyCheck
	return r
}

// Indicate to Override the check on Maximum Room Occupancy if applicable.
func (r ReservationApiDeleteShareReservationByExtIdRequest) OverrideRateAvailabilityCheck(overrideRateAvailabilityCheck bool) ReservationApiDeleteShareReservationByExtIdRequest {
	r.overrideRateAvailabilityCheck = &overrideRateAvailabilityCheck
	return r
}

// After the break share operation, return the new list of Sharer Reservations.
func (r ReservationApiDeleteShareReservationByExtIdRequest) ReturnShareReservations(returnShareReservations bool) ReservationApiDeleteShareReservationByExtIdRequest {
	r.returnShareReservations = &returnShareReservations
	return r
}

// External system code.
func (r ReservationApiDeleteShareReservationByExtIdRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteShareReservationByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteShareReservationByExtIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteShareReservationByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteShareReservationByExtIdRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteShareReservationByExtIdExecute(r)
}

/*
DeleteShareReservationByExtId Separate share Reservations

This API can be used to separate the share reservations. <p><strong>OperationId:</strong>deleteShareReservationByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationExternalId External reservation ID.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteShareReservationByExtIdRequest
*/
func (a *ReservationApiService) DeleteShareReservationByExtId(ctx context.Context, reservationExternalId string, externalSystemCode string, hotelId string) ReservationApiDeleteShareReservationByExtIdRequest {
	return ReservationApiDeleteShareReservationByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationExternalId: reservationExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteShareReservationByExtIdExecute(r ReservationApiDeleteShareReservationByExtIdRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteShareReservationByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/reservations/{reservationExternalId}/shares"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationExternalId"+"}", url.PathEscape(parameterValueToString(r.reservationExternalId, "reservationExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationExternalId) < 1 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have at least 1 elements")
	}
	if strlen(r.reservationExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.overrideInventoryCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideInventoryCheck", r.overrideInventoryCheck, "")
	}
	if r.overrideMaxOccupancyCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideMaxOccupancyCheck", r.overrideMaxOccupancyCheck, "")
	}
	if r.overrideRateAvailabilityCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideRateAvailabilityCheck", r.overrideRateAvailabilityCheck, "")
	}
	if r.returnShareReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnShareReservations", r.returnShareReservations, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteTicketsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteTicketsRequest) Authorization(authorization string) ReservationApiDeleteTicketsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteTicketsRequest) XAppKey(xAppKey string) ReservationApiDeleteTicketsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteTicketsRequest) XHotelid(xHotelid string) ReservationApiDeleteTicketsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteTicketsRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteTicketsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteTicketsRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteTicketsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteTicketsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTicketsExecute(r)
}

/*
DeleteTickets Delete tickets

You can use this API to delete tickets from a reservation. <p><strong>OperationId:</strong>deleteTickets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteTicketsRequest
*/
func (a *ReservationApiService) DeleteTickets(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteTicketsRequest {
	return ReservationApiDeleteTicketsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteTicketsExecute(r ReservationApiDeleteTicketsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteTickets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/tickets"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteTransactionDiversionsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteTransactionDiversionsRequest) Authorization(authorization string) ReservationApiDeleteTransactionDiversionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteTransactionDiversionsRequest) XAppKey(xAppKey string) ReservationApiDeleteTransactionDiversionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteTransactionDiversionsRequest) XHotelid(xHotelid string) ReservationApiDeleteTransactionDiversionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteTransactionDiversionsRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteTransactionDiversionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteTransactionDiversionsRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteTransactionDiversionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteTransactionDiversionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTransactionDiversionsExecute(r)
}

/*
DeleteTransactionDiversions Delete Transaction Diversions 

You can use this API to delete Transaction Diversions. <p><strong>OperationId:</strong>deleteTransactionDiversions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteTransactionDiversionsRequest
*/
func (a *ReservationApiService) DeleteTransactionDiversions(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteTransactionDiversionsRequest {
	return ReservationApiDeleteTransactionDiversionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteTransactionDiversionsExecute(r ReservationApiDeleteTransactionDiversionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteTransactionDiversions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/transactionDiversions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiDeleteUpsellRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiDeleteUpsellRequest) Authorization(authorization string) ReservationApiDeleteUpsellRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiDeleteUpsellRequest) XAppKey(xAppKey string) ReservationApiDeleteUpsellRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiDeleteUpsellRequest) XHotelid(xHotelid string) ReservationApiDeleteUpsellRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiDeleteUpsellRequest) XExternalsystem(xExternalsystem string) ReservationApiDeleteUpsellRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiDeleteUpsellRequest) AcceptLanguage(acceptLanguage string) ReservationApiDeleteUpsellRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiDeleteUpsellRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteUpsellExecute(r)
}

/*
DeleteUpsell Delete a Reservation Upsell

This API will enable you to delete an upsell from a reservation. There may be reservation policies that might prevent an upsell from being deleted and as such an appropriate response will be returned. <p><strong>OperationId:</strong>deleteUpsell</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiDeleteUpsellRequest
*/
func (a *ReservationApiService) DeleteUpsell(ctx context.Context, reservationId string, hotelId string) ReservationApiDeleteUpsellRequest {
	return ReservationApiDeleteUpsellRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) DeleteUpsellExecute(r ReservationApiDeleteUpsellRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.DeleteUpsell")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/upsell"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetAlertNoticesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	alertArea *string
	welcomeOffer *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetAlertNoticesRequest) Authorization(authorization string) ReservationApiGetAlertNoticesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetAlertNoticesRequest) XAppKey(xAppKey string) ReservationApiGetAlertNoticesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetAlertNoticesRequest) XHotelid(xHotelid string) ReservationApiGetAlertNoticesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ReservationApiGetAlertNoticesRequest) AlertArea(alertArea string) ReservationApiGetAlertNoticesRequest {
	r.alertArea = &alertArea
	return r
}

// Determines whether to fetch Global Alert Notices or Welcome Offer Alert Notice.
func (r ReservationApiGetAlertNoticesRequest) WelcomeOffer(welcomeOffer bool) ReservationApiGetAlertNoticesRequest {
	r.welcomeOffer = &welcomeOffer
	return r
}

// External system code.
func (r ReservationApiGetAlertNoticesRequest) XExternalsystem(xExternalsystem string) ReservationApiGetAlertNoticesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetAlertNoticesRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetAlertNoticesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetAlertNoticesRequest) Execute() (*Alerts, *http.Response, error) {
	return r.ApiService.GetAlertNoticesExecute(r)
}

/*
GetAlertNotices Fetch Alert Notices

Get the alert notices including global alerts for a reservation. <p><strong>OperationId:</strong>getAlertNotices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetAlertNoticesRequest
*/
func (a *ReservationApiService) GetAlertNotices(ctx context.Context, reservationId string, hotelId string) ReservationApiGetAlertNoticesRequest {
	return ReservationApiGetAlertNoticesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Alerts
func (a *ReservationApiService) GetAlertNoticesExecute(r ReservationApiGetAlertNoticesRequest) (*Alerts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Alerts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetAlertNotices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/alerts"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.alertArea != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alertArea", r.alertArea, "")
	}
	if r.welcomeOffer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "welcomeOffer", r.welcomeOffer, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetAwardUpgradesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileId *string
	idContext *string
	profileIdType *string
	membershipType *string
	membershipCardNo *string
	membershipPoints *int32
	id *[]string
	reservationTimeSpanStartDate *string
	reservationTimeSpanEndDate *string
	reservationTimeSpanDuration *string
	numberOfRooms *int32
	roomType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetAwardUpgradesRequest) Authorization(authorization string) ReservationApiGetAwardUpgradesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetAwardUpgradesRequest) XAppKey(xAppKey string) ReservationApiGetAwardUpgradesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetAwardUpgradesRequest) XHotelid(xHotelid string) ReservationApiGetAwardUpgradesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetAwardUpgradesRequest) ProfileId(profileId string) ReservationApiGetAwardUpgradesRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ReservationApiGetAwardUpgradesRequest) IdContext(idContext string) ReservationApiGetAwardUpgradesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetAwardUpgradesRequest) ProfileIdType(profileIdType string) ReservationApiGetAwardUpgradesRequest {
	r.profileIdType = &profileIdType
	return r
}

// The type of the membership.
func (r ReservationApiGetAwardUpgradesRequest) MembershipType(membershipType string) ReservationApiGetAwardUpgradesRequest {
	r.membershipType = &membershipType
	return r
}

// The card number associated with this membership.
func (r ReservationApiGetAwardUpgradesRequest) MembershipCardNo(membershipCardNo string) ReservationApiGetAwardUpgradesRequest {
	r.membershipCardNo = &membershipCardNo
	return r
}

// Current membership points available for this guest.
func (r ReservationApiGetAwardUpgradesRequest) MembershipPoints(membershipPoints int32) ReservationApiGetAwardUpgradesRequest {
	r.membershipPoints = &membershipPoints
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetAwardUpgradesRequest) Id(id []string) ReservationApiGetAwardUpgradesRequest {
	r.id = &id
	return r
}

func (r ReservationApiGetAwardUpgradesRequest) ReservationTimeSpanStartDate(reservationTimeSpanStartDate string) ReservationApiGetAwardUpgradesRequest {
	r.reservationTimeSpanStartDate = &reservationTimeSpanStartDate
	return r
}

func (r ReservationApiGetAwardUpgradesRequest) ReservationTimeSpanEndDate(reservationTimeSpanEndDate string) ReservationApiGetAwardUpgradesRequest {
	r.reservationTimeSpanEndDate = &reservationTimeSpanEndDate
	return r
}

func (r ReservationApiGetAwardUpgradesRequest) ReservationTimeSpanDuration(reservationTimeSpanDuration string) ReservationApiGetAwardUpgradesRequest {
	r.reservationTimeSpanDuration = &reservationTimeSpanDuration
	return r
}

// The number of rooms.
func (r ReservationApiGetAwardUpgradesRequest) NumberOfRooms(numberOfRooms int32) ReservationApiGetAwardUpgradesRequest {
	r.numberOfRooms = &numberOfRooms
	return r
}

// Room type associated with the reservation.
func (r ReservationApiGetAwardUpgradesRequest) RoomType(roomType string) ReservationApiGetAwardUpgradesRequest {
	r.roomType = &roomType
	return r
}

// External system code.
func (r ReservationApiGetAwardUpgradesRequest) XExternalsystem(xExternalsystem string) ReservationApiGetAwardUpgradesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetAwardUpgradesRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetAwardUpgradesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetAwardUpgradesRequest) Execute() (*AwardUpgrades, *http.Response, error) {
	return r.ApiService.GetAwardUpgradesExecute(r)
}

/*
GetAwardUpgrades Get Award Upgrades

Get award upgrades for a specific property. <p><strong>OperationId:</strong>getAwardUpgrades</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetAwardUpgradesRequest
*/
func (a *ReservationApiService) GetAwardUpgrades(ctx context.Context, hotelId string) ReservationApiGetAwardUpgradesRequest {
	return ReservationApiGetAwardUpgradesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AwardUpgrades
func (a *ReservationApiService) GetAwardUpgradesExecute(r ReservationApiGetAwardUpgradesRequest) (*AwardUpgrades, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AwardUpgrades
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetAwardUpgrades")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/awardUpgrades"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
	}
	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
	}
	if r.membershipCardNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipCardNo", r.membershipCardNo, "")
	}
	if r.membershipPoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipPoints", r.membershipPoints, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.reservationTimeSpanStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationTimeSpanStartDate", r.reservationTimeSpanStartDate, "")
	}
	if r.reservationTimeSpanEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationTimeSpanEndDate", r.reservationTimeSpanEndDate, "")
	}
	if r.reservationTimeSpanDuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationTimeSpanDuration", r.reservationTimeSpanDuration, "")
	}
	if r.numberOfRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfRooms", r.numberOfRooms, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetAwardsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetAwardsRequest) Authorization(authorization string) ReservationApiGetAwardsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetAwardsRequest) XAppKey(xAppKey string) ReservationApiGetAwardsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetAwardsRequest) XHotelid(xHotelid string) ReservationApiGetAwardsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetAwardsRequest) ReservationId(reservationId string) ReservationApiGetAwardsRequest {
	r.reservationId = &reservationId
	return r
}

// External system code.
func (r ReservationApiGetAwardsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetAwardsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetAwardsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetAwardsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetAwardsRequest) Execute() (*ReservationAwards, *http.Response, error) {
	return r.ApiService.GetAwardsExecute(r)
}

/*
GetAwards Fetch Awards

Get certificates and awards associated with the Reservation. <p><strong>OperationId:</strong>getAwards</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetAwardsRequest
*/
func (a *ReservationApiService) GetAwards(ctx context.Context, hotelId string) ReservationApiGetAwardsRequest {
	return ReservationApiGetAwardsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationAwards
func (a *ReservationApiService) GetAwardsExecute(r ReservationApiGetAwardsRequest) (*ReservationAwards, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationAwards
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetAwards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/awards"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetCallHistoryRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetCallHistoryRequest) Authorization(authorization string) ReservationApiGetCallHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetCallHistoryRequest) XAppKey(xAppKey string) ReservationApiGetCallHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetCallHistoryRequest) XHotelid(xHotelid string) ReservationApiGetCallHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiGetCallHistoryRequest) XExternalsystem(xExternalsystem string) ReservationApiGetCallHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetCallHistoryRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetCallHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetCallHistoryRequest) Execute() (*CallHistory, *http.Response, error) {
	return r.ApiService.GetCallHistoryExecute(r)
}

/*
GetCallHistory Get the Reservation Call History

Get the Reservation Call History <p><strong>OperationId:</strong>getCallHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetCallHistoryRequest
*/
func (a *ReservationApiService) GetCallHistory(ctx context.Context, reservationId string, hotelId string) ReservationApiGetCallHistoryRequest {
	return ReservationApiGetCallHistoryRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CallHistory
func (a *ReservationApiService) GetCallHistoryExecute(r ReservationApiGetCallHistoryRequest) (*CallHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetCallHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/calls"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetCallStatisticsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	end *string
	start *string
	domain *string
	appUserName *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetCallStatisticsRequest) Authorization(authorization string) ReservationApiGetCallStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetCallStatisticsRequest) XAppKey(xAppKey string) ReservationApiGetCallStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetCallStatisticsRequest) XHotelid(xHotelid string) ReservationApiGetCallStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The ending value of the date range.
func (r ReservationApiGetCallStatisticsRequest) End(end string) ReservationApiGetCallStatisticsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r ReservationApiGetCallStatisticsRequest) Start(start string) ReservationApiGetCallStatisticsRequest {
	r.start = &start
	return r
}

func (r ReservationApiGetCallStatisticsRequest) Domain(domain string) ReservationApiGetCallStatisticsRequest {
	r.domain = &domain
	return r
}

func (r ReservationApiGetCallStatisticsRequest) AppUserName(appUserName []string) ReservationApiGetCallStatisticsRequest {
	r.appUserName = &appUserName
	return r
}

// External system code.
func (r ReservationApiGetCallStatisticsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetCallStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetCallStatisticsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetCallStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetCallStatisticsRequest) Execute() (*CallStatistics, *http.Response, error) {
	return r.ApiService.GetCallStatisticsExecute(r)
}

/*
GetCallStatistics Get call statistics

Use this API to get call statistics. <p><strong>OperationId:</strong>getCallStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationApiGetCallStatisticsRequest
*/
func (a *ReservationApiService) GetCallStatistics(ctx context.Context) ReservationApiGetCallStatisticsRequest {
	return ReservationApiGetCallStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CallStatistics
func (a *ReservationApiService) GetCallStatisticsExecute(r ReservationApiGetCallStatisticsRequest) (*CallStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CallStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetCallStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.appUserName != nil {
		t := *r.appUserName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "appUserName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "appUserName", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetCancellationHistoryRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelName *string
	roomStayStartDate *string
	roomStayEndDate *string
	roomStayDuration *string
	roomClass *string
	roomType *string
	numberOfRooms *int32
	roomId *string
	ratePlanCode *string
	reservationBlockHotelId *string
	reservationBlockId *[]string
	reservationBlockIdType *[]string
	blockName *string
	bookingChannelCode *string
	linkCode *string
	onHold *bool
	membershipAccountId *string
	membershipBonusCode *string
	membershipLevel *string
	membershipId *float32
	lastStayDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetCancellationHistoryRequest) Authorization(authorization string) ReservationApiGetCancellationHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetCancellationHistoryRequest) XAppKey(xAppKey string) ReservationApiGetCancellationHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetCancellationHistoryRequest) XHotelid(xHotelid string) ReservationApiGetCancellationHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ReservationApiGetCancellationHistoryRequest) HotelName(hotelName string) ReservationApiGetCancellationHistoryRequest {
	r.hotelName = &hotelName
	return r
}

func (r ReservationApiGetCancellationHistoryRequest) RoomStayStartDate(roomStayStartDate string) ReservationApiGetCancellationHistoryRequest {
	r.roomStayStartDate = &roomStayStartDate
	return r
}

func (r ReservationApiGetCancellationHistoryRequest) RoomStayEndDate(roomStayEndDate string) ReservationApiGetCancellationHistoryRequest {
	r.roomStayEndDate = &roomStayEndDate
	return r
}

func (r ReservationApiGetCancellationHistoryRequest) RoomStayDuration(roomStayDuration string) ReservationApiGetCancellationHistoryRequest {
	r.roomStayDuration = &roomStayDuration
	return r
}

// Room class code
func (r ReservationApiGetCancellationHistoryRequest) RoomClass(roomClass string) ReservationApiGetCancellationHistoryRequest {
	r.roomClass = &roomClass
	return r
}

// Room type code
func (r ReservationApiGetCancellationHistoryRequest) RoomType(roomType string) ReservationApiGetCancellationHistoryRequest {
	r.roomType = &roomType
	return r
}

// Room Id
func (r ReservationApiGetCancellationHistoryRequest) NumberOfRooms(numberOfRooms int32) ReservationApiGetCancellationHistoryRequest {
	r.numberOfRooms = &numberOfRooms
	return r
}

// Room Id
func (r ReservationApiGetCancellationHistoryRequest) RoomId(roomId string) ReservationApiGetCancellationHistoryRequest {
	r.roomId = &roomId
	return r
}

// Rate plan code
func (r ReservationApiGetCancellationHistoryRequest) RatePlanCode(ratePlanCode string) ReservationApiGetCancellationHistoryRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// This is the HotelCode of the Block.
func (r ReservationApiGetCancellationHistoryRequest) ReservationBlockHotelId(reservationBlockHotelId string) ReservationApiGetCancellationHistoryRequest {
	r.reservationBlockHotelId = &reservationBlockHotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetCancellationHistoryRequest) ReservationBlockId(reservationBlockId []string) ReservationApiGetCancellationHistoryRequest {
	r.reservationBlockId = &reservationBlockId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetCancellationHistoryRequest) ReservationBlockIdType(reservationBlockIdType []string) ReservationApiGetCancellationHistoryRequest {
	r.reservationBlockIdType = &reservationBlockIdType
	return r
}

// The Name of the block that is attached to the reservation.
func (r ReservationApiGetCancellationHistoryRequest) BlockName(blockName string) ReservationApiGetCancellationHistoryRequest {
	r.blockName = &blockName
	return r
}

// Booking channel code
func (r ReservationApiGetCancellationHistoryRequest) BookingChannelCode(bookingChannelCode string) ReservationApiGetCancellationHistoryRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

// Party code
func (r ReservationApiGetCancellationHistoryRequest) LinkCode(linkCode string) ReservationApiGetCancellationHistoryRequest {
	r.linkCode = &linkCode
	return r
}

// Guarantee Code.
func (r ReservationApiGetCancellationHistoryRequest) OnHold(onHold bool) ReservationApiGetCancellationHistoryRequest {
	r.onHold = &onHold
	return r
}

// The account identification number for this particular member in this particular program.
func (r ReservationApiGetCancellationHistoryRequest) MembershipAccountId(membershipAccountId string) ReservationApiGetCancellationHistoryRequest {
	r.membershipAccountId = &membershipAccountId
	return r
}

// The code or name of the bonus program. BonusCode can be used to indicate the level of membership (Gold Club, Platinum member, etc.)
func (r ReservationApiGetCancellationHistoryRequest) MembershipBonusCode(membershipBonusCode string) ReservationApiGetCancellationHistoryRequest {
	r.membershipBonusCode = &membershipBonusCode
	return r
}

// The code or name of the membership level and indicates the level of membership (Gold Club, Platinum member, etc.). This is same as the BonusCode.
func (r ReservationApiGetCancellationHistoryRequest) MembershipLevel(membershipLevel string) ReservationApiGetCancellationHistoryRequest {
	r.membershipLevel = &membershipLevel
	return r
}

// Membership ID (Unique ID from the memberships table).
func (r ReservationApiGetCancellationHistoryRequest) MembershipId(membershipId float32) ReservationApiGetCancellationHistoryRequest {
	r.membershipId = &membershipId
	return r
}

// Guest&#39;s last stay date.
func (r ReservationApiGetCancellationHistoryRequest) LastStayDate(lastStayDate string) ReservationApiGetCancellationHistoryRequest {
	r.lastStayDate = &lastStayDate
	return r
}

// External system code.
func (r ReservationApiGetCancellationHistoryRequest) XExternalsystem(xExternalsystem string) ReservationApiGetCancellationHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetCancellationHistoryRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetCancellationHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetCancellationHistoryRequest) Execute() (*CancellationHistory, *http.Response, error) {
	return r.ApiService.GetCancellationHistoryExecute(r)
}

/*
GetCancellationHistory Get cancellation history

Get cancellation history for a reservation. <p><strong>OperationId:</strong>getCancellationHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetCancellationHistoryRequest
*/
func (a *ReservationApiService) GetCancellationHistory(ctx context.Context, reservationId string, hotelId string) ReservationApiGetCancellationHistoryRequest {
	return ReservationApiGetCancellationHistoryRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CancellationHistory
func (a *ReservationApiService) GetCancellationHistoryExecute(r ReservationApiGetCancellationHistoryRequest) (*CancellationHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancellationHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetCancellationHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/cancellationHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelName", r.hotelName, "")
	}
	if r.roomStayStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomStayStartDate", r.roomStayStartDate, "")
	}
	if r.roomStayEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomStayEndDate", r.roomStayEndDate, "")
	}
	if r.roomStayDuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomStayDuration", r.roomStayDuration, "")
	}
	if r.roomClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", r.roomClass, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	if r.numberOfRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfRooms", r.numberOfRooms, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.reservationBlockHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationBlockHotelId", r.reservationBlockHotelId, "")
	}
	if r.reservationBlockId != nil {
		t := *r.reservationBlockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationBlockId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationBlockId", t, "multi")
		}
	}
	if r.reservationBlockIdType != nil {
		t := *r.reservationBlockIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationBlockIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationBlockIdType", t, "multi")
		}
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.bookingChannelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", r.bookingChannelCode, "")
	}
	if r.linkCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkCode", r.linkCode, "")
	}
	if r.onHold != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onHold", r.onHold, "")
	}
	if r.membershipAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipAccountId", r.membershipAccountId, "")
	}
	if r.membershipBonusCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipBonusCode", r.membershipBonusCode, "")
	}
	if r.membershipLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevel", r.membershipLevel, "")
	}
	if r.membershipId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipId", r.membershipId, "")
	}
	if r.lastStayDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastStayDate", r.lastStayDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetConfirmationLettersRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	notAttached *bool
	pending *bool
	sent *bool
	createdOnEndDate *string
	createdOnStartDate *string
	arrivalEndDate *string
	arrivalStartDate *string
	letterStyleId *[]string
	letterStyle *[]string
	letterStyleIdType *[]string
	reservationGuestId *string
	reservationGuestIdType *string
	membershipId *string
	membershipLevelCode *[]string
	membershipTypeCode *[]string
	surname *string
	givenName *string
	blockHotelId *string
	blockId *[]string
	blockIdType *[]string
	blockName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetConfirmationLettersRequest) Authorization(authorization string) ReservationApiGetConfirmationLettersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetConfirmationLettersRequest) XAppKey(xAppKey string) ReservationApiGetConfirmationLettersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetConfirmationLettersRequest) XHotelid(xHotelid string) ReservationApiGetConfirmationLettersRequest {
	r.xHotelid = &xHotelid
	return r
}

// If true then the fetch result will include the reservations that do not have a letter attached to them.
func (r ReservationApiGetConfirmationLettersRequest) NotAttached(notAttached bool) ReservationApiGetConfirmationLettersRequest {
	r.notAttached = &notAttached
	return r
}

// If true then the result will include only the pending confirmation letters.
func (r ReservationApiGetConfirmationLettersRequest) Pending(pending bool) ReservationApiGetConfirmationLettersRequest {
	r.pending = &pending
	return r
}

// If true then the result will include only the confirmation letters that have been sent to the guest.
func (r ReservationApiGetConfirmationLettersRequest) Sent(sent bool) ReservationApiGetConfirmationLettersRequest {
	r.sent = &sent
	return r
}

// The ending value of the date range.
func (r ReservationApiGetConfirmationLettersRequest) CreatedOnEndDate(createdOnEndDate string) ReservationApiGetConfirmationLettersRequest {
	r.createdOnEndDate = &createdOnEndDate
	return r
}

// The starting value of the date range.
func (r ReservationApiGetConfirmationLettersRequest) CreatedOnStartDate(createdOnStartDate string) ReservationApiGetConfirmationLettersRequest {
	r.createdOnStartDate = &createdOnStartDate
	return r
}

// The ending value of the date range.
func (r ReservationApiGetConfirmationLettersRequest) ArrivalEndDate(arrivalEndDate string) ReservationApiGetConfirmationLettersRequest {
	r.arrivalEndDate = &arrivalEndDate
	return r
}

// The starting value of the date range.
func (r ReservationApiGetConfirmationLettersRequest) ArrivalStartDate(arrivalStartDate string) ReservationApiGetConfirmationLettersRequest {
	r.arrivalStartDate = &arrivalStartDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetConfirmationLettersRequest) LetterStyleId(letterStyleId []string) ReservationApiGetConfirmationLettersRequest {
	r.letterStyleId = &letterStyleId
	return r
}

// Name of the confirmation letter style.
func (r ReservationApiGetConfirmationLettersRequest) LetterStyle(letterStyle []string) ReservationApiGetConfirmationLettersRequest {
	r.letterStyle = &letterStyle
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetConfirmationLettersRequest) LetterStyleIdType(letterStyleIdType []string) ReservationApiGetConfirmationLettersRequest {
	r.letterStyleIdType = &letterStyleIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetConfirmationLettersRequest) ReservationGuestId(reservationGuestId string) ReservationApiGetConfirmationLettersRequest {
	r.reservationGuestId = &reservationGuestId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetConfirmationLettersRequest) ReservationGuestIdType(reservationGuestIdType string) ReservationApiGetConfirmationLettersRequest {
	r.reservationGuestIdType = &reservationGuestIdType
	return r
}

// Membership ID criteria.
func (r ReservationApiGetConfirmationLettersRequest) MembershipId(membershipId string) ReservationApiGetConfirmationLettersRequest {
	r.membershipId = &membershipId
	return r
}

func (r ReservationApiGetConfirmationLettersRequest) MembershipLevelCode(membershipLevelCode []string) ReservationApiGetConfirmationLettersRequest {
	r.membershipLevelCode = &membershipLevelCode
	return r
}

func (r ReservationApiGetConfirmationLettersRequest) MembershipTypeCode(membershipTypeCode []string) ReservationApiGetConfirmationLettersRequest {
	r.membershipTypeCode = &membershipTypeCode
	return r
}

// Family name, last name.
func (r ReservationApiGetConfirmationLettersRequest) Surname(surname string) ReservationApiGetConfirmationLettersRequest {
	r.surname = &surname
	return r
}

// Given name, first name or names
func (r ReservationApiGetConfirmationLettersRequest) GivenName(givenName string) ReservationApiGetConfirmationLettersRequest {
	r.givenName = &givenName
	return r
}

// This is the HotelCode of the Block.
func (r ReservationApiGetConfirmationLettersRequest) BlockHotelId(blockHotelId string) ReservationApiGetConfirmationLettersRequest {
	r.blockHotelId = &blockHotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetConfirmationLettersRequest) BlockId(blockId []string) ReservationApiGetConfirmationLettersRequest {
	r.blockId = &blockId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetConfirmationLettersRequest) BlockIdType(blockIdType []string) ReservationApiGetConfirmationLettersRequest {
	r.blockIdType = &blockIdType
	return r
}

// The Name of the block that is attached to the reservation.
func (r ReservationApiGetConfirmationLettersRequest) BlockName(blockName string) ReservationApiGetConfirmationLettersRequest {
	r.blockName = &blockName
	return r
}

// External system code.
func (r ReservationApiGetConfirmationLettersRequest) XExternalsystem(xExternalsystem string) ReservationApiGetConfirmationLettersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetConfirmationLettersRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetConfirmationLettersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetConfirmationLettersRequest) Execute() (*ReservationConfirmationLetters, *http.Response, error) {
	return r.ApiService.GetConfirmationLettersExecute(r)
}

/*
GetConfirmationLetters Fetch Confirmation Letters

Get a list of Reservations for which confirmation letters need to be sent. <p><strong>OperationId:</strong>getConfirmationLetters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetConfirmationLettersRequest
*/
func (a *ReservationApiService) GetConfirmationLetters(ctx context.Context, hotelId string) ReservationApiGetConfirmationLettersRequest {
	return ReservationApiGetConfirmationLettersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationConfirmationLetters
func (a *ReservationApiService) GetConfirmationLettersExecute(r ReservationApiGetConfirmationLettersRequest) (*ReservationConfirmationLetters, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationConfirmationLetters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetConfirmationLetters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/confirmationLetters"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.notAttached != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notAttached", r.notAttached, "")
	}
	if r.pending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pending", r.pending, "")
	}
	if r.sent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sent", r.sent, "")
	}
	if r.createdOnEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOnEndDate", r.createdOnEndDate, "")
	}
	if r.createdOnStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOnStartDate", r.createdOnStartDate, "")
	}
	if r.arrivalEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEndDate", r.arrivalEndDate, "")
	}
	if r.arrivalStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStartDate", r.arrivalStartDate, "")
	}
	if r.letterStyleId != nil {
		t := *r.letterStyleId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "letterStyleId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "letterStyleId", t, "multi")
		}
	}
	if r.letterStyle != nil {
		t := *r.letterStyle
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "letterStyle", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "letterStyle", t, "multi")
		}
	}
	if r.letterStyleIdType != nil {
		t := *r.letterStyleIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "letterStyleIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "letterStyleIdType", t, "multi")
		}
	}
	if r.reservationGuestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestId", r.reservationGuestId, "")
	}
	if r.reservationGuestIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestIdType", r.reservationGuestIdType, "")
	}
	if r.membershipId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipId", r.membershipId, "")
	}
	if r.membershipLevelCode != nil {
		t := *r.membershipLevelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevelCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevelCode", t, "multi")
		}
	}
	if r.membershipTypeCode != nil {
		t := *r.membershipTypeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypeCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypeCode", t, "multi")
		}
	}
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.blockHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockHotelId", r.blockHotelId, "")
	}
	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
	}
	if r.blockIdType != nil {
		t := *r.blockIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", t, "multi")
		}
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetECouponsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetECouponsRequest) Authorization(authorization string) ReservationApiGetECouponsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetECouponsRequest) XAppKey(xAppKey string) ReservationApiGetECouponsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetECouponsRequest) XHotelid(xHotelid string) ReservationApiGetECouponsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationApiGetECouponsRequest) Limit(limit int32) ReservationApiGetECouponsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationApiGetECouponsRequest) Offset(offset int32) ReservationApiGetECouponsRequest {
	r.offset = &offset
	return r
}

// External system code.
func (r ReservationApiGetECouponsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetECouponsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetECouponsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetECouponsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetECouponsRequest) Execute() (*ECoupons, *http.Response, error) {
	return r.ApiService.GetECouponsExecute(r)
}

/*
GetECoupons Get Reservation Ecoupons

Get the Reservation Ecoupons. <p><strong>OperationId:</strong>getECoupons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetECouponsRequest
*/
func (a *ReservationApiService) GetECoupons(ctx context.Context, reservationId string, hotelId string) ReservationApiGetECouponsRequest {
	return ReservationApiGetECouponsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ECoupons
func (a *ReservationApiService) GetECouponsExecute(r ReservationApiGetECouponsRequest) (*ECoupons, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECoupons
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetECoupons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/eCoupons"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetExternalSystemDeliveryHistoryRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationId *string
	reservationIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetExternalSystemDeliveryHistoryRequest) Authorization(authorization string) ReservationApiGetExternalSystemDeliveryHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetExternalSystemDeliveryHistoryRequest) XAppKey(xAppKey string) ReservationApiGetExternalSystemDeliveryHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetExternalSystemDeliveryHistoryRequest) XHotelid(xHotelid string) ReservationApiGetExternalSystemDeliveryHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemDeliveryHistoryRequest) ReservationId(reservationId string) ReservationApiGetExternalSystemDeliveryHistoryRequest {
	r.reservationId = &reservationId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetExternalSystemDeliveryHistoryRequest) ReservationIdType(reservationIdType string) ReservationApiGetExternalSystemDeliveryHistoryRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// External system code.
func (r ReservationApiGetExternalSystemDeliveryHistoryRequest) XExternalsystem(xExternalsystem string) ReservationApiGetExternalSystemDeliveryHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetExternalSystemDeliveryHistoryRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetExternalSystemDeliveryHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetExternalSystemDeliveryHistoryRequest) Execute() (*DeliveryHistoryLog, *http.Response, error) {
	return r.ApiService.GetExternalSystemDeliveryHistoryExecute(r)
}

/*
GetExternalSystemDeliveryHistory Get External system delivery history

Get external system delivery history. <p><strong>OperationId:</strong>getExternalSystemDeliveryHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetExternalSystemDeliveryHistoryRequest
*/
func (a *ReservationApiService) GetExternalSystemDeliveryHistory(ctx context.Context, hotelId string) ReservationApiGetExternalSystemDeliveryHistoryRequest {
	return ReservationApiGetExternalSystemDeliveryHistoryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DeliveryHistoryLog
func (a *ReservationApiService) GetExternalSystemDeliveryHistoryExecute(r ReservationApiGetExternalSystemDeliveryHistoryRequest) (*DeliveryHistoryLog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeliveryHistoryLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetExternalSystemDeliveryHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fetchExternalSystemDeliveryHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetExternalSystemReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	extSystemCode string
	externalReferenceList *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	recentlyAccessed *bool
	limit *int32
	offset *int32
	searchType *string
	hotelIds *[]string
	text *string
	arrivalEndDate *string
	arrivalStartDate *string
	departureEndDate *string
	departureStartDate *string
	expectedArrivalStartTime *string
	expectedArrivalEndTime *string
	expectedReturnEndTime *string
	expectedReturnStartTime *string
	companyNames *[]string
	travelAgentIds *[]string
	companyIds *[]string
	sourceIds *[]string
	contactIds *[]string
	groupIds *[]string
	billingContactIds *[]string
	profileIds *[]string
	membershipCardNumber *string
	membershipLevels *[]string
	membershipTypes *[]string
	surname *string
	givenName *string
	anyVIPStatus *bool
	vipCodes *[]string
	guaranteeCode *string
	paymentMethod *string
	discountApplied *bool
	user *[]string
	createdBy *string
	cancelledByList *[]string
	cancelledOn *string
	ratePlanCodes *[]string
	sourceCodes *[]string
	marketCodes *[]string
	excludeBlockReservations *bool
	blockName *string
	blockIds *[]string
	blockCodes *[]string
	customReference *string
	recordLocator *string
	orderBy *[]string
	sortOrder *[]string
	roomAssignedOnly *bool
	roomUnassignedOnly *bool
	roomId *string
	roomType *[]string
	roomFeatures *[]string
	roomSpecials *[]string
	roomSmokingPreference *string
	roomFloorPreferences *[]string
	housekeepingRoomStatuses *[]string
	roomClasses *[]string
	roomRangeFrom *string
	roomRangeTo *string
	communication *string
	fetchInstructions *[]string
	allowPreRegistration *bool
	hasDepositBalance *bool
	hasOpenBalance *bool
	hasOpenFolio *bool
	includeScheduledCheckOut *bool
	linkedOnly *bool
	unlinkedOnly *bool
	actualArrivals *bool
	actualDepartures *bool
	complimentaryReservations *bool
	dayOfArrivalCancels *bool
	dayUse *bool
	earlyDepartures *bool
	expectedArrivals *bool
	expectedDepartures *bool
	extendedStays *bool
	houseUseReservations *bool
	stayovers *bool
	stayDate *string
	roomRoutingId *string
	excludePseudoRoomReservations *bool
	excludeReservationIds *[]string
	excludeVIPStatusCodes *[]string
	excludeSpecials *[]string
	excludeFloorPreferences *[]string
	excludeAdvanceCheckedIn *bool
	excludeRoomFeatures *[]string
	playerId *string
	gamingBalanceFrom *float32
	gamingBalanceTo *float32
	compAccountingBalanceFrom *float32
	compAccountingBalanceTo *float32
	searchTypes *[]string
	reservationStatuses *[]string
	transportationCodes *[]string
	roomReadyStatuses *[]string
	checkoutMessageReceived *bool
	optedForCommunication *bool
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemReservationsRequest) ExternalReferenceList(externalReferenceList []string) ReservationApiGetExternalSystemReservationsRequest {
	r.externalReferenceList = &externalReferenceList
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetExternalSystemReservationsRequest) Authorization(authorization string) ReservationApiGetExternalSystemReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetExternalSystemReservationsRequest) XAppKey(xAppKey string) ReservationApiGetExternalSystemReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetExternalSystemReservationsRequest) XHotelid(xHotelid string) ReservationApiGetExternalSystemReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Mark this reservation as recently accessed.
func (r ReservationApiGetExternalSystemReservationsRequest) RecentlyAccessed(recentlyAccessed bool) ReservationApiGetExternalSystemReservationsRequest {
	r.recentlyAccessed = &recentlyAccessed
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationApiGetExternalSystemReservationsRequest) Limit(limit int32) ReservationApiGetExternalSystemReservationsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationApiGetExternalSystemReservationsRequest) Offset(offset int32) ReservationApiGetExternalSystemReservationsRequest {
	r.offset = &offset
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ReservationApiGetExternalSystemReservationsRequest) SearchType(searchType string) ReservationApiGetExternalSystemReservationsRequest {
	r.searchType = &searchType
	return r
}

// List of Hotels to support searches with multiple resorts for which traces are to be fetched.
func (r ReservationApiGetExternalSystemReservationsRequest) HotelIds(hotelIds []string) ReservationApiGetExternalSystemReservationsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Free form text field for searching all reservation fields
func (r ReservationApiGetExternalSystemReservationsRequest) Text(text string) ReservationApiGetExternalSystemReservationsRequest {
	r.text = &text
	return r
}

// The ending value of the date range.
func (r ReservationApiGetExternalSystemReservationsRequest) ArrivalEndDate(arrivalEndDate string) ReservationApiGetExternalSystemReservationsRequest {
	r.arrivalEndDate = &arrivalEndDate
	return r
}

// The starting value of the date range.
func (r ReservationApiGetExternalSystemReservationsRequest) ArrivalStartDate(arrivalStartDate string) ReservationApiGetExternalSystemReservationsRequest {
	r.arrivalStartDate = &arrivalStartDate
	return r
}

// The ending value of the date range.
func (r ReservationApiGetExternalSystemReservationsRequest) DepartureEndDate(departureEndDate string) ReservationApiGetExternalSystemReservationsRequest {
	r.departureEndDate = &departureEndDate
	return r
}

// The starting value of the date range.
func (r ReservationApiGetExternalSystemReservationsRequest) DepartureStartDate(departureStartDate string) ReservationApiGetExternalSystemReservationsRequest {
	r.departureStartDate = &departureStartDate
	return r
}

// The ending value of the time span.
func (r ReservationApiGetExternalSystemReservationsRequest) ExpectedArrivalStartTime(expectedArrivalStartTime string) ReservationApiGetExternalSystemReservationsRequest {
	r.expectedArrivalStartTime = &expectedArrivalStartTime
	return r
}

// The starting value of the time span.
func (r ReservationApiGetExternalSystemReservationsRequest) ExpectedArrivalEndTime(expectedArrivalEndTime string) ReservationApiGetExternalSystemReservationsRequest {
	r.expectedArrivalEndTime = &expectedArrivalEndTime
	return r
}

// The ending value of the time span.
func (r ReservationApiGetExternalSystemReservationsRequest) ExpectedReturnEndTime(expectedReturnEndTime string) ReservationApiGetExternalSystemReservationsRequest {
	r.expectedReturnEndTime = &expectedReturnEndTime
	return r
}

// The starting value of the time span.
func (r ReservationApiGetExternalSystemReservationsRequest) ExpectedReturnStartTime(expectedReturnStartTime string) ReservationApiGetExternalSystemReservationsRequest {
	r.expectedReturnStartTime = &expectedReturnStartTime
	return r
}

// Attached profile name
func (r ReservationApiGetExternalSystemReservationsRequest) CompanyNames(companyNames []string) ReservationApiGetExternalSystemReservationsRequest {
	r.companyNames = &companyNames
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemReservationsRequest) TravelAgentIds(travelAgentIds []string) ReservationApiGetExternalSystemReservationsRequest {
	r.travelAgentIds = &travelAgentIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemReservationsRequest) CompanyIds(companyIds []string) ReservationApiGetExternalSystemReservationsRequest {
	r.companyIds = &companyIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemReservationsRequest) SourceIds(sourceIds []string) ReservationApiGetExternalSystemReservationsRequest {
	r.sourceIds = &sourceIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemReservationsRequest) ContactIds(contactIds []string) ReservationApiGetExternalSystemReservationsRequest {
	r.contactIds = &contactIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemReservationsRequest) GroupIds(groupIds []string) ReservationApiGetExternalSystemReservationsRequest {
	r.groupIds = &groupIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemReservationsRequest) BillingContactIds(billingContactIds []string) ReservationApiGetExternalSystemReservationsRequest {
	r.billingContactIds = &billingContactIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemReservationsRequest) ProfileIds(profileIds []string) ReservationApiGetExternalSystemReservationsRequest {
	r.profileIds = &profileIds
	return r
}

// Membership ID criteria.
func (r ReservationApiGetExternalSystemReservationsRequest) MembershipCardNumber(membershipCardNumber string) ReservationApiGetExternalSystemReservationsRequest {
	r.membershipCardNumber = &membershipCardNumber
	return r
}

func (r ReservationApiGetExternalSystemReservationsRequest) MembershipLevels(membershipLevels []string) ReservationApiGetExternalSystemReservationsRequest {
	r.membershipLevels = &membershipLevels
	return r
}

func (r ReservationApiGetExternalSystemReservationsRequest) MembershipTypes(membershipTypes []string) ReservationApiGetExternalSystemReservationsRequest {
	r.membershipTypes = &membershipTypes
	return r
}

// Family name, last name.
func (r ReservationApiGetExternalSystemReservationsRequest) Surname(surname string) ReservationApiGetExternalSystemReservationsRequest {
	r.surname = &surname
	return r
}

// Given name, first name or names
func (r ReservationApiGetExternalSystemReservationsRequest) GivenName(givenName string) ReservationApiGetExternalSystemReservationsRequest {
	r.givenName = &givenName
	return r
}

// VIP status of the customer.
func (r ReservationApiGetExternalSystemReservationsRequest) AnyVIPStatus(anyVIPStatus bool) ReservationApiGetExternalSystemReservationsRequest {
	r.anyVIPStatus = &anyVIPStatus
	return r
}

// VIP status of the customer.
func (r ReservationApiGetExternalSystemReservationsRequest) VipCodes(vipCodes []string) ReservationApiGetExternalSystemReservationsRequest {
	r.vipCodes = &vipCodes
	return r
}

// Fetches the reservation having Guarantee Code(Reservation Type) supplied here.
func (r ReservationApiGetExternalSystemReservationsRequest) GuaranteeCode(guaranteeCode string) ReservationApiGetExternalSystemReservationsRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// Fetches the reservation having method of payment supplied here.
func (r ReservationApiGetExternalSystemReservationsRequest) PaymentMethod(paymentMethod string) ReservationApiGetExternalSystemReservationsRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Fetches the reservation for which discount is applied
func (r ReservationApiGetExternalSystemReservationsRequest) DiscountApplied(discountApplied bool) ReservationApiGetExternalSystemReservationsRequest {
	r.discountApplied = &discountApplied
	return r
}

func (r ReservationApiGetExternalSystemReservationsRequest) User(user []string) ReservationApiGetExternalSystemReservationsRequest {
	r.user = &user
	return r
}

// Fetches reservation created by specified user. If both CreatedByUsers and CreatedBy is specified, CreatedByUsers will take precedence.
func (r ReservationApiGetExternalSystemReservationsRequest) CreatedBy(createdBy string) ReservationApiGetExternalSystemReservationsRequest {
	r.createdBy = &createdBy
	return r
}

// Fetches reservations cancelled by list of users.
func (r ReservationApiGetExternalSystemReservationsRequest) CancelledByList(cancelledByList []string) ReservationApiGetExternalSystemReservationsRequest {
	r.cancelledByList = &cancelledByList
	return r
}

// Fetches the reservations which are cancelled on a specific date.
func (r ReservationApiGetExternalSystemReservationsRequest) CancelledOn(cancelledOn string) ReservationApiGetExternalSystemReservationsRequest {
	r.cancelledOn = &cancelledOn
	return r
}

func (r ReservationApiGetExternalSystemReservationsRequest) RatePlanCodes(ratePlanCodes []string) ReservationApiGetExternalSystemReservationsRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ReservationApiGetExternalSystemReservationsRequest) SourceCodes(sourceCodes []string) ReservationApiGetExternalSystemReservationsRequest {
	r.sourceCodes = &sourceCodes
	return r
}

func (r ReservationApiGetExternalSystemReservationsRequest) MarketCodes(marketCodes []string) ReservationApiGetExternalSystemReservationsRequest {
	r.marketCodes = &marketCodes
	return r
}

// If true the search result will exclude the blocks reservations.
func (r ReservationApiGetExternalSystemReservationsRequest) ExcludeBlockReservations(excludeBlockReservations bool) ReservationApiGetExternalSystemReservationsRequest {
	r.excludeBlockReservations = &excludeBlockReservations
	return r
}

// The Name of the block that is attached to the reservation.
func (r ReservationApiGetExternalSystemReservationsRequest) BlockName(blockName string) ReservationApiGetExternalSystemReservationsRequest {
	r.blockName = &blockName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemReservationsRequest) BlockIds(blockIds []string) ReservationApiGetExternalSystemReservationsRequest {
	r.blockIds = &blockIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemReservationsRequest) BlockCodes(blockCodes []string) ReservationApiGetExternalSystemReservationsRequest {
	r.blockCodes = &blockCodes
	return r
}

// Custom reference
func (r ReservationApiGetExternalSystemReservationsRequest) CustomReference(customReference string) ReservationApiGetExternalSystemReservationsRequest {
	r.customReference = &customReference
	return r
}

// GDS Record Locator for reservation.
func (r ReservationApiGetExternalSystemReservationsRequest) RecordLocator(recordLocator string) ReservationApiGetExternalSystemReservationsRequest {
	r.recordLocator = &recordLocator
	return r
}

func (r ReservationApiGetExternalSystemReservationsRequest) OrderBy(orderBy []string) ReservationApiGetExternalSystemReservationsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ReservationApiGetExternalSystemReservationsRequest) SortOrder(sortOrder []string) ReservationApiGetExternalSystemReservationsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Indicator to query reservations which have a room number assigned.
func (r ReservationApiGetExternalSystemReservationsRequest) RoomAssignedOnly(roomAssignedOnly bool) ReservationApiGetExternalSystemReservationsRequest {
	r.roomAssignedOnly = &roomAssignedOnly
	return r
}

// Indicator to query reservations which does not have a room number assigned.
func (r ReservationApiGetExternalSystemReservationsRequest) RoomUnassignedOnly(roomUnassignedOnly bool) ReservationApiGetExternalSystemReservationsRequest {
	r.roomUnassignedOnly = &roomUnassignedOnly
	return r
}

// Room number of the reservation to search by.
func (r ReservationApiGetExternalSystemReservationsRequest) RoomId(roomId string) ReservationApiGetExternalSystemReservationsRequest {
	r.roomId = &roomId
	return r
}

// Room Type.
func (r ReservationApiGetExternalSystemReservationsRequest) RoomType(roomType []string) ReservationApiGetExternalSystemReservationsRequest {
	r.roomType = &roomType
	return r
}

// A code representing a room feature.
func (r ReservationApiGetExternalSystemReservationsRequest) RoomFeatures(roomFeatures []string) ReservationApiGetExternalSystemReservationsRequest {
	r.roomFeatures = &roomFeatures
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetExternalSystemReservationsRequest) RoomSpecials(roomSpecials []string) ReservationApiGetExternalSystemReservationsRequest {
	r.roomSpecials = &roomSpecials
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetExternalSystemReservationsRequest) RoomSmokingPreference(roomSmokingPreference string) ReservationApiGetExternalSystemReservationsRequest {
	r.roomSmokingPreference = &roomSmokingPreference
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetExternalSystemReservationsRequest) RoomFloorPreferences(roomFloorPreferences []string) ReservationApiGetExternalSystemReservationsRequest {
	r.roomFloorPreferences = &roomFloorPreferences
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r ReservationApiGetExternalSystemReservationsRequest) HousekeepingRoomStatuses(housekeepingRoomStatuses []string) ReservationApiGetExternalSystemReservationsRequest {
	r.housekeepingRoomStatuses = &housekeepingRoomStatuses
	return r
}

func (r ReservationApiGetExternalSystemReservationsRequest) RoomClasses(roomClasses []string) ReservationApiGetExternalSystemReservationsRequest {
	r.roomClasses = &roomClasses
	return r
}

func (r ReservationApiGetExternalSystemReservationsRequest) RoomRangeFrom(roomRangeFrom string) ReservationApiGetExternalSystemReservationsRequest {
	r.roomRangeFrom = &roomRangeFrom
	return r
}

func (r ReservationApiGetExternalSystemReservationsRequest) RoomRangeTo(roomRangeTo string) ReservationApiGetExternalSystemReservationsRequest {
	r.roomRangeTo = &roomRangeTo
	return r
}

// Filter by the last digits of a reservation&#39;s phone number.
func (r ReservationApiGetExternalSystemReservationsRequest) Communication(communication string) ReservationApiGetExternalSystemReservationsRequest {
	r.communication = &communication
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r ReservationApiGetExternalSystemReservationsRequest) FetchInstructions(fetchInstructions []string) ReservationApiGetExternalSystemReservationsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Flag containing true or false value for reservation to be eligible for prior check in by guest using mobile device. Pass the &#39;true&#39; or &#39;false&#39; values when creating / modifying reservation to indicate whether a reservation is eligible for mobile check in yes / no. Upon fetch, the current state of the flag will show true or false.
func (r ReservationApiGetExternalSystemReservationsRequest) AllowPreRegistration(allowPreRegistration bool) ReservationApiGetExternalSystemReservationsRequest {
	r.allowPreRegistration = &allowPreRegistration
	return r
}

// Indicates that only reservations with deposit balance should be expected from the result.
func (r ReservationApiGetExternalSystemReservationsRequest) HasDepositBalance(hasDepositBalance bool) ReservationApiGetExternalSystemReservationsRequest {
	r.hasDepositBalance = &hasDepositBalance
	return r
}

// Indicates that only reservations with open balance should be expected from the result.
func (r ReservationApiGetExternalSystemReservationsRequest) HasOpenBalance(hasOpenBalance bool) ReservationApiGetExternalSystemReservationsRequest {
	r.hasOpenBalance = &hasOpenBalance
	return r
}

// Indicates that only reservations with open folio should be expected from the result.
func (r ReservationApiGetExternalSystemReservationsRequest) HasOpenFolio(hasOpenFolio bool) ReservationApiGetExternalSystemReservationsRequest {
	r.hasOpenFolio = &hasOpenFolio
	return r
}

// Criteria that indicates whether to scheduled checkouts or not.
func (r ReservationApiGetExternalSystemReservationsRequest) IncludeScheduledCheckOut(includeScheduledCheckOut bool) ReservationApiGetExternalSystemReservationsRequest {
	r.includeScheduledCheckOut = &includeScheduledCheckOut
	return r
}

// Indicates that only linked reservations should be expected from the result.
func (r ReservationApiGetExternalSystemReservationsRequest) LinkedOnly(linkedOnly bool) ReservationApiGetExternalSystemReservationsRequest {
	r.linkedOnly = &linkedOnly
	return r
}

// Indicates that only unlinked reservations should be expected from the result.
func (r ReservationApiGetExternalSystemReservationsRequest) UnlinkedOnly(unlinkedOnly bool) ReservationApiGetExternalSystemReservationsRequest {
	r.unlinkedOnly = &unlinkedOnly
	return r
}

// Indicates if reservations which have already arrived on the Search Date is required.
func (r ReservationApiGetExternalSystemReservationsRequest) ActualArrivals(actualArrivals bool) ReservationApiGetExternalSystemReservationsRequest {
	r.actualArrivals = &actualArrivals
	return r
}

// Indicates if reservations which were expected to depart on the Search Date and have already checked, is required.
func (r ReservationApiGetExternalSystemReservationsRequest) ActualDepartures(actualDepartures bool) ReservationApiGetExternalSystemReservationsRequest {
	r.actualDepartures = &actualDepartures
	return r
}

// Indicates if reservations where rate codes are marked as Complimentary Rates , is required. This flag should be used in conjunction with the Arrivals, Departures or StayOvers criteria.
func (r ReservationApiGetExternalSystemReservationsRequest) ComplimentaryReservations(complimentaryReservations bool) ReservationApiGetExternalSystemReservationsRequest {
	r.complimentaryReservations = &complimentaryReservations
	return r
}

// Indicates if reservations which have cancelled on the Search Date which is also the day of arrival is required.
func (r ReservationApiGetExternalSystemReservationsRequest) DayOfArrivalCancels(dayOfArrivalCancels bool) ReservationApiGetExternalSystemReservationsRequest {
	r.dayOfArrivalCancels = &dayOfArrivalCancels
	return r
}

// Indicates if reservations which are day use reservation on the Search Date, is required.
func (r ReservationApiGetExternalSystemReservationsRequest) DayUse(dayUse bool) ReservationApiGetExternalSystemReservationsRequest {
	r.dayUse = &dayUse
	return r
}

// Indicates if reservations which checked out early on the Search Date, is required.
func (r ReservationApiGetExternalSystemReservationsRequest) EarlyDepartures(earlyDepartures bool) ReservationApiGetExternalSystemReservationsRequest {
	r.earlyDepartures = &earlyDepartures
	return r
}

// Indicates if reservations which are expected arrivals for the Search Date and who have not yet arrived, is required.
func (r ReservationApiGetExternalSystemReservationsRequest) ExpectedArrivals(expectedArrivals bool) ReservationApiGetExternalSystemReservationsRequest {
	r.expectedArrivals = &expectedArrivals
	return r
}

// Indicates if reservations which are expected departures for the Search Date and who have not yet departed, is required.
func (r ReservationApiGetExternalSystemReservationsRequest) ExpectedDepartures(expectedDepartures bool) ReservationApiGetExternalSystemReservationsRequest {
	r.expectedDepartures = &expectedDepartures
	return r
}

// Indicates if reservations which have extended their stays on the Search Date, is required.
func (r ReservationApiGetExternalSystemReservationsRequest) ExtendedStays(extendedStays bool) ReservationApiGetExternalSystemReservationsRequest {
	r.extendedStays = &extendedStays
	return r
}

// Indicates if reservations where rate codes are marked as House Use Rates , is required. This flag should be used in conjunction with the Arrivals, Departures or StayOvers criteria.
func (r ReservationApiGetExternalSystemReservationsRequest) HouseUseReservations(houseUseReservations bool) ReservationApiGetExternalSystemReservationsRequest {
	r.houseUseReservations = &houseUseReservations
	return r
}

// Indicates if reservations which are StayOvers on the Search Date, is required.
func (r ReservationApiGetExternalSystemReservationsRequest) Stayovers(stayovers bool) ReservationApiGetExternalSystemReservationsRequest {
	r.stayovers = &stayovers
	return r
}

// Date for searching the reservations. This is the date for which the search types are applicable. If date is not available, the business date will be used by default.
func (r ReservationApiGetExternalSystemReservationsRequest) StayDate(stayDate string) ReservationApiGetExternalSystemReservationsRequest {
	r.stayDate = &stayDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemReservationsRequest) RoomRoutingId(roomRoutingId string) ReservationApiGetExternalSystemReservationsRequest {
	r.roomRoutingId = &roomRoutingId
	return r
}

// Indicates to exclude Pseudo room reservations.
func (r ReservationApiGetExternalSystemReservationsRequest) ExcludePseudoRoomReservations(excludePseudoRoomReservations bool) ReservationApiGetExternalSystemReservationsRequest {
	r.excludePseudoRoomReservations = &excludePseudoRoomReservations
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetExternalSystemReservationsRequest) ExcludeReservationIds(excludeReservationIds []string) ReservationApiGetExternalSystemReservationsRequest {
	r.excludeReservationIds = &excludeReservationIds
	return r
}

// VIP status of the customer.
func (r ReservationApiGetExternalSystemReservationsRequest) ExcludeVIPStatusCodes(excludeVIPStatusCodes []string) ReservationApiGetExternalSystemReservationsRequest {
	r.excludeVIPStatusCodes = &excludeVIPStatusCodes
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetExternalSystemReservationsRequest) ExcludeSpecials(excludeSpecials []string) ReservationApiGetExternalSystemReservationsRequest {
	r.excludeSpecials = &excludeSpecials
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetExternalSystemReservationsRequest) ExcludeFloorPreferences(excludeFloorPreferences []string) ReservationApiGetExternalSystemReservationsRequest {
	r.excludeFloorPreferences = &excludeFloorPreferences
	return r
}

// Indicates to exclude Advance Checked In Reservations from search result.
func (r ReservationApiGetExternalSystemReservationsRequest) ExcludeAdvanceCheckedIn(excludeAdvanceCheckedIn bool) ReservationApiGetExternalSystemReservationsRequest {
	r.excludeAdvanceCheckedIn = &excludeAdvanceCheckedIn
	return r
}

// Exclude the reservation(s) with provided room features from the search result.
func (r ReservationApiGetExternalSystemReservationsRequest) ExcludeRoomFeatures(excludeRoomFeatures []string) ReservationApiGetExternalSystemReservationsRequest {
	r.excludeRoomFeatures = &excludeRoomFeatures
	return r
}

// Player ID associated to the reservation.
func (r ReservationApiGetExternalSystemReservationsRequest) PlayerId(playerId string) ReservationApiGetExternalSystemReservationsRequest {
	r.playerId = &playerId
	return r
}

// Balance from.
func (r ReservationApiGetExternalSystemReservationsRequest) GamingBalanceFrom(gamingBalanceFrom float32) ReservationApiGetExternalSystemReservationsRequest {
	r.gamingBalanceFrom = &gamingBalanceFrom
	return r
}

// Balance to.
func (r ReservationApiGetExternalSystemReservationsRequest) GamingBalanceTo(gamingBalanceTo float32) ReservationApiGetExternalSystemReservationsRequest {
	r.gamingBalanceTo = &gamingBalanceTo
	return r
}

// Comp Balance From
func (r ReservationApiGetExternalSystemReservationsRequest) CompAccountingBalanceFrom(compAccountingBalanceFrom float32) ReservationApiGetExternalSystemReservationsRequest {
	r.compAccountingBalanceFrom = &compAccountingBalanceFrom
	return r
}

// Comp Balance To
func (r ReservationApiGetExternalSystemReservationsRequest) CompAccountingBalanceTo(compAccountingBalanceTo float32) ReservationApiGetExternalSystemReservationsRequest {
	r.compAccountingBalanceTo = &compAccountingBalanceTo
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ReservationApiGetExternalSystemReservationsRequest) SearchTypes(searchTypes []string) ReservationApiGetExternalSystemReservationsRequest {
	r.searchTypes = &searchTypes
	return r
}

// Reservation status type for reservations search.
func (r ReservationApiGetExternalSystemReservationsRequest) ReservationStatuses(reservationStatuses []string) ReservationApiGetExternalSystemReservationsRequest {
	r.reservationStatuses = &reservationStatuses
	return r
}

// Codes to be searched.
func (r ReservationApiGetExternalSystemReservationsRequest) TransportationCodes(transportationCodes []string) ReservationApiGetExternalSystemReservationsRequest {
	r.transportationCodes = &transportationCodes
	return r
}

// Enum to denote the Status of Readiness messages sent to Guest Devices.
func (r ReservationApiGetExternalSystemReservationsRequest) RoomReadyStatuses(roomReadyStatuses []string) ReservationApiGetExternalSystemReservationsRequest {
	r.roomReadyStatuses = &roomReadyStatuses
	return r
}

// Fetches the reservations for which Checkout Message is received.
func (r ReservationApiGetExternalSystemReservationsRequest) CheckoutMessageReceived(checkoutMessageReceived bool) ReservationApiGetExternalSystemReservationsRequest {
	r.checkoutMessageReceived = &checkoutMessageReceived
	return r
}

// Fetches the reservations for which reservation communication has been opted.
func (r ReservationApiGetExternalSystemReservationsRequest) OptedForCommunication(optedForCommunication bool) ReservationApiGetExternalSystemReservationsRequest {
	r.optedForCommunication = &optedForCommunication
	return r
}

// External system code.
func (r ReservationApiGetExternalSystemReservationsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetExternalSystemReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetExternalSystemReservationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetExternalSystemReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetExternalSystemReservationsRequest) Execute() (*ReservationsDetails, *http.Response, error) {
	return r.ApiService.GetExternalSystemReservationsExecute(r)
}

/*
GetExternalSystemReservations Get Reservations for a hotel

This API will allow a user to retrieve a list of reservations based on the search criteria specified in the request body. For example you can search for reservations using query parameters like first name, last name, arrival/departure date, external confirmation number. <p><strong>OperationId:</strong>getExternalSystemReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param extSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @return ReservationApiGetExternalSystemReservationsRequest
*/
func (a *ReservationApiService) GetExternalSystemReservations(ctx context.Context, extSystemCode string) ReservationApiGetExternalSystemReservationsRequest {
	return ReservationApiGetExternalSystemReservationsRequest{
		ApiService: a,
		ctx: ctx,
		extSystemCode: extSystemCode,
	}
}

// Execute executes the request
//  @return ReservationsDetails
func (a *ReservationApiService) GetExternalSystemReservationsExecute(r ReservationApiGetExternalSystemReservationsRequest) (*ReservationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetExternalSystemReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.extSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("extSystemCode must have less than 2000 elements")
	}

	{
		t := *r.externalReferenceList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceList", t, "multi")
		}
	}
	if r.recentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recentlyAccessed", r.recentlyAccessed, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchType", r.searchType, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.arrivalEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEndDate", r.arrivalEndDate, "")
	}
	if r.arrivalStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStartDate", r.arrivalStartDate, "")
	}
	if r.departureEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureEndDate", r.departureEndDate, "")
	}
	if r.departureStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureStartDate", r.departureStartDate, "")
	}
	if r.expectedArrivalStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalStartTime", r.expectedArrivalStartTime, "")
	}
	if r.expectedArrivalEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalEndTime", r.expectedArrivalEndTime, "")
	}
	if r.expectedReturnEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnEndTime", r.expectedReturnEndTime, "")
	}
	if r.expectedReturnStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnStartTime", r.expectedReturnStartTime, "")
	}
	if r.companyNames != nil {
		t := *r.companyNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyNames", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyNames", t, "multi")
		}
	}
	if r.travelAgentIds != nil {
		t := *r.travelAgentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", t, "multi")
		}
	}
	if r.companyIds != nil {
		t := *r.companyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", t, "multi")
		}
	}
	if r.sourceIds != nil {
		t := *r.sourceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", t, "multi")
		}
	}
	if r.contactIds != nil {
		t := *r.contactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", t, "multi")
		}
	}
	if r.groupIds != nil {
		t := *r.groupIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", t, "multi")
		}
	}
	if r.billingContactIds != nil {
		t := *r.billingContactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", t, "multi")
		}
	}
	if r.profileIds != nil {
		t := *r.profileIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", t, "multi")
		}
	}
	if r.membershipCardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipCardNumber", r.membershipCardNumber, "")
	}
	if r.membershipLevels != nil {
		t := *r.membershipLevels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", t, "multi")
		}
	}
	if r.membershipTypes != nil {
		t := *r.membershipTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", t, "multi")
		}
	}
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.anyVIPStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anyVIPStatus", r.anyVIPStatus, "")
	}
	if r.vipCodes != nil {
		t := *r.vipCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", t, "multi")
		}
	}
	if r.guaranteeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", r.guaranteeCode, "")
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	}
	if r.discountApplied != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discountApplied", r.discountApplied, "")
	}
	if r.user != nil {
		t := *r.user
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user", t, "multi")
		}
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBy", r.createdBy, "")
	}
	if r.cancelledByList != nil {
		t := *r.cancelledByList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledByList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledByList", t, "multi")
		}
	}
	if r.cancelledOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledOn", r.cancelledOn, "")
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.sourceCodes != nil {
		t := *r.sourceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", t, "multi")
		}
	}
	if r.marketCodes != nil {
		t := *r.marketCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", t, "multi")
		}
	}
	if r.excludeBlockReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeBlockReservations", r.excludeBlockReservations, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.blockIds != nil {
		t := *r.blockIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIds", t, "multi")
		}
	}
	if r.blockCodes != nil {
		t := *r.blockCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodes", t, "multi")
		}
	}
	if r.customReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customReference", r.customReference, "")
	}
	if r.recordLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recordLocator", r.recordLocator, "")
	}
	if r.orderBy != nil {
		t := *r.orderBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", t, "multi")
		}
	}
	if r.sortOrder != nil {
		t := *r.sortOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", t, "multi")
		}
	}
	if r.roomAssignedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignedOnly", r.roomAssignedOnly, "")
	}
	if r.roomUnassignedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomUnassignedOnly", r.roomUnassignedOnly, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "csv")
	}
	if r.roomFeatures != nil {
		t := *r.roomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", t, "multi")
		}
	}
	if r.roomSpecials != nil {
		t := *r.roomSpecials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomSpecials", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomSpecials", t, "multi")
		}
	}
	if r.roomSmokingPreference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomSmokingPreference", r.roomSmokingPreference, "")
	}
	if r.roomFloorPreferences != nil {
		t := *r.roomFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFloorPreferences", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFloorPreferences", t, "multi")
		}
	}
	if r.housekeepingRoomStatuses != nil {
		t := *r.housekeepingRoomStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatuses", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	if r.roomRangeFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRangeFrom", r.roomRangeFrom, "")
	}
	if r.roomRangeTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRangeTo", r.roomRangeTo, "")
	}
	if r.communication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "communication", r.communication, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.allowPreRegistration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowPreRegistration", r.allowPreRegistration, "")
	}
	if r.hasDepositBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasDepositBalance", r.hasDepositBalance, "")
	}
	if r.hasOpenBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenBalance", r.hasOpenBalance, "")
	}
	if r.hasOpenFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenFolio", r.hasOpenFolio, "")
	}
	if r.includeScheduledCheckOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeScheduledCheckOut", r.includeScheduledCheckOut, "")
	}
	if r.linkedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedOnly", r.linkedOnly, "")
	}
	if r.unlinkedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unlinkedOnly", r.unlinkedOnly, "")
	}
	if r.actualArrivals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actualArrivals", r.actualArrivals, "")
	}
	if r.actualDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actualDepartures", r.actualDepartures, "")
	}
	if r.complimentaryReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "complimentaryReservations", r.complimentaryReservations, "")
	}
	if r.dayOfArrivalCancels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayOfArrivalCancels", r.dayOfArrivalCancels, "")
	}
	if r.dayUse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayUse", r.dayUse, "")
	}
	if r.earlyDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "earlyDepartures", r.earlyDepartures, "")
	}
	if r.expectedArrivals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivals", r.expectedArrivals, "")
	}
	if r.expectedDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedDepartures", r.expectedDepartures, "")
	}
	if r.extendedStays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extendedStays", r.extendedStays, "")
	}
	if r.houseUseReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "houseUseReservations", r.houseUseReservations, "")
	}
	if r.stayovers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayovers", r.stayovers, "")
	}
	if r.stayDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayDate", r.stayDate, "")
	}
	if r.roomRoutingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRoutingId", r.roomRoutingId, "")
	}
	if r.excludePseudoRoomReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludePseudoRoomReservations", r.excludePseudoRoomReservations, "")
	}
	if r.excludeReservationIds != nil {
		t := *r.excludeReservationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReservationIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReservationIds", t, "multi")
		}
	}
	if r.excludeVIPStatusCodes != nil {
		t := *r.excludeVIPStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVIPStatusCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVIPStatusCodes", t, "multi")
		}
	}
	if r.excludeSpecials != nil {
		t := *r.excludeSpecials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSpecials", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSpecials", t, "multi")
		}
	}
	if r.excludeFloorPreferences != nil {
		t := *r.excludeFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", t, "multi")
		}
	}
	if r.excludeAdvanceCheckedIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeAdvanceCheckedIn", r.excludeAdvanceCheckedIn, "")
	}
	if r.excludeRoomFeatures != nil {
		t := *r.excludeRoomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRoomFeatures", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRoomFeatures", t, "multi")
		}
	}
	if r.playerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playerId", r.playerId, "")
	}
	if r.gamingBalanceFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gamingBalanceFrom", r.gamingBalanceFrom, "")
	}
	if r.gamingBalanceTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gamingBalanceTo", r.gamingBalanceTo, "")
	}
	if r.compAccountingBalanceFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccountingBalanceFrom", r.compAccountingBalanceFrom, "")
	}
	if r.compAccountingBalanceTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccountingBalanceTo", r.compAccountingBalanceTo, "")
	}
	if r.searchTypes != nil {
		t := *r.searchTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypes", t, "multi")
		}
	}
	if r.reservationStatuses != nil {
		t := *r.reservationStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", t, "multi")
		}
	}
	if r.transportationCodes != nil {
		t := *r.transportationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", t, "multi")
		}
	}
	if r.roomReadyStatuses != nil {
		t := *r.roomReadyStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomReadyStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomReadyStatuses", t, "multi")
		}
	}
	if r.checkoutMessageReceived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkoutMessageReceived", r.checkoutMessageReceived, "")
	}
	if r.optedForCommunication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "optedForCommunication", r.optedForCommunication, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetFutureReservationsOrBlocksRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetFutureReservationsOrBlocksRequest) Authorization(authorization string) ReservationApiGetFutureReservationsOrBlocksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetFutureReservationsOrBlocksRequest) XAppKey(xAppKey string) ReservationApiGetFutureReservationsOrBlocksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetFutureReservationsOrBlocksRequest) XHotelid(xHotelid string) ReservationApiGetFutureReservationsOrBlocksRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiGetFutureReservationsOrBlocksRequest) XExternalsystem(xExternalsystem string) ReservationApiGetFutureReservationsOrBlocksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetFutureReservationsOrBlocksRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetFutureReservationsOrBlocksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetFutureReservationsOrBlocksRequest) Execute() (*FutureReservationsOrBlocksDetails, *http.Response, error) {
	return r.ApiService.GetFutureReservationsOrBlocksExecute(r)
}

/*
GetFutureReservationsOrBlocks Get Future Reservations on a profile

Use this API to identify whether there are future reservations or business block for the profile id. <p><strong>OperationId:</strong>getFutureReservationsOrBlocks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique OPERA internal profile ID which is used to find any type of profile from OPERA. This ID is a primary identification of a profile in OPERA.
 @return ReservationApiGetFutureReservationsOrBlocksRequest
*/
func (a *ReservationApiService) GetFutureReservationsOrBlocks(ctx context.Context, profileId string) ReservationApiGetFutureReservationsOrBlocksRequest {
	return ReservationApiGetFutureReservationsOrBlocksRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return FutureReservationsOrBlocksDetails
func (a *ReservationApiService) GetFutureReservationsOrBlocksExecute(r ReservationApiGetFutureReservationsOrBlocksRequest) (*FutureReservationsOrBlocksDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FutureReservationsOrBlocksDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetFutureReservationsOrBlocks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetGuestMessagesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	reservationId *string
	retrieveDeliveredMessages *bool
	room *string
	travelAgent *string
	company *string
	group *string
	source *string
	reservationStatus *string
	retrieveUndeliveredMessages *bool
	retrievePrintedMessages *bool
	retrieveTextedMessages *bool
	blockName *string
	recipientName *string
	confirmationNo *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetGuestMessagesRequest) Authorization(authorization string) ReservationApiGetGuestMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetGuestMessagesRequest) XAppKey(xAppKey string) ReservationApiGetGuestMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetGuestMessagesRequest) XHotelid(xHotelid string) ReservationApiGetGuestMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationApiGetGuestMessagesRequest) Limit(limit int32) ReservationApiGetGuestMessagesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationApiGetGuestMessagesRequest) Offset(offset int32) ReservationApiGetGuestMessagesRequest {
	r.offset = &offset
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetGuestMessagesRequest) ReservationId(reservationId string) ReservationApiGetGuestMessagesRequest {
	r.reservationId = &reservationId
	return r
}

// Flag that specified if Delivered Guest Messages will also be retrieved.
func (r ReservationApiGetGuestMessagesRequest) RetrieveDeliveredMessages(retrieveDeliveredMessages bool) ReservationApiGetGuestMessagesRequest {
	r.retrieveDeliveredMessages = &retrieveDeliveredMessages
	return r
}

// Room number attached to the reservation.
func (r ReservationApiGetGuestMessagesRequest) Room(room string) ReservationApiGetGuestMessagesRequest {
	r.room = &room
	return r
}

// Lookup guest messages with this Travel agent name.
func (r ReservationApiGetGuestMessagesRequest) TravelAgent(travelAgent string) ReservationApiGetGuestMessagesRequest {
	r.travelAgent = &travelAgent
	return r
}

// Lookup guest messages with the Company name.
func (r ReservationApiGetGuestMessagesRequest) Company(company string) ReservationApiGetGuestMessagesRequest {
	r.company = &company
	return r
}

// Lookup guest messages with the Travel agent name.
func (r ReservationApiGetGuestMessagesRequest) Group(group string) ReservationApiGetGuestMessagesRequest {
	r.group = &group
	return r
}

// Lookup guest messages with the Source name.
func (r ReservationApiGetGuestMessagesRequest) Source(source string) ReservationApiGetGuestMessagesRequest {
	r.source = &source
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ReservationApiGetGuestMessagesRequest) ReservationStatus(reservationStatus string) ReservationApiGetGuestMessagesRequest {
	r.reservationStatus = &reservationStatus
	return r
}

// Flag that specified if Undelivered Guest Messages will also be retrieved.
func (r ReservationApiGetGuestMessagesRequest) RetrieveUndeliveredMessages(retrieveUndeliveredMessages bool) ReservationApiGetGuestMessagesRequest {
	r.retrieveUndeliveredMessages = &retrieveUndeliveredMessages
	return r
}

// Flag that specified if Printed Guest Messages will also be retrieved.
func (r ReservationApiGetGuestMessagesRequest) RetrievePrintedMessages(retrievePrintedMessages bool) ReservationApiGetGuestMessagesRequest {
	r.retrievePrintedMessages = &retrievePrintedMessages
	return r
}

// Flag that specified if Texted Guest Messages will also be retrieved.
func (r ReservationApiGetGuestMessagesRequest) RetrieveTextedMessages(retrieveTextedMessages bool) ReservationApiGetGuestMessagesRequest {
	r.retrieveTextedMessages = &retrieveTextedMessages
	return r
}

// Lookup messages using Block name.
func (r ReservationApiGetGuestMessagesRequest) BlockName(blockName string) ReservationApiGetGuestMessagesRequest {
	r.blockName = &blockName
	return r
}

// Lookup guest messages with the recipient name.
func (r ReservationApiGetGuestMessagesRequest) RecipientName(recipientName string) ReservationApiGetGuestMessagesRequest {
	r.recipientName = &recipientName
	return r
}

// Lookup guest messages using reservation confirmation no.
func (r ReservationApiGetGuestMessagesRequest) ConfirmationNo(confirmationNo string) ReservationApiGetGuestMessagesRequest {
	r.confirmationNo = &confirmationNo
	return r
}

// External system code.
func (r ReservationApiGetGuestMessagesRequest) XExternalsystem(xExternalsystem string) ReservationApiGetGuestMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetGuestMessagesRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetGuestMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetGuestMessagesRequest) Execute() (*GuestMessages, *http.Response, error) {
	return r.ApiService.GetGuestMessagesExecute(r)
}

/*
GetGuestMessages Get guest messages

Get guest messages which exist on a reservation. <p><strong>OperationId:</strong>getGuestMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetGuestMessagesRequest
*/
func (a *ReservationApiService) GetGuestMessages(ctx context.Context, hotelId string) ReservationApiGetGuestMessagesRequest {
	return ReservationApiGetGuestMessagesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GuestMessages
func (a *ReservationApiService) GetGuestMessagesExecute(r ReservationApiGetGuestMessagesRequest) (*GuestMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuestMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetGuestMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/guestMessages"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.retrieveDeliveredMessages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrieveDeliveredMessages", r.retrieveDeliveredMessages, "")
	}
	if r.room != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "room", r.room, "")
	}
	if r.travelAgent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgent", r.travelAgent, "")
	}
	if r.company != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "company", r.company, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "")
	}
	if r.reservationStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", r.reservationStatus, "")
	}
	if r.retrieveUndeliveredMessages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrieveUndeliveredMessages", r.retrieveUndeliveredMessages, "")
	}
	if r.retrievePrintedMessages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrievePrintedMessages", r.retrievePrintedMessages, "")
	}
	if r.retrieveTextedMessages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrieveTextedMessages", r.retrieveTextedMessages, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.recipientName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipientName", r.recipientName, "")
	}
	if r.confirmationNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "confirmationNo", r.confirmationNo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetHotelReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	keyTrack2 *string
	discrepancy *string
	recentlyAccessed *bool
	limit *int32
	offset *int32
	searchType *string
	text *string
	reservationIdList *[]string
	confirmationNumberList *[]string
	cancellationNumberList *[]string
	externalReferenceIds *[]string
	externalSystemCodes *[]string
	arrivalEndDate *string
	arrivalStartDate *string
	departureEndDate *string
	departureStartDate *string
	stayOnStartDate *string
	createdOnStartDate *string
	expectedArrivalEndTime *string
	expectedArrivalStartTime *string
	depositDueEndDate *string
	depositDueStartDate *string
	expectedReturnEndTime *string
	expectedReturnStartTime *string
	companyNames *[]string
	sourceNames *[]string
	travelAgentNames *[]string
	groupNames *[]string
	travelAgentIds *[]string
	companyIds *[]string
	sourceIds *[]string
	contactIds *[]string
	groupIds *[]string
	billingContactIds *[]string
	profileId *string
	commissionPaid *bool
	membershipCardNumber *string
	membershipLevels *[]string
	membershipTypes *[]string
	surname *string
	givenName *string
	fromName *string
	toName *string
	anyVIPStatus *bool
	vipCodes *[]string
	guaranteeCode *string
	paymentMethod *string
	discountApplied *bool
	user *[]string
	createdBy *string
	cancelledByList *[]string
	cancelledOn *string
	ratePlanCodes *[]string
	sourceCodes *[]string
	marketCodes *[]string
	excludeBlockReservations *bool
	blockCriteriaHotelCode *string
	blockName *string
	blockIds *[]string
	blockCodes *[]string
	customReference *string
	recordLocator *string
	orderBy *[]string
	sortOrder *[]string
	roomAssignedOnly *bool
	roomUnassignedOnly *bool
	roomId *string
	roomType *[]string
	roomFeatures *[]string
	roomSpecials *[]string
	roomSmokingPreference *string
	roomFloorPreferences *[]string
	housekeepingRoomStatuses *[]string
	roomClasses *[]string
	roomRangeFrom *string
	roomRangeTo *string
	communication *string
	fetchInstructions *[]string
	allowedReservationActions *[]string
	allowPreRegistration *bool
	excludeNoPost *bool
	excludePMRooms *bool
	hasDepositBalance *bool
	hasOpenBalance *bool
	hasOpenFolio *bool
	includeScheduledCheckOut *bool
	linkedOnly *bool
	unlinkedOnly *bool
	actualArrivals *bool
	actualDepartures *bool
	complimentaryReservations *bool
	dayOfArrivalCancels *bool
	dayUse *bool
	earlyDepartures *bool
	expectedArrivals *bool
	expectedDepartures *bool
	extendedStays *bool
	houseUseReservations *bool
	stayovers *bool
	stayDate *string
	roomRoutingId *string
	periodicFolio *string
	folioSettlementTypes *string
	defaultDays *bool
	excludePseudoRoomReservations *bool
	excludeReservationIds *[]string
	excludeVIPStatusCodes *[]string
	excludeSpecials *[]string
	excludeFloorPreferences *[]string
	excludeAdvanceCheckedIn *bool
	excludeRoomFeatures *[]string
	playerId *string
	gamingBalanceFrom *float32
	gamingBalanceTo *float32
	compAccountingBalanceFrom *float32
	compAccountingBalanceTo *float32
	searchTypes *[]string
	reservationStatuses *[]string
	transportationCodes *[]string
	roomReadyStatuses *[]string
	checkoutMessageReceived *bool
	optedForCommunication *bool
	swapShiftRoomReservationId *string
	roomSmokingPreferences *[]string
	roomFeaturePreferences *[]string
	roomsFloorPreferences *[]string
	contactNames *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetHotelReservationsRequest) Authorization(authorization string) ReservationApiGetHotelReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetHotelReservationsRequest) XAppKey(xAppKey string) ReservationApiGetHotelReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetHotelReservationsRequest) XHotelid(xHotelid string) ReservationApiGetHotelReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// keyTrack2 is an id which is either generated by the PMS or provided by the door lock system and which is associated to the reservation. With the keyTrack2 value a reservation can be identified.
func (r ReservationApiGetHotelReservationsRequest) KeyTrack2(keyTrack2 string) ReservationApiGetHotelReservationsRequest {
	r.keyTrack2 = &keyTrack2
	return r
}

func (r ReservationApiGetHotelReservationsRequest) Discrepancy(discrepancy string) ReservationApiGetHotelReservationsRequest {
	r.discrepancy = &discrepancy
	return r
}

// Mark this reservation as recently accessed.
func (r ReservationApiGetHotelReservationsRequest) RecentlyAccessed(recentlyAccessed bool) ReservationApiGetHotelReservationsRequest {
	r.recentlyAccessed = &recentlyAccessed
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationApiGetHotelReservationsRequest) Limit(limit int32) ReservationApiGetHotelReservationsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationApiGetHotelReservationsRequest) Offset(offset int32) ReservationApiGetHotelReservationsRequest {
	r.offset = &offset
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ReservationApiGetHotelReservationsRequest) SearchType(searchType string) ReservationApiGetHotelReservationsRequest {
	r.searchType = &searchType
	return r
}

// Free form text field for searching all reservation fields
func (r ReservationApiGetHotelReservationsRequest) Text(text string) ReservationApiGetHotelReservationsRequest {
	r.text = &text
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetHotelReservationsRequest) ReservationIdList(reservationIdList []string) ReservationApiGetHotelReservationsRequest {
	r.reservationIdList = &reservationIdList
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetHotelReservationsRequest) ConfirmationNumberList(confirmationNumberList []string) ReservationApiGetHotelReservationsRequest {
	r.confirmationNumberList = &confirmationNumberList
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetHotelReservationsRequest) CancellationNumberList(cancellationNumberList []string) ReservationApiGetHotelReservationsRequest {
	r.cancellationNumberList = &cancellationNumberList
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetHotelReservationsRequest) ExternalReferenceIds(externalReferenceIds []string) ReservationApiGetHotelReservationsRequest {
	r.externalReferenceIds = &externalReferenceIds
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ReservationApiGetHotelReservationsRequest) ExternalSystemCodes(externalSystemCodes []string) ReservationApiGetHotelReservationsRequest {
	r.externalSystemCodes = &externalSystemCodes
	return r
}

// The ending value of the date range.
func (r ReservationApiGetHotelReservationsRequest) ArrivalEndDate(arrivalEndDate string) ReservationApiGetHotelReservationsRequest {
	r.arrivalEndDate = &arrivalEndDate
	return r
}

// The starting value of the date range.
func (r ReservationApiGetHotelReservationsRequest) ArrivalStartDate(arrivalStartDate string) ReservationApiGetHotelReservationsRequest {
	r.arrivalStartDate = &arrivalStartDate
	return r
}

// The ending value of the date range.
func (r ReservationApiGetHotelReservationsRequest) DepartureEndDate(departureEndDate string) ReservationApiGetHotelReservationsRequest {
	r.departureEndDate = &departureEndDate
	return r
}

// The starting value of the date range.
func (r ReservationApiGetHotelReservationsRequest) DepartureStartDate(departureStartDate string) ReservationApiGetHotelReservationsRequest {
	r.departureStartDate = &departureStartDate
	return r
}

// The starting value of the date range.
func (r ReservationApiGetHotelReservationsRequest) StayOnStartDate(stayOnStartDate string) ReservationApiGetHotelReservationsRequest {
	r.stayOnStartDate = &stayOnStartDate
	return r
}

// Fetches reservations which are created on the given property business date.
func (r ReservationApiGetHotelReservationsRequest) CreatedOnStartDate(createdOnStartDate string) ReservationApiGetHotelReservationsRequest {
	r.createdOnStartDate = &createdOnStartDate
	return r
}

// The ending value of the time span.
func (r ReservationApiGetHotelReservationsRequest) ExpectedArrivalEndTime(expectedArrivalEndTime string) ReservationApiGetHotelReservationsRequest {
	r.expectedArrivalEndTime = &expectedArrivalEndTime
	return r
}

// The starting value of the time span.
func (r ReservationApiGetHotelReservationsRequest) ExpectedArrivalStartTime(expectedArrivalStartTime string) ReservationApiGetHotelReservationsRequest {
	r.expectedArrivalStartTime = &expectedArrivalStartTime
	return r
}

// The ending value of the date range.
func (r ReservationApiGetHotelReservationsRequest) DepositDueEndDate(depositDueEndDate string) ReservationApiGetHotelReservationsRequest {
	r.depositDueEndDate = &depositDueEndDate
	return r
}

// The starting value of the date range.
func (r ReservationApiGetHotelReservationsRequest) DepositDueStartDate(depositDueStartDate string) ReservationApiGetHotelReservationsRequest {
	r.depositDueStartDate = &depositDueStartDate
	return r
}

// The ending value of the time span.
func (r ReservationApiGetHotelReservationsRequest) ExpectedReturnEndTime(expectedReturnEndTime string) ReservationApiGetHotelReservationsRequest {
	r.expectedReturnEndTime = &expectedReturnEndTime
	return r
}

// The starting value of the time span.
func (r ReservationApiGetHotelReservationsRequest) ExpectedReturnStartTime(expectedReturnStartTime string) ReservationApiGetHotelReservationsRequest {
	r.expectedReturnStartTime = &expectedReturnStartTime
	return r
}

// Attached profile name
func (r ReservationApiGetHotelReservationsRequest) CompanyNames(companyNames []string) ReservationApiGetHotelReservationsRequest {
	r.companyNames = &companyNames
	return r
}

// Attached profile name
func (r ReservationApiGetHotelReservationsRequest) SourceNames(sourceNames []string) ReservationApiGetHotelReservationsRequest {
	r.sourceNames = &sourceNames
	return r
}

// Attached profile name
func (r ReservationApiGetHotelReservationsRequest) TravelAgentNames(travelAgentNames []string) ReservationApiGetHotelReservationsRequest {
	r.travelAgentNames = &travelAgentNames
	return r
}

// Attached profile name
func (r ReservationApiGetHotelReservationsRequest) GroupNames(groupNames []string) ReservationApiGetHotelReservationsRequest {
	r.groupNames = &groupNames
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation. API expects CompanyName Query parameter along with the ID to obtain correct results.
func (r ReservationApiGetHotelReservationsRequest) TravelAgentIds(travelAgentIds []string) ReservationApiGetHotelReservationsRequest {
	r.travelAgentIds = &travelAgentIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation. API expects CompanyName Query parameter along with the ID to obtain correct results.
func (r ReservationApiGetHotelReservationsRequest) CompanyIds(companyIds []string) ReservationApiGetHotelReservationsRequest {
	r.companyIds = &companyIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation. API expects CompanyName Query parameter along with the ID to obtain correct results.
func (r ReservationApiGetHotelReservationsRequest) SourceIds(sourceIds []string) ReservationApiGetHotelReservationsRequest {
	r.sourceIds = &sourceIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation. API expects CompanyName Query parameter along with the ID to obtain correct results.
func (r ReservationApiGetHotelReservationsRequest) ContactIds(contactIds []string) ReservationApiGetHotelReservationsRequest {
	r.contactIds = &contactIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation. API expects CompanyName Query parameter along with the ID to obtain correct results.
func (r ReservationApiGetHotelReservationsRequest) GroupIds(groupIds []string) ReservationApiGetHotelReservationsRequest {
	r.groupIds = &groupIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation. API expects CompanyName Query parameter along with the ID to obtain correct results.
func (r ReservationApiGetHotelReservationsRequest) BillingContactIds(billingContactIds []string) ReservationApiGetHotelReservationsRequest {
	r.billingContactIds = &billingContactIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetHotelReservationsRequest) ProfileId(profileId string) ReservationApiGetHotelReservationsRequest {
	r.profileId = &profileId
	return r
}

// Commission Paid criteria
func (r ReservationApiGetHotelReservationsRequest) CommissionPaid(commissionPaid bool) ReservationApiGetHotelReservationsRequest {
	r.commissionPaid = &commissionPaid
	return r
}

// Membership ID criteria.
func (r ReservationApiGetHotelReservationsRequest) MembershipCardNumber(membershipCardNumber string) ReservationApiGetHotelReservationsRequest {
	r.membershipCardNumber = &membershipCardNumber
	return r
}

func (r ReservationApiGetHotelReservationsRequest) MembershipLevels(membershipLevels []string) ReservationApiGetHotelReservationsRequest {
	r.membershipLevels = &membershipLevels
	return r
}

func (r ReservationApiGetHotelReservationsRequest) MembershipTypes(membershipTypes []string) ReservationApiGetHotelReservationsRequest {
	r.membershipTypes = &membershipTypes
	return r
}

// Family name, last name.
func (r ReservationApiGetHotelReservationsRequest) Surname(surname string) ReservationApiGetHotelReservationsRequest {
	r.surname = &surname
	return r
}

// Given name, first name or names
func (r ReservationApiGetHotelReservationsRequest) GivenName(givenName string) ReservationApiGetHotelReservationsRequest {
	r.givenName = &givenName
	return r
}

// Given name, first name or names
func (r ReservationApiGetHotelReservationsRequest) FromName(fromName string) ReservationApiGetHotelReservationsRequest {
	r.fromName = &fromName
	return r
}

// Given name, first name or names
func (r ReservationApiGetHotelReservationsRequest) ToName(toName string) ReservationApiGetHotelReservationsRequest {
	r.toName = &toName
	return r
}

// VIP status of the customer.
func (r ReservationApiGetHotelReservationsRequest) AnyVIPStatus(anyVIPStatus bool) ReservationApiGetHotelReservationsRequest {
	r.anyVIPStatus = &anyVIPStatus
	return r
}

// VIP status of the customer.
func (r ReservationApiGetHotelReservationsRequest) VipCodes(vipCodes []string) ReservationApiGetHotelReservationsRequest {
	r.vipCodes = &vipCodes
	return r
}

// Fetches the reservation having Guarantee Code(Reservation Type) supplied here.
func (r ReservationApiGetHotelReservationsRequest) GuaranteeCode(guaranteeCode string) ReservationApiGetHotelReservationsRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// Fetches the reservation having method of payment supplied here.
func (r ReservationApiGetHotelReservationsRequest) PaymentMethod(paymentMethod string) ReservationApiGetHotelReservationsRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Fetches the reservation for which discount is applied
func (r ReservationApiGetHotelReservationsRequest) DiscountApplied(discountApplied bool) ReservationApiGetHotelReservationsRequest {
	r.discountApplied = &discountApplied
	return r
}

func (r ReservationApiGetHotelReservationsRequest) User(user []string) ReservationApiGetHotelReservationsRequest {
	r.user = &user
	return r
}

// Fetches reservation created by specified user. If both CreatedByUsers and CreatedBy is specified, CreatedByUsers will take precedence.
func (r ReservationApiGetHotelReservationsRequest) CreatedBy(createdBy string) ReservationApiGetHotelReservationsRequest {
	r.createdBy = &createdBy
	return r
}

// Fetches reservations cancelled by list of users.
func (r ReservationApiGetHotelReservationsRequest) CancelledByList(cancelledByList []string) ReservationApiGetHotelReservationsRequest {
	r.cancelledByList = &cancelledByList
	return r
}

// Fetches reservations which are cancelled on the given property business date.
func (r ReservationApiGetHotelReservationsRequest) CancelledOn(cancelledOn string) ReservationApiGetHotelReservationsRequest {
	r.cancelledOn = &cancelledOn
	return r
}

func (r ReservationApiGetHotelReservationsRequest) RatePlanCodes(ratePlanCodes []string) ReservationApiGetHotelReservationsRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ReservationApiGetHotelReservationsRequest) SourceCodes(sourceCodes []string) ReservationApiGetHotelReservationsRequest {
	r.sourceCodes = &sourceCodes
	return r
}

func (r ReservationApiGetHotelReservationsRequest) MarketCodes(marketCodes []string) ReservationApiGetHotelReservationsRequest {
	r.marketCodes = &marketCodes
	return r
}

// If true the search result will exclude the blocks reservations.
func (r ReservationApiGetHotelReservationsRequest) ExcludeBlockReservations(excludeBlockReservations bool) ReservationApiGetHotelReservationsRequest {
	r.excludeBlockReservations = &excludeBlockReservations
	return r
}

// The Hotel Code of the Block.
func (r ReservationApiGetHotelReservationsRequest) BlockCriteriaHotelCode(blockCriteriaHotelCode string) ReservationApiGetHotelReservationsRequest {
	r.blockCriteriaHotelCode = &blockCriteriaHotelCode
	return r
}

// The Name of the block that is attached to the reservation.
func (r ReservationApiGetHotelReservationsRequest) BlockName(blockName string) ReservationApiGetHotelReservationsRequest {
	r.blockName = &blockName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetHotelReservationsRequest) BlockIds(blockIds []string) ReservationApiGetHotelReservationsRequest {
	r.blockIds = &blockIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetHotelReservationsRequest) BlockCodes(blockCodes []string) ReservationApiGetHotelReservationsRequest {
	r.blockCodes = &blockCodes
	return r
}

// Custom reference
func (r ReservationApiGetHotelReservationsRequest) CustomReference(customReference string) ReservationApiGetHotelReservationsRequest {
	r.customReference = &customReference
	return r
}

// GDS Record Locator for reservation.
func (r ReservationApiGetHotelReservationsRequest) RecordLocator(recordLocator string) ReservationApiGetHotelReservationsRequest {
	r.recordLocator = &recordLocator
	return r
}

func (r ReservationApiGetHotelReservationsRequest) OrderBy(orderBy []string) ReservationApiGetHotelReservationsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ReservationApiGetHotelReservationsRequest) SortOrder(sortOrder []string) ReservationApiGetHotelReservationsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Indicator to query reservations which have a room number assigned.
func (r ReservationApiGetHotelReservationsRequest) RoomAssignedOnly(roomAssignedOnly bool) ReservationApiGetHotelReservationsRequest {
	r.roomAssignedOnly = &roomAssignedOnly
	return r
}

// Indicator to query reservations which does not have a room number assigned.
func (r ReservationApiGetHotelReservationsRequest) RoomUnassignedOnly(roomUnassignedOnly bool) ReservationApiGetHotelReservationsRequest {
	r.roomUnassignedOnly = &roomUnassignedOnly
	return r
}

// Room number of the reservation to search by.
func (r ReservationApiGetHotelReservationsRequest) RoomId(roomId string) ReservationApiGetHotelReservationsRequest {
	r.roomId = &roomId
	return r
}

// Room Type.
func (r ReservationApiGetHotelReservationsRequest) RoomType(roomType []string) ReservationApiGetHotelReservationsRequest {
	r.roomType = &roomType
	return r
}

// A code representing a room feature.
func (r ReservationApiGetHotelReservationsRequest) RoomFeatures(roomFeatures []string) ReservationApiGetHotelReservationsRequest {
	r.roomFeatures = &roomFeatures
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetHotelReservationsRequest) RoomSpecials(roomSpecials []string) ReservationApiGetHotelReservationsRequest {
	r.roomSpecials = &roomSpecials
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetHotelReservationsRequest) RoomSmokingPreference(roomSmokingPreference string) ReservationApiGetHotelReservationsRequest {
	r.roomSmokingPreference = &roomSmokingPreference
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetHotelReservationsRequest) RoomFloorPreferences(roomFloorPreferences []string) ReservationApiGetHotelReservationsRequest {
	r.roomFloorPreferences = &roomFloorPreferences
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r ReservationApiGetHotelReservationsRequest) HousekeepingRoomStatuses(housekeepingRoomStatuses []string) ReservationApiGetHotelReservationsRequest {
	r.housekeepingRoomStatuses = &housekeepingRoomStatuses
	return r
}

func (r ReservationApiGetHotelReservationsRequest) RoomClasses(roomClasses []string) ReservationApiGetHotelReservationsRequest {
	r.roomClasses = &roomClasses
	return r
}

func (r ReservationApiGetHotelReservationsRequest) RoomRangeFrom(roomRangeFrom string) ReservationApiGetHotelReservationsRequest {
	r.roomRangeFrom = &roomRangeFrom
	return r
}

func (r ReservationApiGetHotelReservationsRequest) RoomRangeTo(roomRangeTo string) ReservationApiGetHotelReservationsRequest {
	r.roomRangeTo = &roomRangeTo
	return r
}

// Filter by the last digits of a reservation&#39;s phone number.
func (r ReservationApiGetHotelReservationsRequest) Communication(communication string) ReservationApiGetHotelReservationsRequest {
	r.communication = &communication
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r ReservationApiGetHotelReservationsRequest) FetchInstructions(fetchInstructions []string) ReservationApiGetHotelReservationsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Flag indicating whether the Enrollment is in progress or not for the Profile associated with this Reservation.
func (r ReservationApiGetHotelReservationsRequest) AllowedReservationActions(allowedReservationActions []string) ReservationApiGetHotelReservationsRequest {
	r.allowedReservationActions = &allowedReservationActions
	return r
}

// Flag containing true or false value for reservation to be eligible for prior check in by guest using mobile device. Pass the &#39;true&#39; or &#39;false&#39; values when creating / modifying reservation to indicate whether a reservation is eligible for mobile check in yes / no. Upon fetch, the current state of the flag will show true or false.
func (r ReservationApiGetHotelReservationsRequest) AllowPreRegistration(allowPreRegistration bool) ReservationApiGetHotelReservationsRequest {
	r.allowPreRegistration = &allowPreRegistration
	return r
}

// Indicates that reservations with No Post flag should not be expected from the result.
func (r ReservationApiGetHotelReservationsRequest) ExcludeNoPost(excludeNoPost bool) ReservationApiGetHotelReservationsRequest {
	r.excludeNoPost = &excludeNoPost
	return r
}

// Indicates that reservations with PM room type should not be expected from the result.
func (r ReservationApiGetHotelReservationsRequest) ExcludePMRooms(excludePMRooms bool) ReservationApiGetHotelReservationsRequest {
	r.excludePMRooms = &excludePMRooms
	return r
}

// Indicates that only reservations with deposit balance should be expected from the result.
func (r ReservationApiGetHotelReservationsRequest) HasDepositBalance(hasDepositBalance bool) ReservationApiGetHotelReservationsRequest {
	r.hasDepositBalance = &hasDepositBalance
	return r
}

// Indicates that only reservations with open balance should be expected from the result.
func (r ReservationApiGetHotelReservationsRequest) HasOpenBalance(hasOpenBalance bool) ReservationApiGetHotelReservationsRequest {
	r.hasOpenBalance = &hasOpenBalance
	return r
}

// Indicates that only reservations with open folio should be expected from the result.
func (r ReservationApiGetHotelReservationsRequest) HasOpenFolio(hasOpenFolio bool) ReservationApiGetHotelReservationsRequest {
	r.hasOpenFolio = &hasOpenFolio
	return r
}

// Criteria that indicates whether to scheduled checkouts or not.
func (r ReservationApiGetHotelReservationsRequest) IncludeScheduledCheckOut(includeScheduledCheckOut bool) ReservationApiGetHotelReservationsRequest {
	r.includeScheduledCheckOut = &includeScheduledCheckOut
	return r
}

// Indicates that only linked reservations should be expected from the result.
func (r ReservationApiGetHotelReservationsRequest) LinkedOnly(linkedOnly bool) ReservationApiGetHotelReservationsRequest {
	r.linkedOnly = &linkedOnly
	return r
}

// Indicates that only unlinked reservations should be expected from the result.
func (r ReservationApiGetHotelReservationsRequest) UnlinkedOnly(unlinkedOnly bool) ReservationApiGetHotelReservationsRequest {
	r.unlinkedOnly = &unlinkedOnly
	return r
}

// Indicates if reservations which have already arrived on the Search Date is required.
func (r ReservationApiGetHotelReservationsRequest) ActualArrivals(actualArrivals bool) ReservationApiGetHotelReservationsRequest {
	r.actualArrivals = &actualArrivals
	return r
}

// Indicates if reservations which were expected to depart on the Search Date and have already checked, is required.
func (r ReservationApiGetHotelReservationsRequest) ActualDepartures(actualDepartures bool) ReservationApiGetHotelReservationsRequest {
	r.actualDepartures = &actualDepartures
	return r
}

// Indicates if reservations where rate codes are marked as Complimentary Rates , is required. This flag should be used in conjunction with the Arrivals, Departures or StayOvers criteria.
func (r ReservationApiGetHotelReservationsRequest) ComplimentaryReservations(complimentaryReservations bool) ReservationApiGetHotelReservationsRequest {
	r.complimentaryReservations = &complimentaryReservations
	return r
}

// Indicates if reservations which have cancelled on the Search Date which is also the day of arrival is required.
func (r ReservationApiGetHotelReservationsRequest) DayOfArrivalCancels(dayOfArrivalCancels bool) ReservationApiGetHotelReservationsRequest {
	r.dayOfArrivalCancels = &dayOfArrivalCancels
	return r
}

// Indicates if reservations which are day use reservation on the Search Date, is required.
func (r ReservationApiGetHotelReservationsRequest) DayUse(dayUse bool) ReservationApiGetHotelReservationsRequest {
	r.dayUse = &dayUse
	return r
}

// Indicates if reservations which checked out early on the Search Date, is required.
func (r ReservationApiGetHotelReservationsRequest) EarlyDepartures(earlyDepartures bool) ReservationApiGetHotelReservationsRequest {
	r.earlyDepartures = &earlyDepartures
	return r
}

// Indicates if reservations which are expected arrivals for the Search Date and who have not yet arrived, is required.
func (r ReservationApiGetHotelReservationsRequest) ExpectedArrivals(expectedArrivals bool) ReservationApiGetHotelReservationsRequest {
	r.expectedArrivals = &expectedArrivals
	return r
}

// Indicates if reservations which are expected departures for the Search Date and who have not yet departed, is required.
func (r ReservationApiGetHotelReservationsRequest) ExpectedDepartures(expectedDepartures bool) ReservationApiGetHotelReservationsRequest {
	r.expectedDepartures = &expectedDepartures
	return r
}

// Indicates if reservations which have extended their stays on the Search Date, is required.
func (r ReservationApiGetHotelReservationsRequest) ExtendedStays(extendedStays bool) ReservationApiGetHotelReservationsRequest {
	r.extendedStays = &extendedStays
	return r
}

// Indicates if reservations where rate codes are marked as House Use Rates , is required. This flag should be used in conjunction with the Arrivals, Departures or StayOvers criteria.
func (r ReservationApiGetHotelReservationsRequest) HouseUseReservations(houseUseReservations bool) ReservationApiGetHotelReservationsRequest {
	r.houseUseReservations = &houseUseReservations
	return r
}

// Indicates if reservations which are StayOvers on the Search Date, is required.
func (r ReservationApiGetHotelReservationsRequest) Stayovers(stayovers bool) ReservationApiGetHotelReservationsRequest {
	r.stayovers = &stayovers
	return r
}

// Date for searching the reservations. This is the date for which the search types are applicable. If date is not available, the business date will be used by default.
func (r ReservationApiGetHotelReservationsRequest) StayDate(stayDate string) ReservationApiGetHotelReservationsRequest {
	r.stayDate = &stayDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetHotelReservationsRequest) RoomRoutingId(roomRoutingId string) ReservationApiGetHotelReservationsRequest {
	r.roomRoutingId = &roomRoutingId
	return r
}

// Periodic folio type.
func (r ReservationApiGetHotelReservationsRequest) PeriodicFolio(periodicFolio string) ReservationApiGetHotelReservationsRequest {
	r.periodicFolio = &periodicFolio
	return r
}

// Comma-delimited list of Folio Settlement Type codes.
func (r ReservationApiGetHotelReservationsRequest) FolioSettlementTypes(folioSettlementTypes string) ReservationApiGetHotelReservationsRequest {
	r.folioSettlementTypes = &folioSettlementTypes
	return r
}

// Use the Number of Days For Settlement, defined for the Reservation.
func (r ReservationApiGetHotelReservationsRequest) DefaultDays(defaultDays bool) ReservationApiGetHotelReservationsRequest {
	r.defaultDays = &defaultDays
	return r
}

// Indicates to exclude Pseudo room reservations.
func (r ReservationApiGetHotelReservationsRequest) ExcludePseudoRoomReservations(excludePseudoRoomReservations bool) ReservationApiGetHotelReservationsRequest {
	r.excludePseudoRoomReservations = &excludePseudoRoomReservations
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetHotelReservationsRequest) ExcludeReservationIds(excludeReservationIds []string) ReservationApiGetHotelReservationsRequest {
	r.excludeReservationIds = &excludeReservationIds
	return r
}

// VIP status of the customer.
func (r ReservationApiGetHotelReservationsRequest) ExcludeVIPStatusCodes(excludeVIPStatusCodes []string) ReservationApiGetHotelReservationsRequest {
	r.excludeVIPStatusCodes = &excludeVIPStatusCodes
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetHotelReservationsRequest) ExcludeSpecials(excludeSpecials []string) ReservationApiGetHotelReservationsRequest {
	r.excludeSpecials = &excludeSpecials
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetHotelReservationsRequest) ExcludeFloorPreferences(excludeFloorPreferences []string) ReservationApiGetHotelReservationsRequest {
	r.excludeFloorPreferences = &excludeFloorPreferences
	return r
}

// Indicates to exclude Advance Checked In Reservations from search result.
func (r ReservationApiGetHotelReservationsRequest) ExcludeAdvanceCheckedIn(excludeAdvanceCheckedIn bool) ReservationApiGetHotelReservationsRequest {
	r.excludeAdvanceCheckedIn = &excludeAdvanceCheckedIn
	return r
}

// Exclude the reservation(s) with provided room features from the search result.
func (r ReservationApiGetHotelReservationsRequest) ExcludeRoomFeatures(excludeRoomFeatures []string) ReservationApiGetHotelReservationsRequest {
	r.excludeRoomFeatures = &excludeRoomFeatures
	return r
}

// Player ID associated to the reservation.
func (r ReservationApiGetHotelReservationsRequest) PlayerId(playerId string) ReservationApiGetHotelReservationsRequest {
	r.playerId = &playerId
	return r
}

// Balance from.
func (r ReservationApiGetHotelReservationsRequest) GamingBalanceFrom(gamingBalanceFrom float32) ReservationApiGetHotelReservationsRequest {
	r.gamingBalanceFrom = &gamingBalanceFrom
	return r
}

// Balance to.
func (r ReservationApiGetHotelReservationsRequest) GamingBalanceTo(gamingBalanceTo float32) ReservationApiGetHotelReservationsRequest {
	r.gamingBalanceTo = &gamingBalanceTo
	return r
}

// Comp Balance From
func (r ReservationApiGetHotelReservationsRequest) CompAccountingBalanceFrom(compAccountingBalanceFrom float32) ReservationApiGetHotelReservationsRequest {
	r.compAccountingBalanceFrom = &compAccountingBalanceFrom
	return r
}

// Comp Balance To
func (r ReservationApiGetHotelReservationsRequest) CompAccountingBalanceTo(compAccountingBalanceTo float32) ReservationApiGetHotelReservationsRequest {
	r.compAccountingBalanceTo = &compAccountingBalanceTo
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ReservationApiGetHotelReservationsRequest) SearchTypes(searchTypes []string) ReservationApiGetHotelReservationsRequest {
	r.searchTypes = &searchTypes
	return r
}

// Reservation status type for reservations search.
func (r ReservationApiGetHotelReservationsRequest) ReservationStatuses(reservationStatuses []string) ReservationApiGetHotelReservationsRequest {
	r.reservationStatuses = &reservationStatuses
	return r
}

// Codes to be searched.
func (r ReservationApiGetHotelReservationsRequest) TransportationCodes(transportationCodes []string) ReservationApiGetHotelReservationsRequest {
	r.transportationCodes = &transportationCodes
	return r
}

// Enum to denote the Status of Readiness messages sent to Guest Devices.
func (r ReservationApiGetHotelReservationsRequest) RoomReadyStatuses(roomReadyStatuses []string) ReservationApiGetHotelReservationsRequest {
	r.roomReadyStatuses = &roomReadyStatuses
	return r
}

// Fetches the reservations for which Checkout Message is received.
func (r ReservationApiGetHotelReservationsRequest) CheckoutMessageReceived(checkoutMessageReceived bool) ReservationApiGetHotelReservationsRequest {
	r.checkoutMessageReceived = &checkoutMessageReceived
	return r
}

// Fetches the reservations for which reservation communication has been opted.
func (r ReservationApiGetHotelReservationsRequest) OptedForCommunication(optedForCommunication bool) ReservationApiGetHotelReservationsRequest {
	r.optedForCommunication = &optedForCommunication
	return r
}

// Fetches the reservations for which this reservation room can be shifted or swapped.
func (r ReservationApiGetHotelReservationsRequest) SwapShiftRoomReservationId(swapShiftRoomReservationId string) ReservationApiGetHotelReservationsRequest {
	r.swapShiftRoomReservationId = &swapShiftRoomReservationId
	return r
}

// The smoking preferences of rooms to be fetched.
func (r ReservationApiGetHotelReservationsRequest) RoomSmokingPreferences(roomSmokingPreferences []string) ReservationApiGetHotelReservationsRequest {
	r.roomSmokingPreferences = &roomSmokingPreferences
	return r
}

// The room features of the rooms. Fetches reservations with rooms that have same room features. It has to be used in conjunction with roomType, arrivalStartDate, and arrivalEndDate.
func (r ReservationApiGetHotelReservationsRequest) RoomFeaturePreferences(roomFeaturePreferences []string) ReservationApiGetHotelReservationsRequest {
	r.roomFeaturePreferences = &roomFeaturePreferences
	return r
}

// The floor of the rooms. Fetches reservations with rooms that are on the same floor. It has to be used in conjunction with roomType, arrivalStartDate, and arrivalEndDate.
func (r ReservationApiGetHotelReservationsRequest) RoomsFloorPreferences(roomsFloorPreferences []string) ReservationApiGetHotelReservationsRequest {
	r.roomsFloorPreferences = &roomsFloorPreferences
	return r
}

// Name of Contact Profile associated with Reservation.
func (r ReservationApiGetHotelReservationsRequest) ContactNames(contactNames []string) ReservationApiGetHotelReservationsRequest {
	r.contactNames = &contactNames
	return r
}

// External system code.
func (r ReservationApiGetHotelReservationsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetHotelReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetHotelReservationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetHotelReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetHotelReservationsRequest) Execute() (*ReservationsDetails, *http.Response, error) {
	return r.ApiService.GetHotelReservationsExecute(r)
}

/*
GetHotelReservations Get and search for reservations in a hotel

Use this API to search reservations in a hotel, filtering by whether they are Day Use, Due In, Checked In, Due Out, Checked Out, Cancelled, No Show and Complimentary or any other of the large selection of search criteria. It also serves as an entry way for changing existing reservation information, canceling reservations, checking in guests, canceling check ins, etc. You can use further query parameters to narrow your results. This API is not designed to support sync between two systems or initial upload of data.<p><strong>OperationId:</strong>getHotelReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetHotelReservationsRequest
*/
func (a *ReservationApiService) GetHotelReservations(ctx context.Context, hotelId string) ReservationApiGetHotelReservationsRequest {
	return ReservationApiGetHotelReservationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationsDetails
func (a *ReservationApiService) GetHotelReservationsExecute(r ReservationApiGetHotelReservationsRequest) (*ReservationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetHotelReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.keyTrack2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyTrack2", r.keyTrack2, "")
	}
	if r.discrepancy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discrepancy", r.discrepancy, "")
	}
	if r.recentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recentlyAccessed", r.recentlyAccessed, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchType", r.searchType, "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.reservationIdList != nil {
		t := *r.reservationIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdList", t, "multi")
		}
	}
	if r.confirmationNumberList != nil {
		t := *r.confirmationNumberList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "confirmationNumberList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "confirmationNumberList", t, "multi")
		}
	}
	if r.cancellationNumberList != nil {
		t := *r.cancellationNumberList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cancellationNumberList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cancellationNumberList", t, "multi")
		}
	}
	if r.externalReferenceIds != nil {
		t := *r.externalReferenceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", t, "multi")
		}
	}
	if r.externalSystemCodes != nil {
		t := *r.externalSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", t, "multi")
		}
	}
	if r.arrivalEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEndDate", r.arrivalEndDate, "")
	}
	if r.arrivalStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStartDate", r.arrivalStartDate, "")
	}
	if r.departureEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureEndDate", r.departureEndDate, "")
	}
	if r.departureStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureStartDate", r.departureStartDate, "")
	}
	if r.stayOnStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayOnStartDate", r.stayOnStartDate, "")
	}
	if r.createdOnStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOnStartDate", r.createdOnStartDate, "")
	}
	if r.expectedArrivalEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalEndTime", r.expectedArrivalEndTime, "")
	}
	if r.expectedArrivalStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalStartTime", r.expectedArrivalStartTime, "")
	}
	if r.depositDueEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depositDueEndDate", r.depositDueEndDate, "")
	}
	if r.depositDueStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depositDueStartDate", r.depositDueStartDate, "")
	}
	if r.expectedReturnEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnEndTime", r.expectedReturnEndTime, "")
	}
	if r.expectedReturnStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnStartTime", r.expectedReturnStartTime, "")
	}
	if r.companyNames != nil {
		t := *r.companyNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyNames", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyNames", t, "multi")
		}
	}
	if r.sourceNames != nil {
		t := *r.sourceNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceNames", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceNames", t, "multi")
		}
	}
	if r.travelAgentNames != nil {
		t := *r.travelAgentNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentNames", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentNames", t, "multi")
		}
	}
	if r.groupNames != nil {
		t := *r.groupNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupNames", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupNames", t, "multi")
		}
	}
	if r.travelAgentIds != nil {
		t := *r.travelAgentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", t, "multi")
		}
	}
	if r.companyIds != nil {
		t := *r.companyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", t, "multi")
		}
	}
	if r.sourceIds != nil {
		t := *r.sourceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", t, "multi")
		}
	}
	if r.contactIds != nil {
		t := *r.contactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", t, "multi")
		}
	}
	if r.groupIds != nil {
		t := *r.groupIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", t, "multi")
		}
	}
	if r.billingContactIds != nil {
		t := *r.billingContactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", t, "multi")
		}
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.commissionPaid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "commissionPaid", r.commissionPaid, "")
	}
	if r.membershipCardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipCardNumber", r.membershipCardNumber, "")
	}
	if r.membershipLevels != nil {
		t := *r.membershipLevels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", t, "multi")
		}
	}
	if r.membershipTypes != nil {
		t := *r.membershipTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", t, "multi")
		}
	}
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.fromName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromName", r.fromName, "")
	}
	if r.toName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toName", r.toName, "")
	}
	if r.anyVIPStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anyVIPStatus", r.anyVIPStatus, "")
	}
	if r.vipCodes != nil {
		t := *r.vipCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", t, "multi")
		}
	}
	if r.guaranteeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", r.guaranteeCode, "")
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	}
	if r.discountApplied != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discountApplied", r.discountApplied, "")
	}
	if r.user != nil {
		t := *r.user
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user", t, "multi")
		}
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBy", r.createdBy, "")
	}
	if r.cancelledByList != nil {
		t := *r.cancelledByList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledByList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledByList", t, "multi")
		}
	}
	if r.cancelledOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledOn", r.cancelledOn, "")
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.sourceCodes != nil {
		t := *r.sourceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", t, "multi")
		}
	}
	if r.marketCodes != nil {
		t := *r.marketCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", t, "multi")
		}
	}
	if r.excludeBlockReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeBlockReservations", r.excludeBlockReservations, "")
	}
	if r.blockCriteriaHotelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCriteriaHotelCode", r.blockCriteriaHotelCode, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.blockIds != nil {
		t := *r.blockIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIds", t, "multi")
		}
	}
	if r.blockCodes != nil {
		t := *r.blockCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodes", t, "multi")
		}
	}
	if r.customReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customReference", r.customReference, "")
	}
	if r.recordLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recordLocator", r.recordLocator, "")
	}
	if r.orderBy != nil {
		t := *r.orderBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", t, "multi")
		}
	}
	if r.sortOrder != nil {
		t := *r.sortOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", t, "multi")
		}
	}
	if r.roomAssignedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignedOnly", r.roomAssignedOnly, "")
	}
	if r.roomUnassignedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomUnassignedOnly", r.roomUnassignedOnly, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "csv")
	}
	if r.roomFeatures != nil {
		t := *r.roomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", t, "multi")
		}
	}
	if r.roomSpecials != nil {
		t := *r.roomSpecials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomSpecials", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomSpecials", t, "multi")
		}
	}
	if r.roomSmokingPreference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomSmokingPreference", r.roomSmokingPreference, "")
	}
	if r.roomFloorPreferences != nil {
		t := *r.roomFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFloorPreferences", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFloorPreferences", t, "multi")
		}
	}
	if r.housekeepingRoomStatuses != nil {
		t := *r.housekeepingRoomStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatuses", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	if r.roomRangeFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRangeFrom", r.roomRangeFrom, "")
	}
	if r.roomRangeTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRangeTo", r.roomRangeTo, "")
	}
	if r.communication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "communication", r.communication, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.allowedReservationActions != nil {
		t := *r.allowedReservationActions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedReservationActions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedReservationActions", t, "multi")
		}
	}
	if r.allowPreRegistration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowPreRegistration", r.allowPreRegistration, "")
	}
	if r.excludeNoPost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeNoPost", r.excludeNoPost, "")
	}
	if r.excludePMRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludePMRooms", r.excludePMRooms, "")
	}
	if r.hasDepositBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasDepositBalance", r.hasDepositBalance, "")
	}
	if r.hasOpenBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenBalance", r.hasOpenBalance, "")
	}
	if r.hasOpenFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenFolio", r.hasOpenFolio, "")
	}
	if r.includeScheduledCheckOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeScheduledCheckOut", r.includeScheduledCheckOut, "")
	}
	if r.linkedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedOnly", r.linkedOnly, "")
	}
	if r.unlinkedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unlinkedOnly", r.unlinkedOnly, "")
	}
	if r.actualArrivals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actualArrivals", r.actualArrivals, "")
	}
	if r.actualDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actualDepartures", r.actualDepartures, "")
	}
	if r.complimentaryReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "complimentaryReservations", r.complimentaryReservations, "")
	}
	if r.dayOfArrivalCancels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayOfArrivalCancels", r.dayOfArrivalCancels, "")
	}
	if r.dayUse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayUse", r.dayUse, "")
	}
	if r.earlyDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "earlyDepartures", r.earlyDepartures, "")
	}
	if r.expectedArrivals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivals", r.expectedArrivals, "")
	}
	if r.expectedDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedDepartures", r.expectedDepartures, "")
	}
	if r.extendedStays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extendedStays", r.extendedStays, "")
	}
	if r.houseUseReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "houseUseReservations", r.houseUseReservations, "")
	}
	if r.stayovers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayovers", r.stayovers, "")
	}
	if r.stayDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayDate", r.stayDate, "")
	}
	if r.roomRoutingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRoutingId", r.roomRoutingId, "")
	}
	if r.periodicFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "periodicFolio", r.periodicFolio, "")
	}
	if r.folioSettlementTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioSettlementTypes", r.folioSettlementTypes, "")
	}
	if r.defaultDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultDays", r.defaultDays, "")
	}
	if r.excludePseudoRoomReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludePseudoRoomReservations", r.excludePseudoRoomReservations, "")
	}
	if r.excludeReservationIds != nil {
		t := *r.excludeReservationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReservationIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReservationIds", t, "multi")
		}
	}
	if r.excludeVIPStatusCodes != nil {
		t := *r.excludeVIPStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVIPStatusCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVIPStatusCodes", t, "multi")
		}
	}
	if r.excludeSpecials != nil {
		t := *r.excludeSpecials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSpecials", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSpecials", t, "multi")
		}
	}
	if r.excludeFloorPreferences != nil {
		t := *r.excludeFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", t, "multi")
		}
	}
	if r.excludeAdvanceCheckedIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeAdvanceCheckedIn", r.excludeAdvanceCheckedIn, "")
	}
	if r.excludeRoomFeatures != nil {
		t := *r.excludeRoomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRoomFeatures", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRoomFeatures", t, "multi")
		}
	}
	if r.playerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playerId", r.playerId, "")
	}
	if r.gamingBalanceFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gamingBalanceFrom", r.gamingBalanceFrom, "")
	}
	if r.gamingBalanceTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gamingBalanceTo", r.gamingBalanceTo, "")
	}
	if r.compAccountingBalanceFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccountingBalanceFrom", r.compAccountingBalanceFrom, "")
	}
	if r.compAccountingBalanceTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccountingBalanceTo", r.compAccountingBalanceTo, "")
	}
	if r.searchTypes != nil {
		t := *r.searchTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypes", t, "multi")
		}
	}
	if r.reservationStatuses != nil {
		t := *r.reservationStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", t, "multi")
		}
	}
	if r.transportationCodes != nil {
		t := *r.transportationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", t, "multi")
		}
	}
	if r.roomReadyStatuses != nil {
		t := *r.roomReadyStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomReadyStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomReadyStatuses", t, "multi")
		}
	}
	if r.checkoutMessageReceived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkoutMessageReceived", r.checkoutMessageReceived, "")
	}
	if r.optedForCommunication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "optedForCommunication", r.optedForCommunication, "")
	}
	if r.swapShiftRoomReservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swapShiftRoomReservationId", r.swapShiftRoomReservationId, "")
	}
	if r.roomSmokingPreferences != nil {
		t := *r.roomSmokingPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomSmokingPreferences", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomSmokingPreferences", t, "multi")
		}
	}
	if r.roomFeaturePreferences != nil {
		t := *r.roomFeaturePreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeaturePreferences", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeaturePreferences", t, "multi")
		}
	}
	if r.roomsFloorPreferences != nil {
		t := *r.roomsFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomsFloorPreferences", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomsFloorPreferences", t, "multi")
		}
	}
	if r.contactNames != nil {
		t := *r.contactNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contactNames", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contactNames", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetLinkedReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	additionalReservationId *[]string
	additionalReservationIdType *[]string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetLinkedReservationsRequest) Authorization(authorization string) ReservationApiGetLinkedReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetLinkedReservationsRequest) XAppKey(xAppKey string) ReservationApiGetLinkedReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetLinkedReservationsRequest) XHotelid(xHotelid string) ReservationApiGetLinkedReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetLinkedReservationsRequest) AdditionalReservationId(additionalReservationId []string) ReservationApiGetLinkedReservationsRequest {
	r.additionalReservationId = &additionalReservationId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetLinkedReservationsRequest) AdditionalReservationIdType(additionalReservationIdType []string) ReservationApiGetLinkedReservationsRequest {
	r.additionalReservationIdType = &additionalReservationIdType
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r ReservationApiGetLinkedReservationsRequest) FetchInstructions(fetchInstructions []string) ReservationApiGetLinkedReservationsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ReservationApiGetLinkedReservationsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetLinkedReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetLinkedReservationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetLinkedReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetLinkedReservationsRequest) Execute() (*LinkedHotelReservations, *http.Response, error) {
	return r.ApiService.GetLinkedReservationsExecute(r)
}

/*
GetLinkedReservations Get linked Reservations 

Get linked Reservations for given Reservation. <p><strong>OperationId:</strong>getLinkedReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetLinkedReservationsRequest
*/
func (a *ReservationApiService) GetLinkedReservations(ctx context.Context, reservationId string, hotelId string) ReservationApiGetLinkedReservationsRequest {
	return ReservationApiGetLinkedReservationsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return LinkedHotelReservations
func (a *ReservationApiService) GetLinkedReservationsExecute(r ReservationApiGetLinkedReservationsRequest) (*LinkedHotelReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkedHotelReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetLinkedReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/linked"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.additionalReservationId != nil {
		t := *r.additionalReservationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationId", t, "multi")
		}
	}
	if r.additionalReservationIdType != nil {
		t := *r.additionalReservationIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationIdType", t, "multi")
		}
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetLinkedReservationsSummaryRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	additionalReservationId *[]string
	additionalReservationIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetLinkedReservationsSummaryRequest) Authorization(authorization string) ReservationApiGetLinkedReservationsSummaryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetLinkedReservationsSummaryRequest) XAppKey(xAppKey string) ReservationApiGetLinkedReservationsSummaryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetLinkedReservationsSummaryRequest) XHotelid(xHotelid string) ReservationApiGetLinkedReservationsSummaryRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetLinkedReservationsSummaryRequest) AdditionalReservationId(additionalReservationId []string) ReservationApiGetLinkedReservationsSummaryRequest {
	r.additionalReservationId = &additionalReservationId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetLinkedReservationsSummaryRequest) AdditionalReservationIdType(additionalReservationIdType []string) ReservationApiGetLinkedReservationsSummaryRequest {
	r.additionalReservationIdType = &additionalReservationIdType
	return r
}

// External system code.
func (r ReservationApiGetLinkedReservationsSummaryRequest) XExternalsystem(xExternalsystem string) ReservationApiGetLinkedReservationsSummaryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetLinkedReservationsSummaryRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetLinkedReservationsSummaryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetLinkedReservationsSummaryRequest) Execute() (*LinkedReservationsInfo, *http.Response, error) {
	return r.ApiService.GetLinkedReservationsSummaryExecute(r)
}

/*
GetLinkedReservationsSummary Get Reservation summary for linked Reservation

Get Reservation summary for linked Reservation of given Reservation id. <p><strong>OperationId:</strong>getLinkedReservationsSummary</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetLinkedReservationsSummaryRequest
*/
func (a *ReservationApiService) GetLinkedReservationsSummary(ctx context.Context, reservationId string, hotelId string) ReservationApiGetLinkedReservationsSummaryRequest {
	return ReservationApiGetLinkedReservationsSummaryRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return LinkedReservationsInfo
func (a *ReservationApiService) GetLinkedReservationsSummaryExecute(r ReservationApiGetLinkedReservationsSummaryRequest) (*LinkedReservationsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkedReservationsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetLinkedReservationsSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/linkedSummary"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.additionalReservationId != nil {
		t := *r.additionalReservationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationId", t, "multi")
		}
	}
	if r.additionalReservationIdType != nil {
		t := *r.additionalReservationIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationIdType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetPackageRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postingRhythm *string
	productCode *string
	ratePlanCode *string
	reservationTimeSpanStartDate *string
	reservationTimeSpanEndDate *string
	packageTimeSpanStartDate *string
	packageTimeSpanEndDate *string
	packageQuantity *int32
	packageExcludedQuantity *int32
	reservationAdults *int32
	reservationChildren *int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetPackageRequest) Authorization(authorization string) ReservationApiGetPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetPackageRequest) XAppKey(xAppKey string) ReservationApiGetPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetPackageRequest) XHotelid(xHotelid string) ReservationApiGetPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ReservationApiGetPackageRequest) PostingRhythm(postingRhythm string) ReservationApiGetPackageRequest {
	r.postingRhythm = &postingRhythm
	return r
}

func (r ReservationApiGetPackageRequest) ProductCode(productCode string) ReservationApiGetPackageRequest {
	r.productCode = &productCode
	return r
}

func (r ReservationApiGetPackageRequest) RatePlanCode(ratePlanCode string) ReservationApiGetPackageRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

func (r ReservationApiGetPackageRequest) ReservationTimeSpanStartDate(reservationTimeSpanStartDate string) ReservationApiGetPackageRequest {
	r.reservationTimeSpanStartDate = &reservationTimeSpanStartDate
	return r
}

func (r ReservationApiGetPackageRequest) ReservationTimeSpanEndDate(reservationTimeSpanEndDate string) ReservationApiGetPackageRequest {
	r.reservationTimeSpanEndDate = &reservationTimeSpanEndDate
	return r
}

func (r ReservationApiGetPackageRequest) PackageTimeSpanStartDate(packageTimeSpanStartDate string) ReservationApiGetPackageRequest {
	r.packageTimeSpanStartDate = &packageTimeSpanStartDate
	return r
}

func (r ReservationApiGetPackageRequest) PackageTimeSpanEndDate(packageTimeSpanEndDate string) ReservationApiGetPackageRequest {
	r.packageTimeSpanEndDate = &packageTimeSpanEndDate
	return r
}

func (r ReservationApiGetPackageRequest) PackageQuantity(packageQuantity int32) ReservationApiGetPackageRequest {
	r.packageQuantity = &packageQuantity
	return r
}

func (r ReservationApiGetPackageRequest) PackageExcludedQuantity(packageExcludedQuantity int32) ReservationApiGetPackageRequest {
	r.packageExcludedQuantity = &packageExcludedQuantity
	return r
}

// Defines the number of Adults.
func (r ReservationApiGetPackageRequest) ReservationAdults(reservationAdults int32) ReservationApiGetPackageRequest {
	r.reservationAdults = &reservationAdults
	return r
}

// Defines the number of Children.
func (r ReservationApiGetPackageRequest) ReservationChildren(reservationChildren int32) ReservationApiGetPackageRequest {
	r.reservationChildren = &reservationChildren
	return r
}

// Simple type for package instructions that can be used in requests for partial operations.
func (r ReservationApiGetPackageRequest) FetchInstructions(fetchInstructions []string) ReservationApiGetPackageRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ReservationApiGetPackageRequest) XExternalsystem(xExternalsystem string) ReservationApiGetPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetPackageRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetPackageRequest) Execute() (*Packages, *http.Response, error) {
	return r.ApiService.GetPackageExecute(r)
}

/*
GetPackage Get Package

Get the package availability for a hotel code and reservation id <p><strong>OperationId:</strong>getPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetPackageRequest
*/
func (a *ReservationApiService) GetPackage(ctx context.Context, reservationId string, hotelId string) ReservationApiGetPackageRequest {
	return ReservationApiGetPackageRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Packages
func (a *ReservationApiService) GetPackageExecute(r ReservationApiGetPackageRequest) (*Packages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Packages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/packages"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.postingRhythm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingRhythm", r.postingRhythm, "")
	}
	if r.productCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productCode", r.productCode, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.reservationTimeSpanStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationTimeSpanStartDate", r.reservationTimeSpanStartDate, "")
	}
	if r.reservationTimeSpanEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationTimeSpanEndDate", r.reservationTimeSpanEndDate, "")
	}
	if r.packageTimeSpanStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageTimeSpanStartDate", r.packageTimeSpanStartDate, "")
	}
	if r.packageTimeSpanEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageTimeSpanEndDate", r.packageTimeSpanEndDate, "")
	}
	if r.packageQuantity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageQuantity", r.packageQuantity, "")
	}
	if r.packageExcludedQuantity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageExcludedQuantity", r.packageExcludedQuantity, "")
	}
	if r.reservationAdults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationAdults", r.reservationAdults, "")
	}
	if r.reservationChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationChildren", r.reservationChildren, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetPaymentMethodsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeAmounts *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetPaymentMethodsRequest) Authorization(authorization string) ReservationApiGetPaymentMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetPaymentMethodsRequest) XAppKey(xAppKey string) ReservationApiGetPaymentMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetPaymentMethodsRequest) XHotelid(xHotelid string) ReservationApiGetPaymentMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to notify the operation to also retrieve the outstanding balance, current authorized amount and amount needed to be approved for each folio.
func (r ReservationApiGetPaymentMethodsRequest) IncludeAmounts(includeAmounts bool) ReservationApiGetPaymentMethodsRequest {
	r.includeAmounts = &includeAmounts
	return r
}

// External system code.
func (r ReservationApiGetPaymentMethodsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetPaymentMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetPaymentMethodsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetPaymentMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetPaymentMethodsRequest) Execute() (*ReservationPaymentMethods, *http.Response, error) {
	return r.ApiService.GetPaymentMethodsExecute(r)
}

/*
GetPaymentMethods Get a payment method 

This API will return the payment method(s) that exist on a reservation. <p><strong>OperationId:</strong>getPaymentMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetPaymentMethodsRequest
*/
func (a *ReservationApiService) GetPaymentMethods(ctx context.Context, reservationId string, hotelId string) ReservationApiGetPaymentMethodsRequest {
	return ReservationApiGetPaymentMethodsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationPaymentMethods
func (a *ReservationApiService) GetPaymentMethodsExecute(r ReservationApiGetPaymentMethodsRequest) (*ReservationPaymentMethods, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationPaymentMethods
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/paymentMethods"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeAmounts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAmounts", r.includeAmounts, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetPreArrivalMemberReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	end *string
	start *string
	membershipType *string
	externalReferenceType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetPreArrivalMemberReservationsRequest) Authorization(authorization string) ReservationApiGetPreArrivalMemberReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetPreArrivalMemberReservationsRequest) XAppKey(xAppKey string) ReservationApiGetPreArrivalMemberReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetPreArrivalMemberReservationsRequest) XHotelid(xHotelid string) ReservationApiGetPreArrivalMemberReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The ending value of the date range.
func (r ReservationApiGetPreArrivalMemberReservationsRequest) End(end string) ReservationApiGetPreArrivalMemberReservationsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r ReservationApiGetPreArrivalMemberReservationsRequest) Start(start string) ReservationApiGetPreArrivalMemberReservationsRequest {
	r.start = &start
	return r
}

// Membership Type.
func (r ReservationApiGetPreArrivalMemberReservationsRequest) MembershipType(membershipType string) ReservationApiGetPreArrivalMemberReservationsRequest {
	r.membershipType = &membershipType
	return r
}

// Type of the desired reservation external confirmation number.
func (r ReservationApiGetPreArrivalMemberReservationsRequest) ExternalReferenceType(externalReferenceType string) ReservationApiGetPreArrivalMemberReservationsRequest {
	r.externalReferenceType = &externalReferenceType
	return r
}

// External system code.
func (r ReservationApiGetPreArrivalMemberReservationsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetPreArrivalMemberReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetPreArrivalMemberReservationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetPreArrivalMemberReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetPreArrivalMemberReservationsRequest) Execute() (*PreArrivalMemberReservationsDetails, *http.Response, error) {
	return r.ApiService.GetPreArrivalMemberReservationsExecute(r)
}

/*
GetPreArrivalMemberReservations Get preArrival Member Reservations

Get preArrival Member Reservations. <p><strong>OperationId:</strong>getPreArrivalMemberReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetPreArrivalMemberReservationsRequest
*/
func (a *ReservationApiService) GetPreArrivalMemberReservations(ctx context.Context, hotelId string) ReservationApiGetPreArrivalMemberReservationsRequest {
	return ReservationApiGetPreArrivalMemberReservationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PreArrivalMemberReservationsDetails
func (a *ReservationApiService) GetPreArrivalMemberReservationsExecute(r ReservationApiGetPreArrivalMemberReservationsRequest) (*PreArrivalMemberReservationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreArrivalMemberReservationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetPreArrivalMemberReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/preArrivalMembersReservations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
	}
	if r.externalReferenceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceType", r.externalReferenceType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetPreConfiguredRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rateCode *string
	promotionCodes *[]string
	guestName *string
	guestIds *[]string
	companyName *string
	companyIds *[]string
	groupName *string
	groupIds *[]string
	travelAgentName *string
	travelAgentIds *[]string
	sourceName *string
	sourceIds *[]string
	contactName *string
	contactIds *[]string
	billingContactName *string
	billingContactIds *[]string
	addresseeName *string
	addresseeIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) Authorization(authorization string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) XAppKey(xAppKey string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) XHotelid(xHotelid string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) RateCode(rateCode string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.rateCode = &rateCode
	return r
}

// Promotion Code for ComplimentaryRouting
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) PromotionCodes(promotionCodes []string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.promotionCodes = &promotionCodes
	return r
}

// Attached profile name
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) GuestName(guestName string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.guestName = &guestName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) GuestIds(guestIds []string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.guestIds = &guestIds
	return r
}

// Attached profile name
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) CompanyName(companyName string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.companyName = &companyName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) CompanyIds(companyIds []string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.companyIds = &companyIds
	return r
}

// Attached profile name
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) GroupName(groupName string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.groupName = &groupName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) GroupIds(groupIds []string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.groupIds = &groupIds
	return r
}

// Attached profile name
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) TravelAgentName(travelAgentName string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.travelAgentName = &travelAgentName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) TravelAgentIds(travelAgentIds []string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.travelAgentIds = &travelAgentIds
	return r
}

// Attached profile name
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) SourceName(sourceName string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.sourceName = &sourceName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) SourceIds(sourceIds []string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.sourceIds = &sourceIds
	return r
}

// Attached profile name
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) ContactName(contactName string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.contactName = &contactName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) ContactIds(contactIds []string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.contactIds = &contactIds
	return r
}

// Attached profile name
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) BillingContactName(billingContactName string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.billingContactName = &billingContactName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) BillingContactIds(billingContactIds []string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.billingContactIds = &billingContactIds
	return r
}

// Attached profile name
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) AddresseeName(addresseeName string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.addresseeName = &addresseeName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) AddresseeIds(addresseeIds []string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.addresseeIds = &addresseeIds
	return r
}

// External system code.
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetPreConfiguredRoutingInstructionsRequest) Execute() (*PreConfiguredRoutingInstructions, *http.Response, error) {
	return r.ApiService.GetPreConfiguredRoutingInstructionsExecute(r)
}

/*
GetPreConfiguredRoutingInstructions Get pre-Configured Routing Instructions

Get preConfigured Routing Instructions. <p><strong>OperationId:</strong>getPreConfiguredRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetPreConfiguredRoutingInstructionsRequest
*/
func (a *ReservationApiService) GetPreConfiguredRoutingInstructions(ctx context.Context, hotelId string) ReservationApiGetPreConfiguredRoutingInstructionsRequest {
	return ReservationApiGetPreConfiguredRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PreConfiguredRoutingInstructions
func (a *ReservationApiService) GetPreConfiguredRoutingInstructionsExecute(r ReservationApiGetPreConfiguredRoutingInstructionsRequest) (*PreConfiguredRoutingInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreConfiguredRoutingInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetPreConfiguredRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/preConfiguredRoutingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.rateCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", r.rateCode, "")
	}
	if r.promotionCodes != nil {
		t := *r.promotionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCodes", t, "multi")
		}
	}
	if r.guestName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", r.guestName, "")
	}
	if r.guestIds != nil {
		t := *r.guestIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guestIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guestIds", t, "multi")
		}
	}
	if r.companyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "companyName", r.companyName, "")
	}
	if r.companyIds != nil {
		t := *r.companyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", t, "multi")
		}
	}
	if r.groupName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupName", r.groupName, "")
	}
	if r.groupIds != nil {
		t := *r.groupIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", t, "multi")
		}
	}
	if r.travelAgentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentName", r.travelAgentName, "")
	}
	if r.travelAgentIds != nil {
		t := *r.travelAgentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", t, "multi")
		}
	}
	if r.sourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceName", r.sourceName, "")
	}
	if r.sourceIds != nil {
		t := *r.sourceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", t, "multi")
		}
	}
	if r.contactName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactName", r.contactName, "")
	}
	if r.contactIds != nil {
		t := *r.contactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", t, "multi")
		}
	}
	if r.billingContactName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactName", r.billingContactName, "")
	}
	if r.billingContactIds != nil {
		t := *r.billingContactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", t, "multi")
		}
	}
	if r.addresseeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeName", r.addresseeName, "")
	}
	if r.addresseeIds != nil {
		t := *r.addresseeIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetRateInfoRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyCode *string
	summaryInfo *bool
	criteriaStartDate *string
	criteriaEndDate *string
	adults *int32
	children *int32
	childAge *[]int32
	bucket1Count *int32
	bucket2Count *int32
	bucket3Count *int32
	bucket4Count *int32
	bucket5Count *int32
	detailDate *string
	blockId *string
	blockIdType *string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	ratePlanCode *string
	effectiveRateEnd *[]string
	effectiveRateStart *[]string
	roomType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetRateInfoRequest) Authorization(authorization string) ReservationApiGetRateInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetRateInfoRequest) XAppKey(xAppKey string) ReservationApiGetRateInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetRateInfoRequest) XHotelid(xHotelid string) ReservationApiGetRateInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// The code specifying a monetary unit. Use ISO 4217, three alpha code.
func (r ReservationApiGetRateInfoRequest) CurrencyCode(currencyCode string) ReservationApiGetRateInfoRequest {
	r.currencyCode = &currencyCode
	return r
}

// Flag to indicate if summary information is required.
func (r ReservationApiGetRateInfoRequest) SummaryInfo(summaryInfo bool) ReservationApiGetRateInfoRequest {
	r.summaryInfo = &summaryInfo
	return r
}

func (r ReservationApiGetRateInfoRequest) CriteriaStartDate(criteriaStartDate string) ReservationApiGetRateInfoRequest {
	r.criteriaStartDate = &criteriaStartDate
	return r
}

func (r ReservationApiGetRateInfoRequest) CriteriaEndDate(criteriaEndDate string) ReservationApiGetRateInfoRequest {
	r.criteriaEndDate = &criteriaEndDate
	return r
}

// Defines the number of Adults.
func (r ReservationApiGetRateInfoRequest) Adults(adults int32) ReservationApiGetRateInfoRequest {
	r.adults = &adults
	return r
}

// Defines the number of Children.
func (r ReservationApiGetRateInfoRequest) Children(children int32) ReservationApiGetRateInfoRequest {
	r.children = &children
	return r
}

// Age of a child in years.
func (r ReservationApiGetRateInfoRequest) ChildAge(childAge []int32) ReservationApiGetRateInfoRequest {
	r.childAge = &childAge
	return r
}

// Number of children classified under the first Age Qualifying Group(Child Bucket#1).
func (r ReservationApiGetRateInfoRequest) Bucket1Count(bucket1Count int32) ReservationApiGetRateInfoRequest {
	r.bucket1Count = &bucket1Count
	return r
}

// Number of children classified under the second Age Qualifying Group(Child Bucket#2).
func (r ReservationApiGetRateInfoRequest) Bucket2Count(bucket2Count int32) ReservationApiGetRateInfoRequest {
	r.bucket2Count = &bucket2Count
	return r
}

// Number of children classified under the third Age Qualifying Group(Child Bucket#3).
func (r ReservationApiGetRateInfoRequest) Bucket3Count(bucket3Count int32) ReservationApiGetRateInfoRequest {
	r.bucket3Count = &bucket3Count
	return r
}

// Number of children classified under the fourth Age Qualifying Group(Child Bucket#4).
func (r ReservationApiGetRateInfoRequest) Bucket4Count(bucket4Count int32) ReservationApiGetRateInfoRequest {
	r.bucket4Count = &bucket4Count
	return r
}

// Number of children classified under the fifth Age Qualifying Group(Child Bucket#5).
func (r ReservationApiGetRateInfoRequest) Bucket5Count(bucket5Count int32) ReservationApiGetRateInfoRequest {
	r.bucket5Count = &bucket5Count
	return r
}

// This field is only required when the criteria is meant for a detailed results. The date for the rate detail is needed.
func (r ReservationApiGetRateInfoRequest) DetailDate(detailDate string) ReservationApiGetRateInfoRequest {
	r.detailDate = &detailDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetRateInfoRequest) BlockId(blockId string) ReservationApiGetRateInfoRequest {
	r.blockId = &blockId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetRateInfoRequest) BlockIdType(blockIdType string) ReservationApiGetRateInfoRequest {
	r.blockIdType = &blockIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetRateInfoRequest) Id(id string) ReservationApiGetRateInfoRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ReservationApiGetRateInfoRequest) IdExtension(idExtension int32) ReservationApiGetRateInfoRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ReservationApiGetRateInfoRequest) IdContext(idContext string) ReservationApiGetRateInfoRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetRateInfoRequest) Type_(type_ string) ReservationApiGetRateInfoRequest {
	r.type_ = &type_
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ReservationApiGetRateInfoRequest) RatePlanCode(ratePlanCode string) ReservationApiGetRateInfoRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// The ending value of the date range.
func (r ReservationApiGetRateInfoRequest) EffectiveRateEnd(effectiveRateEnd []string) ReservationApiGetRateInfoRequest {
	r.effectiveRateEnd = &effectiveRateEnd
	return r
}

// The starting value of the date range.
func (r ReservationApiGetRateInfoRequest) EffectiveRateStart(effectiveRateStart []string) ReservationApiGetRateInfoRequest {
	r.effectiveRateStart = &effectiveRateStart
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ReservationApiGetRateInfoRequest) RoomType(roomType string) ReservationApiGetRateInfoRequest {
	r.roomType = &roomType
	return r
}

// External system code.
func (r ReservationApiGetRateInfoRequest) XExternalsystem(xExternalsystem string) ReservationApiGetRateInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetRateInfoRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetRateInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetRateInfoRequest) Execute() (*RateInfo, *http.Response, error) {
	return r.ApiService.GetRateInfoExecute(r)
}

/*
GetRateInfo Get rate information

Use this API to retrieve rate plan information including a breakdown of packages and taxes.<p><strong>OperationId:</strong>getRateInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetRateInfoRequest
*/
func (a *ReservationApiService) GetRateInfo(ctx context.Context, hotelId string) ReservationApiGetRateInfoRequest {
	return ReservationApiGetRateInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RateInfo
func (a *ReservationApiService) GetRateInfoExecute(r ReservationApiGetRateInfoRequest) (*RateInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RateInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetRateInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/rateInfo"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.summaryInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryInfo", r.summaryInfo, "")
	}
	if r.criteriaStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaStartDate", r.criteriaStartDate, "")
	}
	if r.criteriaEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaEndDate", r.criteriaEndDate, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.childAge != nil {
		t := *r.childAge
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", t, "multi")
		}
	}
	if r.bucket1Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket1Count", r.bucket1Count, "")
	}
	if r.bucket2Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket2Count", r.bucket2Count, "")
	}
	if r.bucket3Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket3Count", r.bucket3Count, "")
	}
	if r.bucket4Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket4Count", r.bucket4Count, "")
	}
	if r.bucket5Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket5Count", r.bucket5Count, "")
	}
	if r.detailDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailDate", r.detailDate, "")
	}
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.effectiveRateEnd != nil {
		t := *r.effectiveRateEnd
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "effectiveRateEnd", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "effectiveRateEnd", t, "multi")
		}
	}
	if r.effectiveRateStart != nil {
		t := *r.effectiveRateStart
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "effectiveRateStart", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "effectiveRateStart", t, "multi")
		}
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetRecentlyAccessedReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetRecentlyAccessedReservationsRequest) Authorization(authorization string) ReservationApiGetRecentlyAccessedReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetRecentlyAccessedReservationsRequest) XAppKey(xAppKey string) ReservationApiGetRecentlyAccessedReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetRecentlyAccessedReservationsRequest) XHotelid(xHotelid string) ReservationApiGetRecentlyAccessedReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiGetRecentlyAccessedReservationsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetRecentlyAccessedReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetRecentlyAccessedReservationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetRecentlyAccessedReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetRecentlyAccessedReservationsRequest) Execute() (*RecentlyAccessedReservations, *http.Response, error) {
	return r.ApiService.GetRecentlyAccessedReservationsExecute(r)
}

/*
GetRecentlyAccessedReservations Get recently accessed Reservations

This API will return all recently accessed Reservations. <p><strong>OperationId:</strong>getRecentlyAccessedReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationApiGetRecentlyAccessedReservationsRequest
*/
func (a *ReservationApiService) GetRecentlyAccessedReservations(ctx context.Context) ReservationApiGetRecentlyAccessedReservationsRequest {
	return ReservationApiGetRecentlyAccessedReservationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RecentlyAccessedReservations
func (a *ReservationApiService) GetRecentlyAccessedReservationsExecute(r ReservationApiGetRecentlyAccessedReservationsRequest) (*RecentlyAccessedReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RecentlyAccessedReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetRecentlyAccessedReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recentlyAccessedReservations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReprintTicketsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ticketId *string
	ticketIdType *string
	packageCode *[]string
	reservationProductId *string
	reservationProductIdType *string
	ticketNumberId *string
	ticketNumberIdType *string
	ticketIssueDate *[]string
	ticketConsumptionDate *[]string
	ticketRateCode *[]string
	ticketStatus *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReprintTicketsRequest) Authorization(authorization string) ReservationApiGetReprintTicketsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReprintTicketsRequest) XAppKey(xAppKey string) ReservationApiGetReprintTicketsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReprintTicketsRequest) XHotelid(xHotelid string) ReservationApiGetReprintTicketsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReprintTicketsRequest) TicketId(ticketId string) ReservationApiGetReprintTicketsRequest {
	r.ticketId = &ticketId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetReprintTicketsRequest) TicketIdType(ticketIdType string) ReservationApiGetReprintTicketsRequest {
	r.ticketIdType = &ticketIdType
	return r
}

// Package Code.
func (r ReservationApiGetReprintTicketsRequest) PackageCode(packageCode []string) ReservationApiGetReprintTicketsRequest {
	r.packageCode = &packageCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReprintTicketsRequest) ReservationProductId(reservationProductId string) ReservationApiGetReprintTicketsRequest {
	r.reservationProductId = &reservationProductId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetReprintTicketsRequest) ReservationProductIdType(reservationProductIdType string) ReservationApiGetReprintTicketsRequest {
	r.reservationProductIdType = &reservationProductIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReprintTicketsRequest) TicketNumberId(ticketNumberId string) ReservationApiGetReprintTicketsRequest {
	r.ticketNumberId = &ticketNumberId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetReprintTicketsRequest) TicketNumberIdType(ticketNumberIdType string) ReservationApiGetReprintTicketsRequest {
	r.ticketNumberIdType = &ticketNumberIdType
	return r
}

// Tickets issue date.
func (r ReservationApiGetReprintTicketsRequest) TicketIssueDate(ticketIssueDate []string) ReservationApiGetReprintTicketsRequest {
	r.ticketIssueDate = &ticketIssueDate
	return r
}

// Tickets comsumption date.
func (r ReservationApiGetReprintTicketsRequest) TicketConsumptionDate(ticketConsumptionDate []string) ReservationApiGetReprintTicketsRequest {
	r.ticketConsumptionDate = &ticketConsumptionDate
	return r
}

// The Rate Code to which tickets belong to.
func (r ReservationApiGetReprintTicketsRequest) TicketRateCode(ticketRateCode []string) ReservationApiGetReprintTicketsRequest {
	r.ticketRateCode = &ticketRateCode
	return r
}

// The Status Code for outbound WS call.
func (r ReservationApiGetReprintTicketsRequest) TicketStatus(ticketStatus []string) ReservationApiGetReprintTicketsRequest {
	r.ticketStatus = &ticketStatus
	return r
}

// External system code.
func (r ReservationApiGetReprintTicketsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReprintTicketsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReprintTicketsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReprintTicketsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReprintTicketsRequest) Execute() (*Tickets, *http.Response, error) {
	return r.ApiService.GetReprintTicketsExecute(r)
}

/*
GetReprintTickets Reprints Reservation tickets

You can use this API to reprint Reservation tickets. <p><strong>OperationId:</strong>getReprintTickets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetReprintTicketsRequest
*/
func (a *ReservationApiService) GetReprintTickets(ctx context.Context, reservationId string, hotelId string) ReservationApiGetReprintTicketsRequest {
	return ReservationApiGetReprintTicketsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Tickets
func (a *ReservationApiService) GetReprintTicketsExecute(r ReservationApiGetReprintTicketsRequest) (*Tickets, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tickets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReprintTickets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/tickets/reprint"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.ticketId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketId", r.ticketId, "")
	}
	if r.ticketIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketIdType", r.ticketIdType, "")
	}
	if r.packageCode != nil {
		t := *r.packageCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", t, "multi")
		}
	}
	if r.reservationProductId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProductId", r.reservationProductId, "")
	}
	if r.reservationProductIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProductIdType", r.reservationProductIdType, "")
	}
	if r.ticketNumberId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketNumberId", r.ticketNumberId, "")
	}
	if r.ticketNumberIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketNumberIdType", r.ticketNumberIdType, "")
	}
	if r.ticketIssueDate != nil {
		t := *r.ticketIssueDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ticketIssueDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ticketIssueDate", t, "multi")
		}
	}
	if r.ticketConsumptionDate != nil {
		t := *r.ticketConsumptionDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ticketConsumptionDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ticketConsumptionDate", t, "multi")
		}
	}
	if r.ticketRateCode != nil {
		t := *r.ticketRateCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ticketRateCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ticketRateCode", t, "multi")
		}
	}
	if r.ticketStatus != nil {
		t := *r.ticketStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ticketStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ticketStatus", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	allowedActions *[]string
	markAsRecentlyAccessed *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationRequest) Authorization(authorization string) ReservationApiGetReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationRequest) XAppKey(xAppKey string) ReservationApiGetReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationRequest) XHotelid(xHotelid string) ReservationApiGetReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r ReservationApiGetReservationRequest) FetchInstructions(fetchInstructions []string) ReservationApiGetReservationRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Flag indicating whether the Enrollment is in progress or not for the Profile associated with this Reservation.
func (r ReservationApiGetReservationRequest) AllowedActions(allowedActions []string) ReservationApiGetReservationRequest {
	r.allowedActions = &allowedActions
	return r
}

// Marks the reservation as recently accessed.
func (r ReservationApiGetReservationRequest) MarkAsRecentlyAccessed(markAsRecentlyAccessed bool) ReservationApiGetReservationRequest {
	r.markAsRecentlyAccessed = &markAsRecentlyAccessed
	return r
}

// External system code.
func (r ReservationApiGetReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationRequest) Execute() (*Reservation, *http.Response, error) {
	return r.ApiService.GetReservationExecute(r)
}

/*
GetReservation Get reservation by ID

Use this API to retrieve a reservation&apos;s detail such as guest&apos;s stay, arrival and departure dates, transportation, room and rate information, preferences, packages, and more using OPERA&apos;s reservationId.<p><strong>OperationId:</strong>getReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetReservationRequest
*/
func (a *ReservationApiService) GetReservation(ctx context.Context, reservationId string, hotelId string) ReservationApiGetReservationRequest {
	return ReservationApiGetReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Reservation
func (a *ReservationApiService) GetReservationExecute(r ReservationApiGetReservationRequest) (*Reservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.allowedActions != nil {
		t := *r.allowedActions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedActions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedActions", t, "multi")
		}
	}
	if r.markAsRecentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRecentlyAccessed", r.markAsRecentlyAccessed, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationActivityLogRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	parameterName *[]string
	parameterValue *[]string
	activityGroup *string
	activityType *string
	fromDate *string
	toDate *string
	searchText *string
	userByIdsUserId *[]int32
	userForIdsUserId *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationActivityLogRequest) Authorization(authorization string) ReservationApiGetReservationActivityLogRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationActivityLogRequest) XAppKey(xAppKey string) ReservationApiGetReservationActivityLogRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationActivityLogRequest) XHotelid(xHotelid string) ReservationApiGetReservationActivityLogRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationApiGetReservationActivityLogRequest) Limit(limit int32) ReservationApiGetReservationActivityLogRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationApiGetReservationActivityLogRequest) Offset(offset int32) ReservationApiGetReservationActivityLogRequest {
	r.offset = &offset
	return r
}

// Name of the parameter.
func (r ReservationApiGetReservationActivityLogRequest) ParameterName(parameterName []string) ReservationApiGetReservationActivityLogRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ReservationApiGetReservationActivityLogRequest) ParameterValue(parameterValue []string) ReservationApiGetReservationActivityLogRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r ReservationApiGetReservationActivityLogRequest) ActivityGroup(activityGroup string) ReservationApiGetReservationActivityLogRequest {
	r.activityGroup = &activityGroup
	return r
}

func (r ReservationApiGetReservationActivityLogRequest) ActivityType(activityType string) ReservationApiGetReservationActivityLogRequest {
	r.activityType = &activityType
	return r
}

// Search from date for the user activity log.
func (r ReservationApiGetReservationActivityLogRequest) FromDate(fromDate string) ReservationApiGetReservationActivityLogRequest {
	r.fromDate = &fromDate
	return r
}

// Search to date for the user activity log.
func (r ReservationApiGetReservationActivityLogRequest) ToDate(toDate string) ReservationApiGetReservationActivityLogRequest {
	r.toDate = &toDate
	return r
}

// Search text for the user activity log.
func (r ReservationApiGetReservationActivityLogRequest) SearchText(searchText string) ReservationApiGetReservationActivityLogRequest {
	r.searchText = &searchText
	return r
}

func (r ReservationApiGetReservationActivityLogRequest) UserByIdsUserId(userByIdsUserId []int32) ReservationApiGetReservationActivityLogRequest {
	r.userByIdsUserId = &userByIdsUserId
	return r
}

func (r ReservationApiGetReservationActivityLogRequest) UserForIdsUserId(userForIdsUserId []int32) ReservationApiGetReservationActivityLogRequest {
	r.userForIdsUserId = &userForIdsUserId
	return r
}

// External system code.
func (r ReservationApiGetReservationActivityLogRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationActivityLogRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationActivityLogRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationActivityLogRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationActivityLogRequest) Execute() (*ActivityLog, *http.Response, error) {
	return r.ApiService.GetReservationActivityLogExecute(r)
}

/*
GetReservationActivityLog Fetch reservation activity log

Use this API to get the activity log data of reservations being created and managed.<p><strong>OperationId:</strong>getReservationActivityLog</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetReservationActivityLogRequest
*/
func (a *ReservationApiService) GetReservationActivityLog(ctx context.Context, hotelId string) ReservationApiGetReservationActivityLogRequest {
	return ReservationApiGetReservationActivityLogRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ActivityLog
func (a *ReservationApiService) GetReservationActivityLogExecute(r ReservationApiGetReservationActivityLogRequest) (*ActivityLog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivityLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationActivityLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/activityLog"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.activityGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityGroup", r.activityGroup, "")
	}
	if r.activityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", r.activityType, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
	}
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "")
	}
	if r.userByIdsUserId != nil {
		t := *r.userByIdsUserId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userByIdsUserId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userByIdsUserId", t, "multi")
		}
	}
	if r.userForIdsUserId != nil {
		t := *r.userForIdsUserId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userForIdsUserId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userForIdsUserId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationAttachmentsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	webRegistrationCard *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationAttachmentsRequest) Authorization(authorization string) ReservationApiGetReservationAttachmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationAttachmentsRequest) XAppKey(xAppKey string) ReservationApiGetReservationAttachmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationAttachmentsRequest) XHotelid(xHotelid string) ReservationApiGetReservationAttachmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicator to retrieve e-Signed registration card attachments.
func (r ReservationApiGetReservationAttachmentsRequest) WebRegistrationCard(webRegistrationCard bool) ReservationApiGetReservationAttachmentsRequest {
	r.webRegistrationCard = &webRegistrationCard
	return r
}

// External system code.
func (r ReservationApiGetReservationAttachmentsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationAttachmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationAttachmentsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationAttachmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationAttachmentsRequest) Execute() (*ReservationAttachments, *http.Response, error) {
	return r.ApiService.GetReservationAttachmentsExecute(r)
}

/*
GetReservationAttachments Get Reservation attachments

Get Reservation attachments <p><strong>OperationId:</strong>getReservationAttachments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetReservationAttachmentsRequest
*/
func (a *ReservationApiService) GetReservationAttachments(ctx context.Context, reservationId string, hotelId string) ReservationApiGetReservationAttachmentsRequest {
	return ReservationApiGetReservationAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationAttachments
func (a *ReservationApiService) GetReservationAttachmentsExecute(r ReservationApiGetReservationAttachmentsRequest) (*ReservationAttachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationAttachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.webRegistrationCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webRegistrationCard", r.webRegistrationCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationByExtIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	allowedActions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationByExtIdRequest) Authorization(authorization string) ReservationApiGetReservationByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationByExtIdRequest) XAppKey(xAppKey string) ReservationApiGetReservationByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationByExtIdRequest) XHotelid(xHotelid string) ReservationApiGetReservationByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r ReservationApiGetReservationByExtIdRequest) FetchInstructions(fetchInstructions []string) ReservationApiGetReservationByExtIdRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Flag indicating whether the Enrollment is in progress or not for the Profile associated with this Reservation.
func (r ReservationApiGetReservationByExtIdRequest) AllowedActions(allowedActions []string) ReservationApiGetReservationByExtIdRequest {
	r.allowedActions = &allowedActions
	return r
}

// External system code.
func (r ReservationApiGetReservationByExtIdRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationByExtIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationByExtIdRequest) Execute() (*Reservation, *http.Response, error) {
	return r.ApiService.GetReservationByExtIdExecute(r)
}

/*
GetReservationByExtId Get reservation by external ID

Use this API to get a reservation using the external reference ID associated with the reservation such as a Central Reservation System confirmation number or booking engine confirmation number.<p><strong>OperationId:</strong>getReservationByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationExternalId External reservation Id.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel where reservation is searched based on external reservation Id.
 @return ReservationApiGetReservationByExtIdRequest
*/
func (a *ReservationApiService) GetReservationByExtId(ctx context.Context, reservationExternalId string, externalSystemCode string, hotelId string) ReservationApiGetReservationByExtIdRequest {
	return ReservationApiGetReservationByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationExternalId: reservationExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Reservation
func (a *ReservationApiService) GetReservationByExtIdExecute(r ReservationApiGetReservationByExtIdRequest) (*Reservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/reservations/{reservationExternalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationExternalId"+"}", url.PathEscape(parameterValueToString(r.reservationExternalId, "reservationExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationExternalId) < 1 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have at least 1 elements")
	}
	if strlen(r.reservationExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.allowedActions != nil {
		t := *r.allowedActions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedActions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedActions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationExcludedPreferencesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	preferenceType *string
	preferenceCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationExcludedPreferencesRequest) Authorization(authorization string) ReservationApiGetReservationExcludedPreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationExcludedPreferencesRequest) XAppKey(xAppKey string) ReservationApiGetReservationExcludedPreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationExcludedPreferencesRequest) XHotelid(xHotelid string) ReservationApiGetReservationExcludedPreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// The preference type for which the excluded preference search will be performed.
func (r ReservationApiGetReservationExcludedPreferencesRequest) PreferenceType(preferenceType string) ReservationApiGetReservationExcludedPreferencesRequest {
	r.preferenceType = &preferenceType
	return r
}

// The preference code for which the excluded preference search will be performed.
func (r ReservationApiGetReservationExcludedPreferencesRequest) PreferenceCode(preferenceCode string) ReservationApiGetReservationExcludedPreferencesRequest {
	r.preferenceCode = &preferenceCode
	return r
}

// External system code.
func (r ReservationApiGetReservationExcludedPreferencesRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationExcludedPreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationExcludedPreferencesRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationExcludedPreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationExcludedPreferencesRequest) Execute() (*ReservationExcludedPreferences, *http.Response, error) {
	return r.ApiService.GetReservationExcludedPreferencesExecute(r)
}

/*
GetReservationExcludedPreferences Fetch Reservation excluded preferences

Get the Reservation excluded preferences. <p><strong>OperationId:</strong>getReservationExcludedPreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetReservationExcludedPreferencesRequest
*/
func (a *ReservationApiService) GetReservationExcludedPreferences(ctx context.Context, reservationId string, hotelId string) ReservationApiGetReservationExcludedPreferencesRequest {
	return ReservationApiGetReservationExcludedPreferencesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationExcludedPreferences
func (a *ReservationApiService) GetReservationExcludedPreferencesExecute(r ReservationApiGetReservationExcludedPreferencesRequest) (*ReservationExcludedPreferences, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationExcludedPreferences
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationExcludedPreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/excludedPreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.preferenceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceType", r.preferenceType, "")
	}
	if r.preferenceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceCode", r.preferenceCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationIndicatorsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationId *[]string
	checkInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationIndicatorsRequest) Authorization(authorization string) ReservationApiGetReservationIndicatorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationIndicatorsRequest) XAppKey(xAppKey string) ReservationApiGetReservationIndicatorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationIndicatorsRequest) XHotelid(xHotelid string) ReservationApiGetReservationIndicatorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationIndicatorsRequest) ReservationId(reservationId []string) ReservationApiGetReservationIndicatorsRequest {
	r.reservationId = &reservationId
	return r
}

// Simple type that corresponds to check reservation instructions.
func (r ReservationApiGetReservationIndicatorsRequest) CheckInstructions(checkInstructions []string) ReservationApiGetReservationIndicatorsRequest {
	r.checkInstructions = &checkInstructions
	return r
}

// External system code.
func (r ReservationApiGetReservationIndicatorsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationIndicatorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationIndicatorsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationIndicatorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationIndicatorsRequest) Execute() (*CheckReservationsDetails, *http.Response, error) {
	return r.ApiService.GetReservationIndicatorsExecute(r)
}

/*
GetReservationIndicators Get Reservation indicators

Get Reservation indicators. <p><strong>OperationId:</strong>getReservationIndicators</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationApiGetReservationIndicatorsRequest
*/
func (a *ReservationApiService) GetReservationIndicators(ctx context.Context) ReservationApiGetReservationIndicatorsRequest {
	return ReservationApiGetReservationIndicatorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CheckReservationsDetails
func (a *ReservationApiService) GetReservationIndicatorsExecute(r ReservationApiGetReservationIndicatorsRequest) (*CheckReservationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckReservationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationIndicators")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservations/indicators"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.reservationId != nil {
		t := *r.reservationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", t, "multi")
		}
	}
	if r.checkInstructions != nil {
		t := *r.checkInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checkInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checkInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationLocatorsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationLocatorsRequest) Authorization(authorization string) ReservationApiGetReservationLocatorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationLocatorsRequest) XAppKey(xAppKey string) ReservationApiGetReservationLocatorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationLocatorsRequest) XHotelid(xHotelid string) ReservationApiGetReservationLocatorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiGetReservationLocatorsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationLocatorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationLocatorsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationLocatorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationLocatorsRequest) Execute() (*ReservationLocators, *http.Response, error) {
	return r.ApiService.GetReservationLocatorsExecute(r)
}

/*
GetReservationLocators Fetch Reservation Guest Locator

Get the Guest locater for a Reservation. <p><strong>OperationId:</strong>getReservationLocators</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetReservationLocatorsRequest
*/
func (a *ReservationApiService) GetReservationLocators(ctx context.Context, reservationId string, hotelId string) ReservationApiGetReservationLocatorsRequest {
	return ReservationApiGetReservationLocatorsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationLocators
func (a *ReservationApiService) GetReservationLocatorsExecute(r ReservationApiGetReservationLocatorsRequest) (*ReservationLocators, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationLocators
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationLocators")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/guestLocators"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationPoliciesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchDepositPolicies *bool
	fetchCancellationPolicies *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationPoliciesRequest) Authorization(authorization string) ReservationApiGetReservationPoliciesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationPoliciesRequest) XAppKey(xAppKey string) ReservationApiGetReservationPoliciesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationPoliciesRequest) XHotelid(xHotelid string) ReservationApiGetReservationPoliciesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A flag which instructs whether the deposit policies needs to be fetched.
func (r ReservationApiGetReservationPoliciesRequest) FetchDepositPolicies(fetchDepositPolicies bool) ReservationApiGetReservationPoliciesRequest {
	r.fetchDepositPolicies = &fetchDepositPolicies
	return r
}

// A flag which instructs whether the cancel policies needs to be fetched.
func (r ReservationApiGetReservationPoliciesRequest) FetchCancellationPolicies(fetchCancellationPolicies bool) ReservationApiGetReservationPoliciesRequest {
	r.fetchCancellationPolicies = &fetchCancellationPolicies
	return r
}

// External system code.
func (r ReservationApiGetReservationPoliciesRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationPoliciesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationPoliciesRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationPoliciesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationPoliciesRequest) Execute() (*ReservationPolicies, *http.Response, error) {
	return r.ApiService.GetReservationPoliciesExecute(r)
}

/*
GetReservationPolicies Get reservation cancel and deposit policies

Use this API to get cancelation and deposit policies for a given reservation.<p><strong>OperationId:</strong>getReservationPolicies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetReservationPoliciesRequest
*/
func (a *ReservationApiService) GetReservationPolicies(ctx context.Context, reservationId string, hotelId string) ReservationApiGetReservationPoliciesRequest {
	return ReservationApiGetReservationPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationPolicies
func (a *ReservationApiService) GetReservationPoliciesExecute(r ReservationApiGetReservationPoliciesRequest) (*ReservationPolicies, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationPolicies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchDepositPolicies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchDepositPolicies", r.fetchDepositPolicies, "")
	}
	if r.fetchCancellationPolicies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchCancellationPolicies", r.fetchCancellationPolicies, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationPreferenceRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	preferenceTypeCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationPreferenceRequest) Authorization(authorization string) ReservationApiGetReservationPreferenceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationPreferenceRequest) XAppKey(xAppKey string) ReservationApiGetReservationPreferenceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationPreferenceRequest) XHotelid(xHotelid string) ReservationApiGetReservationPreferenceRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ReservationApiGetReservationPreferenceRequest) PreferenceTypeCode(preferenceTypeCode []string) ReservationApiGetReservationPreferenceRequest {
	r.preferenceTypeCode = &preferenceTypeCode
	return r
}

// External system code.
func (r ReservationApiGetReservationPreferenceRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationPreferenceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationPreferenceRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationPreferenceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationPreferenceRequest) Execute() (*ReservationPreference, *http.Response, error) {
	return r.ApiService.GetReservationPreferenceExecute(r)
}

/*
GetReservationPreference Get Reservation Preferences

You can use this API to retrieve the preferences that exist on a reservation. <p><strong>OperationId:</strong>getReservationPreference</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetReservationPreferenceRequest
*/
func (a *ReservationApiService) GetReservationPreference(ctx context.Context, reservationId string, hotelId string) ReservationApiGetReservationPreferenceRequest {
	return ReservationApiGetReservationPreferenceRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationPreference
func (a *ReservationApiService) GetReservationPreferenceExecute(r ReservationApiGetReservationPreferenceRequest) (*ReservationPreference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationPreference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationPreference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.preferenceTypeCode != nil {
		t := *r.preferenceTypeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceTypeCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceTypeCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationUpsellInfoRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationUpsellInfoRequest) Authorization(authorization string) ReservationApiGetReservationUpsellInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationUpsellInfoRequest) XAppKey(xAppKey string) ReservationApiGetReservationUpsellInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationUpsellInfoRequest) XHotelid(xHotelid string) ReservationApiGetReservationUpsellInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiGetReservationUpsellInfoRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationUpsellInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationUpsellInfoRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationUpsellInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationUpsellInfoRequest) Execute() (*ReservationUpsellInfo, *http.Response, error) {
	return r.ApiService.GetReservationUpsellInfoExecute(r)
}

/*
GetReservationUpsellInfo Get available Upsell offers

Use this API to retrieve the available upsell offers for a specific reservation. If no upsell options are configured for this hotel or available for this reservation, an appropriate error will be returned. <p><strong>OperationId:</strong>getReservationUpsellInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetReservationUpsellInfoRequest
*/
func (a *ReservationApiService) GetReservationUpsellInfo(ctx context.Context, reservationId string, hotelId string) ReservationApiGetReservationUpsellInfoRequest {
	return ReservationApiGetReservationUpsellInfoRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationUpsellInfo
func (a *ReservationApiService) GetReservationUpsellInfoExecute(r ReservationApiGetReservationUpsellInfoRequest) (*ReservationUpsellInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationUpsellInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationUpsellInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/upsell"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	recentlyAccessed *bool
	limit *int32
	offset *int32
	searchType *string
	hotelIds *[]string
	text *string
	reservationIdList *[]string
	confirmationNumberList *[]string
	cancellationNumberList *[]string
	externalReferenceIds *[]string
	externalSystemCodes *[]string
	arrivalEndDate *string
	arrivalStartDate *string
	departureEndDate *string
	departureStartDate *string
	expectedArrivalStartTime *string
	expectedArrivalEndTime *string
	expectedReturnEndTime *string
	expectedReturnStartTime *string
	companyNames *[]string
	sourceNames *[]string
	travelAgentNames *[]string
	groupNames *[]string
	travelAgentIds *[]string
	companyIds *[]string
	sourceIds *[]string
	contactIds *[]string
	groupIds *[]string
	billingContactIds *[]string
	profileIds *[]string
	membershipCardNumber *string
	membershipLevels *[]string
	membershipTypes *[]string
	surname *string
	givenName *string
	anyVIPStatus *bool
	vipCodes *[]string
	guaranteeCode *string
	paymentMethod *string
	discountApplied *bool
	user *[]string
	createdBy *string
	cancelledByList *[]string
	cancelledOn *string
	ratePlanCodes *[]string
	sourceCodes *[]string
	marketCodes *[]string
	excludeBlockReservations *bool
	blockName *string
	blockIds *[]string
	blockCodes *[]string
	customReference *string
	recordLocator *string
	orderBy *[]string
	sortOrder *[]string
	roomAssignedOnly *bool
	roomUnassignedOnly *bool
	roomId *string
	roomType *[]string
	roomFeatures *[]string
	roomSpecials *[]string
	roomSmokingPreference *string
	roomFloorPreferences *[]string
	housekeepingRoomStatuses *[]string
	roomClasses *[]string
	roomRangeFrom *string
	roomRangeTo *string
	communication *string
	fetchInstructions *[]string
	allowedReservationActions *[]string
	allowPreRegistration *bool
	hasDepositBalance *bool
	hasOpenBalance *bool
	hasOpenFolio *bool
	includeScheduledCheckOut *bool
	linkedOnly *bool
	unlinkedOnly *bool
	actualArrivals *bool
	actualDepartures *bool
	complimentaryReservations *bool
	dayOfArrivalCancels *bool
	dayUse *bool
	earlyDepartures *bool
	expectedArrivals *bool
	expectedDepartures *bool
	extendedStays *bool
	houseUseReservations *bool
	stayovers *bool
	stayDate *string
	roomRoutingId *string
	excludePseudoRoomReservations *bool
	excludeReservationIds *[]string
	excludeVIPStatusCodes *[]string
	excludeSpecials *[]string
	excludeFloorPreferences *[]string
	excludeAdvanceCheckedIn *bool
	excludeRoomFeatures *[]string
	playerId *string
	gamingBalanceFrom *float32
	gamingBalanceTo *float32
	compAccountingBalanceFrom *float32
	compAccountingBalanceTo *float32
	searchTypes *[]string
	reservationStatuses *[]string
	transportationCodes *[]string
	roomReadyStatuses *[]string
	checkoutMessageReceived *bool
	optedForCommunication *bool
	createdOn *string
	stayOn *string
	contactNames *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationsRequest) Authorization(authorization string) ReservationApiGetReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationsRequest) XAppKey(xAppKey string) ReservationApiGetReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationsRequest) XHotelid(xHotelid string) ReservationApiGetReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Mark this reservation as recently accessed.
func (r ReservationApiGetReservationsRequest) RecentlyAccessed(recentlyAccessed bool) ReservationApiGetReservationsRequest {
	r.recentlyAccessed = &recentlyAccessed
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationApiGetReservationsRequest) Limit(limit int32) ReservationApiGetReservationsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationApiGetReservationsRequest) Offset(offset int32) ReservationApiGetReservationsRequest {
	r.offset = &offset
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ReservationApiGetReservationsRequest) SearchType(searchType string) ReservationApiGetReservationsRequest {
	r.searchType = &searchType
	return r
}

// List of Hotels to support searches with multiple resorts for which traces are to be fetched.
func (r ReservationApiGetReservationsRequest) HotelIds(hotelIds []string) ReservationApiGetReservationsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Free form text field for searching all reservation fields
func (r ReservationApiGetReservationsRequest) Text(text string) ReservationApiGetReservationsRequest {
	r.text = &text
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) ReservationIdList(reservationIdList []string) ReservationApiGetReservationsRequest {
	r.reservationIdList = &reservationIdList
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) ConfirmationNumberList(confirmationNumberList []string) ReservationApiGetReservationsRequest {
	r.confirmationNumberList = &confirmationNumberList
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) CancellationNumberList(cancellationNumberList []string) ReservationApiGetReservationsRequest {
	r.cancellationNumberList = &cancellationNumberList
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) ExternalReferenceIds(externalReferenceIds []string) ReservationApiGetReservationsRequest {
	r.externalReferenceIds = &externalReferenceIds
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ReservationApiGetReservationsRequest) ExternalSystemCodes(externalSystemCodes []string) ReservationApiGetReservationsRequest {
	r.externalSystemCodes = &externalSystemCodes
	return r
}

// The ending value of the date range.
func (r ReservationApiGetReservationsRequest) ArrivalEndDate(arrivalEndDate string) ReservationApiGetReservationsRequest {
	r.arrivalEndDate = &arrivalEndDate
	return r
}

// The starting value of the date range.
func (r ReservationApiGetReservationsRequest) ArrivalStartDate(arrivalStartDate string) ReservationApiGetReservationsRequest {
	r.arrivalStartDate = &arrivalStartDate
	return r
}

// The ending value of the date range.
func (r ReservationApiGetReservationsRequest) DepartureEndDate(departureEndDate string) ReservationApiGetReservationsRequest {
	r.departureEndDate = &departureEndDate
	return r
}

// The starting value of the date range.
func (r ReservationApiGetReservationsRequest) DepartureStartDate(departureStartDate string) ReservationApiGetReservationsRequest {
	r.departureStartDate = &departureStartDate
	return r
}

// The ending value of the time span.
func (r ReservationApiGetReservationsRequest) ExpectedArrivalStartTime(expectedArrivalStartTime string) ReservationApiGetReservationsRequest {
	r.expectedArrivalStartTime = &expectedArrivalStartTime
	return r
}

// The starting value of the time span.
func (r ReservationApiGetReservationsRequest) ExpectedArrivalEndTime(expectedArrivalEndTime string) ReservationApiGetReservationsRequest {
	r.expectedArrivalEndTime = &expectedArrivalEndTime
	return r
}

// The ending value of the time span.
func (r ReservationApiGetReservationsRequest) ExpectedReturnEndTime(expectedReturnEndTime string) ReservationApiGetReservationsRequest {
	r.expectedReturnEndTime = &expectedReturnEndTime
	return r
}

// The starting value of the time span.
func (r ReservationApiGetReservationsRequest) ExpectedReturnStartTime(expectedReturnStartTime string) ReservationApiGetReservationsRequest {
	r.expectedReturnStartTime = &expectedReturnStartTime
	return r
}

// Attached profile name
func (r ReservationApiGetReservationsRequest) CompanyNames(companyNames []string) ReservationApiGetReservationsRequest {
	r.companyNames = &companyNames
	return r
}

// Attached profile name
func (r ReservationApiGetReservationsRequest) SourceNames(sourceNames []string) ReservationApiGetReservationsRequest {
	r.sourceNames = &sourceNames
	return r
}

// Attached profile name
func (r ReservationApiGetReservationsRequest) TravelAgentNames(travelAgentNames []string) ReservationApiGetReservationsRequest {
	r.travelAgentNames = &travelAgentNames
	return r
}

// Attached profile name
func (r ReservationApiGetReservationsRequest) GroupNames(groupNames []string) ReservationApiGetReservationsRequest {
	r.groupNames = &groupNames
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) TravelAgentIds(travelAgentIds []string) ReservationApiGetReservationsRequest {
	r.travelAgentIds = &travelAgentIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) CompanyIds(companyIds []string) ReservationApiGetReservationsRequest {
	r.companyIds = &companyIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) SourceIds(sourceIds []string) ReservationApiGetReservationsRequest {
	r.sourceIds = &sourceIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) ContactIds(contactIds []string) ReservationApiGetReservationsRequest {
	r.contactIds = &contactIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) GroupIds(groupIds []string) ReservationApiGetReservationsRequest {
	r.groupIds = &groupIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) BillingContactIds(billingContactIds []string) ReservationApiGetReservationsRequest {
	r.billingContactIds = &billingContactIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) ProfileIds(profileIds []string) ReservationApiGetReservationsRequest {
	r.profileIds = &profileIds
	return r
}

// Membership ID criteria.
func (r ReservationApiGetReservationsRequest) MembershipCardNumber(membershipCardNumber string) ReservationApiGetReservationsRequest {
	r.membershipCardNumber = &membershipCardNumber
	return r
}

func (r ReservationApiGetReservationsRequest) MembershipLevels(membershipLevels []string) ReservationApiGetReservationsRequest {
	r.membershipLevels = &membershipLevels
	return r
}

func (r ReservationApiGetReservationsRequest) MembershipTypes(membershipTypes []string) ReservationApiGetReservationsRequest {
	r.membershipTypes = &membershipTypes
	return r
}

// Family name, last name.
func (r ReservationApiGetReservationsRequest) Surname(surname string) ReservationApiGetReservationsRequest {
	r.surname = &surname
	return r
}

// Given name, first name or names
func (r ReservationApiGetReservationsRequest) GivenName(givenName string) ReservationApiGetReservationsRequest {
	r.givenName = &givenName
	return r
}

// VIP status of the customer.
func (r ReservationApiGetReservationsRequest) AnyVIPStatus(anyVIPStatus bool) ReservationApiGetReservationsRequest {
	r.anyVIPStatus = &anyVIPStatus
	return r
}

// VIP status of the customer.
func (r ReservationApiGetReservationsRequest) VipCodes(vipCodes []string) ReservationApiGetReservationsRequest {
	r.vipCodes = &vipCodes
	return r
}

// Fetches the reservation having Guarantee Code(Reservation Type) supplied here.
func (r ReservationApiGetReservationsRequest) GuaranteeCode(guaranteeCode string) ReservationApiGetReservationsRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// Fetches the reservation having method of payment supplied here.
func (r ReservationApiGetReservationsRequest) PaymentMethod(paymentMethod string) ReservationApiGetReservationsRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Fetches the reservation for which discount is applied
func (r ReservationApiGetReservationsRequest) DiscountApplied(discountApplied bool) ReservationApiGetReservationsRequest {
	r.discountApplied = &discountApplied
	return r
}

func (r ReservationApiGetReservationsRequest) User(user []string) ReservationApiGetReservationsRequest {
	r.user = &user
	return r
}

// Fetches reservation created by specified user. If both CreatedByUsers and CreatedBy is specified, CreatedByUsers will take precedence.
func (r ReservationApiGetReservationsRequest) CreatedBy(createdBy string) ReservationApiGetReservationsRequest {
	r.createdBy = &createdBy
	return r
}

// Fetches reservations cancelled by list of users.
func (r ReservationApiGetReservationsRequest) CancelledByList(cancelledByList []string) ReservationApiGetReservationsRequest {
	r.cancelledByList = &cancelledByList
	return r
}

// Fetches the reservations which are cancelled on a specific date.
func (r ReservationApiGetReservationsRequest) CancelledOn(cancelledOn string) ReservationApiGetReservationsRequest {
	r.cancelledOn = &cancelledOn
	return r
}

func (r ReservationApiGetReservationsRequest) RatePlanCodes(ratePlanCodes []string) ReservationApiGetReservationsRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ReservationApiGetReservationsRequest) SourceCodes(sourceCodes []string) ReservationApiGetReservationsRequest {
	r.sourceCodes = &sourceCodes
	return r
}

func (r ReservationApiGetReservationsRequest) MarketCodes(marketCodes []string) ReservationApiGetReservationsRequest {
	r.marketCodes = &marketCodes
	return r
}

// If true the search result will exclude the blocks reservations.
func (r ReservationApiGetReservationsRequest) ExcludeBlockReservations(excludeBlockReservations bool) ReservationApiGetReservationsRequest {
	r.excludeBlockReservations = &excludeBlockReservations
	return r
}

// The Name of the block that is attached to the reservation.
func (r ReservationApiGetReservationsRequest) BlockName(blockName string) ReservationApiGetReservationsRequest {
	r.blockName = &blockName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) BlockIds(blockIds []string) ReservationApiGetReservationsRequest {
	r.blockIds = &blockIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) BlockCodes(blockCodes []string) ReservationApiGetReservationsRequest {
	r.blockCodes = &blockCodes
	return r
}

// Custom reference
func (r ReservationApiGetReservationsRequest) CustomReference(customReference string) ReservationApiGetReservationsRequest {
	r.customReference = &customReference
	return r
}

// GDS Record Locator for reservation.
func (r ReservationApiGetReservationsRequest) RecordLocator(recordLocator string) ReservationApiGetReservationsRequest {
	r.recordLocator = &recordLocator
	return r
}

func (r ReservationApiGetReservationsRequest) OrderBy(orderBy []string) ReservationApiGetReservationsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ReservationApiGetReservationsRequest) SortOrder(sortOrder []string) ReservationApiGetReservationsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Indicator to query reservations which have a room number assigned.
func (r ReservationApiGetReservationsRequest) RoomAssignedOnly(roomAssignedOnly bool) ReservationApiGetReservationsRequest {
	r.roomAssignedOnly = &roomAssignedOnly
	return r
}

// Indicator to query reservations which does not have a room number assigned.
func (r ReservationApiGetReservationsRequest) RoomUnassignedOnly(roomUnassignedOnly bool) ReservationApiGetReservationsRequest {
	r.roomUnassignedOnly = &roomUnassignedOnly
	return r
}

// Room number of the reservation to search by.
func (r ReservationApiGetReservationsRequest) RoomId(roomId string) ReservationApiGetReservationsRequest {
	r.roomId = &roomId
	return r
}

// Room Type.
func (r ReservationApiGetReservationsRequest) RoomType(roomType []string) ReservationApiGetReservationsRequest {
	r.roomType = &roomType
	return r
}

// A code representing a room feature.
func (r ReservationApiGetReservationsRequest) RoomFeatures(roomFeatures []string) ReservationApiGetReservationsRequest {
	r.roomFeatures = &roomFeatures
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetReservationsRequest) RoomSpecials(roomSpecials []string) ReservationApiGetReservationsRequest {
	r.roomSpecials = &roomSpecials
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetReservationsRequest) RoomSmokingPreference(roomSmokingPreference string) ReservationApiGetReservationsRequest {
	r.roomSmokingPreference = &roomSmokingPreference
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetReservationsRequest) RoomFloorPreferences(roomFloorPreferences []string) ReservationApiGetReservationsRequest {
	r.roomFloorPreferences = &roomFloorPreferences
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r ReservationApiGetReservationsRequest) HousekeepingRoomStatuses(housekeepingRoomStatuses []string) ReservationApiGetReservationsRequest {
	r.housekeepingRoomStatuses = &housekeepingRoomStatuses
	return r
}

func (r ReservationApiGetReservationsRequest) RoomClasses(roomClasses []string) ReservationApiGetReservationsRequest {
	r.roomClasses = &roomClasses
	return r
}

func (r ReservationApiGetReservationsRequest) RoomRangeFrom(roomRangeFrom string) ReservationApiGetReservationsRequest {
	r.roomRangeFrom = &roomRangeFrom
	return r
}

func (r ReservationApiGetReservationsRequest) RoomRangeTo(roomRangeTo string) ReservationApiGetReservationsRequest {
	r.roomRangeTo = &roomRangeTo
	return r
}

// Filter by the last digits of a reservation&#39;s phone number.
func (r ReservationApiGetReservationsRequest) Communication(communication string) ReservationApiGetReservationsRequest {
	r.communication = &communication
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r ReservationApiGetReservationsRequest) FetchInstructions(fetchInstructions []string) ReservationApiGetReservationsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Flag indicating whether the Enrollment is in progress or not for the Profile associated with this Reservation.
func (r ReservationApiGetReservationsRequest) AllowedReservationActions(allowedReservationActions []string) ReservationApiGetReservationsRequest {
	r.allowedReservationActions = &allowedReservationActions
	return r
}

// Flag containing true or false value for reservation to be eligible for prior check in by guest using mobile device. Pass the &#39;true&#39; or &#39;false&#39; values when creating / modifying reservation to indicate whether a reservation is eligible for mobile check in yes / no. Upon fetch, the current state of the flag will show true or false.
func (r ReservationApiGetReservationsRequest) AllowPreRegistration(allowPreRegistration bool) ReservationApiGetReservationsRequest {
	r.allowPreRegistration = &allowPreRegistration
	return r
}

// Indicates that only reservations with deposit balance should be expected from the result.
func (r ReservationApiGetReservationsRequest) HasDepositBalance(hasDepositBalance bool) ReservationApiGetReservationsRequest {
	r.hasDepositBalance = &hasDepositBalance
	return r
}

// Indicates that only reservations with open balance should be expected from the result.
func (r ReservationApiGetReservationsRequest) HasOpenBalance(hasOpenBalance bool) ReservationApiGetReservationsRequest {
	r.hasOpenBalance = &hasOpenBalance
	return r
}

// Indicates that only reservations with open folio should be expected from the result.
func (r ReservationApiGetReservationsRequest) HasOpenFolio(hasOpenFolio bool) ReservationApiGetReservationsRequest {
	r.hasOpenFolio = &hasOpenFolio
	return r
}

// Criteria that indicates whether to scheduled checkouts or not.
func (r ReservationApiGetReservationsRequest) IncludeScheduledCheckOut(includeScheduledCheckOut bool) ReservationApiGetReservationsRequest {
	r.includeScheduledCheckOut = &includeScheduledCheckOut
	return r
}

// Indicates that only linked reservations should be expected from the result.
func (r ReservationApiGetReservationsRequest) LinkedOnly(linkedOnly bool) ReservationApiGetReservationsRequest {
	r.linkedOnly = &linkedOnly
	return r
}

// Indicates that only unlinked reservations should be expected from the result.
func (r ReservationApiGetReservationsRequest) UnlinkedOnly(unlinkedOnly bool) ReservationApiGetReservationsRequest {
	r.unlinkedOnly = &unlinkedOnly
	return r
}

// Indicates if reservations which have already arrived on the Search Date is required.
func (r ReservationApiGetReservationsRequest) ActualArrivals(actualArrivals bool) ReservationApiGetReservationsRequest {
	r.actualArrivals = &actualArrivals
	return r
}

// Indicates if reservations which were expected to depart on the Search Date and have already checked, is required.
func (r ReservationApiGetReservationsRequest) ActualDepartures(actualDepartures bool) ReservationApiGetReservationsRequest {
	r.actualDepartures = &actualDepartures
	return r
}

// Indicates if reservations where rate codes are marked as Complimentary Rates , is required. This flag should be used in conjunction with the Arrivals, Departures or StayOvers criteria.
func (r ReservationApiGetReservationsRequest) ComplimentaryReservations(complimentaryReservations bool) ReservationApiGetReservationsRequest {
	r.complimentaryReservations = &complimentaryReservations
	return r
}

// Indicates if reservations which have cancelled on the Search Date which is also the day of arrival is required.
func (r ReservationApiGetReservationsRequest) DayOfArrivalCancels(dayOfArrivalCancels bool) ReservationApiGetReservationsRequest {
	r.dayOfArrivalCancels = &dayOfArrivalCancels
	return r
}

// Indicates if reservations which are day use reservation on the Search Date, is required.
func (r ReservationApiGetReservationsRequest) DayUse(dayUse bool) ReservationApiGetReservationsRequest {
	r.dayUse = &dayUse
	return r
}

// Indicates if reservations which checked out early on the Search Date, is required.
func (r ReservationApiGetReservationsRequest) EarlyDepartures(earlyDepartures bool) ReservationApiGetReservationsRequest {
	r.earlyDepartures = &earlyDepartures
	return r
}

// Indicates if reservations which are expected arrivals for the Search Date and who have not yet arrived, is required.
func (r ReservationApiGetReservationsRequest) ExpectedArrivals(expectedArrivals bool) ReservationApiGetReservationsRequest {
	r.expectedArrivals = &expectedArrivals
	return r
}

// Indicates if reservations which are expected departures for the Search Date and who have not yet departed, is required.
func (r ReservationApiGetReservationsRequest) ExpectedDepartures(expectedDepartures bool) ReservationApiGetReservationsRequest {
	r.expectedDepartures = &expectedDepartures
	return r
}

// Indicates if reservations which have extended their stays on the Search Date, is required.
func (r ReservationApiGetReservationsRequest) ExtendedStays(extendedStays bool) ReservationApiGetReservationsRequest {
	r.extendedStays = &extendedStays
	return r
}

// Indicates if reservations where rate codes are marked as House Use Rates , is required. This flag should be used in conjunction with the Arrivals, Departures or StayOvers criteria.
func (r ReservationApiGetReservationsRequest) HouseUseReservations(houseUseReservations bool) ReservationApiGetReservationsRequest {
	r.houseUseReservations = &houseUseReservations
	return r
}

// Indicates if reservations which are StayOvers on the Search Date, is required.
func (r ReservationApiGetReservationsRequest) Stayovers(stayovers bool) ReservationApiGetReservationsRequest {
	r.stayovers = &stayovers
	return r
}

// Date for searching the reservations. This is the date for which the search types are applicable. If date is not available, the business date will be used by default.
func (r ReservationApiGetReservationsRequest) StayDate(stayDate string) ReservationApiGetReservationsRequest {
	r.stayDate = &stayDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) RoomRoutingId(roomRoutingId string) ReservationApiGetReservationsRequest {
	r.roomRoutingId = &roomRoutingId
	return r
}

// Indicates to exclude Pseudo room reservations.
func (r ReservationApiGetReservationsRequest) ExcludePseudoRoomReservations(excludePseudoRoomReservations bool) ReservationApiGetReservationsRequest {
	r.excludePseudoRoomReservations = &excludePseudoRoomReservations
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsRequest) ExcludeReservationIds(excludeReservationIds []string) ReservationApiGetReservationsRequest {
	r.excludeReservationIds = &excludeReservationIds
	return r
}

// VIP status of the customer.
func (r ReservationApiGetReservationsRequest) ExcludeVIPStatusCodes(excludeVIPStatusCodes []string) ReservationApiGetReservationsRequest {
	r.excludeVIPStatusCodes = &excludeVIPStatusCodes
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetReservationsRequest) ExcludeSpecials(excludeSpecials []string) ReservationApiGetReservationsRequest {
	r.excludeSpecials = &excludeSpecials
	return r
}

// Preference value for display purposes.
func (r ReservationApiGetReservationsRequest) ExcludeFloorPreferences(excludeFloorPreferences []string) ReservationApiGetReservationsRequest {
	r.excludeFloorPreferences = &excludeFloorPreferences
	return r
}

// Indicates to exclude Advance Checked In Reservations from search result.
func (r ReservationApiGetReservationsRequest) ExcludeAdvanceCheckedIn(excludeAdvanceCheckedIn bool) ReservationApiGetReservationsRequest {
	r.excludeAdvanceCheckedIn = &excludeAdvanceCheckedIn
	return r
}

// Exclude the reservation(s) with provided room features from the search result.
func (r ReservationApiGetReservationsRequest) ExcludeRoomFeatures(excludeRoomFeatures []string) ReservationApiGetReservationsRequest {
	r.excludeRoomFeatures = &excludeRoomFeatures
	return r
}

// Player ID associated to the reservation.
func (r ReservationApiGetReservationsRequest) PlayerId(playerId string) ReservationApiGetReservationsRequest {
	r.playerId = &playerId
	return r
}

// Balance from.
func (r ReservationApiGetReservationsRequest) GamingBalanceFrom(gamingBalanceFrom float32) ReservationApiGetReservationsRequest {
	r.gamingBalanceFrom = &gamingBalanceFrom
	return r
}

// Balance to.
func (r ReservationApiGetReservationsRequest) GamingBalanceTo(gamingBalanceTo float32) ReservationApiGetReservationsRequest {
	r.gamingBalanceTo = &gamingBalanceTo
	return r
}

// Comp Balance From
func (r ReservationApiGetReservationsRequest) CompAccountingBalanceFrom(compAccountingBalanceFrom float32) ReservationApiGetReservationsRequest {
	r.compAccountingBalanceFrom = &compAccountingBalanceFrom
	return r
}

// Comp Balance To
func (r ReservationApiGetReservationsRequest) CompAccountingBalanceTo(compAccountingBalanceTo float32) ReservationApiGetReservationsRequest {
	r.compAccountingBalanceTo = &compAccountingBalanceTo
	return r
}

// Represents Reservation search type Player Snapshot.
func (r ReservationApiGetReservationsRequest) SearchTypes(searchTypes []string) ReservationApiGetReservationsRequest {
	r.searchTypes = &searchTypes
	return r
}

// Reservation status type for reservations search.
func (r ReservationApiGetReservationsRequest) ReservationStatuses(reservationStatuses []string) ReservationApiGetReservationsRequest {
	r.reservationStatuses = &reservationStatuses
	return r
}

// Codes to be searched.
func (r ReservationApiGetReservationsRequest) TransportationCodes(transportationCodes []string) ReservationApiGetReservationsRequest {
	r.transportationCodes = &transportationCodes
	return r
}

// Enum to denote the Status of Readiness messages sent to Guest Devices.
func (r ReservationApiGetReservationsRequest) RoomReadyStatuses(roomReadyStatuses []string) ReservationApiGetReservationsRequest {
	r.roomReadyStatuses = &roomReadyStatuses
	return r
}

// Fetches the reservations for which Checkout Message is received.
func (r ReservationApiGetReservationsRequest) CheckoutMessageReceived(checkoutMessageReceived bool) ReservationApiGetReservationsRequest {
	r.checkoutMessageReceived = &checkoutMessageReceived
	return r
}

// Fetches the reservations for which reservation communication has been opted.
func (r ReservationApiGetReservationsRequest) OptedForCommunication(optedForCommunication bool) ReservationApiGetReservationsRequest {
	r.optedForCommunication = &optedForCommunication
	return r
}

// Fetches reservations which were created on the given property business date.
func (r ReservationApiGetReservationsRequest) CreatedOn(createdOn string) ReservationApiGetReservationsRequest {
	r.createdOn = &createdOn
	return r
}

// Fetches all reservations that are scheduled to stay over the selected date.
func (r ReservationApiGetReservationsRequest) StayOn(stayOn string) ReservationApiGetReservationsRequest {
	r.stayOn = &stayOn
	return r
}

// Name of Contact Profile associated with Reservation.
func (r ReservationApiGetReservationsRequest) ContactNames(contactNames []string) ReservationApiGetReservationsRequest {
	r.contactNames = &contactNames
	return r
}

// External system code.
func (r ReservationApiGetReservationsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationsRequest) Execute() (*ReservationsDetails, *http.Response, error) {
	return r.ApiService.GetReservationsExecute(r)
}

/*
GetReservations Get Reservations for a hotel

This API will allow a user to retrieve a list of reservations based on the search criteria specified in the request body. For example you can search for reservations using query parameters like first name, last name, arrival/departure date, external confirmation number. <p><strong>OperationId:</strong>getReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationApiGetReservationsRequest
*/
func (a *ReservationApiService) GetReservations(ctx context.Context) ReservationApiGetReservationsRequest {
	return ReservationApiGetReservationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReservationsDetails
func (a *ReservationApiService) GetReservationsExecute(r ReservationApiGetReservationsRequest) (*ReservationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recentlyAccessed", r.recentlyAccessed, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchType", r.searchType, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.reservationIdList != nil {
		t := *r.reservationIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdList", t, "multi")
		}
	}
	if r.confirmationNumberList != nil {
		t := *r.confirmationNumberList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "confirmationNumberList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "confirmationNumberList", t, "multi")
		}
	}
	if r.cancellationNumberList != nil {
		t := *r.cancellationNumberList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cancellationNumberList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cancellationNumberList", t, "multi")
		}
	}
	if r.externalReferenceIds != nil {
		t := *r.externalReferenceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", t, "multi")
		}
	}
	if r.externalSystemCodes != nil {
		t := *r.externalSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", t, "multi")
		}
	}
	if r.arrivalEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEndDate", r.arrivalEndDate, "")
	}
	if r.arrivalStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStartDate", r.arrivalStartDate, "")
	}
	if r.departureEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureEndDate", r.departureEndDate, "")
	}
	if r.departureStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureStartDate", r.departureStartDate, "")
	}
	if r.expectedArrivalStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalStartTime", r.expectedArrivalStartTime, "")
	}
	if r.expectedArrivalEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalEndTime", r.expectedArrivalEndTime, "")
	}
	if r.expectedReturnEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnEndTime", r.expectedReturnEndTime, "")
	}
	if r.expectedReturnStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnStartTime", r.expectedReturnStartTime, "")
	}
	if r.companyNames != nil {
		t := *r.companyNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyNames", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyNames", t, "multi")
		}
	}
	if r.sourceNames != nil {
		t := *r.sourceNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceNames", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceNames", t, "multi")
		}
	}
	if r.travelAgentNames != nil {
		t := *r.travelAgentNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentNames", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentNames", t, "multi")
		}
	}
	if r.groupNames != nil {
		t := *r.groupNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupNames", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupNames", t, "multi")
		}
	}
	if r.travelAgentIds != nil {
		t := *r.travelAgentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentIds", t, "multi")
		}
	}
	if r.companyIds != nil {
		t := *r.companyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "companyIds", t, "multi")
		}
	}
	if r.sourceIds != nil {
		t := *r.sourceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", t, "multi")
		}
	}
	if r.contactIds != nil {
		t := *r.contactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contactIds", t, "multi")
		}
	}
	if r.groupIds != nil {
		t := *r.groupIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupIds", t, "multi")
		}
	}
	if r.billingContactIds != nil {
		t := *r.billingContactIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingContactIds", t, "multi")
		}
	}
	if r.profileIds != nil {
		t := *r.profileIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", t, "multi")
		}
	}
	if r.membershipCardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipCardNumber", r.membershipCardNumber, "")
	}
	if r.membershipLevels != nil {
		t := *r.membershipLevels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", t, "multi")
		}
	}
	if r.membershipTypes != nil {
		t := *r.membershipTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", t, "multi")
		}
	}
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.anyVIPStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anyVIPStatus", r.anyVIPStatus, "")
	}
	if r.vipCodes != nil {
		t := *r.vipCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", t, "multi")
		}
	}
	if r.guaranteeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", r.guaranteeCode, "")
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	}
	if r.discountApplied != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discountApplied", r.discountApplied, "")
	}
	if r.user != nil {
		t := *r.user
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user", t, "multi")
		}
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBy", r.createdBy, "")
	}
	if r.cancelledByList != nil {
		t := *r.cancelledByList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledByList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledByList", t, "multi")
		}
	}
	if r.cancelledOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledOn", r.cancelledOn, "")
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.sourceCodes != nil {
		t := *r.sourceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", t, "multi")
		}
	}
	if r.marketCodes != nil {
		t := *r.marketCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", t, "multi")
		}
	}
	if r.excludeBlockReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeBlockReservations", r.excludeBlockReservations, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.blockIds != nil {
		t := *r.blockIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIds", t, "multi")
		}
	}
	if r.blockCodes != nil {
		t := *r.blockCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodes", t, "multi")
		}
	}
	if r.customReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customReference", r.customReference, "")
	}
	if r.recordLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recordLocator", r.recordLocator, "")
	}
	if r.orderBy != nil {
		t := *r.orderBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", t, "multi")
		}
	}
	if r.sortOrder != nil {
		t := *r.sortOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", t, "multi")
		}
	}
	if r.roomAssignedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignedOnly", r.roomAssignedOnly, "")
	}
	if r.roomUnassignedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomUnassignedOnly", r.roomUnassignedOnly, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "csv")
	}
	if r.roomFeatures != nil {
		t := *r.roomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", t, "multi")
		}
	}
	if r.roomSpecials != nil {
		t := *r.roomSpecials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomSpecials", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomSpecials", t, "multi")
		}
	}
	if r.roomSmokingPreference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomSmokingPreference", r.roomSmokingPreference, "")
	}
	if r.roomFloorPreferences != nil {
		t := *r.roomFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFloorPreferences", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFloorPreferences", t, "multi")
		}
	}
	if r.housekeepingRoomStatuses != nil {
		t := *r.housekeepingRoomStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatuses", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	if r.roomRangeFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRangeFrom", r.roomRangeFrom, "")
	}
	if r.roomRangeTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRangeTo", r.roomRangeTo, "")
	}
	if r.communication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "communication", r.communication, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.allowedReservationActions != nil {
		t := *r.allowedReservationActions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedReservationActions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedReservationActions", t, "multi")
		}
	}
	if r.allowPreRegistration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowPreRegistration", r.allowPreRegistration, "")
	}
	if r.hasDepositBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasDepositBalance", r.hasDepositBalance, "")
	}
	if r.hasOpenBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenBalance", r.hasOpenBalance, "")
	}
	if r.hasOpenFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenFolio", r.hasOpenFolio, "")
	}
	if r.includeScheduledCheckOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeScheduledCheckOut", r.includeScheduledCheckOut, "")
	}
	if r.linkedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedOnly", r.linkedOnly, "")
	}
	if r.unlinkedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unlinkedOnly", r.unlinkedOnly, "")
	}
	if r.actualArrivals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actualArrivals", r.actualArrivals, "")
	}
	if r.actualDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actualDepartures", r.actualDepartures, "")
	}
	if r.complimentaryReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "complimentaryReservations", r.complimentaryReservations, "")
	}
	if r.dayOfArrivalCancels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayOfArrivalCancels", r.dayOfArrivalCancels, "")
	}
	if r.dayUse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayUse", r.dayUse, "")
	}
	if r.earlyDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "earlyDepartures", r.earlyDepartures, "")
	}
	if r.expectedArrivals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivals", r.expectedArrivals, "")
	}
	if r.expectedDepartures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedDepartures", r.expectedDepartures, "")
	}
	if r.extendedStays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extendedStays", r.extendedStays, "")
	}
	if r.houseUseReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "houseUseReservations", r.houseUseReservations, "")
	}
	if r.stayovers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayovers", r.stayovers, "")
	}
	if r.stayDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayDate", r.stayDate, "")
	}
	if r.roomRoutingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomRoutingId", r.roomRoutingId, "")
	}
	if r.excludePseudoRoomReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludePseudoRoomReservations", r.excludePseudoRoomReservations, "")
	}
	if r.excludeReservationIds != nil {
		t := *r.excludeReservationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReservationIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReservationIds", t, "multi")
		}
	}
	if r.excludeVIPStatusCodes != nil {
		t := *r.excludeVIPStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVIPStatusCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVIPStatusCodes", t, "multi")
		}
	}
	if r.excludeSpecials != nil {
		t := *r.excludeSpecials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSpecials", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSpecials", t, "multi")
		}
	}
	if r.excludeFloorPreferences != nil {
		t := *r.excludeFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", t, "multi")
		}
	}
	if r.excludeAdvanceCheckedIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeAdvanceCheckedIn", r.excludeAdvanceCheckedIn, "")
	}
	if r.excludeRoomFeatures != nil {
		t := *r.excludeRoomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRoomFeatures", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRoomFeatures", t, "multi")
		}
	}
	if r.playerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playerId", r.playerId, "")
	}
	if r.gamingBalanceFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gamingBalanceFrom", r.gamingBalanceFrom, "")
	}
	if r.gamingBalanceTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gamingBalanceTo", r.gamingBalanceTo, "")
	}
	if r.compAccountingBalanceFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccountingBalanceFrom", r.compAccountingBalanceFrom, "")
	}
	if r.compAccountingBalanceTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccountingBalanceTo", r.compAccountingBalanceTo, "")
	}
	if r.searchTypes != nil {
		t := *r.searchTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypes", t, "multi")
		}
	}
	if r.reservationStatuses != nil {
		t := *r.reservationStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", t, "multi")
		}
	}
	if r.transportationCodes != nil {
		t := *r.transportationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", t, "multi")
		}
	}
	if r.roomReadyStatuses != nil {
		t := *r.roomReadyStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomReadyStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomReadyStatuses", t, "multi")
		}
	}
	if r.checkoutMessageReceived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkoutMessageReceived", r.checkoutMessageReceived, "")
	}
	if r.optedForCommunication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "optedForCommunication", r.optedForCommunication, "")
	}
	if r.createdOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOn", r.createdOn, "")
	}
	if r.stayOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayOn", r.stayOn, "")
	}
	if r.contactNames != nil {
		t := *r.contactNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contactNames", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contactNames", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationsSummaryRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	advancedCheckedIn *bool
	limit *int32
	offset *int32
	preRegistered *bool
	arrivalDate *string
	departureDate *string
	createDateTime *string
	cancelledOn *string
	folioClosedOn *string
	lastName *string
	companyId *float32
	guestNameId *float32
	reservationStatus *string
	confirmationNumber *string
	externalReferenceNumber *string
	cancellationNumber *string
	membershipNumber *string
	registeredCardNumber *string
	balance *float32
	roomId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationsSummaryRequest) Authorization(authorization string) ReservationApiGetReservationsSummaryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationsSummaryRequest) XAppKey(xAppKey string) ReservationApiGetReservationsSummaryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationsSummaryRequest) XHotelid(xHotelid string) ReservationApiGetReservationsSummaryRequest {
	r.xHotelid = &xHotelid
	return r
}

// This filter indicates if the reservation(s) has performed an Advance Check-In or not. Data fetched is for 30 days ahead of business date.
func (r ReservationApiGetReservationsSummaryRequest) AdvancedCheckedIn(advancedCheckedIn bool) ReservationApiGetReservationsSummaryRequest {
	r.advancedCheckedIn = &advancedCheckedIn
	return r
}

// This filter indicates number of records the API has to fetch.
func (r ReservationApiGetReservationsSummaryRequest) Limit(limit int32) ReservationApiGetReservationsSummaryRequest {
	r.limit = &limit
	return r
}

// This filter is for the index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationApiGetReservationsSummaryRequest) Offset(offset int32) ReservationApiGetReservationsSummaryRequest {
	r.offset = &offset
	return r
}

// This filter indicates whether the reservation is Pre-Registered for Internet Check-In or not. Data fetched is for 30 days ahead of business date.
func (r ReservationApiGetReservationsSummaryRequest) PreRegistered(preRegistered bool) ReservationApiGetReservationsSummaryRequest {
	r.preRegistered = &preRegistered
	return r
}

// This filter is for the date of arrival of reservation.
func (r ReservationApiGetReservationsSummaryRequest) ArrivalDate(arrivalDate string) ReservationApiGetReservationsSummaryRequest {
	r.arrivalDate = &arrivalDate
	return r
}

// This filter is for the date of departure of reservation.
func (r ReservationApiGetReservationsSummaryRequest) DepartureDate(departureDate string) ReservationApiGetReservationsSummaryRequest {
	r.departureDate = &departureDate
	return r
}

// This filter is for the business date when reservation(s) was created in the system.
func (r ReservationApiGetReservationsSummaryRequest) CreateDateTime(createDateTime string) ReservationApiGetReservationsSummaryRequest {
	r.createDateTime = &createDateTime
	return r
}

// This filter is for the date when reservation(s) was cancelled.
func (r ReservationApiGetReservationsSummaryRequest) CancelledOn(cancelledOn string) ReservationApiGetReservationsSummaryRequest {
	r.cancelledOn = &cancelledOn
	return r
}

// This filter is for the date when reservation(s) folio was closed.
func (r ReservationApiGetReservationsSummaryRequest) FolioClosedOn(folioClosedOn string) ReservationApiGetReservationsSummaryRequest {
	r.folioClosedOn = &folioClosedOn
	return r
}

// This filter looks up reservations with this last Name. Data fetched is for +-2 business date only when passed alone.
func (r ReservationApiGetReservationsSummaryRequest) LastName(lastName string) ReservationApiGetReservationsSummaryRequest {
	r.lastName = &lastName
	return r
}

// This filter is ID of the company used for the reservation. Data fetched is for +-2 business date only when passed alone.
func (r ReservationApiGetReservationsSummaryRequest) CompanyId(companyId float32) ReservationApiGetReservationsSummaryRequest {
	r.companyId = &companyId
	return r
}

// This filter is ID of the guest.
func (r ReservationApiGetReservationsSummaryRequest) GuestNameId(guestNameId float32) ReservationApiGetReservationsSummaryRequest {
	r.guestNameId = &guestNameId
	return r
}

// This filter is computed reservation status of the reservation(s).
func (r ReservationApiGetReservationsSummaryRequest) ReservationStatus(reservationStatus string) ReservationApiGetReservationsSummaryRequest {
	r.reservationStatus = &reservationStatus
	return r
}

// This filter is ID of confirmation for the reservation.
func (r ReservationApiGetReservationsSummaryRequest) ConfirmationNumber(confirmationNumber string) ReservationApiGetReservationsSummaryRequest {
	r.confirmationNumber = &confirmationNumber
	return r
}

// This filter is ID of external reference for the reservation.
func (r ReservationApiGetReservationsSummaryRequest) ExternalReferenceNumber(externalReferenceNumber string) ReservationApiGetReservationsSummaryRequest {
	r.externalReferenceNumber = &externalReferenceNumber
	return r
}

// This filter is ID of cancellation for the reservation.
func (r ReservationApiGetReservationsSummaryRequest) CancellationNumber(cancellationNumber string) ReservationApiGetReservationsSummaryRequest {
	r.cancellationNumber = &cancellationNumber
	return r
}

// This filter is used for looking up reservations with this membership number. Last Name is required along with membership number to filter the data.
func (r ReservationApiGetReservationsSummaryRequest) MembershipNumber(membershipNumber string) ReservationApiGetReservationsSummaryRequest {
	r.membershipNumber = &membershipNumber
	return r
}

// This filter is unique identifier of the registration card number. Last Name is required along with registration card number to filter the data.
func (r ReservationApiGetReservationsSummaryRequest) RegisteredCardNumber(registeredCardNumber string) ReservationApiGetReservationsSummaryRequest {
	r.registeredCardNumber = &registeredCardNumber
	return r
}

// This filter checks reservations with balance amount greater than or equal to this amount. Departure date is required along with balance to filter the data.
func (r ReservationApiGetReservationsSummaryRequest) Balance(balance float32) ReservationApiGetReservationsSummaryRequest {
	r.balance = &balance
	return r
}

// This filter is for room number.
func (r ReservationApiGetReservationsSummaryRequest) RoomId(roomId string) ReservationApiGetReservationsSummaryRequest {
	r.roomId = &roomId
	return r
}

// External system code.
func (r ReservationApiGetReservationsSummaryRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationsSummaryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationsSummaryRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationsSummaryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationsSummaryRequest) Execute() (*ReservationsSummary, *http.Response, error) {
	return r.ApiService.GetReservationsSummaryExecute(r)
}

/*
GetReservationsSummary Get brief summary for Reservations

<p>This operation fetches brief summary for the reservations and also supports the Global Parameter <strong>MAX ROWS FETCH COUNT</strong>.<br>By default this parameter is configured to support an overall fetch of <strong>5000</strong> Records in total, with maximum number of records that can be fetched at a time being <strong>200</strong> (limit). However, this parameter can be updated to support an overall fetch value being a valid number between <strong>1</strong> and <strong>10000</strong> with maximum number of records that can be fetched at a time being same i.e. <strong>200</strong> (limit).</p><p>Requests with an <strong>offset</strong> and <strong>limit</strong> sum exceeding the <strong>MAX ROWS FETCH COUNT</strong> configured would fail the request.</p> <p><strong>OperationId:</strong>getReservationsSummary</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservations is being searched.
 @return ReservationApiGetReservationsSummaryRequest
*/
func (a *ReservationApiService) GetReservationsSummary(ctx context.Context, hotelId string) ReservationApiGetReservationsSummaryRequest {
	return ReservationApiGetReservationsSummaryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationsSummary
func (a *ReservationApiService) GetReservationsSummaryExecute(r ReservationApiGetReservationsSummaryRequest) (*ReservationsSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationsSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationsSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.advancedCheckedIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "advancedCheckedIn", r.advancedCheckedIn, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.preRegistered != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preRegistered", r.preRegistered, "")
	}
	if r.arrivalDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalDate", r.arrivalDate, "")
	}
	if r.departureDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureDate", r.departureDate, "")
	}
	if r.createDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createDateTime", r.createDateTime, "")
	}
	if r.cancelledOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancelledOn", r.cancelledOn, "")
	}
	if r.folioClosedOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioClosedOn", r.folioClosedOn, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	if r.companyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	}
	if r.guestNameId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestNameId", r.guestNameId, "")
	}
	if r.reservationStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", r.reservationStatus, "")
	}
	if r.confirmationNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "confirmationNumber", r.confirmationNumber, "")
	}
	if r.externalReferenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceNumber", r.externalReferenceNumber, "")
	}
	if r.cancellationNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancellationNumber", r.cancellationNumber, "")
	}
	if r.membershipNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipNumber", r.membershipNumber, "")
	}
	if r.registeredCardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "registeredCardNumber", r.registeredCardNumber, "")
	}
	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationsToShareByProfileIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	profileIdtoShare string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	superSearch *string
	reservationGuestId *string
	reservationGuestIdType *string
	membershipId *string
	membershipLevel *[]string
	membershipType *[]string
	surname *string
	givenName *string
	roomId *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationsToShareByProfileIdRequest) Authorization(authorization string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationsToShareByProfileIdRequest) XAppKey(xAppKey string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationsToShareByProfileIdRequest) XHotelid(xHotelid string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationApiGetReservationsToShareByProfileIdRequest) Limit(limit int32) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.limit = &limit
	return r
}

// Free form text field for searching all reservation fields
func (r ReservationApiGetReservationsToShareByProfileIdRequest) SuperSearch(superSearch string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.superSearch = &superSearch
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsToShareByProfileIdRequest) ReservationGuestId(reservationGuestId string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.reservationGuestId = &reservationGuestId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetReservationsToShareByProfileIdRequest) ReservationGuestIdType(reservationGuestIdType string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.reservationGuestIdType = &reservationGuestIdType
	return r
}

// Membership ID criteria.
func (r ReservationApiGetReservationsToShareByProfileIdRequest) MembershipId(membershipId string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.membershipId = &membershipId
	return r
}

func (r ReservationApiGetReservationsToShareByProfileIdRequest) MembershipLevel(membershipLevel []string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.membershipLevel = &membershipLevel
	return r
}

func (r ReservationApiGetReservationsToShareByProfileIdRequest) MembershipType(membershipType []string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.membershipType = &membershipType
	return r
}

// Family name, last name.
func (r ReservationApiGetReservationsToShareByProfileIdRequest) Surname(surname string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.surname = &surname
	return r
}

// Given name, first name or names
func (r ReservationApiGetReservationsToShareByProfileIdRequest) GivenName(givenName string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.givenName = &givenName
	return r
}

// Room number
func (r ReservationApiGetReservationsToShareByProfileIdRequest) RoomId(roomId string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.roomId = &roomId
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r ReservationApiGetReservationsToShareByProfileIdRequest) FetchInstructions(fetchInstructions []string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ReservationApiGetReservationsToShareByProfileIdRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationsToShareByProfileIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationsToShareByProfileIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationsToShareByProfileIdRequest) Execute() (*FetchReservations, *http.Response, error) {
	return r.ApiService.GetReservationsToShareByProfileIdExecute(r)
}

/*
GetReservationsToShareByProfileId Get Reservations to share 

Get Reservations to share by profile id. <p><strong>OperationId:</strong>getReservationsToShareByProfileId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileIdtoShare Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetReservationsToShareByProfileIdRequest
*/
func (a *ReservationApiService) GetReservationsToShareByProfileId(ctx context.Context, profileIdtoShare string, hotelId string) ReservationApiGetReservationsToShareByProfileIdRequest {
	return ReservationApiGetReservationsToShareByProfileIdRequest{
		ApiService: a,
		ctx: ctx,
		profileIdtoShare: profileIdtoShare,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchReservations
func (a *ReservationApiService) GetReservationsToShareByProfileIdExecute(r ReservationApiGetReservationsToShareByProfileIdRequest) (*FetchReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationsToShareByProfileId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileIdtoShare}/share"
	localVarPath = strings.Replace(localVarPath, "{"+"profileIdtoShare"+"}", url.PathEscape(parameterValueToString(r.profileIdtoShare, "profileIdtoShare")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileIdtoShare) < 1 {
		return localVarReturnValue, nil, reportError("profileIdtoShare must have at least 1 elements")
	}
	if strlen(r.profileIdtoShare) > 2000 {
		return localVarReturnValue, nil, reportError("profileIdtoShare must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.superSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "superSearch", r.superSearch, "")
	}
	if r.reservationGuestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestId", r.reservationGuestId, "")
	}
	if r.reservationGuestIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestIdType", r.reservationGuestIdType, "")
	}
	if r.membershipId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipId", r.membershipId, "")
	}
	if r.membershipLevel != nil {
		t := *r.membershipLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevel", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevel", t, "multi")
		}
	}
	if r.membershipType != nil {
		t := *r.membershipType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", t, "multi")
		}
	}
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservationsToShareByReservationIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationIdtoShare string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	superSearch *string
	reservationGuestId *string
	reservationGuestIdType *string
	membershipId *string
	membershipLevel *[]string
	membershipType *[]string
	surname *string
	givenName *string
	roomId *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservationsToShareByReservationIdRequest) Authorization(authorization string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservationsToShareByReservationIdRequest) XAppKey(xAppKey string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservationsToShareByReservationIdRequest) XHotelid(xHotelid string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationApiGetReservationsToShareByReservationIdRequest) Limit(limit int32) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.limit = &limit
	return r
}

// Free form text field for searching all reservation fields
func (r ReservationApiGetReservationsToShareByReservationIdRequest) SuperSearch(superSearch string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.superSearch = &superSearch
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetReservationsToShareByReservationIdRequest) ReservationGuestId(reservationGuestId string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.reservationGuestId = &reservationGuestId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetReservationsToShareByReservationIdRequest) ReservationGuestIdType(reservationGuestIdType string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.reservationGuestIdType = &reservationGuestIdType
	return r
}

// Membership ID criteria.
func (r ReservationApiGetReservationsToShareByReservationIdRequest) MembershipId(membershipId string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.membershipId = &membershipId
	return r
}

func (r ReservationApiGetReservationsToShareByReservationIdRequest) MembershipLevel(membershipLevel []string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.membershipLevel = &membershipLevel
	return r
}

func (r ReservationApiGetReservationsToShareByReservationIdRequest) MembershipType(membershipType []string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.membershipType = &membershipType
	return r
}

// Family name, last name.
func (r ReservationApiGetReservationsToShareByReservationIdRequest) Surname(surname string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.surname = &surname
	return r
}

// Given name, first name or names
func (r ReservationApiGetReservationsToShareByReservationIdRequest) GivenName(givenName string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.givenName = &givenName
	return r
}

// Room number
func (r ReservationApiGetReservationsToShareByReservationIdRequest) RoomId(roomId string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.roomId = &roomId
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r ReservationApiGetReservationsToShareByReservationIdRequest) FetchInstructions(fetchInstructions []string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ReservationApiGetReservationsToShareByReservationIdRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservationsToShareByReservationIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservationsToShareByReservationIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservationsToShareByReservationIdRequest) Execute() (*FetchReservations, *http.Response, error) {
	return r.ApiService.GetReservationsToShareByReservationIdExecute(r)
}

/*
GetReservationsToShareByReservationId Get Reservations to share by Reservation id

Fetch the reservation that can be shared with an existing reservation. <p><strong>OperationId:</strong>getReservationsToShareByReservationId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationIdtoShare Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetReservationsToShareByReservationIdRequest
*/
func (a *ReservationApiService) GetReservationsToShareByReservationId(ctx context.Context, reservationIdtoShare string, hotelId string) ReservationApiGetReservationsToShareByReservationIdRequest {
	return ReservationApiGetReservationsToShareByReservationIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationIdtoShare: reservationIdtoShare,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchReservations
func (a *ReservationApiService) GetReservationsToShareByReservationIdExecute(r ReservationApiGetReservationsToShareByReservationIdRequest) (*FetchReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservationsToShareByReservationId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationIdtoShare}/share"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationIdtoShare"+"}", url.PathEscape(parameterValueToString(r.reservationIdtoShare, "reservationIdtoShare")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationIdtoShare) < 1 {
		return localVarReturnValue, nil, reportError("reservationIdtoShare must have at least 1 elements")
	}
	if strlen(r.reservationIdtoShare) > 2000 {
		return localVarReturnValue, nil, reportError("reservationIdtoShare must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.superSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "superSearch", r.superSearch, "")
	}
	if r.reservationGuestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestId", r.reservationGuestId, "")
	}
	if r.reservationGuestIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestIdType", r.reservationGuestIdType, "")
	}
	if r.membershipId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipId", r.membershipId, "")
	}
	if r.membershipLevel != nil {
		t := *r.membershipLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevel", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevel", t, "multi")
		}
	}
	if r.membershipType != nil {
		t := *r.membershipType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", t, "multi")
		}
	}
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetReservedInventoryItemsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetReservedInventoryItemsRequest) Authorization(authorization string) ReservationApiGetReservedInventoryItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetReservedInventoryItemsRequest) XAppKey(xAppKey string) ReservationApiGetReservedInventoryItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetReservedInventoryItemsRequest) XHotelid(xHotelid string) ReservationApiGetReservedInventoryItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiGetReservedInventoryItemsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetReservedInventoryItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetReservedInventoryItemsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetReservedInventoryItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetReservedInventoryItemsRequest) Execute() (*InventoryItems, *http.Response, error) {
	return r.ApiService.GetReservedInventoryItemsExecute(r)
}

/*
GetReservedInventoryItems Get Reserved Inventory Items 

Get the Inventory Items reserved for the Reservation. <p><strong>OperationId:</strong>getReservedInventoryItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetReservedInventoryItemsRequest
*/
func (a *ReservationApiService) GetReservedInventoryItems(ctx context.Context, reservationId string, hotelId string) ReservationApiGetReservedInventoryItemsRequest {
	return ReservationApiGetReservedInventoryItemsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return InventoryItems
func (a *ReservationApiService) GetReservedInventoryItemsExecute(r ReservationApiGetReservedInventoryItemsRequest) (*InventoryItems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetReservedInventoryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/inventoryItems"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetRoomCalendarRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	advanceCheckedIn *bool
	assignedRooms *string
	componentRooms *string
	connectingRoomsOnly *string
	dueOut *string
	endDate *string
	isSortDescending *bool
	pageIndex *int32
	partiallyAssignedRooms *string
	recordsPerPage *int32
	roomConditions *string
	ownerRoomsOnly *string
	ownerExclusiveOnly *string
	sortingBy *string
	includeRoomMoveHistory *bool
	includeComponentRoomBlockOutDates *bool
	startDate *string
	unassignedRooms *string
	roomId *[]string
	roomType *[]string
	roomClass *[]string
	floor *[]string
	roomFeature *[]string
	roomStatus *[]string
	smokingPreference *[]string
	bedType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetRoomCalendarRequest) Authorization(authorization string) ReservationApiGetRoomCalendarRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetRoomCalendarRequest) XAppKey(xAppKey string) ReservationApiGetRoomCalendarRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetRoomCalendarRequest) XHotelid(xHotelid string) ReservationApiGetRoomCalendarRequest {
	r.xHotelid = &xHotelid
	return r
}

// If true, then filter room results to rooms with Advance Checked In Reservations.
func (r ReservationApiGetRoomCalendarRequest) AdvanceCheckedIn(advanceCheckedIn bool) ReservationApiGetRoomCalendarRequest {
	r.advanceCheckedIn = &advanceCheckedIn
	return r
}

// If &#39;Y&#39;, then filter room results to rooms that are assigned to guest.
func (r ReservationApiGetRoomCalendarRequest) AssignedRooms(assignedRooms string) ReservationApiGetRoomCalendarRequest {
	r.assignedRooms = &assignedRooms
	return r
}

// If &#39;Y&#39;, then filter room results to component rooms.
func (r ReservationApiGetRoomCalendarRequest) ComponentRooms(componentRooms string) ReservationApiGetRoomCalendarRequest {
	r.componentRooms = &componentRooms
	return r
}

// If &#39;Y&#39;, then filter room results to only connecting rooms.
func (r ReservationApiGetRoomCalendarRequest) ConnectingRoomsOnly(connectingRoomsOnly string) ReservationApiGetRoomCalendarRequest {
	r.connectingRoomsOnly = &connectingRoomsOnly
	return r
}

// If &#39;Y&#39;, then filter room results to rooms with Due Out Reservations.
func (r ReservationApiGetRoomCalendarRequest) DueOut(dueOut string) ReservationApiGetRoomCalendarRequest {
	r.dueOut = &dueOut
	return r
}

// The ending value of the date range.
func (r ReservationApiGetRoomCalendarRequest) EndDate(endDate string) ReservationApiGetRoomCalendarRequest {
	r.endDate = &endDate
	return r
}

// If true, then fetch result will be sorted in descending order.
func (r ReservationApiGetRoomCalendarRequest) IsSortDescending(isSortDescending bool) ReservationApiGetRoomCalendarRequest {
	r.isSortDescending = &isSortDescending
	return r
}

// Page index to be retrieved.
func (r ReservationApiGetRoomCalendarRequest) PageIndex(pageIndex int32) ReservationApiGetRoomCalendarRequest {
	r.pageIndex = &pageIndex
	return r
}

// If &#39;Y&#39;, then filter room results to component rooms that have at least one of its rooms assigned to guest.
func (r ReservationApiGetRoomCalendarRequest) PartiallyAssignedRooms(partiallyAssignedRooms string) ReservationApiGetRoomCalendarRequest {
	r.partiallyAssignedRooms = &partiallyAssignedRooms
	return r
}

// Number of records per page.
func (r ReservationApiGetRoomCalendarRequest) RecordsPerPage(recordsPerPage int32) ReservationApiGetRoomCalendarRequest {
	r.recordsPerPage = &recordsPerPage
	return r
}

// If &#39;Y&#39;, then filter room results to rooms with Room Conditions.
func (r ReservationApiGetRoomCalendarRequest) RoomConditions(roomConditions string) ReservationApiGetRoomCalendarRequest {
	r.roomConditions = &roomConditions
	return r
}

// If &#39;Y&#39;, then filter room results to rooms with rotation rooms only. It is supported only if OPERA Control Room Rotation is active.
func (r ReservationApiGetRoomCalendarRequest) OwnerRoomsOnly(ownerRoomsOnly string) ReservationApiGetRoomCalendarRequest {
	r.ownerRoomsOnly = &ownerRoomsOnly
	return r
}

// If &#39;Y&#39;, then filter room results to rooms that are exclusive to the owner. It is supported only if OPERA Control Room Rotation is active.
func (r ReservationApiGetRoomCalendarRequest) OwnerExclusiveOnly(ownerExclusiveOnly string) ReservationApiGetRoomCalendarRequest {
	r.ownerExclusiveOnly = &ownerExclusiveOnly
	return r
}

// A collection of supported sorting for room calendar.
func (r ReservationApiGetRoomCalendarRequest) SortingBy(sortingBy string) ReservationApiGetRoomCalendarRequest {
	r.sortingBy = &sortingBy
	return r
}

// Include Room Move History in result.
func (r ReservationApiGetRoomCalendarRequest) IncludeRoomMoveHistory(includeRoomMoveHistory bool) ReservationApiGetRoomCalendarRequest {
	r.includeRoomMoveHistory = &includeRoomMoveHistory
	return r
}

// Include information about Component Room Reservation dates when fetching a component suite.
func (r ReservationApiGetRoomCalendarRequest) IncludeComponentRoomBlockOutDates(includeComponentRoomBlockOutDates bool) ReservationApiGetRoomCalendarRequest {
	r.includeComponentRoomBlockOutDates = &includeComponentRoomBlockOutDates
	return r
}

// The starting value of the date range.
func (r ReservationApiGetRoomCalendarRequest) StartDate(startDate string) ReservationApiGetRoomCalendarRequest {
	r.startDate = &startDate
	return r
}

// If &#39;Y&#39;, then filter room results to rooms that are not yet assigned to guest.
func (r ReservationApiGetRoomCalendarRequest) UnassignedRooms(unassignedRooms string) ReservationApiGetRoomCalendarRequest {
	r.unassignedRooms = &unassignedRooms
	return r
}

// Room search filter.
func (r ReservationApiGetRoomCalendarRequest) RoomId(roomId []string) ReservationApiGetRoomCalendarRequest {
	r.roomId = &roomId
	return r
}

// Room Type search filter.
func (r ReservationApiGetRoomCalendarRequest) RoomType(roomType []string) ReservationApiGetRoomCalendarRequest {
	r.roomType = &roomType
	return r
}

// Room Class search filter.
func (r ReservationApiGetRoomCalendarRequest) RoomClass(roomClass []string) ReservationApiGetRoomCalendarRequest {
	r.roomClass = &roomClass
	return r
}

// Floor search filter.
func (r ReservationApiGetRoomCalendarRequest) Floor(floor []string) ReservationApiGetRoomCalendarRequest {
	r.floor = &floor
	return r
}

// A code representing a room feature.
func (r ReservationApiGetRoomCalendarRequest) RoomFeature(roomFeature []string) ReservationApiGetRoomCalendarRequest {
	r.roomFeature = &roomFeature
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r ReservationApiGetRoomCalendarRequest) RoomStatus(roomStatus []string) ReservationApiGetRoomCalendarRequest {
	r.roomStatus = &roomStatus
	return r
}

// Smoking Preference filter.
func (r ReservationApiGetRoomCalendarRequest) SmokingPreference(smokingPreference []string) ReservationApiGetRoomCalendarRequest {
	r.smokingPreference = &smokingPreference
	return r
}

func (r ReservationApiGetRoomCalendarRequest) BedType(bedType []string) ReservationApiGetRoomCalendarRequest {
	r.bedType = &bedType
	return r
}

// External system code.
func (r ReservationApiGetRoomCalendarRequest) XExternalsystem(xExternalsystem string) ReservationApiGetRoomCalendarRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetRoomCalendarRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetRoomCalendarRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetRoomCalendarRequest) Execute() (*RoomCalendar, *http.Response, error) {
	return r.ApiService.GetRoomCalendarExecute(r)
}

/*
GetRoomCalendar Get the room calendar

Use this API to get the room calendar for a hotel. It fetches inventory detail per rooms, the reservations assigned for a selected date range in the past or future, scheduled Out of Order or Out of Service status, room description, room attributes, room features, connecting room, etc.<p><strong>OperationId:</strong>getRoomCalendar</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetRoomCalendarRequest
*/
func (a *ReservationApiService) GetRoomCalendar(ctx context.Context, hotelId string) ReservationApiGetRoomCalendarRequest {
	return ReservationApiGetRoomCalendarRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomCalendar
func (a *ReservationApiService) GetRoomCalendarExecute(r ReservationApiGetRoomCalendarRequest) (*RoomCalendar, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomCalendar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetRoomCalendar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomCalendar"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.advanceCheckedIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "advanceCheckedIn", r.advanceCheckedIn, "")
	}
	if r.assignedRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignedRooms", r.assignedRooms, "")
	}
	if r.componentRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentRooms", r.componentRooms, "")
	}
	if r.connectingRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectingRoomsOnly", r.connectingRoomsOnly, "")
	}
	if r.dueOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueOut", r.dueOut, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.isSortDescending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSortDescending", r.isSortDescending, "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIndex", r.pageIndex, "")
	}
	if r.partiallyAssignedRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partiallyAssignedRooms", r.partiallyAssignedRooms, "")
	}
	if r.recordsPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recordsPerPage", r.recordsPerPage, "")
	}
	if r.roomConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomConditions", r.roomConditions, "")
	}
	if r.ownerRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerRoomsOnly", r.ownerRoomsOnly, "")
	}
	if r.ownerExclusiveOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerExclusiveOnly", r.ownerExclusiveOnly, "")
	}
	if r.sortingBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortingBy", r.sortingBy, "")
	}
	if r.includeRoomMoveHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRoomMoveHistory", r.includeRoomMoveHistory, "")
	}
	if r.includeComponentRoomBlockOutDates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeComponentRoomBlockOutDates", r.includeComponentRoomBlockOutDates, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.unassignedRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unassignedRooms", r.unassignedRooms, "")
	}
	if r.roomId != nil {
		t := *r.roomId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.floor != nil {
		t := *r.floor
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "floor", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "floor", t, "multi")
		}
	}
	if r.roomFeature != nil {
		t := *r.roomFeature
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeature", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeature", t, "multi")
		}
	}
	if r.roomStatus != nil {
		t := *r.roomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatus", t, "multi")
		}
	}
	if r.smokingPreference != nil {
		t := *r.smokingPreference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "smokingPreference", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "smokingPreference", t, "multi")
		}
	}
	if r.bedType != nil {
		t := *r.bedType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bedType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bedType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeWindowRouting *bool
	includeRoomRouting *bool
	includeCompRouting *bool
	includeCompRoutingRequests *bool
	effectiveOn *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetRoutingInstructionsRequest) Authorization(authorization string) ReservationApiGetRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetRoutingInstructionsRequest) XAppKey(xAppKey string) ReservationApiGetRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetRoutingInstructionsRequest) XHotelid(xHotelid string) ReservationApiGetRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Include the window routing instructions to the response.
func (r ReservationApiGetRoutingInstructionsRequest) IncludeWindowRouting(includeWindowRouting bool) ReservationApiGetRoutingInstructionsRequest {
	r.includeWindowRouting = &includeWindowRouting
	return r
}

// Include the room routing instructions in the response.
func (r ReservationApiGetRoutingInstructionsRequest) IncludeRoomRouting(includeRoomRouting bool) ReservationApiGetRoutingInstructionsRequest {
	r.includeRoomRouting = &includeRoomRouting
	return r
}

// Include the comp routing instructions in the response.
func (r ReservationApiGetRoutingInstructionsRequest) IncludeCompRouting(includeCompRouting bool) ReservationApiGetRoutingInstructionsRequest {
	r.includeCompRouting = &includeCompRouting
	return r
}

// Include the comp routing requests in the response.
func (r ReservationApiGetRoutingInstructionsRequest) IncludeCompRoutingRequests(includeCompRoutingRequests bool) ReservationApiGetRoutingInstructionsRequest {
	r.includeCompRoutingRequests = &includeCompRoutingRequests
	return r
}

// If date is included then the search result should only be valid for dates which includes this date.
func (r ReservationApiGetRoutingInstructionsRequest) EffectiveOn(effectiveOn string) ReservationApiGetRoutingInstructionsRequest {
	r.effectiveOn = &effectiveOn
	return r
}

// External system code.
func (r ReservationApiGetRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetRoutingInstructionsRequest) Execute() (*RoutingInstructions, *http.Response, error) {
	return r.ApiService.GetRoutingInstructionsExecute(r)
}

/*
GetRoutingInstructions Get routing instructions

Use this API to fetch a reservation's routing instructions. It requires a reservation ID, which can be fetched using getReservations. <p><strong>OperationId:</strong>getRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetRoutingInstructionsRequest
*/
func (a *ReservationApiService) GetRoutingInstructions(ctx context.Context, reservationId string, hotelId string) ReservationApiGetRoutingInstructionsRequest {
	return ReservationApiGetRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoutingInstructions
func (a *ReservationApiService) GetRoutingInstructionsExecute(r ReservationApiGetRoutingInstructionsRequest) (*RoutingInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoutingInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeWindowRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeWindowRouting", r.includeWindowRouting, "")
	}
	if r.includeRoomRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRoomRouting", r.includeRoomRouting, "")
	}
	if r.includeCompRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCompRouting", r.includeCompRouting, "")
	}
	if r.includeCompRoutingRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCompRoutingRequests", r.includeCompRoutingRequests, "")
	}
	if r.effectiveOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "effectiveOn", r.effectiveOn, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetScriptRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	languageCode *string
	scriptType *string
	reservationId *[]string
	reservationIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetScriptRequest) Authorization(authorization string) ReservationApiGetScriptRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetScriptRequest) XAppKey(xAppKey string) ReservationApiGetScriptRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetScriptRequest) XHotelid(xHotelid string) ReservationApiGetScriptRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ReservationApiGetScriptRequest) LanguageCode(languageCode string) ReservationApiGetScriptRequest {
	r.languageCode = &languageCode
	return r
}

// Used for Character Strings, length 0 to 40.
func (r ReservationApiGetScriptRequest) ScriptType(scriptType string) ReservationApiGetScriptRequest {
	r.scriptType = &scriptType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetScriptRequest) ReservationId(reservationId []string) ReservationApiGetScriptRequest {
	r.reservationId = &reservationId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetScriptRequest) ReservationIdType(reservationIdType []string) ReservationApiGetScriptRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// External system code.
func (r ReservationApiGetScriptRequest) XExternalsystem(xExternalsystem string) ReservationApiGetScriptRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetScriptRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetScriptRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetScriptRequest) Execute() (*Script, *http.Response, error) {
	return r.ApiService.GetScriptExecute(r)
}

/*
GetScript Get a script

This API will get the script for your property. <p><strong>OperationId:</strong>getScript</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetScriptRequest
*/
func (a *ReservationApiService) GetScript(ctx context.Context, hotelId string) ReservationApiGetScriptRequest {
	return ReservationApiGetScriptRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Script
func (a *ReservationApiService) GetScriptExecute(r ReservationApiGetScriptRequest) (*Script, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Script
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetScript")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/script"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "languageCode", r.languageCode, "")
	}
	if r.scriptType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scriptType", r.scriptType, "")
	}
	if r.reservationId != nil {
		t := *r.reservationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", t, "multi")
		}
	}
	if r.reservationIdType != nil {
		t := *r.reservationIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetSellMessageConfigRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	message *string
	roomType *[]string
	ratePlanCode *[]string
	blockId *[]string
	blockIdType *[]string
	blockCode *string
	languageCode *string
	croCode *string
	displayDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetSellMessageConfigRequest) Authorization(authorization string) ReservationApiGetSellMessageConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetSellMessageConfigRequest) XAppKey(xAppKey string) ReservationApiGetSellMessageConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetSellMessageConfigRequest) XHotelid(xHotelid string) ReservationApiGetSellMessageConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationApiGetSellMessageConfigRequest) Limit(limit int32) ReservationApiGetSellMessageConfigRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationApiGetSellMessageConfigRequest) Offset(offset int32) ReservationApiGetSellMessageConfigRequest {
	r.offset = &offset
	return r
}

// Sell Message text.
func (r ReservationApiGetSellMessageConfigRequest) Message(message string) ReservationApiGetSellMessageConfigRequest {
	r.message = &message
	return r
}

// Room Type.
func (r ReservationApiGetSellMessageConfigRequest) RoomType(roomType []string) ReservationApiGetSellMessageConfigRequest {
	r.roomType = &roomType
	return r
}

// Rate Plan code.
func (r ReservationApiGetSellMessageConfigRequest) RatePlanCode(ratePlanCode []string) ReservationApiGetSellMessageConfigRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetSellMessageConfigRequest) BlockId(blockId []string) ReservationApiGetSellMessageConfigRequest {
	r.blockId = &blockId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetSellMessageConfigRequest) BlockIdType(blockIdType []string) ReservationApiGetSellMessageConfigRequest {
	r.blockIdType = &blockIdType
	return r
}

// Block Code to query for.
func (r ReservationApiGetSellMessageConfigRequest) BlockCode(blockCode string) ReservationApiGetSellMessageConfigRequest {
	r.blockCode = &blockCode
	return r
}

// Language code for the sell message.
func (r ReservationApiGetSellMessageConfigRequest) LanguageCode(languageCode string) ReservationApiGetSellMessageConfigRequest {
	r.languageCode = &languageCode
	return r
}

// CRO code to query for.
func (r ReservationApiGetSellMessageConfigRequest) CroCode(croCode string) ReservationApiGetSellMessageConfigRequest {
	r.croCode = &croCode
	return r
}

// The date on which the fetched sell message should be active.
func (r ReservationApiGetSellMessageConfigRequest) DisplayDate(displayDate string) ReservationApiGetSellMessageConfigRequest {
	r.displayDate = &displayDate
	return r
}

// External system code.
func (r ReservationApiGetSellMessageConfigRequest) XExternalsystem(xExternalsystem string) ReservationApiGetSellMessageConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetSellMessageConfigRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetSellMessageConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetSellMessageConfigRequest) Execute() (*FetchSellMessageConfig, *http.Response, error) {
	return r.ApiService.GetSellMessageConfigExecute(r)
}

/*
GetSellMessageConfig Get sell messages 

Fetch the existing sell message configuration for a property. <p><strong>OperationId:</strong>getSellMessageConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetSellMessageConfigRequest
*/
func (a *ReservationApiService) GetSellMessageConfig(ctx context.Context, hotelId string) ReservationApiGetSellMessageConfigRequest {
	return ReservationApiGetSellMessageConfigRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchSellMessageConfig
func (a *ReservationApiService) GetSellMessageConfigExecute(r ReservationApiGetSellMessageConfigRequest) (*FetchSellMessageConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchSellMessageConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetSellMessageConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sellMessages/config"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "")
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
	}
	if r.blockIdType != nil {
		t := *r.blockIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", t, "multi")
		}
	}
	if r.blockCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCode", r.blockCode, "")
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "languageCode", r.languageCode, "")
	}
	if r.croCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "croCode", r.croCode, "")
	}
	if r.displayDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "displayDate", r.displayDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetSellMessageConfigByChainRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	message *string
	roomType *[]string
	ratePlanCode *[]string
	blockId *[]string
	blockIdType *[]string
	blockCode *string
	languageCode *string
	hotelIds *[]string
	chainId *string
	croCode *string
	displayDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetSellMessageConfigByChainRequest) Authorization(authorization string) ReservationApiGetSellMessageConfigByChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetSellMessageConfigByChainRequest) XAppKey(xAppKey string) ReservationApiGetSellMessageConfigByChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetSellMessageConfigByChainRequest) XHotelid(xHotelid string) ReservationApiGetSellMessageConfigByChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationApiGetSellMessageConfigByChainRequest) Limit(limit int32) ReservationApiGetSellMessageConfigByChainRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationApiGetSellMessageConfigByChainRequest) Offset(offset int32) ReservationApiGetSellMessageConfigByChainRequest {
	r.offset = &offset
	return r
}

// Sell Message text.
func (r ReservationApiGetSellMessageConfigByChainRequest) Message(message string) ReservationApiGetSellMessageConfigByChainRequest {
	r.message = &message
	return r
}

// Room Type.
func (r ReservationApiGetSellMessageConfigByChainRequest) RoomType(roomType []string) ReservationApiGetSellMessageConfigByChainRequest {
	r.roomType = &roomType
	return r
}

// Rate Plan code.
func (r ReservationApiGetSellMessageConfigByChainRequest) RatePlanCode(ratePlanCode []string) ReservationApiGetSellMessageConfigByChainRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetSellMessageConfigByChainRequest) BlockId(blockId []string) ReservationApiGetSellMessageConfigByChainRequest {
	r.blockId = &blockId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetSellMessageConfigByChainRequest) BlockIdType(blockIdType []string) ReservationApiGetSellMessageConfigByChainRequest {
	r.blockIdType = &blockIdType
	return r
}

// Block Code to query for.
func (r ReservationApiGetSellMessageConfigByChainRequest) BlockCode(blockCode string) ReservationApiGetSellMessageConfigByChainRequest {
	r.blockCode = &blockCode
	return r
}

// Language code for the sell message.
func (r ReservationApiGetSellMessageConfigByChainRequest) LanguageCode(languageCode string) ReservationApiGetSellMessageConfigByChainRequest {
	r.languageCode = &languageCode
	return r
}

// Hotel code.
func (r ReservationApiGetSellMessageConfigByChainRequest) HotelIds(hotelIds []string) ReservationApiGetSellMessageConfigByChainRequest {
	r.hotelIds = &hotelIds
	return r
}

// Chain code to query for.
func (r ReservationApiGetSellMessageConfigByChainRequest) ChainId(chainId string) ReservationApiGetSellMessageConfigByChainRequest {
	r.chainId = &chainId
	return r
}

// CRO code to query for.
func (r ReservationApiGetSellMessageConfigByChainRequest) CroCode(croCode string) ReservationApiGetSellMessageConfigByChainRequest {
	r.croCode = &croCode
	return r
}

// The date on which the fetched sell message should be active.
func (r ReservationApiGetSellMessageConfigByChainRequest) DisplayDate(displayDate string) ReservationApiGetSellMessageConfigByChainRequest {
	r.displayDate = &displayDate
	return r
}

// External system code.
func (r ReservationApiGetSellMessageConfigByChainRequest) XExternalsystem(xExternalsystem string) ReservationApiGetSellMessageConfigByChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetSellMessageConfigByChainRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetSellMessageConfigByChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetSellMessageConfigByChainRequest) Execute() (*FetchSellMessageConfig, *http.Response, error) {
	return r.ApiService.GetSellMessageConfigByChainExecute(r)
}

/*
GetSellMessageConfigByChain Get sell messages by chain

Fetch the existing sell message configuration. <p><strong>OperationId:</strong>getSellMessageConfigByChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationApiGetSellMessageConfigByChainRequest
*/
func (a *ReservationApiService) GetSellMessageConfigByChain(ctx context.Context) ReservationApiGetSellMessageConfigByChainRequest {
	return ReservationApiGetSellMessageConfigByChainRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchSellMessageConfig
func (a *ReservationApiService) GetSellMessageConfigByChainExecute(r ReservationApiGetSellMessageConfigByChainRequest) (*FetchSellMessageConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchSellMessageConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetSellMessageConfigByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sellMessages/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "")
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
	}
	if r.blockIdType != nil {
		t := *r.blockIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", t, "multi")
		}
	}
	if r.blockCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCode", r.blockCode, "")
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "languageCode", r.languageCode, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.chainId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainId", r.chainId, "")
	}
	if r.croCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "croCode", r.croCode, "")
	}
	if r.displayDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "displayDate", r.displayDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetSellMessagesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	croCode *string
	hotelId *string
	criteriaId *string
	criteriaIdType *string
	limit *int32
	ratePlanCode *string
	roomType *string
	stickyFlagYn *string
	criteriaType *string
	startDate *string
	endDate *string
	duration *string
	fetchInstructions *[]string
	usedInModule *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetSellMessagesRequest) Authorization(authorization string) ReservationApiGetSellMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetSellMessagesRequest) XAppKey(xAppKey string) ReservationApiGetSellMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetSellMessagesRequest) XHotelid(xHotelid string) ReservationApiGetSellMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// This is the Central Reservation office code.
func (r ReservationApiGetSellMessagesRequest) CroCode(croCode string) ReservationApiGetSellMessagesRequest {
	r.croCode = &croCode
	return r
}

// This is the hotel code or resort.
func (r ReservationApiGetSellMessagesRequest) HotelId(hotelId string) ReservationApiGetSellMessagesRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetSellMessagesRequest) CriteriaId(criteriaId string) ReservationApiGetSellMessagesRequest {
	r.criteriaId = &criteriaId
	return r
}

// This is the language code.
func (r ReservationApiGetSellMessagesRequest) CriteriaIdType(criteriaIdType string) ReservationApiGetSellMessagesRequest {
	r.criteriaIdType = &criteriaIdType
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationApiGetSellMessagesRequest) Limit(limit int32) ReservationApiGetSellMessagesRequest {
	r.limit = &limit
	return r
}

// This represents the rate plan code of the room type.
func (r ReservationApiGetSellMessagesRequest) RatePlanCode(ratePlanCode string) ReservationApiGetSellMessagesRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// This represents the room type code.
func (r ReservationApiGetSellMessagesRequest) RoomType(roomType string) ReservationApiGetSellMessagesRequest {
	r.roomType = &roomType
	return r
}

// Flag which tells if this message is Sticky (Y/N).
func (r ReservationApiGetSellMessagesRequest) StickyFlagYn(stickyFlagYn string) ReservationApiGetSellMessagesRequest {
	r.stickyFlagYn = &stickyFlagYn
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetSellMessagesRequest) CriteriaType(criteriaType string) ReservationApiGetSellMessagesRequest {
	r.criteriaType = &criteriaType
	return r
}

func (r ReservationApiGetSellMessagesRequest) StartDate(startDate string) ReservationApiGetSellMessagesRequest {
	r.startDate = &startDate
	return r
}

func (r ReservationApiGetSellMessagesRequest) EndDate(endDate string) ReservationApiGetSellMessagesRequest {
	r.endDate = &endDate
	return r
}

func (r ReservationApiGetSellMessagesRequest) Duration(duration string) ReservationApiGetSellMessagesRequest {
	r.duration = &duration
	return r
}

// Instruction to fetch all Room Type sell messages configured.
func (r ReservationApiGetSellMessagesRequest) FetchInstructions(fetchInstructions []string) ReservationApiGetSellMessagesRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// This represents the moduleType of the SellMessages to be fetched.
func (r ReservationApiGetSellMessagesRequest) UsedInModule(usedInModule string) ReservationApiGetSellMessagesRequest {
	r.usedInModule = &usedInModule
	return r
}

// External system code.
func (r ReservationApiGetSellMessagesRequest) XExternalsystem(xExternalsystem string) ReservationApiGetSellMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetSellMessagesRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetSellMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetSellMessagesRequest) Execute() (*SellMessages, *http.Response, error) {
	return r.ApiService.GetSellMessagesExecute(r)
}

/*
GetSellMessages Get sell messages

Fetch the configured sell messages for a property. <p><strong>OperationId:</strong>getSellMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationApiGetSellMessagesRequest
*/
func (a *ReservationApiService) GetSellMessages(ctx context.Context) ReservationApiGetSellMessagesRequest {
	return ReservationApiGetSellMessagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SellMessages
func (a *ReservationApiService) GetSellMessagesExecute(r ReservationApiGetSellMessagesRequest) (*SellMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SellMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetSellMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sellMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.croCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "croCode", r.croCode, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.criteriaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaId", r.criteriaId, "")
	}
	if r.criteriaIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaIdType", r.criteriaIdType, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	if r.stickyFlagYn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stickyFlagYn", r.stickyFlagYn, "")
	}
	if r.criteriaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaType", r.criteriaType, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.usedInModule != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usedInModule", r.usedInModule, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetShareReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetShareReservationsRequest) Authorization(authorization string) ReservationApiGetShareReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetShareReservationsRequest) XAppKey(xAppKey string) ReservationApiGetShareReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetShareReservationsRequest) XHotelid(xHotelid string) ReservationApiGetShareReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiGetShareReservationsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetShareReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetShareReservationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetShareReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetShareReservationsRequest) Execute() (*ShareReservations, *http.Response, error) {
	return r.ApiService.GetShareReservationsExecute(r)
}

/*
GetShareReservations Get share Reservations

This API can be used to retrieve the share reservations that exist on a reservation. <p><strong>OperationId:</strong>getShareReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetShareReservationsRequest
*/
func (a *ReservationApiService) GetShareReservations(ctx context.Context, reservationId string, hotelId string) ReservationApiGetShareReservationsRequest {
	return ReservationApiGetShareReservationsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ShareReservations
func (a *ReservationApiService) GetShareReservationsExecute(r ReservationApiGetShareReservationsRequest) (*ShareReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShareReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetShareReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/shares"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetShareReservationsByExtIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetShareReservationsByExtIdRequest) Authorization(authorization string) ReservationApiGetShareReservationsByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetShareReservationsByExtIdRequest) XAppKey(xAppKey string) ReservationApiGetShareReservationsByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetShareReservationsByExtIdRequest) XHotelid(xHotelid string) ReservationApiGetShareReservationsByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiGetShareReservationsByExtIdRequest) XExternalsystem(xExternalsystem string) ReservationApiGetShareReservationsByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetShareReservationsByExtIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetShareReservationsByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetShareReservationsByExtIdRequest) Execute() (*ShareReservations, *http.Response, error) {
	return r.ApiService.GetShareReservationsByExtIdExecute(r)
}

/*
GetShareReservationsByExtId Get share Reservations

This API can be used to retrieve the share reservations that exist on a reservation. <p><strong>OperationId:</strong>getShareReservationsByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationExternalId External reservation ID.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel where reservation is searched based on external reservation ID.
 @return ReservationApiGetShareReservationsByExtIdRequest
*/
func (a *ReservationApiService) GetShareReservationsByExtId(ctx context.Context, reservationExternalId string, externalSystemCode string, hotelId string) ReservationApiGetShareReservationsByExtIdRequest {
	return ReservationApiGetShareReservationsByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationExternalId: reservationExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ShareReservations
func (a *ReservationApiService) GetShareReservationsByExtIdExecute(r ReservationApiGetShareReservationsByExtIdRequest) (*ShareReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShareReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetShareReservationsByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/reservations/{reservationExternalId}/shares"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationExternalId"+"}", url.PathEscape(parameterValueToString(r.reservationExternalId, "reservationExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationExternalId) < 1 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have at least 1 elements")
	}
	if strlen(r.reservationExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetTicketsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	packageCode *string
	retrieveIssuedOnly *bool
	retrieveNotIssuedOnly *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetTicketsRequest) Authorization(authorization string) ReservationApiGetTicketsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetTicketsRequest) XAppKey(xAppKey string) ReservationApiGetTicketsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetTicketsRequest) XHotelid(xHotelid string) ReservationApiGetTicketsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property where the tickets messages belongs to.
func (r ReservationApiGetTicketsRequest) PackageCode(packageCode string) ReservationApiGetTicketsRequest {
	r.packageCode = &packageCode
	return r
}

// Flag that specified if only issued tickets will be retrieved.
func (r ReservationApiGetTicketsRequest) RetrieveIssuedOnly(retrieveIssuedOnly bool) ReservationApiGetTicketsRequest {
	r.retrieveIssuedOnly = &retrieveIssuedOnly
	return r
}

// Flag that specified if only not issued tickets will be retrieved.
func (r ReservationApiGetTicketsRequest) RetrieveNotIssuedOnly(retrieveNotIssuedOnly bool) ReservationApiGetTicketsRequest {
	r.retrieveNotIssuedOnly = &retrieveNotIssuedOnly
	return r
}

// External system code.
func (r ReservationApiGetTicketsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetTicketsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetTicketsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetTicketsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetTicketsRequest) Execute() (*Tickets, *http.Response, error) {
	return r.ApiService.GetTicketsExecute(r)
}

/*
GetTickets Get tickets

Get tickets for a reservation. <p><strong>OperationId:</strong>getTickets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetTicketsRequest
*/
func (a *ReservationApiService) GetTickets(ctx context.Context, reservationId string, hotelId string) ReservationApiGetTicketsRequest {
	return ReservationApiGetTicketsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Tickets
func (a *ReservationApiService) GetTicketsExecute(r ReservationApiGetTicketsRequest) (*Tickets, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tickets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetTickets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/tickets"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.packageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", r.packageCode, "")
	}
	if r.retrieveIssuedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrieveIssuedOnly", r.retrieveIssuedOnly, "")
	}
	if r.retrieveNotIssuedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrieveNotIssuedOnly", r.retrieveNotIssuedOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetTicketsInquiryRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ticketId *string
	ticketIdType *string
	packageCode *[]string
	reservationProductId *string
	reservationProductIdType *string
	ticketNumberId *string
	ticketNumberIdType *string
	ticketIssueDate *[]string
	ticketConsumptionDate *[]string
	ticketRateCode *[]string
	ticketStatus *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetTicketsInquiryRequest) Authorization(authorization string) ReservationApiGetTicketsInquiryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetTicketsInquiryRequest) XAppKey(xAppKey string) ReservationApiGetTicketsInquiryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetTicketsInquiryRequest) XHotelid(xHotelid string) ReservationApiGetTicketsInquiryRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetTicketsInquiryRequest) TicketId(ticketId string) ReservationApiGetTicketsInquiryRequest {
	r.ticketId = &ticketId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetTicketsInquiryRequest) TicketIdType(ticketIdType string) ReservationApiGetTicketsInquiryRequest {
	r.ticketIdType = &ticketIdType
	return r
}

// Package Code.
func (r ReservationApiGetTicketsInquiryRequest) PackageCode(packageCode []string) ReservationApiGetTicketsInquiryRequest {
	r.packageCode = &packageCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetTicketsInquiryRequest) ReservationProductId(reservationProductId string) ReservationApiGetTicketsInquiryRequest {
	r.reservationProductId = &reservationProductId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetTicketsInquiryRequest) ReservationProductIdType(reservationProductIdType string) ReservationApiGetTicketsInquiryRequest {
	r.reservationProductIdType = &reservationProductIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ReservationApiGetTicketsInquiryRequest) TicketNumberId(ticketNumberId string) ReservationApiGetTicketsInquiryRequest {
	r.ticketNumberId = &ticketNumberId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ReservationApiGetTicketsInquiryRequest) TicketNumberIdType(ticketNumberIdType string) ReservationApiGetTicketsInquiryRequest {
	r.ticketNumberIdType = &ticketNumberIdType
	return r
}

// Tickets issue date.
func (r ReservationApiGetTicketsInquiryRequest) TicketIssueDate(ticketIssueDate []string) ReservationApiGetTicketsInquiryRequest {
	r.ticketIssueDate = &ticketIssueDate
	return r
}

// Tickets comsumption date.
func (r ReservationApiGetTicketsInquiryRequest) TicketConsumptionDate(ticketConsumptionDate []string) ReservationApiGetTicketsInquiryRequest {
	r.ticketConsumptionDate = &ticketConsumptionDate
	return r
}

// The Rate Code to which tickets belong to.
func (r ReservationApiGetTicketsInquiryRequest) TicketRateCode(ticketRateCode []string) ReservationApiGetTicketsInquiryRequest {
	r.ticketRateCode = &ticketRateCode
	return r
}

// The Status Code for outbound WS call.
func (r ReservationApiGetTicketsInquiryRequest) TicketStatus(ticketStatus []string) ReservationApiGetTicketsInquiryRequest {
	r.ticketStatus = &ticketStatus
	return r
}

// External system code.
func (r ReservationApiGetTicketsInquiryRequest) XExternalsystem(xExternalsystem string) ReservationApiGetTicketsInquiryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetTicketsInquiryRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetTicketsInquiryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetTicketsInquiryRequest) Execute() (*Tickets, *http.Response, error) {
	return r.ApiService.GetTicketsInquiryExecute(r)
}

/*
GetTicketsInquiry Inquiry for Reservation tickets

You can use this API to perform a Inquiry for Reservation tickets. <p><strong>OperationId:</strong>getTicketsInquiry</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetTicketsInquiryRequest
*/
func (a *ReservationApiService) GetTicketsInquiry(ctx context.Context, reservationId string, hotelId string) ReservationApiGetTicketsInquiryRequest {
	return ReservationApiGetTicketsInquiryRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Tickets
func (a *ReservationApiService) GetTicketsInquiryExecute(r ReservationApiGetTicketsInquiryRequest) (*Tickets, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tickets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetTicketsInquiry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/tickets/inquiry"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.ticketId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketId", r.ticketId, "")
	}
	if r.ticketIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketIdType", r.ticketIdType, "")
	}
	if r.packageCode != nil {
		t := *r.packageCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", t, "multi")
		}
	}
	if r.reservationProductId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProductId", r.reservationProductId, "")
	}
	if r.reservationProductIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProductIdType", r.reservationProductIdType, "")
	}
	if r.ticketNumberId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketNumberId", r.ticketNumberId, "")
	}
	if r.ticketNumberIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketNumberIdType", r.ticketNumberIdType, "")
	}
	if r.ticketIssueDate != nil {
		t := *r.ticketIssueDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ticketIssueDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ticketIssueDate", t, "multi")
		}
	}
	if r.ticketConsumptionDate != nil {
		t := *r.ticketConsumptionDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ticketConsumptionDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ticketConsumptionDate", t, "multi")
		}
	}
	if r.ticketRateCode != nil {
		t := *r.ticketRateCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ticketRateCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ticketRateCode", t, "multi")
		}
	}
	if r.ticketStatus != nil {
		t := *r.ticketStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ticketStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ticketStatus", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetTracesByReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetTracesByReservationRequest) Authorization(authorization string) ReservationApiGetTracesByReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetTracesByReservationRequest) XAppKey(xAppKey string) ReservationApiGetTracesByReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetTracesByReservationRequest) XHotelid(xHotelid string) ReservationApiGetTracesByReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiGetTracesByReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiGetTracesByReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetTracesByReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetTracesByReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetTracesByReservationRequest) Execute() (*Traces, *http.Response, error) {
	return r.ApiService.GetTracesByReservationExecute(r)
}

/*
GetTracesByReservation Get traces for a Reservation

You can use this API to get traces for a Reservation. <p><strong>OperationId:</strong>getTracesByReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetTracesByReservationRequest
*/
func (a *ReservationApiService) GetTracesByReservation(ctx context.Context, reservationId string, hotelId string) ReservationApiGetTracesByReservationRequest {
	return ReservationApiGetTracesByReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Traces
func (a *ReservationApiService) GetTracesByReservationExecute(r ReservationApiGetTracesByReservationRequest) (*Traces, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Traces
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetTracesByReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/traces"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetTracesByRoomRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	roomId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetTracesByRoomRequest) Authorization(authorization string) ReservationApiGetTracesByRoomRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetTracesByRoomRequest) XAppKey(xAppKey string) ReservationApiGetTracesByRoomRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetTracesByRoomRequest) XHotelid(xHotelid string) ReservationApiGetTracesByRoomRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationApiGetTracesByRoomRequest) XExternalsystem(xExternalsystem string) ReservationApiGetTracesByRoomRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetTracesByRoomRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetTracesByRoomRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetTracesByRoomRequest) Execute() (*Traces, *http.Response, error) {
	return r.ApiService.GetTracesByRoomExecute(r)
}

/*
GetTracesByRoom Get traces for a Room

This API will fetch the traces for a Room. <p><strong>OperationId:</strong>getTracesByRoom</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomId Room Id
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetTracesByRoomRequest
*/
func (a *ReservationApiService) GetTracesByRoom(ctx context.Context, roomId string, hotelId string) ReservationApiGetTracesByRoomRequest {
	return ReservationApiGetTracesByRoomRequest{
		ApiService: a,
		ctx: ctx,
		roomId: roomId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Traces
func (a *ReservationApiService) GetTracesByRoomExecute(r ReservationApiGetTracesByRoomRequest) (*Traces, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Traces
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetTracesByRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/{roomId}/traces"
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomId) < 1 {
		return localVarReturnValue, nil, reportError("roomId must have at least 1 elements")
	}
	if strlen(r.roomId) > 2000 {
		return localVarReturnValue, nil, reportError("roomId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetTransactionDiversionsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionDiversionCodes *[]string
	includeDailyDetails *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetTransactionDiversionsRequest) Authorization(authorization string) ReservationApiGetTransactionDiversionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetTransactionDiversionsRequest) XAppKey(xAppKey string) ReservationApiGetTransactionDiversionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetTransactionDiversionsRequest) XHotelid(xHotelid string) ReservationApiGetTransactionDiversionsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ReservationApiGetTransactionDiversionsRequest) TransactionDiversionCodes(transactionDiversionCodes []string) ReservationApiGetTransactionDiversionsRequest {
	r.transactionDiversionCodes = &transactionDiversionCodes
	return r
}

// Flag to check if the the daily details are required to be fetched for a particular transaciton.
func (r ReservationApiGetTransactionDiversionsRequest) IncludeDailyDetails(includeDailyDetails bool) ReservationApiGetTransactionDiversionsRequest {
	r.includeDailyDetails = &includeDailyDetails
	return r
}

// External system code.
func (r ReservationApiGetTransactionDiversionsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetTransactionDiversionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetTransactionDiversionsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetTransactionDiversionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetTransactionDiversionsRequest) Execute() (*TransactionDiversions, *http.Response, error) {
	return r.ApiService.GetTransactionDiversionsExecute(r)
}

/*
GetTransactionDiversions Get Transaction Diversions 

You can use this API to get Transaction Diversions. <p><strong>OperationId:</strong>getTransactionDiversions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetTransactionDiversionsRequest
*/
func (a *ReservationApiService) GetTransactionDiversions(ctx context.Context, reservationId string, hotelId string) ReservationApiGetTransactionDiversionsRequest {
	return ReservationApiGetTransactionDiversionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TransactionDiversions
func (a *ReservationApiService) GetTransactionDiversionsExecute(r ReservationApiGetTransactionDiversionsRequest) (*TransactionDiversions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionDiversions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetTransactionDiversions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/transactionDiversions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.transactionDiversionCodes != nil {
		t := *r.transactionDiversionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDiversionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDiversionCodes", t, "multi")
		}
	}
	if r.includeDailyDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDailyDetails", r.includeDailyDetails, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiGetUpgradeEligibilityReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arrivalEndDate *string
	arrivalStartDate *string
	membershipType *string
	externalReferenceType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiGetUpgradeEligibilityReservationsRequest) Authorization(authorization string) ReservationApiGetUpgradeEligibilityReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiGetUpgradeEligibilityReservationsRequest) XAppKey(xAppKey string) ReservationApiGetUpgradeEligibilityReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiGetUpgradeEligibilityReservationsRequest) XHotelid(xHotelid string) ReservationApiGetUpgradeEligibilityReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The ending value of the date range.
func (r ReservationApiGetUpgradeEligibilityReservationsRequest) ArrivalEndDate(arrivalEndDate string) ReservationApiGetUpgradeEligibilityReservationsRequest {
	r.arrivalEndDate = &arrivalEndDate
	return r
}

// The starting value of the date range.
func (r ReservationApiGetUpgradeEligibilityReservationsRequest) ArrivalStartDate(arrivalStartDate string) ReservationApiGetUpgradeEligibilityReservationsRequest {
	r.arrivalStartDate = &arrivalStartDate
	return r
}

// Membership Type.
func (r ReservationApiGetUpgradeEligibilityReservationsRequest) MembershipType(membershipType string) ReservationApiGetUpgradeEligibilityReservationsRequest {
	r.membershipType = &membershipType
	return r
}

// Type of the desired reservation external confirmation number.
func (r ReservationApiGetUpgradeEligibilityReservationsRequest) ExternalReferenceType(externalReferenceType string) ReservationApiGetUpgradeEligibilityReservationsRequest {
	r.externalReferenceType = &externalReferenceType
	return r
}

// External system code.
func (r ReservationApiGetUpgradeEligibilityReservationsRequest) XExternalsystem(xExternalsystem string) ReservationApiGetUpgradeEligibilityReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiGetUpgradeEligibilityReservationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiGetUpgradeEligibilityReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiGetUpgradeEligibilityReservationsRequest) Execute() (*UpgradeEligibilityReservations, *http.Response, error) {
	return r.ApiService.GetUpgradeEligibilityReservationsExecute(r)
}

/*
GetUpgradeEligibilityReservations Fetch Reservations Eligible for an Upgrade

You can use this API to fetch Reservations Eligible for an Upgrade. <p><strong>OperationId:</strong>getUpgradeEligibilityReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiGetUpgradeEligibilityReservationsRequest
*/
func (a *ReservationApiService) GetUpgradeEligibilityReservations(ctx context.Context, hotelId string) ReservationApiGetUpgradeEligibilityReservationsRequest {
	return ReservationApiGetUpgradeEligibilityReservationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return UpgradeEligibilityReservations
func (a *ReservationApiService) GetUpgradeEligibilityReservationsExecute(r ReservationApiGetUpgradeEligibilityReservationsRequest) (*UpgradeEligibilityReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpgradeEligibilityReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.GetUpgradeEligibilityReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/upgradeEligibleReservations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.arrivalEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEndDate", r.arrivalEndDate, "")
	}
	if r.arrivalStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStartDate", r.arrivalStartDate, "")
	}
	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
	}
	if r.externalReferenceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceType", r.externalReferenceType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiMergeReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationsToMerge *MergeReservationsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiMergeReservationsRequest) Authorization(authorization string) ReservationApiMergeReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiMergeReservationsRequest) XAppKey(xAppKey string) ReservationApiMergeReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiMergeReservationsRequest) XHotelid(xHotelid string) ReservationApiMergeReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request method to Merge reservations.
func (r ReservationApiMergeReservationsRequest) ReservationsToMerge(reservationsToMerge MergeReservationsRequest) ReservationApiMergeReservationsRequest {
	r.reservationsToMerge = &reservationsToMerge
	return r
}

// External system code.
func (r ReservationApiMergeReservationsRequest) XExternalsystem(xExternalsystem string) ReservationApiMergeReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiMergeReservationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiMergeReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiMergeReservationsRequest) Execute() (*MergeReservationsStatus, *http.Response, error) {
	return r.ApiService.MergeReservationsExecute(r)
}

/*
MergeReservations Merge multiple Reservations

Use this API to merge multiple reservations. <p><strong>OperationId:</strong>mergeReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiMergeReservationsRequest
*/
func (a *ReservationApiService) MergeReservations(ctx context.Context, reservationId string, hotelId string) ReservationApiMergeReservationsRequest {
	return ReservationApiMergeReservationsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return MergeReservationsStatus
func (a *ReservationApiService) MergeReservationsExecute(r ReservationApiMergeReservationsRequest) (*MergeReservationsStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MergeReservationsStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.MergeReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/mergeReservations"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationsToMerge
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostBreakReservationLockRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationLock *PutAcquireReservationLockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostBreakReservationLockRequest) Authorization(authorization string) ReservationApiPostBreakReservationLockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostBreakReservationLockRequest) XAppKey(xAppKey string) ReservationApiPostBreakReservationLockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostBreakReservationLockRequest) XHotelid(xHotelid string) ReservationApiPostBreakReservationLockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation for forcefully breaking a reservation lock This operation is subject to user permissions.
func (r ReservationApiPostBreakReservationLockRequest) ReservationLock(reservationLock PutAcquireReservationLockRequest) ReservationApiPostBreakReservationLockRequest {
	r.reservationLock = &reservationLock
	return r
}

// External system code.
func (r ReservationApiPostBreakReservationLockRequest) XExternalsystem(xExternalsystem string) ReservationApiPostBreakReservationLockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostBreakReservationLockRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostBreakReservationLockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostBreakReservationLockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBreakReservationLockExecute(r)
}

/*
PostBreakReservationLock Break Reservation lock

Break Reservation lock on a reservation. <p><strong>OperationId:</strong>postBreakReservationLock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostBreakReservationLockRequest
*/
func (a *ReservationApiService) PostBreakReservationLock(ctx context.Context, reservationId string, hotelId string) ReservationApiPostBreakReservationLockRequest {
	return ReservationApiPostBreakReservationLockRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostBreakReservationLockExecute(r ReservationApiPostBreakReservationLockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostBreakReservationLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/locks/break"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationLock
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostBulkReservationAlertsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationAlerts *PostBulkReservationAlertsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostBulkReservationAlertsRequest) Authorization(authorization string) ReservationApiPostBulkReservationAlertsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostBulkReservationAlertsRequest) XAppKey(xAppKey string) ReservationApiPostBulkReservationAlertsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostBulkReservationAlertsRequest) XHotelid(xHotelid string) ReservationApiPostBulkReservationAlertsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create or update multiple alerts information for multiple reservations in bulk.
func (r ReservationApiPostBulkReservationAlertsRequest) ReservationAlerts(reservationAlerts PostBulkReservationAlertsRequest) ReservationApiPostBulkReservationAlertsRequest {
	r.reservationAlerts = &reservationAlerts
	return r
}

// External system code.
func (r ReservationApiPostBulkReservationAlertsRequest) XExternalsystem(xExternalsystem string) ReservationApiPostBulkReservationAlertsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostBulkReservationAlertsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostBulkReservationAlertsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostBulkReservationAlertsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBulkReservationAlertsExecute(r)
}

/*
PostBulkReservationAlerts Create Bulk Reservation Alerts

Create or updates multiple alerts for multiple reservations in bulk. <p><strong>OperationId:</strong>postBulkReservationAlerts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostBulkReservationAlertsRequest
*/
func (a *ReservationApiService) PostBulkReservationAlerts(ctx context.Context, hotelId string) ReservationApiPostBulkReservationAlertsRequest {
	return ReservationApiPostBulkReservationAlertsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostBulkReservationAlertsExecute(r ReservationApiPostBulkReservationAlertsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostBulkReservationAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/alerts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationAlerts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostCallRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	registerCall *PostCallRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostCallRequest) Authorization(authorization string) ReservationApiPostCallRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostCallRequest) XAppKey(xAppKey string) ReservationApiPostCallRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostCallRequest) XHotelid(xHotelid string) ReservationApiPostCallRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to register call. Either creates a new call or updates an existing call.
func (r ReservationApiPostCallRequest) RegisterCall(registerCall PostCallRequest) ReservationApiPostCallRequest {
	r.registerCall = &registerCall
	return r
}

// External system code.
func (r ReservationApiPostCallRequest) XExternalsystem(xExternalsystem string) ReservationApiPostCallRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostCallRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostCallRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostCallRequest) Execute() (*RegisterCall, *http.Response, error) {
	return r.ApiService.PostCallExecute(r)
}

/*
PostCall Register calls

Use this API to request a new call or make updates to an existing call.<p><strong>OperationId:</strong>postCall</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationApiPostCallRequest
*/
func (a *ReservationApiService) PostCall(ctx context.Context) ReservationApiPostCallRequest {
	return ReservationApiPostCallRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegisterCall
func (a *ReservationApiService) PostCallExecute(r ReservationApiPostCallRequest) (*RegisterCall, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegisterCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.registerCall
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostCancelReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cancelReservation *PostCancelReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostCancelReservationRequest) Authorization(authorization string) ReservationApiPostCancelReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostCancelReservationRequest) XAppKey(xAppKey string) ReservationApiPostCancelReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostCancelReservationRequest) XHotelid(xHotelid string) ReservationApiPostCancelReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for canceling reservations.
func (r ReservationApiPostCancelReservationRequest) CancelReservation(cancelReservation PostCancelReservationRequest) ReservationApiPostCancelReservationRequest {
	r.cancelReservation = &cancelReservation
	return r
}

// External system code.
func (r ReservationApiPostCancelReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiPostCancelReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostCancelReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostCancelReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostCancelReservationRequest) Execute() (*CancelReservationDetails, *http.Response, error) {
	return r.ApiService.PostCancelReservationExecute(r)
}

/*
PostCancelReservation Cancel Reservation by ID

Use this if a guest would like to cancel their reservation.  You will receive a cancellation number in the response. <p><strong>OperationId:</strong>postCancelReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostCancelReservationRequest
*/
func (a *ReservationApiService) PostCancelReservation(ctx context.Context, reservationId string, hotelId string) ReservationApiPostCancelReservationRequest {
	return ReservationApiPostCancelReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CancelReservationDetails
func (a *ReservationApiService) PostCancelReservationExecute(r ReservationApiPostCancelReservationRequest) (*CancelReservationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelReservationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostCancelReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/cancellations"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cancelReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostCancelReservationByExtIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cancelReservation *PostCancelReservationByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostCancelReservationByExtIdRequest) Authorization(authorization string) ReservationApiPostCancelReservationByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostCancelReservationByExtIdRequest) XAppKey(xAppKey string) ReservationApiPostCancelReservationByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostCancelReservationByExtIdRequest) XHotelid(xHotelid string) ReservationApiPostCancelReservationByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for canceling reservations.
func (r ReservationApiPostCancelReservationByExtIdRequest) CancelReservation(cancelReservation PostCancelReservationByExtIdRequest) ReservationApiPostCancelReservationByExtIdRequest {
	r.cancelReservation = &cancelReservation
	return r
}

// External system code.
func (r ReservationApiPostCancelReservationByExtIdRequest) XExternalsystem(xExternalsystem string) ReservationApiPostCancelReservationByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostCancelReservationByExtIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostCancelReservationByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostCancelReservationByExtIdRequest) Execute() (*CancelReservationDetails, *http.Response, error) {
	return r.ApiService.PostCancelReservationByExtIdExecute(r)
}

/*
PostCancelReservationByExtId Cancel Reservation by ID

Use this if a guest would like to cancel their reservation.  You will receive a cancellation number in the response. <p><strong>OperationId:</strong>postCancelReservationByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationExternalId External reservation ID.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostCancelReservationByExtIdRequest
*/
func (a *ReservationApiService) PostCancelReservationByExtId(ctx context.Context, reservationExternalId string, externalSystemCode string, hotelId string) ReservationApiPostCancelReservationByExtIdRequest {
	return ReservationApiPostCancelReservationByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationExternalId: reservationExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CancelReservationDetails
func (a *ReservationApiService) PostCancelReservationByExtIdExecute(r ReservationApiPostCancelReservationByExtIdRequest) (*CancelReservationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelReservationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostCancelReservationByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/reservations/{reservationExternalId}/cancellations"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationExternalId"+"}", url.PathEscape(parameterValueToString(r.reservationExternalId, "reservationExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationExternalId) < 1 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have at least 1 elements")
	}
	if strlen(r.reservationExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cancelReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostCancelReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cancelReservations *PostCancelReservationsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostCancelReservationsRequest) Authorization(authorization string) ReservationApiPostCancelReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostCancelReservationsRequest) XAppKey(xAppKey string) ReservationApiPostCancelReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostCancelReservationsRequest) XHotelid(xHotelid string) ReservationApiPostCancelReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to submit batch cancel reservations.
func (r ReservationApiPostCancelReservationsRequest) CancelReservations(cancelReservations PostCancelReservationsRequest) ReservationApiPostCancelReservationsRequest {
	r.cancelReservations = &cancelReservations
	return r
}

// External system code.
func (r ReservationApiPostCancelReservationsRequest) XExternalsystem(xExternalsystem string) ReservationApiPostCancelReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostCancelReservationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostCancelReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostCancelReservationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCancelReservationsExecute(r)
}

/*
PostCancelReservations Cancel Reservations 

This API can be used to  cancel multiple reservations. <p><strong>OperationId:</strong>postCancelReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostCancelReservationsRequest
*/
func (a *ReservationApiService) PostCancelReservations(ctx context.Context, hotelId string) ReservationApiPostCancelReservationsRequest {
	return ReservationApiPostCancelReservationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostCancelReservationsExecute(r ReservationApiPostCancelReservationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostCancelReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/cancellations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cancelReservations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostCancelShareReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cancelReservation *PostCancelReservationByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostCancelShareReservationRequest) Authorization(authorization string) ReservationApiPostCancelShareReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostCancelShareReservationRequest) XAppKey(xAppKey string) ReservationApiPostCancelShareReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostCancelShareReservationRequest) XHotelid(xHotelid string) ReservationApiPostCancelShareReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for canceling reservations.
func (r ReservationApiPostCancelShareReservationRequest) CancelReservation(cancelReservation PostCancelReservationByExtIdRequest) ReservationApiPostCancelShareReservationRequest {
	r.cancelReservation = &cancelReservation
	return r
}

// External system code.
func (r ReservationApiPostCancelShareReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiPostCancelShareReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostCancelShareReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostCancelShareReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostCancelShareReservationRequest) Execute() (*CancelReservationDetails, *http.Response, error) {
	return r.ApiService.PostCancelShareReservationExecute(r)
}

/*
PostCancelShareReservation Cancel reservations

Use this API to cancel reservations including multiple share reservations with single request. You will receive cancellation numbers in the response. <p><strong>OperationId:</strong>postCancelShareReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostCancelShareReservationRequest
*/
func (a *ReservationApiService) PostCancelShareReservation(ctx context.Context, hotelId string) ReservationApiPostCancelShareReservationRequest {
	return ReservationApiPostCancelShareReservationRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CancelReservationDetails
func (a *ReservationApiService) PostCancelShareReservationExecute(r ReservationApiPostCancelShareReservationRequest) (*CancelReservationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelReservationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostCancelShareReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/reservationCancellations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cancelReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostCancellationPolicyRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationCancellationPolicyCriteria *PutCancellationPolicyRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostCancellationPolicyRequest) Authorization(authorization string) ReservationApiPostCancellationPolicyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostCancellationPolicyRequest) XAppKey(xAppKey string) ReservationApiPostCancellationPolicyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostCancellationPolicyRequest) XHotelid(xHotelid string) ReservationApiPostCancellationPolicyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object that holds the details of Cancellation Policy to be created.
func (r ReservationApiPostCancellationPolicyRequest) ReservationCancellationPolicyCriteria(reservationCancellationPolicyCriteria PutCancellationPolicyRequest) ReservationApiPostCancellationPolicyRequest {
	r.reservationCancellationPolicyCriteria = &reservationCancellationPolicyCriteria
	return r
}

// External system code.
func (r ReservationApiPostCancellationPolicyRequest) XExternalsystem(xExternalsystem string) ReservationApiPostCancellationPolicyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostCancellationPolicyRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostCancellationPolicyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostCancellationPolicyRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCancellationPolicyExecute(r)
}

/*
PostCancellationPolicy Create a Cancellation policy

Create a new cancellation policy for a property. <p><strong>OperationId:</strong>postCancellationPolicy</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostCancellationPolicyRequest
*/
func (a *ReservationApiService) PostCancellationPolicy(ctx context.Context, reservationId string, hotelId string) ReservationApiPostCancellationPolicyRequest {
	return ReservationApiPostCancellationPolicyRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostCancellationPolicyExecute(r ReservationApiPostCancellationPolicyRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostCancellationPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/cancellationPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationCancellationPolicyCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostCombineShareReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	combineShareReservations *PostCombineShareReservationsByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostCombineShareReservationsRequest) Authorization(authorization string) ReservationApiPostCombineShareReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostCombineShareReservationsRequest) XAppKey(xAppKey string) ReservationApiPostCombineShareReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostCombineShareReservationsRequest) XHotelid(xHotelid string) ReservationApiPostCombineShareReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to combine sharer reservations. This request requires a Reservation Name Id(Joining to) and a Joining Reservation Id
func (r ReservationApiPostCombineShareReservationsRequest) CombineShareReservations(combineShareReservations PostCombineShareReservationsByExtIdRequest) ReservationApiPostCombineShareReservationsRequest {
	r.combineShareReservations = &combineShareReservations
	return r
}

// External system code.
func (r ReservationApiPostCombineShareReservationsRequest) XExternalsystem(xExternalsystem string) ReservationApiPostCombineShareReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostCombineShareReservationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostCombineShareReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostCombineShareReservationsRequest) Execute() (*CombineShareReservationsDetails, *http.Response, error) {
	return r.ApiService.PostCombineShareReservationsExecute(r)
}

/*
PostCombineShareReservations Combine Share Reservations

Combine share reservation for a given reservation id <p><strong>OperationId:</strong>postCombineShareReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostCombineShareReservationsRequest
*/
func (a *ReservationApiService) PostCombineShareReservations(ctx context.Context, reservationId string, hotelId string) ReservationApiPostCombineShareReservationsRequest {
	return ReservationApiPostCombineShareReservationsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CombineShareReservationsDetails
func (a *ReservationApiService) PostCombineShareReservationsExecute(r ReservationApiPostCombineShareReservationsRequest) (*CombineShareReservationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CombineShareReservationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostCombineShareReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/shares"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.combineShareReservations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostCombineShareReservationsByExtIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	combineShareReservations *PostCombineShareReservationsByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostCombineShareReservationsByExtIdRequest) Authorization(authorization string) ReservationApiPostCombineShareReservationsByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostCombineShareReservationsByExtIdRequest) XAppKey(xAppKey string) ReservationApiPostCombineShareReservationsByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostCombineShareReservationsByExtIdRequest) XHotelid(xHotelid string) ReservationApiPostCombineShareReservationsByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to combine sharer reservations. This request requires a Reservation Name Id(Joining to) and a Joining Reservation Id
func (r ReservationApiPostCombineShareReservationsByExtIdRequest) CombineShareReservations(combineShareReservations PostCombineShareReservationsByExtIdRequest) ReservationApiPostCombineShareReservationsByExtIdRequest {
	r.combineShareReservations = &combineShareReservations
	return r
}

// External system code.
func (r ReservationApiPostCombineShareReservationsByExtIdRequest) XExternalsystem(xExternalsystem string) ReservationApiPostCombineShareReservationsByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostCombineShareReservationsByExtIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostCombineShareReservationsByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostCombineShareReservationsByExtIdRequest) Execute() (*CombineShareReservationsDetails, *http.Response, error) {
	return r.ApiService.PostCombineShareReservationsByExtIdExecute(r)
}

/*
PostCombineShareReservationsByExtId Combine Share Reservations

Combine share reservation for a given reservation id <p><strong>OperationId:</strong>postCombineShareReservationsByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationExternalId External reservation ID.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostCombineShareReservationsByExtIdRequest
*/
func (a *ReservationApiService) PostCombineShareReservationsByExtId(ctx context.Context, reservationExternalId string, externalSystemCode string, hotelId string) ReservationApiPostCombineShareReservationsByExtIdRequest {
	return ReservationApiPostCombineShareReservationsByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationExternalId: reservationExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CombineShareReservationsDetails
func (a *ReservationApiService) PostCombineShareReservationsByExtIdExecute(r ReservationApiPostCombineShareReservationsByExtIdRequest) (*CombineShareReservationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CombineShareReservationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostCombineShareReservationsByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/reservations/{reservationExternalId}/shares"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationExternalId"+"}", url.PathEscape(parameterValueToString(r.reservationExternalId, "reservationExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationExternalId) < 1 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have at least 1 elements")
	}
	if strlen(r.reservationExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.combineShareReservations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostConfirmationLettersRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	confirmationLetters *PostConfirmationLettersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostConfirmationLettersRequest) Authorization(authorization string) ReservationApiPostConfirmationLettersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostConfirmationLettersRequest) XAppKey(xAppKey string) ReservationApiPostConfirmationLettersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostConfirmationLettersRequest) XHotelid(xHotelid string) ReservationApiPostConfirmationLettersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create a confirmation letter.
func (r ReservationApiPostConfirmationLettersRequest) ConfirmationLetters(confirmationLetters PostConfirmationLettersRequest) ReservationApiPostConfirmationLettersRequest {
	r.confirmationLetters = &confirmationLetters
	return r
}

// External system code.
func (r ReservationApiPostConfirmationLettersRequest) XExternalsystem(xExternalsystem string) ReservationApiPostConfirmationLettersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostConfirmationLettersRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostConfirmationLettersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostConfirmationLettersRequest) Execute() (*ConfirmationLettersDetails, *http.Response, error) {
	return r.ApiService.PostConfirmationLettersExecute(r)
}

/*
PostConfirmationLetters Create the confirmation letters

Create a confirmation letter for a property. <p><strong>OperationId:</strong>postConfirmationLetters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostConfirmationLettersRequest
*/
func (a *ReservationApiService) PostConfirmationLetters(ctx context.Context, hotelId string) ReservationApiPostConfirmationLettersRequest {
	return ReservationApiPostConfirmationLettersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ConfirmationLettersDetails
func (a *ReservationApiService) PostConfirmationLettersExecute(r ReservationApiPostConfirmationLettersRequest) (*ConfirmationLettersDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfirmationLettersDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostConfirmationLetters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/confirmationLetters"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.confirmationLetters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostDepositPolicyRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationDepositPolicyCriteria *PutDepositPolicyRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostDepositPolicyRequest) Authorization(authorization string) ReservationApiPostDepositPolicyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostDepositPolicyRequest) XAppKey(xAppKey string) ReservationApiPostDepositPolicyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostDepositPolicyRequest) XHotelid(xHotelid string) ReservationApiPostDepositPolicyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object that holds the details of hotel level Deposit Policy to be created.
func (r ReservationApiPostDepositPolicyRequest) ReservationDepositPolicyCriteria(reservationDepositPolicyCriteria PutDepositPolicyRequest) ReservationApiPostDepositPolicyRequest {
	r.reservationDepositPolicyCriteria = &reservationDepositPolicyCriteria
	return r
}

// External system code.
func (r ReservationApiPostDepositPolicyRequest) XExternalsystem(xExternalsystem string) ReservationApiPostDepositPolicyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostDepositPolicyRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostDepositPolicyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostDepositPolicyRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostDepositPolicyExecute(r)
}

/*
PostDepositPolicy Create deposit policy

Create deposit policy for a property. This policy can then be used for reservations. <p><strong>OperationId:</strong>postDepositPolicy</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostDepositPolicyRequest
*/
func (a *ReservationApiService) PostDepositPolicy(ctx context.Context, reservationId string, hotelId string) ReservationApiPostDepositPolicyRequest {
	return ReservationApiPostDepositPolicyRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostDepositPolicyExecute(r ReservationApiPostDepositPolicyRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostDepositPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationDepositPolicyCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostECouponsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eCouponsInfo *PutECouponsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostECouponsRequest) Authorization(authorization string) ReservationApiPostECouponsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostECouponsRequest) XAppKey(xAppKey string) ReservationApiPostECouponsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostECouponsRequest) XHotelid(xHotelid string) ReservationApiPostECouponsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new eCoupons.
func (r ReservationApiPostECouponsRequest) ECouponsInfo(eCouponsInfo PutECouponsRequest) ReservationApiPostECouponsRequest {
	r.eCouponsInfo = &eCouponsInfo
	return r
}

// External system code.
func (r ReservationApiPostECouponsRequest) XExternalsystem(xExternalsystem string) ReservationApiPostECouponsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostECouponsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostECouponsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostECouponsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostECouponsExecute(r)
}

/*
PostECoupons Create Reservation ECoupon

Create the Reservation Ecoupons. <p><strong>OperationId:</strong>postECoupons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostECouponsRequest
*/
func (a *ReservationApiService) PostECoupons(ctx context.Context, reservationId string, hotelId string) ReservationApiPostECouponsRequest {
	return ReservationApiPostECouponsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostECouponsExecute(r ReservationApiPostECouponsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostECoupons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/eCoupons"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eCouponsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostGuestMessagesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createGuestMessages *PostGuestMessagesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostGuestMessagesRequest) Authorization(authorization string) ReservationApiPostGuestMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostGuestMessagesRequest) XAppKey(xAppKey string) ReservationApiPostGuestMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostGuestMessagesRequest) XHotelid(xHotelid string) ReservationApiPostGuestMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new guest message.
func (r ReservationApiPostGuestMessagesRequest) CreateGuestMessages(createGuestMessages PostGuestMessagesRequest) ReservationApiPostGuestMessagesRequest {
	r.createGuestMessages = &createGuestMessages
	return r
}

// External system code.
func (r ReservationApiPostGuestMessagesRequest) XExternalsystem(xExternalsystem string) ReservationApiPostGuestMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostGuestMessagesRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostGuestMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostGuestMessagesRequest) Execute() (*GuestMessagesDetails, *http.Response, error) {
	return r.ApiService.PostGuestMessagesExecute(r)
}

/*
PostGuestMessages Create guest messages

Create guest message for a guest reservation. <p><strong>OperationId:</strong>postGuestMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostGuestMessagesRequest
*/
func (a *ReservationApiService) PostGuestMessages(ctx context.Context, reservationId string, hotelId string) ReservationApiPostGuestMessagesRequest {
	return ReservationApiPostGuestMessagesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GuestMessagesDetails
func (a *ReservationApiService) PostGuestMessagesExecute(r ReservationApiPostGuestMessagesRequest) (*GuestMessagesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuestMessagesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostGuestMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/guestMessages"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createGuestMessages
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostIssueTicketsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ticketsInfo *PutTicketsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostIssueTicketsRequest) Authorization(authorization string) ReservationApiPostIssueTicketsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostIssueTicketsRequest) XAppKey(xAppKey string) ReservationApiPostIssueTicketsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostIssueTicketsRequest) XHotelid(xHotelid string) ReservationApiPostIssueTicketsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Common tickets request base type.
func (r ReservationApiPostIssueTicketsRequest) TicketsInfo(ticketsInfo PutTicketsRequest) ReservationApiPostIssueTicketsRequest {
	r.ticketsInfo = &ticketsInfo
	return r
}

// External system code.
func (r ReservationApiPostIssueTicketsRequest) XExternalsystem(xExternalsystem string) ReservationApiPostIssueTicketsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostIssueTicketsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostIssueTicketsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostIssueTicketsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostIssueTicketsExecute(r)
}

/*
PostIssueTickets Issue Reservation tickets

You can use this API to issue Reservation tickets. <p><strong>OperationId:</strong>postIssueTickets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostIssueTicketsRequest
*/
func (a *ReservationApiService) PostIssueTickets(ctx context.Context, reservationId string, hotelId string) ReservationApiPostIssueTicketsRequest {
	return ReservationApiPostIssueTicketsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostIssueTicketsExecute(r ReservationApiPostIssueTicketsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostIssueTickets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/tickets/issue"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ticketsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostMasterAccountRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	masterAccount *PutMasterAccountRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostMasterAccountRequest) Authorization(authorization string) ReservationApiPostMasterAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostMasterAccountRequest) XAppKey(xAppKey string) ReservationApiPostMasterAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostMasterAccountRequest) XHotelid(xHotelid string) ReservationApiPostMasterAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for CreateMasterAccount operation.
func (r ReservationApiPostMasterAccountRequest) MasterAccount(masterAccount PutMasterAccountRequest) ReservationApiPostMasterAccountRequest {
	r.masterAccount = &masterAccount
	return r
}

// External system code.
func (r ReservationApiPostMasterAccountRequest) XExternalsystem(xExternalsystem string) ReservationApiPostMasterAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostMasterAccountRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostMasterAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostMasterAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMasterAccountExecute(r)
}

/*
PostMasterAccount Create a Master Account

Create a master account for a reservation. <p><strong>OperationId:</strong>postMasterAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostMasterAccountRequest
*/
func (a *ReservationApiService) PostMasterAccount(ctx context.Context, reservationId string, hotelId string) ReservationApiPostMasterAccountRequest {
	return ReservationApiPostMasterAccountRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostMasterAccountExecute(r ReservationApiPostMasterAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostMasterAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/masterAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.masterAccount
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostPaymentMethodsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationPaymentMethods *PutPaymentMethodsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostPaymentMethodsRequest) Authorization(authorization string) ReservationApiPostPaymentMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostPaymentMethodsRequest) XAppKey(xAppKey string) ReservationApiPostPaymentMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostPaymentMethodsRequest) XHotelid(xHotelid string) ReservationApiPostPaymentMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create payment methods.
func (r ReservationApiPostPaymentMethodsRequest) ReservationPaymentMethods(reservationPaymentMethods PutPaymentMethodsRequest) ReservationApiPostPaymentMethodsRequest {
	r.reservationPaymentMethods = &reservationPaymentMethods
	return r
}

// External system code.
func (r ReservationApiPostPaymentMethodsRequest) XExternalsystem(xExternalsystem string) ReservationApiPostPaymentMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostPaymentMethodsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostPaymentMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostPaymentMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPaymentMethodsExecute(r)
}

/*
PostPaymentMethods Create a payment method 

Use this API to add a payment method to a reservation. <p><strong>OperationId:</strong>postPaymentMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostPaymentMethodsRequest
*/
func (a *ReservationApiService) PostPaymentMethods(ctx context.Context, reservationId string, hotelId string) ReservationApiPostPaymentMethodsRequest {
	return ReservationApiPostPaymentMethodsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostPaymentMethodsExecute(r ReservationApiPostPaymentMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/paymentMethods"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationPaymentMethods
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostPreCheckInReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	preCheckInReservation *PostPreCheckInReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostPreCheckInReservationRequest) Authorization(authorization string) ReservationApiPostPreCheckInReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostPreCheckInReservationRequest) XAppKey(xAppKey string) ReservationApiPostPreCheckInReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostPreCheckInReservationRequest) XHotelid(xHotelid string) ReservationApiPostPreCheckInReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to pre-register a reservation eligible for pre-registration and change arrival details.
func (r ReservationApiPostPreCheckInReservationRequest) PreCheckInReservation(preCheckInReservation PostPreCheckInReservationRequest) ReservationApiPostPreCheckInReservationRequest {
	r.preCheckInReservation = &preCheckInReservation
	return r
}

// External system code.
func (r ReservationApiPostPreCheckInReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiPostPreCheckInReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostPreCheckInReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostPreCheckInReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostPreCheckInReservationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPreCheckInReservationExecute(r)
}

/*
PostPreCheckInReservation Pre-Checkin a Reservation

This will allow you to set a reservation as a pre-registered guest.  The API request requires the guests confirmation number and you can optionally include arrival time.  The behavior of the API will be dependent upon the Pre-registration rules configured for the hotel in OPERA Cloud administration. <p><strong>OperationId:</strong>postPreCheckInReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostPreCheckInReservationRequest
*/
func (a *ReservationApiService) PostPreCheckInReservation(ctx context.Context, reservationId string, hotelId string) ReservationApiPostPreCheckInReservationRequest {
	return ReservationApiPostPreCheckInReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostPreCheckInReservationExecute(r ReservationApiPostPreCheckInReservationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostPreCheckInReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/preCheckIn"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.preCheckInReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createReservation *PostReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReservationRequest) Authorization(authorization string) ReservationApiPostReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReservationRequest) XAppKey(xAppKey string) ReservationApiPostReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReservationRequest) XHotelid(xHotelid string) ReservationApiPostReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create reservations. Includes instructions for information which needs to be returned.
func (r ReservationApiPostReservationRequest) CreateReservation(createReservation PostReservationRequest) ReservationApiPostReservationRequest {
	r.createReservation = &createReservation
	return r
}

// External system code.
func (r ReservationApiPostReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReservationRequest) Execute() (*CreateReservationType, *http.Response, error) {
	return r.ApiService.PostReservationExecute(r)
}

/*
PostReservation Create Reservation

Use this to create a new reservation for a hA12:F24otel.  Generally, you would search for a hotel's availability and rates before proceeding to use postReservation.  There are many fields in postReservation defined by ListOfValues; ensure you have reviewed ListOfValues APIs in order successfully to use postReservation. <p><strong>OperationId:</strong>postReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostReservationRequest
*/
func (a *ReservationApiService) PostReservation(ctx context.Context, hotelId string) ReservationApiPostReservationRequest {
	return ReservationApiPostReservationRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CreateReservationType
func (a *ReservationApiService) PostReservationExecute(r ReservationApiPostReservationRequest) (*CreateReservationType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateReservationType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReservationByBlockRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createReservation *PostReservationByBlockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReservationByBlockRequest) Authorization(authorization string) ReservationApiPostReservationByBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReservationByBlockRequest) XAppKey(xAppKey string) ReservationApiPostReservationByBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReservationByBlockRequest) XHotelid(xHotelid string) ReservationApiPostReservationByBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create reservations. Includes instructions for information which needs to be returned.
func (r ReservationApiPostReservationByBlockRequest) CreateReservation(createReservation PostReservationByBlockRequest) ReservationApiPostReservationByBlockRequest {
	r.createReservation = &createReservation
	return r
}

// External system code.
func (r ReservationApiPostReservationByBlockRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReservationByBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReservationByBlockRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReservationByBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReservationByBlockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationByBlockExecute(r)
}

/*
PostReservationByBlock Create Reservation for a Block

Use this to create a new reservation for a block, you must know the block Code to create this reservation.  In order to post a successful block reservation, please ensure you use the ListOfValues API's to know the hotel's codes; such as Address Type, Country Code,  Titles, preferenceCodes etc. <p><strong>OperationId:</strong>postReservationByBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Unique OPERA internal ID for the block.
 @param hotelId Unique ID of the hotel where reservation is created.
 @return ReservationApiPostReservationByBlockRequest
*/
func (a *ReservationApiService) PostReservationByBlock(ctx context.Context, blockId string, hotelId string) ReservationApiPostReservationByBlockRequest {
	return ReservationApiPostReservationByBlockRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationByBlockExecute(r ReservationApiPostReservationByBlockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationByBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReservationCertificateRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	attachCertificate *PostReservationCertificateRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReservationCertificateRequest) Authorization(authorization string) ReservationApiPostReservationCertificateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReservationCertificateRequest) XAppKey(xAppKey string) ReservationApiPostReservationCertificateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReservationCertificateRequest) XHotelid(xHotelid string) ReservationApiPostReservationCertificateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to attach certificate to the Reservation.
func (r ReservationApiPostReservationCertificateRequest) AttachCertificate(attachCertificate PostReservationCertificateRequest) ReservationApiPostReservationCertificateRequest {
	r.attachCertificate = &attachCertificate
	return r
}

// External system code.
func (r ReservationApiPostReservationCertificateRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReservationCertificateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReservationCertificateRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReservationCertificateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReservationCertificateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationCertificateExecute(r)
}

/*
PostReservationCertificate Attach Certificate

Attach a certificate to Reservation. <p><strong>OperationId:</strong>postReservationCertificate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostReservationCertificateRequest
*/
func (a *ReservationApiService) PostReservationCertificate(ctx context.Context, reservationId string, hotelId string) ReservationApiPostReservationCertificateRequest {
	return ReservationApiPostReservationCertificateRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationCertificateExecute(r ReservationApiPostReservationCertificateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/certificates"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.attachCertificate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReservationCopyRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyReservation *PostReservationCopyRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReservationCopyRequest) Authorization(authorization string) ReservationApiPostReservationCopyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReservationCopyRequest) XAppKey(xAppKey string) ReservationApiPostReservationCopyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReservationCopyRequest) XHotelid(xHotelid string) ReservationApiPostReservationCopyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for copying a reservation&#39;s information as a template for a new reservation.
func (r ReservationApiPostReservationCopyRequest) CopyReservation(copyReservation PostReservationCopyRequest) ReservationApiPostReservationCopyRequest {
	r.copyReservation = &copyReservation
	return r
}

// External system code.
func (r ReservationApiPostReservationCopyRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReservationCopyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReservationCopyRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReservationCopyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReservationCopyRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationCopyExecute(r)
}

/*
PostReservationCopy Copy a Reservation

Copy a Reservation. <p><strong>OperationId:</strong>postReservationCopy</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostReservationCopyRequest
*/
func (a *ReservationApiService) PostReservationCopy(ctx context.Context, reservationId string, hotelId string) ReservationApiPostReservationCopyRequest {
	return ReservationApiPostReservationCopyRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationCopyExecute(r ReservationApiPostReservationCopyRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationCopy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReservationLinksRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	linkReservationsCriteria *PostReservationLinksRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReservationLinksRequest) Authorization(authorization string) ReservationApiPostReservationLinksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReservationLinksRequest) XAppKey(xAppKey string) ReservationApiPostReservationLinksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReservationLinksRequest) XHotelid(xHotelid string) ReservationApiPostReservationLinksRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to link a list of reservations with another existing reservation.
func (r ReservationApiPostReservationLinksRequest) LinkReservationsCriteria(linkReservationsCriteria PostReservationLinksRequest) ReservationApiPostReservationLinksRequest {
	r.linkReservationsCriteria = &linkReservationsCriteria
	return r
}

// External system code.
func (r ReservationApiPostReservationLinksRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReservationLinksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReservationLinksRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReservationLinksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReservationLinksRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationLinksExecute(r)
}

/*
PostReservationLinks Link Reservations

This will allow you to link 1 or more reservations to an existing reservation.  <p><strong>OperationId:</strong>postReservationLinks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostReservationLinksRequest
*/
func (a *ReservationApiService) PostReservationLinks(ctx context.Context, reservationId string, hotelId string) ReservationApiPostReservationLinksRequest {
	return ReservationApiPostReservationLinksRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationLinksExecute(r ReservationApiPostReservationLinksRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/linkedReservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.linkReservationsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReservationLinksByChainRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	authorization *string
	xAppKey *string
	xHotelid *string
	linkReservationsCriteria *PostReservationLinksByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReservationLinksByChainRequest) Authorization(authorization string) ReservationApiPostReservationLinksByChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReservationLinksByChainRequest) XAppKey(xAppKey string) ReservationApiPostReservationLinksByChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReservationLinksByChainRequest) XHotelid(xHotelid string) ReservationApiPostReservationLinksByChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to link a list of reservations with another existing reservation.
func (r ReservationApiPostReservationLinksByChainRequest) LinkReservationsCriteria(linkReservationsCriteria PostReservationLinksByExtIdRequest) ReservationApiPostReservationLinksByChainRequest {
	r.linkReservationsCriteria = &linkReservationsCriteria
	return r
}

// External system code.
func (r ReservationApiPostReservationLinksByChainRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReservationLinksByChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReservationLinksByChainRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReservationLinksByChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReservationLinksByChainRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationLinksByChainExecute(r)
}

/*
PostReservationLinksByChain Link Reservations By Chain

This will allow you to link 1 or more reservations to an existing reservation.  <p><strong>OperationId:</strong>postReservationLinksByChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @return ReservationApiPostReservationLinksByChainRequest
*/
func (a *ReservationApiService) PostReservationLinksByChain(ctx context.Context, reservationId string) ReservationApiPostReservationLinksByChainRequest {
	return ReservationApiPostReservationLinksByChainRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationLinksByChainExecute(r ReservationApiPostReservationLinksByChainRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationLinksByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservations/linkedReservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.linkReservationsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReservationLinksByExtIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	linkReservationsCriteria *PostReservationLinksByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReservationLinksByExtIdRequest) Authorization(authorization string) ReservationApiPostReservationLinksByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReservationLinksByExtIdRequest) XAppKey(xAppKey string) ReservationApiPostReservationLinksByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReservationLinksByExtIdRequest) XHotelid(xHotelid string) ReservationApiPostReservationLinksByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to link a list of reservations with another existing reservation.
func (r ReservationApiPostReservationLinksByExtIdRequest) LinkReservationsCriteria(linkReservationsCriteria PostReservationLinksByExtIdRequest) ReservationApiPostReservationLinksByExtIdRequest {
	r.linkReservationsCriteria = &linkReservationsCriteria
	return r
}

// External system code.
func (r ReservationApiPostReservationLinksByExtIdRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReservationLinksByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReservationLinksByExtIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReservationLinksByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReservationLinksByExtIdRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationLinksByExtIdExecute(r)
}

/*
PostReservationLinksByExtId Link Reservations

This will allow you to link 1 or more reservations to an existing reservation.  <p><strong>OperationId:</strong>postReservationLinksByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationExternalId External reservation ID.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostReservationLinksByExtIdRequest
*/
func (a *ReservationApiService) PostReservationLinksByExtId(ctx context.Context, reservationExternalId string, externalSystemCode string, hotelId string) ReservationApiPostReservationLinksByExtIdRequest {
	return ReservationApiPostReservationLinksByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationExternalId: reservationExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationLinksByExtIdExecute(r ReservationApiPostReservationLinksByExtIdRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationLinksByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/reservations/linkedReservations/{reservationExternalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationExternalId"+"}", url.PathEscape(parameterValueToString(r.reservationExternalId, "reservationExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationExternalId) < 1 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have at least 1 elements")
	}
	if strlen(r.reservationExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.linkReservationsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReservationLocatorsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationLocatorsDetailsInfo *PostReservationLocatorsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReservationLocatorsRequest) Authorization(authorization string) ReservationApiPostReservationLocatorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReservationLocatorsRequest) XAppKey(xAppKey string) ReservationApiPostReservationLocatorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReservationLocatorsRequest) XHotelid(xHotelid string) ReservationApiPostReservationLocatorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Notes for the hotels
func (r ReservationApiPostReservationLocatorsRequest) ReservationLocatorsDetailsInfo(reservationLocatorsDetailsInfo PostReservationLocatorsRequest) ReservationApiPostReservationLocatorsRequest {
	r.reservationLocatorsDetailsInfo = &reservationLocatorsDetailsInfo
	return r
}

// External system code.
func (r ReservationApiPostReservationLocatorsRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReservationLocatorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReservationLocatorsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReservationLocatorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReservationLocatorsRequest) Execute() (*ReservationLocatorsDetails, *http.Response, error) {
	return r.ApiService.PostReservationLocatorsExecute(r)
}

/*
PostReservationLocators Create Reservation Guest Locator

Create Guest Locater for a list of Reservations. <p><strong>OperationId:</strong>postReservationLocators</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostReservationLocatorsRequest
*/
func (a *ReservationApiService) PostReservationLocators(ctx context.Context, reservationId string, hotelId string) ReservationApiPostReservationLocatorsRequest {
	return ReservationApiPostReservationLocatorsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationLocatorsDetails
func (a *ReservationApiService) PostReservationLocatorsExecute(r ReservationApiPostReservationLocatorsRequest) (*ReservationLocatorsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationLocatorsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationLocators")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/guestLocators"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationLocatorsDetailsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReservationMembershipRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationMembership *PostReservationMembershipRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReservationMembershipRequest) Authorization(authorization string) ReservationApiPostReservationMembershipRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReservationMembershipRequest) XAppKey(xAppKey string) ReservationApiPostReservationMembershipRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReservationMembershipRequest) XHotelid(xHotelid string) ReservationApiPostReservationMembershipRequest {
	r.xHotelid = &xHotelid
	return r
}

// Method to create a reservation membership on an existing reservation.
func (r ReservationApiPostReservationMembershipRequest) ReservationMembership(reservationMembership PostReservationMembershipRequest) ReservationApiPostReservationMembershipRequest {
	r.reservationMembership = &reservationMembership
	return r
}

// External system code.
func (r ReservationApiPostReservationMembershipRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReservationMembershipRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReservationMembershipRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReservationMembershipRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReservationMembershipRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationMembershipExecute(r)
}

/*
PostReservationMembership Create a Reservation membership

Add a membership to an existing reservation. <p><strong>OperationId:</strong>postReservationMembership</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostReservationMembershipRequest
*/
func (a *ReservationApiService) PostReservationMembership(ctx context.Context, reservationId string, hotelId string) ReservationApiPostReservationMembershipRequest {
	return ReservationApiPostReservationMembershipRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationMembershipExecute(r ReservationApiPostReservationMembershipRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationMembership")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/memberships"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationMembership
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReservationPackageRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationPackagesInfo *PutReservationPackageRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReservationPackageRequest) Authorization(authorization string) ReservationApiPostReservationPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReservationPackageRequest) XAppKey(xAppKey string) ReservationApiPostReservationPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReservationPackageRequest) XHotelid(xHotelid string) ReservationApiPostReservationPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request method to attach a package to an existing reservation.
func (r ReservationApiPostReservationPackageRequest) ReservationPackagesInfo(reservationPackagesInfo PutReservationPackageRequest) ReservationApiPostReservationPackageRequest {
	r.reservationPackagesInfo = &reservationPackagesInfo
	return r
}

// External system code.
func (r ReservationApiPostReservationPackageRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReservationPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReservationPackageRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReservationPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReservationPackageRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationPackageExecute(r)
}

/*
PostReservationPackage Add a package to a Reservation

This API will allow you to add packages to a reservation. <p><strong>OperationId:</strong>postReservationPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostReservationPackageRequest
*/
func (a *ReservationApiService) PostReservationPackage(ctx context.Context, reservationId string, hotelId string) ReservationApiPostReservationPackageRequest {
	return ReservationApiPostReservationPackageRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationPackageExecute(r ReservationApiPostReservationPackageRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/packages"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationPackagesInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReservationPreferenceRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationPreferenceInfo *PostReservationPreferenceRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReservationPreferenceRequest) Authorization(authorization string) ReservationApiPostReservationPreferenceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReservationPreferenceRequest) XAppKey(xAppKey string) ReservationApiPostReservationPreferenceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReservationPreferenceRequest) XHotelid(xHotelid string) ReservationApiPostReservationPreferenceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Method to create a reservation preference on an existing reservation.
func (r ReservationApiPostReservationPreferenceRequest) ReservationPreferenceInfo(reservationPreferenceInfo PostReservationPreferenceRequest) ReservationApiPostReservationPreferenceRequest {
	r.reservationPreferenceInfo = &reservationPreferenceInfo
	return r
}

// External system code.
func (r ReservationApiPostReservationPreferenceRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReservationPreferenceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReservationPreferenceRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReservationPreferenceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReservationPreferenceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationPreferenceExecute(r)
}

/*
PostReservationPreference Add a preference to a Reservation

This API will add a preference to a Reservation.  <p><strong>OperationId:</strong>postReservationPreference</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostReservationPreferenceRequest
*/
func (a *ReservationApiService) PostReservationPreference(ctx context.Context, reservationId string, hotelId string) ReservationApiPostReservationPreferenceRequest {
	return ReservationApiPostReservationPreferenceRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReservationPreferenceExecute(r ReservationApiPostReservationPreferenceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReservationPreference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationPreferenceInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReserveInventoryItemsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reserveInventoryItems *PostReserveInventoryItemsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReserveInventoryItemsRequest) Authorization(authorization string) ReservationApiPostReserveInventoryItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReserveInventoryItemsRequest) XAppKey(xAppKey string) ReservationApiPostReserveInventoryItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReserveInventoryItemsRequest) XHotelid(xHotelid string) ReservationApiPostReserveInventoryItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to reserve inventory Items for a reservation.
func (r ReservationApiPostReserveInventoryItemsRequest) ReserveInventoryItems(reserveInventoryItems PostReserveInventoryItemsRequest) ReservationApiPostReserveInventoryItemsRequest {
	r.reserveInventoryItems = &reserveInventoryItems
	return r
}

// External system code.
func (r ReservationApiPostReserveInventoryItemsRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReserveInventoryItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReserveInventoryItemsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReserveInventoryItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReserveInventoryItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReserveInventoryItemsExecute(r)
}

/*
PostReserveInventoryItems Reserve Reservation inventory items

Reserve Reservation inventory items. <p><strong>OperationId:</strong>postReserveInventoryItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostReserveInventoryItemsRequest
*/
func (a *ReservationApiService) PostReserveInventoryItems(ctx context.Context, reservationId string, hotelId string) ReservationApiPostReserveInventoryItemsRequest {
	return ReservationApiPostReserveInventoryItemsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReserveInventoryItemsExecute(r ReservationApiPostReserveInventoryItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReserveInventoryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/inventoryItems"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reserveInventoryItems
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostReverseDepositPolicyRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	policyId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reverseDepositPolicy *PostReverseDepositPolicyRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostReverseDepositPolicyRequest) Authorization(authorization string) ReservationApiPostReverseDepositPolicyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostReverseDepositPolicyRequest) XAppKey(xAppKey string) ReservationApiPostReverseDepositPolicyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostReverseDepositPolicyRequest) XHotelid(xHotelid string) ReservationApiPostReverseDepositPolicyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type to reverse deposit policy of a reservation.(This is applicable only when advance deposit handling is set to &#39;17&#39;) ReverseDepositPolicy operation will reverse the policy by creating a new request with same opposite amount.
func (r ReservationApiPostReverseDepositPolicyRequest) ReverseDepositPolicy(reverseDepositPolicy PostReverseDepositPolicyRequest) ReservationApiPostReverseDepositPolicyRequest {
	r.reverseDepositPolicy = &reverseDepositPolicy
	return r
}

// External system code.
func (r ReservationApiPostReverseDepositPolicyRequest) XExternalsystem(xExternalsystem string) ReservationApiPostReverseDepositPolicyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostReverseDepositPolicyRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostReverseDepositPolicyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostReverseDepositPolicyRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReverseDepositPolicyExecute(r)
}

/*
PostReverseDepositPolicy Reverse a deposit policy

You can use this API to reverse a deposit policy on a specified reservation. <p><strong>OperationId:</strong>postReverseDepositPolicy</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyId Policy ID
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostReverseDepositPolicyRequest
*/
func (a *ReservationApiService) PostReverseDepositPolicy(ctx context.Context, policyId string, reservationId string, hotelId string) ReservationApiPostReverseDepositPolicyRequest {
	return ReservationApiPostReverseDepositPolicyRequest{
		ApiService: a,
		ctx: ctx,
		policyId: policyId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostReverseDepositPolicyExecute(r ReservationApiPostReverseDepositPolicyRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostReverseDepositPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/reverseDepositPolicy/{policyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", url.PathEscape(parameterValueToString(r.policyId, "policyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.policyId) < 1 {
		return localVarReturnValue, nil, reportError("policyId must have at least 1 elements")
	}
	if strlen(r.policyId) > 2000 {
		return localVarReturnValue, nil, reportError("policyId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reverseDepositPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationRoutingCriteria *PostRoutingInstructionsByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostRoutingInstructionsRequest) Authorization(authorization string) ReservationApiPostRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostRoutingInstructionsRequest) XAppKey(xAppKey string) ReservationApiPostRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostRoutingInstructionsRequest) XHotelid(xHotelid string) ReservationApiPostRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a routing instruction.
func (r ReservationApiPostRoutingInstructionsRequest) ReservationRoutingCriteria(reservationRoutingCriteria PostRoutingInstructionsByExtIdRequest) ReservationApiPostRoutingInstructionsRequest {
	r.reservationRoutingCriteria = &reservationRoutingCriteria
	return r
}

// External system code.
func (r ReservationApiPostRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ReservationApiPostRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostRoutingInstructionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoutingInstructionsExecute(r)
}

/*
PostRoutingInstructions Create routing instructions for a reservation

You can use this API to create routing instructions on a reservation. It requires a reservation ID, which can be fetched using getReservations. <p><strong>OperationId:</strong>postRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostRoutingInstructionsRequest
*/
func (a *ReservationApiService) PostRoutingInstructions(ctx context.Context, reservationId string, hotelId string) ReservationApiPostRoutingInstructionsRequest {
	return ReservationApiPostRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostRoutingInstructionsExecute(r ReservationApiPostRoutingInstructionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationRoutingCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostRoutingInstructionsByExtIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationRoutingCriteria *PostRoutingInstructionsByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostRoutingInstructionsByExtIdRequest) Authorization(authorization string) ReservationApiPostRoutingInstructionsByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostRoutingInstructionsByExtIdRequest) XAppKey(xAppKey string) ReservationApiPostRoutingInstructionsByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostRoutingInstructionsByExtIdRequest) XHotelid(xHotelid string) ReservationApiPostRoutingInstructionsByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a routing instruction.
func (r ReservationApiPostRoutingInstructionsByExtIdRequest) ReservationRoutingCriteria(reservationRoutingCriteria PostRoutingInstructionsByExtIdRequest) ReservationApiPostRoutingInstructionsByExtIdRequest {
	r.reservationRoutingCriteria = &reservationRoutingCriteria
	return r
}

// External system code.
func (r ReservationApiPostRoutingInstructionsByExtIdRequest) XExternalsystem(xExternalsystem string) ReservationApiPostRoutingInstructionsByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostRoutingInstructionsByExtIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostRoutingInstructionsByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostRoutingInstructionsByExtIdRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoutingInstructionsByExtIdExecute(r)
}

/*
PostRoutingInstructionsByExtId Create routing instructions

You can use this API to create routing instructions on a reservation. <p><strong>OperationId:</strong>postRoutingInstructionsByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationExternalId External reservation ID.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostRoutingInstructionsByExtIdRequest
*/
func (a *ReservationApiService) PostRoutingInstructionsByExtId(ctx context.Context, reservationExternalId string, externalSystemCode string, hotelId string) ReservationApiPostRoutingInstructionsByExtIdRequest {
	return ReservationApiPostRoutingInstructionsByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationExternalId: reservationExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostRoutingInstructionsByExtIdExecute(r ReservationApiPostRoutingInstructionsByExtIdRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostRoutingInstructionsByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/reservations/{reservationExternalId}/routingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationExternalId"+"}", url.PathEscape(parameterValueToString(r.reservationExternalId, "reservationExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationExternalId) < 1 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have at least 1 elements")
	}
	if strlen(r.reservationExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationRoutingCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostSellMessageConfigRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	sellMessageConfig *PutSellMessageConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostSellMessageConfigRequest) Authorization(authorization string) ReservationApiPostSellMessageConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostSellMessageConfigRequest) XAppKey(xAppKey string) ReservationApiPostSellMessageConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostSellMessageConfigRequest) XHotelid(xHotelid string) ReservationApiPostSellMessageConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// This is the request message type for creating sell messages.
func (r ReservationApiPostSellMessageConfigRequest) SellMessageConfig(sellMessageConfig PutSellMessageConfigRequest) ReservationApiPostSellMessageConfigRequest {
	r.sellMessageConfig = &sellMessageConfig
	return r
}

// External system code.
func (r ReservationApiPostSellMessageConfigRequest) XExternalsystem(xExternalsystem string) ReservationApiPostSellMessageConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostSellMessageConfigRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostSellMessageConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostSellMessageConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostSellMessageConfigExecute(r)
}

/*
PostSellMessageConfig Create sell message

Create sell message configuration for a property. <p><strong>OperationId:</strong>postSellMessageConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostSellMessageConfigRequest
*/
func (a *ReservationApiService) PostSellMessageConfig(ctx context.Context, hotelId string) ReservationApiPostSellMessageConfigRequest {
	return ReservationApiPostSellMessageConfigRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostSellMessageConfigExecute(r ReservationApiPostSellMessageConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostSellMessageConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sellMessages/config"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.sellMessageConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostSellMessageConfigByChainRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	sellMessageConfig *PutSellMessageConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostSellMessageConfigByChainRequest) Authorization(authorization string) ReservationApiPostSellMessageConfigByChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostSellMessageConfigByChainRequest) XAppKey(xAppKey string) ReservationApiPostSellMessageConfigByChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostSellMessageConfigByChainRequest) XHotelid(xHotelid string) ReservationApiPostSellMessageConfigByChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// This is the request message type for creating sell messages.
func (r ReservationApiPostSellMessageConfigByChainRequest) SellMessageConfig(sellMessageConfig PutSellMessageConfigRequest) ReservationApiPostSellMessageConfigByChainRequest {
	r.sellMessageConfig = &sellMessageConfig
	return r
}

// External system code.
func (r ReservationApiPostSellMessageConfigByChainRequest) XExternalsystem(xExternalsystem string) ReservationApiPostSellMessageConfigByChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostSellMessageConfigByChainRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostSellMessageConfigByChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostSellMessageConfigByChainRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostSellMessageConfigByChainExecute(r)
}

/*
PostSellMessageConfigByChain Create sell message by chain

Create sell message configuration. <p><strong>OperationId:</strong>postSellMessageConfigByChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationApiPostSellMessageConfigByChainRequest
*/
func (a *ReservationApiService) PostSellMessageConfigByChain(ctx context.Context) ReservationApiPostSellMessageConfigByChainRequest {
	return ReservationApiPostSellMessageConfigByChainRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostSellMessageConfigByChainExecute(r ReservationApiPostSellMessageConfigByChainRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostSellMessageConfigByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sellMessages/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.sellMessageConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostTicketsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ticketsInfo *PutTicketsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostTicketsRequest) Authorization(authorization string) ReservationApiPostTicketsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostTicketsRequest) XAppKey(xAppKey string) ReservationApiPostTicketsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostTicketsRequest) XHotelid(xHotelid string) ReservationApiPostTicketsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Common tickets request base type.
func (r ReservationApiPostTicketsRequest) TicketsInfo(ticketsInfo PutTicketsRequest) ReservationApiPostTicketsRequest {
	r.ticketsInfo = &ticketsInfo
	return r
}

// External system code.
func (r ReservationApiPostTicketsRequest) XExternalsystem(xExternalsystem string) ReservationApiPostTicketsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostTicketsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostTicketsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostTicketsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTicketsExecute(r)
}

/*
PostTickets Create tickets

Use this API to create tickets on a reservation. <p><strong>OperationId:</strong>postTickets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostTicketsRequest
*/
func (a *ReservationApiService) PostTickets(ctx context.Context, reservationId string, hotelId string) ReservationApiPostTicketsRequest {
	return ReservationApiPostTicketsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostTicketsExecute(r ReservationApiPostTicketsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostTickets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/tickets"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ticketsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostTransactionDiversionsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionDiversionsInfo *PutTransactionDiversionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostTransactionDiversionsRequest) Authorization(authorization string) ReservationApiPostTransactionDiversionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostTransactionDiversionsRequest) XAppKey(xAppKey string) ReservationApiPostTransactionDiversionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostTransactionDiversionsRequest) XHotelid(xHotelid string) ReservationApiPostTransactionDiversionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create transaction diversion rules for a reservation.
func (r ReservationApiPostTransactionDiversionsRequest) TransactionDiversionsInfo(transactionDiversionsInfo PutTransactionDiversionsRequest) ReservationApiPostTransactionDiversionsRequest {
	r.transactionDiversionsInfo = &transactionDiversionsInfo
	return r
}

// External system code.
func (r ReservationApiPostTransactionDiversionsRequest) XExternalsystem(xExternalsystem string) ReservationApiPostTransactionDiversionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostTransactionDiversionsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostTransactionDiversionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostTransactionDiversionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTransactionDiversionsExecute(r)
}

/*
PostTransactionDiversions Create Transaction Diversions 

You can use this API to create Transaction Diversions. <p><strong>OperationId:</strong>postTransactionDiversions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostTransactionDiversionsRequest
*/
func (a *ReservationApiService) PostTransactionDiversions(ctx context.Context, reservationId string, hotelId string) ReservationApiPostTransactionDiversionsRequest {
	return ReservationApiPostTransactionDiversionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostTransactionDiversionsExecute(r ReservationApiPostTransactionDiversionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostTransactionDiversions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/transactionDiversions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionDiversionsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostTurnawayReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	registerTurnaway *PostTurnawayReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostTurnawayReservationRequest) Authorization(authorization string) ReservationApiPostTurnawayReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostTurnawayReservationRequest) XAppKey(xAppKey string) ReservationApiPostTurnawayReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostTurnawayReservationRequest) XHotelid(xHotelid string) ReservationApiPostTurnawayReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to register turn away reservation.
func (r ReservationApiPostTurnawayReservationRequest) RegisterTurnaway(registerTurnaway PostTurnawayReservationRequest) ReservationApiPostTurnawayReservationRequest {
	r.registerTurnaway = &registerTurnaway
	return r
}

// External system code.
func (r ReservationApiPostTurnawayReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiPostTurnawayReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostTurnawayReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostTurnawayReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostTurnawayReservationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTurnawayReservationExecute(r)
}

/*
PostTurnawayReservation Register Turnaway

Register turnaways for a property. <p><strong>OperationId:</strong>postTurnawayReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostTurnawayReservationRequest
*/
func (a *ReservationApiService) PostTurnawayReservation(ctx context.Context, hotelId string) ReservationApiPostTurnawayReservationRequest {
	return ReservationApiPostTurnawayReservationRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostTurnawayReservationExecute(r ReservationApiPostTurnawayReservationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostTurnawayReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/turnaways"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.registerTurnaway
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPostUpsellReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	upsellReservation *PostUpsellReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPostUpsellReservationRequest) Authorization(authorization string) ReservationApiPostUpsellReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPostUpsellReservationRequest) XAppKey(xAppKey string) ReservationApiPostUpsellReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPostUpsellReservationRequest) XHotelid(xHotelid string) ReservationApiPostUpsellReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to upsell a reservation.
func (r ReservationApiPostUpsellReservationRequest) UpsellReservation(upsellReservation PostUpsellReservationRequest) ReservationApiPostUpsellReservationRequest {
	r.upsellReservation = &upsellReservation
	return r
}

// External system code.
func (r ReservationApiPostUpsellReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiPostUpsellReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPostUpsellReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiPostUpsellReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPostUpsellReservationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostUpsellReservationExecute(r)
}

/*
PostUpsellReservation Upsell a Reservation

This API will allow you to upsell a reservation in OPERA.  You would need to already know the upsell rules that are available for this reservation - you can do this by using the getUpsell API. <p><strong>OperationId:</strong>postUpsellReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPostUpsellReservationRequest
*/
func (a *ReservationApiService) PostUpsellReservation(ctx context.Context, reservationId string, hotelId string) ReservationApiPostUpsellReservationRequest {
	return ReservationApiPostUpsellReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PostUpsellReservationExecute(r ReservationApiPostUpsellReservationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PostUpsellReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/upsell"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.upsellReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutAcquireReservationLockRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationLock *PutAcquireReservationLockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutAcquireReservationLockRequest) Authorization(authorization string) ReservationApiPutAcquireReservationLockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutAcquireReservationLockRequest) XAppKey(xAppKey string) ReservationApiPutAcquireReservationLockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutAcquireReservationLockRequest) XHotelid(xHotelid string) ReservationApiPutAcquireReservationLockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation for requesting a lock on a reservation.
func (r ReservationApiPutAcquireReservationLockRequest) ReservationLock(reservationLock PutAcquireReservationLockRequest) ReservationApiPutAcquireReservationLockRequest {
	r.reservationLock = &reservationLock
	return r
}

// External system code.
func (r ReservationApiPutAcquireReservationLockRequest) XExternalsystem(xExternalsystem string) ReservationApiPutAcquireReservationLockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutAcquireReservationLockRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutAcquireReservationLockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutAcquireReservationLockRequest) Execute() (*ReservationLockDetails, *http.Response, error) {
	return r.ApiService.PutAcquireReservationLockExecute(r)
}

/*
PutAcquireReservationLock Acquire Reservation Lock

Acquire Reservation Lock. <p><strong>OperationId:</strong>putAcquireReservationLock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutAcquireReservationLockRequest
*/
func (a *ReservationApiService) PutAcquireReservationLock(ctx context.Context, reservationId string, hotelId string) ReservationApiPutAcquireReservationLockRequest {
	return ReservationApiPutAcquireReservationLockRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationLockDetails
func (a *ReservationApiService) PutAcquireReservationLockExecute(r ReservationApiPutAcquireReservationLockRequest) (*ReservationLockDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationLockDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutAcquireReservationLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/locks"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationLock
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutBreakShareValidationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	breakShareValidations *PutBreakShareValidationsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutBreakShareValidationsRequest) Authorization(authorization string) ReservationApiPutBreakShareValidationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutBreakShareValidationsRequest) XAppKey(xAppKey string) ReservationApiPutBreakShareValidationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutBreakShareValidationsRequest) XHotelid(xHotelid string) ReservationApiPutBreakShareValidationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for Break Share operation validations. This request should be done prior to the actual Break Share operation request. Based on the validations returned from this request the appropriate parameters can be returned in the actual break share request.
func (r ReservationApiPutBreakShareValidationsRequest) BreakShareValidations(breakShareValidations PutBreakShareValidationsRequest) ReservationApiPutBreakShareValidationsRequest {
	r.breakShareValidations = &breakShareValidations
	return r
}

// External system code.
func (r ReservationApiPutBreakShareValidationsRequest) XExternalsystem(xExternalsystem string) ReservationApiPutBreakShareValidationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutBreakShareValidationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutBreakShareValidationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutBreakShareValidationsRequest) Execute() (*BreakShareValidationsDetails, *http.Response, error) {
	return r.ApiService.PutBreakShareValidationsExecute(r)
}

/*
PutBreakShareValidations Validate before breaking a share Reservation

This API performs a validation before separating share reservations. <p><strong>OperationId:</strong>putBreakShareValidations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutBreakShareValidationsRequest
*/
func (a *ReservationApiService) PutBreakShareValidations(ctx context.Context, reservationId string, hotelId string) ReservationApiPutBreakShareValidationsRequest {
	return ReservationApiPutBreakShareValidationsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BreakShareValidationsDetails
func (a *ReservationApiService) PutBreakShareValidationsExecute(r ReservationApiPutBreakShareValidationsRequest) (*BreakShareValidationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BreakShareValidationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutBreakShareValidations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/breakshares/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.breakShareValidations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutCancellationPolicyRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationCancellationPolicyCriteria *PutCancellationPolicyRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutCancellationPolicyRequest) Authorization(authorization string) ReservationApiPutCancellationPolicyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutCancellationPolicyRequest) XAppKey(xAppKey string) ReservationApiPutCancellationPolicyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutCancellationPolicyRequest) XHotelid(xHotelid string) ReservationApiPutCancellationPolicyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object that holds the details of Cancellation Policy to be changed.
func (r ReservationApiPutCancellationPolicyRequest) ReservationCancellationPolicyCriteria(reservationCancellationPolicyCriteria PutCancellationPolicyRequest) ReservationApiPutCancellationPolicyRequest {
	r.reservationCancellationPolicyCriteria = &reservationCancellationPolicyCriteria
	return r
}

// External system code.
func (r ReservationApiPutCancellationPolicyRequest) XExternalsystem(xExternalsystem string) ReservationApiPutCancellationPolicyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutCancellationPolicyRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutCancellationPolicyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutCancellationPolicyRequest) Execute() (*ReservationCancellationPolicyCriteria, *http.Response, error) {
	return r.ApiService.PutCancellationPolicyExecute(r)
}

/*
PutCancellationPolicy Change a Cancellation policy

Change cancellation policy that is configured for a property. <p><strong>OperationId:</strong>putCancellationPolicy</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutCancellationPolicyRequest
*/
func (a *ReservationApiService) PutCancellationPolicy(ctx context.Context, hotelId string) ReservationApiPutCancellationPolicyRequest {
	return ReservationApiPutCancellationPolicyRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationCancellationPolicyCriteria
func (a *ReservationApiService) PutCancellationPolicyExecute(r ReservationApiPutCancellationPolicyRequest) (*ReservationCancellationPolicyCriteria, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationCancellationPolicyCriteria
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutCancellationPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cancellationPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationCancellationPolicyCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutCombineShareValidationsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	combineShareValidations *PutCombineShareValidationsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutCombineShareValidationsRequest) Authorization(authorization string) ReservationApiPutCombineShareValidationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutCombineShareValidationsRequest) XAppKey(xAppKey string) ReservationApiPutCombineShareValidationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutCombineShareValidationsRequest) XHotelid(xHotelid string) ReservationApiPutCombineShareValidationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to validate a combine share operation. This would be done prior to the actual Combine Share operation. Based on the validations returned from this request, the appropriate values can be returned to the Combine Share operation request.
func (r ReservationApiPutCombineShareValidationsRequest) CombineShareValidations(combineShareValidations PutCombineShareValidationsRequest) ReservationApiPutCombineShareValidationsRequest {
	r.combineShareValidations = &combineShareValidations
	return r
}

// External system code.
func (r ReservationApiPutCombineShareValidationsRequest) XExternalsystem(xExternalsystem string) ReservationApiPutCombineShareValidationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutCombineShareValidationsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutCombineShareValidationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutCombineShareValidationsRequest) Execute() (*CombineShareValidationsDetails, *http.Response, error) {
	return r.ApiService.PutCombineShareValidationsExecute(r)
}

/*
PutCombineShareValidations Combine Share Validations

Validate before combining Reservations for shares. <p><strong>OperationId:</strong>putCombineShareValidations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutCombineShareValidationsRequest
*/
func (a *ReservationApiService) PutCombineShareValidations(ctx context.Context, reservationId string, hotelId string) ReservationApiPutCombineShareValidationsRequest {
	return ReservationApiPutCombineShareValidationsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CombineShareValidationsDetails
func (a *ReservationApiService) PutCombineShareValidationsExecute(r ReservationApiPutCombineShareValidationsRequest) (*CombineShareValidationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CombineShareValidationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutCombineShareValidations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/combineshares/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.combineShareValidations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutComputeCancellationPoliciesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	computeCancellationPolicies *PutComputeCancellationPoliciesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutComputeCancellationPoliciesRequest) Authorization(authorization string) ReservationApiPutComputeCancellationPoliciesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutComputeCancellationPoliciesRequest) XAppKey(xAppKey string) ReservationApiPutComputeCancellationPoliciesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutComputeCancellationPoliciesRequest) XHotelid(xHotelid string) ReservationApiPutComputeCancellationPoliciesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to fetch the details for cancellation rules, applicable to a reservation. Based on the criteria the rule information can be retrieved for all cancellation rules or for a particular rule.
func (r ReservationApiPutComputeCancellationPoliciesRequest) ComputeCancellationPolicies(computeCancellationPolicies PutComputeCancellationPoliciesRequest) ReservationApiPutComputeCancellationPoliciesRequest {
	r.computeCancellationPolicies = &computeCancellationPolicies
	return r
}

// External system code.
func (r ReservationApiPutComputeCancellationPoliciesRequest) XExternalsystem(xExternalsystem string) ReservationApiPutComputeCancellationPoliciesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutComputeCancellationPoliciesRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutComputeCancellationPoliciesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutComputeCancellationPoliciesRequest) Execute() (*ComputeCancellationPoliciesDetails, *http.Response, error) {
	return r.ApiService.PutComputeCancellationPoliciesExecute(r)
}

/*
PutComputeCancellationPolicies Compute the cancellation policies

Compute the cancellation policies for a reservation. <p><strong>OperationId:</strong>putComputeCancellationPolicies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutComputeCancellationPoliciesRequest
*/
func (a *ReservationApiService) PutComputeCancellationPolicies(ctx context.Context, reservationId string, hotelId string) ReservationApiPutComputeCancellationPoliciesRequest {
	return ReservationApiPutComputeCancellationPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ComputeCancellationPoliciesDetails
func (a *ReservationApiService) PutComputeCancellationPoliciesExecute(r ReservationApiPutComputeCancellationPoliciesRequest) (*ComputeCancellationPoliciesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputeCancellationPoliciesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutComputeCancellationPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/cancellationPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.computeCancellationPolicies
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutComputeDepositPoliciesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	computeDepositPolicies *PutComputeDepositPoliciesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutComputeDepositPoliciesRequest) Authorization(authorization string) ReservationApiPutComputeDepositPoliciesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutComputeDepositPoliciesRequest) XAppKey(xAppKey string) ReservationApiPutComputeDepositPoliciesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutComputeDepositPoliciesRequest) XHotelid(xHotelid string) ReservationApiPutComputeDepositPoliciesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to fetch the details for deposit rules, applicable to a reservation. Based on the criteria the rule information can be retrieved for all deposit rules or for a particular rule.
func (r ReservationApiPutComputeDepositPoliciesRequest) ComputeDepositPolicies(computeDepositPolicies PutComputeDepositPoliciesRequest) ReservationApiPutComputeDepositPoliciesRequest {
	r.computeDepositPolicies = &computeDepositPolicies
	return r
}

// External system code.
func (r ReservationApiPutComputeDepositPoliciesRequest) XExternalsystem(xExternalsystem string) ReservationApiPutComputeDepositPoliciesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutComputeDepositPoliciesRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutComputeDepositPoliciesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutComputeDepositPoliciesRequest) Execute() (*ComputeDepositPoliciesDetails, *http.Response, error) {
	return r.ApiService.PutComputeDepositPoliciesExecute(r)
}

/*
PutComputeDepositPolicies Computes the deposit policies

Computes the deposit policies. <p><strong>OperationId:</strong>putComputeDepositPolicies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutComputeDepositPoliciesRequest
*/
func (a *ReservationApiService) PutComputeDepositPolicies(ctx context.Context, reservationId string, hotelId string) ReservationApiPutComputeDepositPoliciesRequest {
	return ReservationApiPutComputeDepositPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ComputeDepositPoliciesDetails
func (a *ReservationApiService) PutComputeDepositPoliciesExecute(r ReservationApiPutComputeDepositPoliciesRequest) (*ComputeDepositPoliciesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputeDepositPoliciesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutComputeDepositPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.computeDepositPolicies
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutDepositPolicyRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationDepositPolicyCriteria *PutDepositPolicyRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutDepositPolicyRequest) Authorization(authorization string) ReservationApiPutDepositPolicyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutDepositPolicyRequest) XAppKey(xAppKey string) ReservationApiPutDepositPolicyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutDepositPolicyRequest) XHotelid(xHotelid string) ReservationApiPutDepositPolicyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object that holds the details of hotel level Deposit Policy to be changed.
func (r ReservationApiPutDepositPolicyRequest) ReservationDepositPolicyCriteria(reservationDepositPolicyCriteria PutDepositPolicyRequest) ReservationApiPutDepositPolicyRequest {
	r.reservationDepositPolicyCriteria = &reservationDepositPolicyCriteria
	return r
}

// External system code.
func (r ReservationApiPutDepositPolicyRequest) XExternalsystem(xExternalsystem string) ReservationApiPutDepositPolicyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutDepositPolicyRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutDepositPolicyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutDepositPolicyRequest) Execute() (*ChangeDepositPolicyDetails, *http.Response, error) {
	return r.ApiService.PutDepositPolicyExecute(r)
}

/*
PutDepositPolicy Change deposit policy

Change deposit policy which already exists for a property. <p><strong>OperationId:</strong>putDepositPolicy</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutDepositPolicyRequest
*/
func (a *ReservationApiService) PutDepositPolicy(ctx context.Context, hotelId string) ReservationApiPutDepositPolicyRequest {
	return ReservationApiPutDepositPolicyRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangeDepositPolicyDetails
func (a *ReservationApiService) PutDepositPolicyExecute(r ReservationApiPutDepositPolicyRequest) (*ChangeDepositPolicyDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeDepositPolicyDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutDepositPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/depositPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationDepositPolicyCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutECouponsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eCouponsInfo *PutECouponsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutECouponsRequest) Authorization(authorization string) ReservationApiPutECouponsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutECouponsRequest) XAppKey(xAppKey string) ReservationApiPutECouponsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutECouponsRequest) XHotelid(xHotelid string) ReservationApiPutECouponsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing the existing eCoupons attached to Reservation.
func (r ReservationApiPutECouponsRequest) ECouponsInfo(eCouponsInfo PutECouponsRequest) ReservationApiPutECouponsRequest {
	r.eCouponsInfo = &eCouponsInfo
	return r
}

// External system code.
func (r ReservationApiPutECouponsRequest) XExternalsystem(xExternalsystem string) ReservationApiPutECouponsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutECouponsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutECouponsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutECouponsRequest) Execute() (*ECoupons, *http.Response, error) {
	return r.ApiService.PutECouponsExecute(r)
}

/*
PutECoupons Change Reservation Ecoupon

Change the Reservation Ecoupons. <p><strong>OperationId:</strong>putECoupons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutECouponsRequest
*/
func (a *ReservationApiService) PutECoupons(ctx context.Context, reservationId string, hotelId string) ReservationApiPutECouponsRequest {
	return ReservationApiPutECouponsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ECoupons
func (a *ReservationApiService) PutECouponsExecute(r ReservationApiPutECouponsRequest) (*ECoupons, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECoupons
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutECoupons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/eCoupons"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eCouponsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutGuestMessagesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	guestMessageId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeGuestMessages *PutGuestMessagesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutGuestMessagesRequest) Authorization(authorization string) ReservationApiPutGuestMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutGuestMessagesRequest) XAppKey(xAppKey string) ReservationApiPutGuestMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutGuestMessagesRequest) XHotelid(xHotelid string) ReservationApiPutGuestMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying an existing guest message.
func (r ReservationApiPutGuestMessagesRequest) ChangeGuestMessages(changeGuestMessages PutGuestMessagesRequest) ReservationApiPutGuestMessagesRequest {
	r.changeGuestMessages = &changeGuestMessages
	return r
}

// External system code.
func (r ReservationApiPutGuestMessagesRequest) XExternalsystem(xExternalsystem string) ReservationApiPutGuestMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutGuestMessagesRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutGuestMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutGuestMessagesRequest) Execute() (*ChangeGuestMessages, *http.Response, error) {
	return r.ApiService.PutGuestMessagesExecute(r)
}

/*
PutGuestMessages Change guest Message  

Change guest Message on a reservation. <p><strong>OperationId:</strong>putGuestMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guestMessageId Guest Message Id
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutGuestMessagesRequest
*/
func (a *ReservationApiService) PutGuestMessages(ctx context.Context, guestMessageId string, reservationId string, hotelId string) ReservationApiPutGuestMessagesRequest {
	return ReservationApiPutGuestMessagesRequest{
		ApiService: a,
		ctx: ctx,
		guestMessageId: guestMessageId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangeGuestMessages
func (a *ReservationApiService) PutGuestMessagesExecute(r ReservationApiPutGuestMessagesRequest) (*ChangeGuestMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeGuestMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutGuestMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/guestMessages/{guestMessageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"guestMessageId"+"}", url.PathEscape(parameterValueToString(r.guestMessageId, "guestMessageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.guestMessageId) < 1 {
		return localVarReturnValue, nil, reportError("guestMessageId must have at least 1 elements")
	}
	if strlen(r.guestMessageId) > 2000 {
		return localVarReturnValue, nil, reportError("guestMessageId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeGuestMessages
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutMasterAccountRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	masterAccount *PutMasterAccountRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutMasterAccountRequest) Authorization(authorization string) ReservationApiPutMasterAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutMasterAccountRequest) XAppKey(xAppKey string) ReservationApiPutMasterAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutMasterAccountRequest) XHotelid(xHotelid string) ReservationApiPutMasterAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for ChangeMasterAccount operation.
func (r ReservationApiPutMasterAccountRequest) MasterAccount(masterAccount PutMasterAccountRequest) ReservationApiPutMasterAccountRequest {
	r.masterAccount = &masterAccount
	return r
}

// External system code.
func (r ReservationApiPutMasterAccountRequest) XExternalsystem(xExternalsystem string) ReservationApiPutMasterAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutMasterAccountRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutMasterAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutMasterAccountRequest) Execute() (*MasterAccountSummary, *http.Response, error) {
	return r.ApiService.PutMasterAccountExecute(r)
}

/*
PutMasterAccount Change a Master Account

Change a master account on a reservation. <p><strong>OperationId:</strong>putMasterAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutMasterAccountRequest
*/
func (a *ReservationApiService) PutMasterAccount(ctx context.Context, reservationId string, hotelId string) ReservationApiPutMasterAccountRequest {
	return ReservationApiPutMasterAccountRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return MasterAccountSummary
func (a *ReservationApiService) PutMasterAccountExecute(r ReservationApiPutMasterAccountRequest) (*MasterAccountSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MasterAccountSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutMasterAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/masterAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.masterAccount
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutPaymentMethodsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationPaymentMethods *PutPaymentMethodsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutPaymentMethodsRequest) Authorization(authorization string) ReservationApiPutPaymentMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutPaymentMethodsRequest) XAppKey(xAppKey string) ReservationApiPutPaymentMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutPaymentMethodsRequest) XHotelid(xHotelid string) ReservationApiPutPaymentMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Method to update a reservation&#39;s payment methods.
func (r ReservationApiPutPaymentMethodsRequest) ReservationPaymentMethods(reservationPaymentMethods PutPaymentMethodsRequest) ReservationApiPutPaymentMethodsRequest {
	r.reservationPaymentMethods = &reservationPaymentMethods
	return r
}

// External system code.
func (r ReservationApiPutPaymentMethodsRequest) XExternalsystem(xExternalsystem string) ReservationApiPutPaymentMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutPaymentMethodsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutPaymentMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutPaymentMethodsRequest) Execute() (*ReservationPaymentMethods, *http.Response, error) {
	return r.ApiService.PutPaymentMethodsExecute(r)
}

/*
PutPaymentMethods Change a payment method 

This API will update an existing payment method on a reservation. <p><strong>OperationId:</strong>putPaymentMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutPaymentMethodsRequest
*/
func (a *ReservationApiService) PutPaymentMethods(ctx context.Context, reservationId string, hotelId string) ReservationApiPutPaymentMethodsRequest {
	return ReservationApiPutPaymentMethodsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationPaymentMethods
func (a *ReservationApiService) PutPaymentMethodsExecute(r ReservationApiPutPaymentMethodsRequest) (*ReservationPaymentMethods, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationPaymentMethods
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/paymentMethods"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationPaymentMethods
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutReinstateReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reinstateReservation *PutReinstateReservationByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutReinstateReservationRequest) Authorization(authorization string) ReservationApiPutReinstateReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutReinstateReservationRequest) XAppKey(xAppKey string) ReservationApiPutReinstateReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutReinstateReservationRequest) XHotelid(xHotelid string) ReservationApiPutReinstateReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Overriding the validation check will log the supposed errors in the warnings log if they would fail.
func (r ReservationApiPutReinstateReservationRequest) ReinstateReservation(reinstateReservation PutReinstateReservationByExtIdRequest) ReservationApiPutReinstateReservationRequest {
	r.reinstateReservation = &reinstateReservation
	return r
}

// External system code.
func (r ReservationApiPutReinstateReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiPutReinstateReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutReinstateReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutReinstateReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutReinstateReservationRequest) Execute() (*ReinstateReservationDetails, *http.Response, error) {
	return r.ApiService.PutReinstateReservationExecute(r)
}

/*
PutReinstateReservation Reinstate a Reservation

Use this API to reinstate a cancelled reservation. <p><strong>OperationId:</strong>putReinstateReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutReinstateReservationRequest
*/
func (a *ReservationApiService) PutReinstateReservation(ctx context.Context, reservationId string, hotelId string) ReservationApiPutReinstateReservationRequest {
	return ReservationApiPutReinstateReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReinstateReservationDetails
func (a *ReservationApiService) PutReinstateReservationExecute(r ReservationApiPutReinstateReservationRequest) (*ReinstateReservationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReinstateReservationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReinstateReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/cancellations"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reinstateReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutReinstateReservationByExtIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reinstateReservation *PutReinstateReservationByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutReinstateReservationByExtIdRequest) Authorization(authorization string) ReservationApiPutReinstateReservationByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutReinstateReservationByExtIdRequest) XAppKey(xAppKey string) ReservationApiPutReinstateReservationByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutReinstateReservationByExtIdRequest) XHotelid(xHotelid string) ReservationApiPutReinstateReservationByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Overriding the validation check will log the supposed errors in the warnings log if they would fail.
func (r ReservationApiPutReinstateReservationByExtIdRequest) ReinstateReservation(reinstateReservation PutReinstateReservationByExtIdRequest) ReservationApiPutReinstateReservationByExtIdRequest {
	r.reinstateReservation = &reinstateReservation
	return r
}

// External system code.
func (r ReservationApiPutReinstateReservationByExtIdRequest) XExternalsystem(xExternalsystem string) ReservationApiPutReinstateReservationByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutReinstateReservationByExtIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutReinstateReservationByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutReinstateReservationByExtIdRequest) Execute() (*ReinstateReservationDetails, *http.Response, error) {
	return r.ApiService.PutReinstateReservationByExtIdExecute(r)
}

/*
PutReinstateReservationByExtId Reinstate a Reservation

Use this API to reinstate a cancelled reservation. <p><strong>OperationId:</strong>putReinstateReservationByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationExternalId External reservation ID.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutReinstateReservationByExtIdRequest
*/
func (a *ReservationApiService) PutReinstateReservationByExtId(ctx context.Context, reservationExternalId string, externalSystemCode string, hotelId string) ReservationApiPutReinstateReservationByExtIdRequest {
	return ReservationApiPutReinstateReservationByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationExternalId: reservationExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReinstateReservationDetails
func (a *ReservationApiService) PutReinstateReservationByExtIdExecute(r ReservationApiPutReinstateReservationByExtIdRequest) (*ReinstateReservationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReinstateReservationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReinstateReservationByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/reservations/{reservationExternalId}/cancellations"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationExternalId"+"}", url.PathEscape(parameterValueToString(r.reservationExternalId, "reservationExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationExternalId) < 1 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have at least 1 elements")
	}
	if strlen(r.reservationExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reinstateReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeReservation *PutReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutReservationRequest) Authorization(authorization string) ReservationApiPutReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutReservationRequest) XAppKey(xAppKey string) ReservationApiPutReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutReservationRequest) XHotelid(xHotelid string) ReservationApiPutReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request method to change a reservations information.
func (r ReservationApiPutReservationRequest) ChangeReservation(changeReservation PutReservationRequest) ReservationApiPutReservationRequest {
	r.changeReservation = &changeReservation
	return r
}

// External system code.
func (r ReservationApiPutReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiPutReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutReservationRequest) Execute() (*ChangeReservationDetails, *http.Response, error) {
	return r.ApiService.PutReservationExecute(r)
}

/*
PutReservation Update Reservation by ID

Use this to update an existing reservation for a hotel, such as adding comments, changing the number of guests.   There are many fields in putReservation defined by ListOfValues; ensure you have reviewed ListOfValues APIs in order successfully to use putReservation. <p><strong>OperationId:</strong>putReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutReservationRequest
*/
func (a *ReservationApiService) PutReservation(ctx context.Context, reservationId string, hotelId string) ReservationApiPutReservationRequest {
	return ReservationApiPutReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangeReservationDetails
func (a *ReservationApiService) PutReservationExecute(r ReservationApiPutReservationRequest) (*ChangeReservationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeReservationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutReservationByExtIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeReservation *PutReservationByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutReservationByExtIdRequest) Authorization(authorization string) ReservationApiPutReservationByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutReservationByExtIdRequest) XAppKey(xAppKey string) ReservationApiPutReservationByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutReservationByExtIdRequest) XHotelid(xHotelid string) ReservationApiPutReservationByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request method to change a reservations information.
func (r ReservationApiPutReservationByExtIdRequest) ChangeReservation(changeReservation PutReservationByExtIdRequest) ReservationApiPutReservationByExtIdRequest {
	r.changeReservation = &changeReservation
	return r
}

// External system code.
func (r ReservationApiPutReservationByExtIdRequest) XExternalsystem(xExternalsystem string) ReservationApiPutReservationByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutReservationByExtIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutReservationByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutReservationByExtIdRequest) Execute() (*ChangeReservationDetails, *http.Response, error) {
	return r.ApiService.PutReservationByExtIdExecute(r)
}

/*
PutReservationByExtId Update Reservation by ID

Use this to update an existing reservation for a hotel, such as adding comments, changing the number of guests.   There are many fields in putReservation defined by ListOfValues; ensure you have reviewed ListOfValues APIs in order successfully to use putReservation. <p><strong>OperationId:</strong>putReservationByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationExternalId External reservation ID.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutReservationByExtIdRequest
*/
func (a *ReservationApiService) PutReservationByExtId(ctx context.Context, reservationExternalId string, externalSystemCode string, hotelId string) ReservationApiPutReservationByExtIdRequest {
	return ReservationApiPutReservationByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationExternalId: reservationExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangeReservationDetails
func (a *ReservationApiService) PutReservationByExtIdExecute(r ReservationApiPutReservationByExtIdRequest) (*ChangeReservationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeReservationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReservationByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/reservations/{reservationExternalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationExternalId"+"}", url.PathEscape(parameterValueToString(r.reservationExternalId, "reservationExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationExternalId) < 1 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have at least 1 elements")
	}
	if strlen(r.reservationExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutReservationDailyRateDetailValidationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationDailyRateDetail *PutReservationDailyRateDetailValidationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutReservationDailyRateDetailValidationRequest) Authorization(authorization string) ReservationApiPutReservationDailyRateDetailValidationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutReservationDailyRateDetailValidationRequest) XAppKey(xAppKey string) ReservationApiPutReservationDailyRateDetailValidationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutReservationDailyRateDetailValidationRequest) XHotelid(xHotelid string) ReservationApiPutReservationDailyRateDetailValidationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for validating Daily Rate Details modifications.
func (r ReservationApiPutReservationDailyRateDetailValidationRequest) ReservationDailyRateDetail(reservationDailyRateDetail PutReservationDailyRateDetailValidationRequest) ReservationApiPutReservationDailyRateDetailValidationRequest {
	r.reservationDailyRateDetail = &reservationDailyRateDetail
	return r
}

// External system code.
func (r ReservationApiPutReservationDailyRateDetailValidationRequest) XExternalsystem(xExternalsystem string) ReservationApiPutReservationDailyRateDetailValidationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutReservationDailyRateDetailValidationRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutReservationDailyRateDetailValidationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutReservationDailyRateDetailValidationRequest) Execute() (*ReservationDailyRateDetailDetails, *http.Response, error) {
	return r.ApiService.PutReservationDailyRateDetailValidationExecute(r)
}

/*
PutReservationDailyRateDetailValidation Validate daily rate details change

Validate daily rate details change. <p><strong>OperationId:</strong>putReservationDailyRateDetailValidation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutReservationDailyRateDetailValidationRequest
*/
func (a *ReservationApiService) PutReservationDailyRateDetailValidation(ctx context.Context, reservationId string, hotelId string) ReservationApiPutReservationDailyRateDetailValidationRequest {
	return ReservationApiPutReservationDailyRateDetailValidationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationDailyRateDetailDetails
func (a *ReservationApiService) PutReservationDailyRateDetailValidationExecute(r ReservationApiPutReservationDailyRateDetailValidationRequest) (*ReservationDailyRateDetailDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationDailyRateDetailDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReservationDailyRateDetailValidation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/dailyRates/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationDailyRateDetail
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutReservationHeaderValidationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationDailyRateDetail *PutReservationDailyRateDetailValidationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutReservationHeaderValidationRequest) Authorization(authorization string) ReservationApiPutReservationHeaderValidationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutReservationHeaderValidationRequest) XAppKey(xAppKey string) ReservationApiPutReservationHeaderValidationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutReservationHeaderValidationRequest) XHotelid(xHotelid string) ReservationApiPutReservationHeaderValidationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for validating Reservation Header modifications.
func (r ReservationApiPutReservationHeaderValidationRequest) ReservationDailyRateDetail(reservationDailyRateDetail PutReservationDailyRateDetailValidationRequest) ReservationApiPutReservationHeaderValidationRequest {
	r.reservationDailyRateDetail = &reservationDailyRateDetail
	return r
}

// External system code.
func (r ReservationApiPutReservationHeaderValidationRequest) XExternalsystem(xExternalsystem string) ReservationApiPutReservationHeaderValidationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutReservationHeaderValidationRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutReservationHeaderValidationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutReservationHeaderValidationRequest) Execute() (*ReservationDailyRateDetailDetails, *http.Response, error) {
	return r.ApiService.PutReservationHeaderValidationExecute(r)
}

/*
PutReservationHeaderValidation Validate Reservation header change

Validate Reservation header change. <p><strong>OperationId:</strong>putReservationHeaderValidation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutReservationHeaderValidationRequest
*/
func (a *ReservationApiService) PutReservationHeaderValidation(ctx context.Context, reservationId string, hotelId string) ReservationApiPutReservationHeaderValidationRequest {
	return ReservationApiPutReservationHeaderValidationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationDailyRateDetailDetails
func (a *ReservationApiService) PutReservationHeaderValidationExecute(r ReservationApiPutReservationHeaderValidationRequest) (*ReservationDailyRateDetailDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationDailyRateDetailDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReservationHeaderValidation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/header/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationDailyRateDetail
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutReservationHotelMoveRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	moveReservationHotel *PutReservationHotelMoveRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutReservationHotelMoveRequest) Authorization(authorization string) ReservationApiPutReservationHotelMoveRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutReservationHotelMoveRequest) XAppKey(xAppKey string) ReservationApiPutReservationHotelMoveRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutReservationHotelMoveRequest) XHotelid(xHotelid string) ReservationApiPutReservationHotelMoveRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for moving a reservation and its valid sharers to a different hotel.
func (r ReservationApiPutReservationHotelMoveRequest) MoveReservationHotel(moveReservationHotel PutReservationHotelMoveRequest) ReservationApiPutReservationHotelMoveRequest {
	r.moveReservationHotel = &moveReservationHotel
	return r
}

// External system code.
func (r ReservationApiPutReservationHotelMoveRequest) XExternalsystem(xExternalsystem string) ReservationApiPutReservationHotelMoveRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutReservationHotelMoveRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutReservationHotelMoveRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutReservationHotelMoveRequest) Execute() (*MoveReservationHotelDetails, *http.Response, error) {
	return r.ApiService.PutReservationHotelMoveExecute(r)
}

/*
PutReservationHotelMove Move the Reservation 

This API can be used to move a reservation to a different hotel. <p><strong>OperationId:</strong>putReservationHotelMove</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutReservationHotelMoveRequest
*/
func (a *ReservationApiService) PutReservationHotelMove(ctx context.Context, reservationId string, hotelId string) ReservationApiPutReservationHotelMoveRequest {
	return ReservationApiPutReservationHotelMoveRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return MoveReservationHotelDetails
func (a *ReservationApiService) PutReservationHotelMoveExecute(r ReservationApiPutReservationHotelMoveRequest) (*MoveReservationHotelDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoveReservationHotelDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReservationHotelMove")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/move"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.moveReservationHotel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutReservationLockRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	lockHandle string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	extendReservationLock *PutReservationLockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutReservationLockRequest) Authorization(authorization string) ReservationApiPutReservationLockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutReservationLockRequest) XAppKey(xAppKey string) ReservationApiPutReservationLockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutReservationLockRequest) XHotelid(xHotelid string) ReservationApiPutReservationLockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation for extending the lifetime of a lock on a reservation.
func (r ReservationApiPutReservationLockRequest) ExtendReservationLock(extendReservationLock PutReservationLockRequest) ReservationApiPutReservationLockRequest {
	r.extendReservationLock = &extendReservationLock
	return r
}

// External system code.
func (r ReservationApiPutReservationLockRequest) XExternalsystem(xExternalsystem string) ReservationApiPutReservationLockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutReservationLockRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutReservationLockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutReservationLockRequest) Execute() (*ExtendReservationLockDetails, *http.Response, error) {
	return r.ApiService.PutReservationLockExecute(r)
}

/*
PutReservationLock Extend Reservation Lock

Extend Reservation Lock. <p><strong>OperationId:</strong>putReservationLock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lockHandle Lock handle of the lock to be extended.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutReservationLockRequest
*/
func (a *ReservationApiService) PutReservationLock(ctx context.Context, lockHandle string, hotelId string) ReservationApiPutReservationLockRequest {
	return ReservationApiPutReservationLockRequest{
		ApiService: a,
		ctx: ctx,
		lockHandle: lockHandle,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ExtendReservationLockDetails
func (a *ReservationApiService) PutReservationLockExecute(r ReservationApiPutReservationLockRequest) (*ExtendReservationLockDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtendReservationLockDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReservationLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/locks/{lockHandle}"
	localVarPath = strings.Replace(localVarPath, "{"+"lockHandle"+"}", url.PathEscape(parameterValueToString(r.lockHandle, "lockHandle")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.lockHandle) < 1 {
		return localVarReturnValue, nil, reportError("lockHandle must have at least 1 elements")
	}
	if strlen(r.lockHandle) > 2000 {
		return localVarReturnValue, nil, reportError("lockHandle must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.extendReservationLock
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutReservationPackageRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationPackagesInfo *PutReservationPackageRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutReservationPackageRequest) Authorization(authorization string) ReservationApiPutReservationPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutReservationPackageRequest) XAppKey(xAppKey string) ReservationApiPutReservationPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutReservationPackageRequest) XHotelid(xHotelid string) ReservationApiPutReservationPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Method to change/modify a reservation package on an existing reservation. The main information required are the Package Code, Resort, RateCode(if applicable), Original Begin Date(if applicable) and Original End Date(if applicable). These are the criteria by which the package will be identified in order to be modified/changed. The elements that can be changed are the Quantity, Excluded Quantity, Unit Price and Unit Allowance if existing. For RateCode packages, the begin date and end date cannot be changed. For non-RateCode packages, the begin date or end date can be changed.
func (r ReservationApiPutReservationPackageRequest) ReservationPackagesInfo(reservationPackagesInfo PutReservationPackageRequest) ReservationApiPutReservationPackageRequest {
	r.reservationPackagesInfo = &reservationPackagesInfo
	return r
}

// External system code.
func (r ReservationApiPutReservationPackageRequest) XExternalsystem(xExternalsystem string) ReservationApiPutReservationPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutReservationPackageRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutReservationPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutReservationPackageRequest) Execute() (*ReservationPackagesInfo, *http.Response, error) {
	return r.ApiService.PutReservationPackageExecute(r)
}

/*
PutReservationPackage Update a package on a Reservation

This API will allow you to update existing packages on a reservation. <p><strong>OperationId:</strong>putReservationPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutReservationPackageRequest
*/
func (a *ReservationApiService) PutReservationPackage(ctx context.Context, reservationId string, hotelId string) ReservationApiPutReservationPackageRequest {
	return ReservationApiPutReservationPackageRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationPackagesInfo
func (a *ReservationApiService) PutReservationPackageExecute(r ReservationApiPutReservationPackageRequest) (*ReservationPackagesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationPackagesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReservationPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/packages"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationPackagesInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutReservationPreferenceRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	preferenceCode string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationPreferenceInfo *PostReservationPreferenceRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutReservationPreferenceRequest) Authorization(authorization string) ReservationApiPutReservationPreferenceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutReservationPreferenceRequest) XAppKey(xAppKey string) ReservationApiPutReservationPreferenceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutReservationPreferenceRequest) XHotelid(xHotelid string) ReservationApiPutReservationPreferenceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Method to change a reservation preference on an existing reservation.
func (r ReservationApiPutReservationPreferenceRequest) ReservationPreferenceInfo(reservationPreferenceInfo PostReservationPreferenceRequest) ReservationApiPutReservationPreferenceRequest {
	r.reservationPreferenceInfo = &reservationPreferenceInfo
	return r
}

// External system code.
func (r ReservationApiPutReservationPreferenceRequest) XExternalsystem(xExternalsystem string) ReservationApiPutReservationPreferenceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutReservationPreferenceRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutReservationPreferenceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutReservationPreferenceRequest) Execute() (*ReservationPreferenceDetails, *http.Response, error) {
	return r.ApiService.PutReservationPreferenceExecute(r)
}

/*
PutReservationPreference Change a Reservation Preference

You can use this API to update the preferences that exist on a reservation. <p><strong>OperationId:</strong>putReservationPreference</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param preferenceCode Preference Code
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutReservationPreferenceRequest
*/
func (a *ReservationApiService) PutReservationPreference(ctx context.Context, preferenceCode string, reservationId string, hotelId string) ReservationApiPutReservationPreferenceRequest {
	return ReservationApiPutReservationPreferenceRequest{
		ApiService: a,
		ctx: ctx,
		preferenceCode: preferenceCode,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationPreferenceDetails
func (a *ReservationApiService) PutReservationPreferenceExecute(r ReservationApiPutReservationPreferenceRequest) (*ReservationPreferenceDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationPreferenceDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReservationPreference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/preferences/{preferenceCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"preferenceCode"+"}", url.PathEscape(parameterValueToString(r.preferenceCode, "preferenceCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.preferenceCode) < 1 {
		return localVarReturnValue, nil, reportError("preferenceCode must have at least 1 elements")
	}
	if strlen(r.preferenceCode) > 2000 {
		return localVarReturnValue, nil, reportError("preferenceCode must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationPreferenceInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutReservationsUpgradeEligibilityRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationsUpgradeEligibility *PutReservationsUpgradeEligibilityRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutReservationsUpgradeEligibilityRequest) Authorization(authorization string) ReservationApiPutReservationsUpgradeEligibilityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutReservationsUpgradeEligibilityRequest) XAppKey(xAppKey string) ReservationApiPutReservationsUpgradeEligibilityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutReservationsUpgradeEligibilityRequest) XHotelid(xHotelid string) ReservationApiPutReservationsUpgradeEligibilityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object containing a list of reservation name ids, hotel code and eligibility flag.
func (r ReservationApiPutReservationsUpgradeEligibilityRequest) ReservationsUpgradeEligibility(reservationsUpgradeEligibility PutReservationsUpgradeEligibilityRequest) ReservationApiPutReservationsUpgradeEligibilityRequest {
	r.reservationsUpgradeEligibility = &reservationsUpgradeEligibility
	return r
}

// External system code.
func (r ReservationApiPutReservationsUpgradeEligibilityRequest) XExternalsystem(xExternalsystem string) ReservationApiPutReservationsUpgradeEligibilityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutReservationsUpgradeEligibilityRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutReservationsUpgradeEligibilityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutReservationsUpgradeEligibilityRequest) Execute() (*ReservationsUpgradeEligibilityDetails, *http.Response, error) {
	return r.ApiService.PutReservationsUpgradeEligibilityExecute(r)
}

/*
PutReservationsUpgradeEligibility Set Upgrade Eligibility for Reservations

You can use this API to set Upgrade Eligibility for Reservations. <p><strong>OperationId:</strong>putReservationsUpgradeEligibility</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutReservationsUpgradeEligibilityRequest
*/
func (a *ReservationApiService) PutReservationsUpgradeEligibility(ctx context.Context, reservationId string, hotelId string) ReservationApiPutReservationsUpgradeEligibilityRequest {
	return ReservationApiPutReservationsUpgradeEligibilityRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationsUpgradeEligibilityDetails
func (a *ReservationApiService) PutReservationsUpgradeEligibilityExecute(r ReservationApiPutReservationsUpgradeEligibilityRequest) (*ReservationsUpgradeEligibilityDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationsUpgradeEligibilityDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReservationsUpgradeEligibility")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/upgradeEligibleReservations"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationsUpgradeEligibility
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutReservedInventoryItemsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservedInventoryItemsInfo *PutReservedInventoryItemsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutReservedInventoryItemsRequest) Authorization(authorization string) ReservationApiPutReservedInventoryItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutReservedInventoryItemsRequest) XAppKey(xAppKey string) ReservationApiPutReservedInventoryItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutReservedInventoryItemsRequest) XHotelid(xHotelid string) ReservationApiPutReservedInventoryItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change the reserved inventory Items for a reservation.
func (r ReservationApiPutReservedInventoryItemsRequest) ReservedInventoryItemsInfo(reservedInventoryItemsInfo PutReservedInventoryItemsRequest) ReservationApiPutReservedInventoryItemsRequest {
	r.reservedInventoryItemsInfo = &reservedInventoryItemsInfo
	return r
}

// External system code.
func (r ReservationApiPutReservedInventoryItemsRequest) XExternalsystem(xExternalsystem string) ReservationApiPutReservedInventoryItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutReservedInventoryItemsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutReservedInventoryItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutReservedInventoryItemsRequest) Execute() (*ReservedInventoryItemsInfo, *http.Response, error) {
	return r.ApiService.PutReservedInventoryItemsExecute(r)
}

/*
PutReservedInventoryItems Change reserved Inventory Items 

Change the Inventory Items reserved for the Reservation. <p><strong>OperationId:</strong>putReservedInventoryItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutReservedInventoryItemsRequest
*/
func (a *ReservationApiService) PutReservedInventoryItems(ctx context.Context, reservationId string, hotelId string) ReservationApiPutReservedInventoryItemsRequest {
	return ReservationApiPutReservedInventoryItemsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservedInventoryItemsInfo
func (a *ReservationApiService) PutReservedInventoryItemsExecute(r ReservationApiPutReservedInventoryItemsRequest) (*ReservedInventoryItemsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservedInventoryItemsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutReservedInventoryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/inventoryItems"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservedInventoryItemsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutResvGuestMessagesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeResvGuestMessages *PutResvGuestMessagesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutResvGuestMessagesRequest) Authorization(authorization string) ReservationApiPutResvGuestMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutResvGuestMessagesRequest) XAppKey(xAppKey string) ReservationApiPutResvGuestMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutResvGuestMessagesRequest) XHotelid(xHotelid string) ReservationApiPutResvGuestMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for updating the Guest Messages for a Reservation Workspace.
func (r ReservationApiPutResvGuestMessagesRequest) ChangeResvGuestMessages(changeResvGuestMessages PutResvGuestMessagesRequest) ReservationApiPutResvGuestMessagesRequest {
	r.changeResvGuestMessages = &changeResvGuestMessages
	return r
}

// External system code.
func (r ReservationApiPutResvGuestMessagesRequest) XExternalsystem(xExternalsystem string) ReservationApiPutResvGuestMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutResvGuestMessagesRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutResvGuestMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutResvGuestMessagesRequest) Execute() (*ChangeResvGuestMessages, *http.Response, error) {
	return r.ApiService.PutResvGuestMessagesExecute(r)
}

/*
PutResvGuestMessages Change Reservation Guest Messages

Change guest messages for Reservation. <p><strong>OperationId:</strong>putResvGuestMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutResvGuestMessagesRequest
*/
func (a *ReservationApiService) PutResvGuestMessages(ctx context.Context, reservationId string, hotelId string) ReservationApiPutResvGuestMessagesRequest {
	return ReservationApiPutResvGuestMessagesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangeResvGuestMessages
func (a *ReservationApiService) PutResvGuestMessagesExecute(r ReservationApiPutResvGuestMessagesRequest) (*ChangeResvGuestMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeResvGuestMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutResvGuestMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/guestMessages"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeResvGuestMessages
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	routingInstructionsInfo *PutRoutingInstructionsByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutRoutingInstructionsRequest) Authorization(authorization string) ReservationApiPutRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutRoutingInstructionsRequest) XAppKey(xAppKey string) ReservationApiPutRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutRoutingInstructionsRequest) XHotelid(xHotelid string) ReservationApiPutRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request when changing a routing instruction.
func (r ReservationApiPutRoutingInstructionsRequest) RoutingInstructionsInfo(routingInstructionsInfo PutRoutingInstructionsByExtIdRequest) ReservationApiPutRoutingInstructionsRequest {
	r.routingInstructionsInfo = &routingInstructionsInfo
	return r
}

// External system code.
func (r ReservationApiPutRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) ReservationApiPutRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutRoutingInstructionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoutingInstructionsExecute(r)
}

/*
PutRoutingInstructions Change routing instructions

Change routing instructions on an existing reservation. <p><strong>OperationId:</strong>putRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutRoutingInstructionsRequest
*/
func (a *ReservationApiService) PutRoutingInstructions(ctx context.Context, reservationId string, hotelId string) ReservationApiPutRoutingInstructionsRequest {
	return ReservationApiPutRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PutRoutingInstructionsExecute(r ReservationApiPutRoutingInstructionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.routingInstructionsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutRoutingInstructionsByExtIdRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	routingInstructionsInfo *PutRoutingInstructionsByExtIdRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutRoutingInstructionsByExtIdRequest) Authorization(authorization string) ReservationApiPutRoutingInstructionsByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutRoutingInstructionsByExtIdRequest) XAppKey(xAppKey string) ReservationApiPutRoutingInstructionsByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutRoutingInstructionsByExtIdRequest) XHotelid(xHotelid string) ReservationApiPutRoutingInstructionsByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request when changing a routing instruction.
func (r ReservationApiPutRoutingInstructionsByExtIdRequest) RoutingInstructionsInfo(routingInstructionsInfo PutRoutingInstructionsByExtIdRequest) ReservationApiPutRoutingInstructionsByExtIdRequest {
	r.routingInstructionsInfo = &routingInstructionsInfo
	return r
}

// External system code.
func (r ReservationApiPutRoutingInstructionsByExtIdRequest) XExternalsystem(xExternalsystem string) ReservationApiPutRoutingInstructionsByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutRoutingInstructionsByExtIdRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutRoutingInstructionsByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutRoutingInstructionsByExtIdRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoutingInstructionsByExtIdExecute(r)
}

/*
PutRoutingInstructionsByExtId Change routing instructions

Change routing instructions on an existing reservation. <p><strong>OperationId:</strong>putRoutingInstructionsByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationExternalId External reservation ID.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutRoutingInstructionsByExtIdRequest
*/
func (a *ReservationApiService) PutRoutingInstructionsByExtId(ctx context.Context, reservationExternalId string, externalSystemCode string, hotelId string) ReservationApiPutRoutingInstructionsByExtIdRequest {
	return ReservationApiPutRoutingInstructionsByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationExternalId: reservationExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationApiService) PutRoutingInstructionsByExtIdExecute(r ReservationApiPutRoutingInstructionsByExtIdRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutRoutingInstructionsByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/reservations/{reservationExternalId}/routingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationExternalId"+"}", url.PathEscape(parameterValueToString(r.reservationExternalId, "reservationExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationExternalId) < 1 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have at least 1 elements")
	}
	if strlen(r.reservationExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.routingInstructionsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutSellMessageConfigRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	sellMessageConfig *PutSellMessageConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutSellMessageConfigRequest) Authorization(authorization string) ReservationApiPutSellMessageConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutSellMessageConfigRequest) XAppKey(xAppKey string) ReservationApiPutSellMessageConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutSellMessageConfigRequest) XHotelid(xHotelid string) ReservationApiPutSellMessageConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// This is the request message type for sell message update operation.
func (r ReservationApiPutSellMessageConfigRequest) SellMessageConfig(sellMessageConfig PutSellMessageConfigRequest) ReservationApiPutSellMessageConfigRequest {
	r.sellMessageConfig = &sellMessageConfig
	return r
}

// External system code.
func (r ReservationApiPutSellMessageConfigRequest) XExternalsystem(xExternalsystem string) ReservationApiPutSellMessageConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutSellMessageConfigRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutSellMessageConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutSellMessageConfigRequest) Execute() (*SellMessageConfig, *http.Response, error) {
	return r.ApiService.PutSellMessageConfigExecute(r)
}

/*
PutSellMessageConfig Change sell message

Update the existing sell message configuration for a property. <p><strong>OperationId:</strong>putSellMessageConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutSellMessageConfigRequest
*/
func (a *ReservationApiService) PutSellMessageConfig(ctx context.Context, hotelId string) ReservationApiPutSellMessageConfigRequest {
	return ReservationApiPutSellMessageConfigRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return SellMessageConfig
func (a *ReservationApiService) PutSellMessageConfigExecute(r ReservationApiPutSellMessageConfigRequest) (*SellMessageConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SellMessageConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutSellMessageConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sellMessages/config"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.sellMessageConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutSellMessageConfigByChainRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	sellMessageConfig *PutSellMessageConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutSellMessageConfigByChainRequest) Authorization(authorization string) ReservationApiPutSellMessageConfigByChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutSellMessageConfigByChainRequest) XAppKey(xAppKey string) ReservationApiPutSellMessageConfigByChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutSellMessageConfigByChainRequest) XHotelid(xHotelid string) ReservationApiPutSellMessageConfigByChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// This is the request message type for sell message update operation.
func (r ReservationApiPutSellMessageConfigByChainRequest) SellMessageConfig(sellMessageConfig PutSellMessageConfigRequest) ReservationApiPutSellMessageConfigByChainRequest {
	r.sellMessageConfig = &sellMessageConfig
	return r
}

// External system code.
func (r ReservationApiPutSellMessageConfigByChainRequest) XExternalsystem(xExternalsystem string) ReservationApiPutSellMessageConfigByChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutSellMessageConfigByChainRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutSellMessageConfigByChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutSellMessageConfigByChainRequest) Execute() (*SellMessageConfig, *http.Response, error) {
	return r.ApiService.PutSellMessageConfigByChainExecute(r)
}

/*
PutSellMessageConfigByChain Change sell message by chain

Update the existing sell message configuration. <p><strong>OperationId:</strong>putSellMessageConfigByChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationApiPutSellMessageConfigByChainRequest
*/
func (a *ReservationApiService) PutSellMessageConfigByChain(ctx context.Context) ReservationApiPutSellMessageConfigByChainRequest {
	return ReservationApiPutSellMessageConfigByChainRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SellMessageConfig
func (a *ReservationApiService) PutSellMessageConfigByChainExecute(r ReservationApiPutSellMessageConfigByChainRequest) (*SellMessageConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SellMessageConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutSellMessageConfigByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sellMessages/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.sellMessageConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutShareRateAmountRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeShareRateAmount *PutShareRateAmountRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutShareRateAmountRequest) Authorization(authorization string) ReservationApiPutShareRateAmountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutShareRateAmountRequest) XAppKey(xAppKey string) ReservationApiPutShareRateAmountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutShareRateAmountRequest) XHotelid(xHotelid string) ReservationApiPutShareRateAmountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change the share amount for a sharer reservation. The amount change type can be Full, Entire or Split
func (r ReservationApiPutShareRateAmountRequest) ChangeShareRateAmount(changeShareRateAmount PutShareRateAmountRequest) ReservationApiPutShareRateAmountRequest {
	r.changeShareRateAmount = &changeShareRateAmount
	return r
}

// External system code.
func (r ReservationApiPutShareRateAmountRequest) XExternalsystem(xExternalsystem string) ReservationApiPutShareRateAmountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutShareRateAmountRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutShareRateAmountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutShareRateAmountRequest) Execute() (*ShareReservations, *http.Response, error) {
	return r.ApiService.PutShareRateAmountExecute(r)
}

/*
PutShareRateAmount Change Share Rate Amount

Change the share amounts of a reservation <p><strong>OperationId:</strong>putShareRateAmount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutShareRateAmountRequest
*/
func (a *ReservationApiService) PutShareRateAmount(ctx context.Context, reservationId string, hotelId string) ReservationApiPutShareRateAmountRequest {
	return ReservationApiPutShareRateAmountRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ShareReservations
func (a *ReservationApiService) PutShareRateAmountExecute(r ReservationApiPutShareRateAmountRequest) (*ShareReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShareReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutShareRateAmount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/shareRateAmount"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeShareRateAmount
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutSharingGuestsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeSharingGuests *PutSharingGuestsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutSharingGuestsRequest) Authorization(authorization string) ReservationApiPutSharingGuestsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutSharingGuestsRequest) XAppKey(xAppKey string) ReservationApiPutSharingGuestsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutSharingGuestsRequest) XHotelid(xHotelid string) ReservationApiPutSharingGuestsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change Sharing Reservations Guest Counts(adults or children) information.
func (r ReservationApiPutSharingGuestsRequest) ChangeSharingGuests(changeSharingGuests PutSharingGuestsRequest) ReservationApiPutSharingGuestsRequest {
	r.changeSharingGuests = &changeSharingGuests
	return r
}

// External system code.
func (r ReservationApiPutSharingGuestsRequest) XExternalsystem(xExternalsystem string) ReservationApiPutSharingGuestsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutSharingGuestsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutSharingGuestsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutSharingGuestsRequest) Execute() (*ChangeSharingGuests, *http.Response, error) {
	return r.ApiService.PutSharingGuestsExecute(r)
}

/*
PutSharingGuests Change Sharing Guests

Change the guest counts(adults or children) for a Sharing Reservation <p><strong>OperationId:</strong>putSharingGuests</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutSharingGuestsRequest
*/
func (a *ReservationApiService) PutSharingGuests(ctx context.Context, reservationId string, hotelId string) ReservationApiPutSharingGuestsRequest {
	return ReservationApiPutSharingGuestsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangeSharingGuests
func (a *ReservationApiService) PutSharingGuestsExecute(r ReservationApiPutSharingGuestsRequest) (*ChangeSharingGuests, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeSharingGuests
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutSharingGuests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/sharedGuestCount"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeSharingGuests
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutSplitMultiRoomReservationRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	authorization *string
	xAppKey *string
	xHotelid *string
	splitMultiRoomReservation *PutSplitMultiRoomReservationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutSplitMultiRoomReservationRequest) Authorization(authorization string) ReservationApiPutSplitMultiRoomReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutSplitMultiRoomReservationRequest) XAppKey(xAppKey string) ReservationApiPutSplitMultiRoomReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutSplitMultiRoomReservationRequest) XHotelid(xHotelid string) ReservationApiPutSplitMultiRoomReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to split multi-room reservation into separate reservations.
func (r ReservationApiPutSplitMultiRoomReservationRequest) SplitMultiRoomReservation(splitMultiRoomReservation PutSplitMultiRoomReservationRequest) ReservationApiPutSplitMultiRoomReservationRequest {
	r.splitMultiRoomReservation = &splitMultiRoomReservation
	return r
}

// External system code.
func (r ReservationApiPutSplitMultiRoomReservationRequest) XExternalsystem(xExternalsystem string) ReservationApiPutSplitMultiRoomReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutSplitMultiRoomReservationRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutSplitMultiRoomReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutSplitMultiRoomReservationRequest) Execute() (*SplitMultiRoomReservationDetails, *http.Response, error) {
	return r.ApiService.PutSplitMultiRoomReservationExecute(r)
}

/*
PutSplitMultiRoomReservation Split multi room Reservation

You can use this API to split a multi room reservation.  This will create a new confirmation number for the split reservation. <p><strong>OperationId:</strong>putSplitMultiRoomReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @return ReservationApiPutSplitMultiRoomReservationRequest
*/
func (a *ReservationApiService) PutSplitMultiRoomReservation(ctx context.Context, reservationId string) ReservationApiPutSplitMultiRoomReservationRequest {
	return ReservationApiPutSplitMultiRoomReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
	}
}

// Execute executes the request
//  @return SplitMultiRoomReservationDetails
func (a *ReservationApiService) PutSplitMultiRoomReservationExecute(r ReservationApiPutSplitMultiRoomReservationRequest) (*SplitMultiRoomReservationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SplitMultiRoomReservationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutSplitMultiRoomReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservations/{reservationId}/split"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.splitMultiRoomReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutTicketsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ticketsInfo *PutTicketsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutTicketsRequest) Authorization(authorization string) ReservationApiPutTicketsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutTicketsRequest) XAppKey(xAppKey string) ReservationApiPutTicketsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutTicketsRequest) XHotelid(xHotelid string) ReservationApiPutTicketsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Common tickets request base type.
func (r ReservationApiPutTicketsRequest) TicketsInfo(ticketsInfo PutTicketsRequest) ReservationApiPutTicketsRequest {
	r.ticketsInfo = &ticketsInfo
	return r
}

// External system code.
func (r ReservationApiPutTicketsRequest) XExternalsystem(xExternalsystem string) ReservationApiPutTicketsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutTicketsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutTicketsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutTicketsRequest) Execute() (*Tickets, *http.Response, error) {
	return r.ApiService.PutTicketsExecute(r)
}

/*
PutTickets Change tickets

Use this API to change tickets on a reservation. <p><strong>OperationId:</strong>putTickets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutTicketsRequest
*/
func (a *ReservationApiService) PutTickets(ctx context.Context, reservationId string, hotelId string) ReservationApiPutTicketsRequest {
	return ReservationApiPutTicketsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Tickets
func (a *ReservationApiService) PutTicketsExecute(r ReservationApiPutTicketsRequest) (*Tickets, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tickets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutTickets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/tickets"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ticketsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutTransactionDiversionsRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionDiversionsInfo *PutTransactionDiversionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutTransactionDiversionsRequest) Authorization(authorization string) ReservationApiPutTransactionDiversionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutTransactionDiversionsRequest) XAppKey(xAppKey string) ReservationApiPutTransactionDiversionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutTransactionDiversionsRequest) XHotelid(xHotelid string) ReservationApiPutTransactionDiversionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to modify transaction diversion rules attached to a reservation.
func (r ReservationApiPutTransactionDiversionsRequest) TransactionDiversionsInfo(transactionDiversionsInfo PutTransactionDiversionsRequest) ReservationApiPutTransactionDiversionsRequest {
	r.transactionDiversionsInfo = &transactionDiversionsInfo
	return r
}

// External system code.
func (r ReservationApiPutTransactionDiversionsRequest) XExternalsystem(xExternalsystem string) ReservationApiPutTransactionDiversionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutTransactionDiversionsRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutTransactionDiversionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutTransactionDiversionsRequest) Execute() (*TransactionDiversionsDetails, *http.Response, error) {
	return r.ApiService.PutTransactionDiversionsExecute(r)
}

/*
PutTransactionDiversions Change Transaction Diversions 

You can use this API to change Transaction Diversions. <p><strong>OperationId:</strong>putTransactionDiversions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutTransactionDiversionsRequest
*/
func (a *ReservationApiService) PutTransactionDiversions(ctx context.Context, reservationId string, hotelId string) ReservationApiPutTransactionDiversionsRequest {
	return ReservationApiPutTransactionDiversionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TransactionDiversionsDetails
func (a *ReservationApiService) PutTransactionDiversionsExecute(r ReservationApiPutTransactionDiversionsRequest) (*TransactionDiversionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionDiversionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutTransactionDiversions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/transactionDiversions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionDiversionsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutValidateOverlappingStayRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	overlappingStay *PutValidateOverlappingStayRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutValidateOverlappingStayRequest) Authorization(authorization string) ReservationApiPutValidateOverlappingStayRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutValidateOverlappingStayRequest) XAppKey(xAppKey string) ReservationApiPutValidateOverlappingStayRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutValidateOverlappingStayRequest) XHotelid(xHotelid string) ReservationApiPutValidateOverlappingStayRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to check for overlapping stays of reservations.
func (r ReservationApiPutValidateOverlappingStayRequest) OverlappingStay(overlappingStay PutValidateOverlappingStayRequest) ReservationApiPutValidateOverlappingStayRequest {
	r.overlappingStay = &overlappingStay
	return r
}

// External system code.
func (r ReservationApiPutValidateOverlappingStayRequest) XExternalsystem(xExternalsystem string) ReservationApiPutValidateOverlappingStayRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutValidateOverlappingStayRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutValidateOverlappingStayRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutValidateOverlappingStayRequest) Execute() (*OverlappingStayDetails, *http.Response, error) {
	return r.ApiService.PutValidateOverlappingStayExecute(r)
}

/*
PutValidateOverlappingStay Check overlapping stay

Validate overlapping stay for a reservation <p><strong>OperationId:</strong>putValidateOverlappingStay</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutValidateOverlappingStayRequest
*/
func (a *ReservationApiService) PutValidateOverlappingStay(ctx context.Context, reservationId string, hotelId string) ReservationApiPutValidateOverlappingStayRequest {
	return ReservationApiPutValidateOverlappingStayRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return OverlappingStayDetails
func (a *ReservationApiService) PutValidateOverlappingStayExecute(r ReservationApiPutValidateOverlappingStayRequest) (*OverlappingStayDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OverlappingStayDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutValidateOverlappingStay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/stay/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.overlappingStay
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutValidateOverlappingStaysRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	overlappingStay *PutValidateOverlappingStayRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutValidateOverlappingStaysRequest) Authorization(authorization string) ReservationApiPutValidateOverlappingStaysRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutValidateOverlappingStaysRequest) XAppKey(xAppKey string) ReservationApiPutValidateOverlappingStaysRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutValidateOverlappingStaysRequest) XHotelid(xHotelid string) ReservationApiPutValidateOverlappingStaysRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to check for overlapping stays of reservations.
func (r ReservationApiPutValidateOverlappingStaysRequest) OverlappingStay(overlappingStay PutValidateOverlappingStayRequest) ReservationApiPutValidateOverlappingStaysRequest {
	r.overlappingStay = &overlappingStay
	return r
}

// External system code.
func (r ReservationApiPutValidateOverlappingStaysRequest) XExternalsystem(xExternalsystem string) ReservationApiPutValidateOverlappingStaysRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutValidateOverlappingStaysRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutValidateOverlappingStaysRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutValidateOverlappingStaysRequest) Execute() (*OverlappingStayDetails, *http.Response, error) {
	return r.ApiService.PutValidateOverlappingStaysExecute(r)
}

/*
PutValidateOverlappingStays Check overlapping stay

Validate overlapping stays <p><strong>OperationId:</strong>putValidateOverlappingStays</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutValidateOverlappingStaysRequest
*/
func (a *ReservationApiService) PutValidateOverlappingStays(ctx context.Context, hotelId string) ReservationApiPutValidateOverlappingStaysRequest {
	return ReservationApiPutValidateOverlappingStaysRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return OverlappingStayDetails
func (a *ReservationApiService) PutValidateOverlappingStaysExecute(r ReservationApiPutValidateOverlappingStaysRequest) (*OverlappingStayDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OverlappingStayDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutValidateOverlappingStays")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/stay/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.overlappingStay
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiPutValidateReservationChangesRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	validateReservationChanges *PutValidateReservationChangesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiPutValidateReservationChangesRequest) Authorization(authorization string) ReservationApiPutValidateReservationChangesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiPutValidateReservationChangesRequest) XAppKey(xAppKey string) ReservationApiPutValidateReservationChangesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiPutValidateReservationChangesRequest) XHotelid(xHotelid string) ReservationApiPutValidateReservationChangesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to validate reservation changes.
func (r ReservationApiPutValidateReservationChangesRequest) ValidateReservationChanges(validateReservationChanges PutValidateReservationChangesRequest) ReservationApiPutValidateReservationChangesRequest {
	r.validateReservationChanges = &validateReservationChanges
	return r
}

// External system code.
func (r ReservationApiPutValidateReservationChangesRequest) XExternalsystem(xExternalsystem string) ReservationApiPutValidateReservationChangesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiPutValidateReservationChangesRequest) AcceptLanguage(acceptLanguage string) ReservationApiPutValidateReservationChangesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiPutValidateReservationChangesRequest) Execute() (*ValidateReservationChangesDetails, *http.Response, error) {
	return r.ApiService.PutValidateReservationChangesExecute(r)
}

/*
PutValidateReservationChanges Validate Reservation Change

Use this API to validate either the guarantee type or stay details of a reservation you are about to create. <p><strong>OperationId:</strong>putValidateReservationChanges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiPutValidateReservationChangesRequest
*/
func (a *ReservationApiService) PutValidateReservationChanges(ctx context.Context, hotelId string) ReservationApiPutValidateReservationChangesRequest {
	return ReservationApiPutValidateReservationChangesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ValidateReservationChangesDetails
func (a *ReservationApiService) PutValidateReservationChangesExecute(r ReservationApiPutValidateReservationChangesRequest) (*ValidateReservationChangesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateReservationChangesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.PutValidateReservationChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/validations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.validateReservationChanges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationApiValidateRateInfoRequest struct {
	ctx context.Context
	ApiService *ReservationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	validateRateInfo *ValidateRateInfoRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationApiValidateRateInfoRequest) Authorization(authorization string) ReservationApiValidateRateInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationApiValidateRateInfoRequest) XAppKey(xAppKey string) ReservationApiValidateRateInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationApiValidateRateInfoRequest) XHotelid(xHotelid string) ReservationApiValidateRateInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Retrieve either the reservation&#39;s rate information or make a quotation for a rate information. SummaryInfo attribute specifies if the item being requested is of detail or summary type.
func (r ReservationApiValidateRateInfoRequest) ValidateRateInfo(validateRateInfo ValidateRateInfoRequest) ReservationApiValidateRateInfoRequest {
	r.validateRateInfo = &validateRateInfo
	return r
}

// External system code.
func (r ReservationApiValidateRateInfoRequest) XExternalsystem(xExternalsystem string) ReservationApiValidateRateInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationApiValidateRateInfoRequest) AcceptLanguage(acceptLanguage string) ReservationApiValidateRateInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationApiValidateRateInfoRequest) Execute() (*RateInfo, *http.Response, error) {
	return r.ApiService.ValidateRateInfoExecute(r)
}

/*
ValidateRateInfo Validate rate information

Validate the rate plan information for a reservation. <p><strong>OperationId:</strong>validateRateInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where reservation is searched based on reservation ID.
 @return ReservationApiValidateRateInfoRequest
*/
func (a *ReservationApiService) ValidateRateInfo(ctx context.Context, hotelId string) ReservationApiValidateRateInfoRequest {
	return ReservationApiValidateRateInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RateInfo
func (a *ReservationApiService) ValidateRateInfoExecute(r ReservationApiValidateRateInfoRequest) (*RateInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RateInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.ValidateRateInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rateInfoValidation"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.validateRateInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
