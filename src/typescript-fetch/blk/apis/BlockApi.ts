/* tslint:disable */
/* eslint-disable */
/**
 * OPERA Cloud Block API
 * APIs to cater for Business Block functionality in OPERA Cloud. <br /><br /> A block is a group of rooms held for guests who are attending an event, meeting, or function. You can create blocks for family reunions, business conferences, weddings, and so on. You can also set aside rooms for the event (block).<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>
 *
 * The version of the OpenAPI document: 23.2
 * Contact: hospitality_apis_ww_grp@oracle.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AllRestrictions,
  Allocation,
  Block,
  BlockAccessExclusion,
  BlockAccessExclusionInfo,
  BlockActivityLog,
  BlockAllocationRange,
  BlockAllocationWash,
  BlockAlternateDates,
  BlockAttachments,
  BlockAvailability,
  BlockChanged,
  BlockCodeToValidate,
  BlockCopy,
  BlockDailyStatistics,
  BlockOwners,
  BlockOwnersToAssign,
  BlockOwnersToChange,
  BlockPMReservations,
  BlockPostingMaster,
  BlockRangeInfo,
  BlockReservations,
  BlockReservationsToChange,
  BlockRestriction,
  BlockRestrictions,
  BlockRevenueChanges,
  BlockRoomTypes,
  BlockRoomsStatus,
  BlockStatistics,
  BlockStatus,
  BlockStatusChanges,
  BlockStatusToChange,
  BlockSummaries,
  BlockToBeChanged,
  BlockToCancel,
  BlockToShift,
  BlockValidate,
  BlockWashInfo,
  BlockWashSchedules,
  BlockWashSchedulesInfo,
  BorrowedInventoryToReturn,
  CateringStatusToChange,
  ChangedBlockReservations,
  ChangedBlockStatus,
  ChangedCateringStatus,
  DefaultBlockCodeDetails,
  ExceptionDetailType,
  InventoryToBorrow,
  InventoryToBorrowInfo,
  NextBlockStatus,
  RateOverride,
  RateOverrideStatus,
  RecentlyAccessedBlocks,
  RoomTypeOrder,
  RoomingList,
  RoomingListDetails,
  SalesAllowances,
  ShiftedBlock,
  Status,
  SubAllocation,
  SubBlock,
  TourSeries,
  TracesByDateRange,
} from '../models/index';
import {
    AllRestrictionsFromJSON,
    AllRestrictionsToJSON,
    AllocationFromJSON,
    AllocationToJSON,
    BlockFromJSON,
    BlockToJSON,
    BlockAccessExclusionFromJSON,
    BlockAccessExclusionToJSON,
    BlockAccessExclusionInfoFromJSON,
    BlockAccessExclusionInfoToJSON,
    BlockActivityLogFromJSON,
    BlockActivityLogToJSON,
    BlockAllocationRangeFromJSON,
    BlockAllocationRangeToJSON,
    BlockAllocationWashFromJSON,
    BlockAllocationWashToJSON,
    BlockAlternateDatesFromJSON,
    BlockAlternateDatesToJSON,
    BlockAttachmentsFromJSON,
    BlockAttachmentsToJSON,
    BlockAvailabilityFromJSON,
    BlockAvailabilityToJSON,
    BlockChangedFromJSON,
    BlockChangedToJSON,
    BlockCodeToValidateFromJSON,
    BlockCodeToValidateToJSON,
    BlockCopyFromJSON,
    BlockCopyToJSON,
    BlockDailyStatisticsFromJSON,
    BlockDailyStatisticsToJSON,
    BlockOwnersFromJSON,
    BlockOwnersToJSON,
    BlockOwnersToAssignFromJSON,
    BlockOwnersToAssignToJSON,
    BlockOwnersToChangeFromJSON,
    BlockOwnersToChangeToJSON,
    BlockPMReservationsFromJSON,
    BlockPMReservationsToJSON,
    BlockPostingMasterFromJSON,
    BlockPostingMasterToJSON,
    BlockRangeInfoFromJSON,
    BlockRangeInfoToJSON,
    BlockReservationsFromJSON,
    BlockReservationsToJSON,
    BlockReservationsToChangeFromJSON,
    BlockReservationsToChangeToJSON,
    BlockRestrictionFromJSON,
    BlockRestrictionToJSON,
    BlockRestrictionsFromJSON,
    BlockRestrictionsToJSON,
    BlockRevenueChangesFromJSON,
    BlockRevenueChangesToJSON,
    BlockRoomTypesFromJSON,
    BlockRoomTypesToJSON,
    BlockRoomsStatusFromJSON,
    BlockRoomsStatusToJSON,
    BlockStatisticsFromJSON,
    BlockStatisticsToJSON,
    BlockStatusFromJSON,
    BlockStatusToJSON,
    BlockStatusChangesFromJSON,
    BlockStatusChangesToJSON,
    BlockStatusToChangeFromJSON,
    BlockStatusToChangeToJSON,
    BlockSummariesFromJSON,
    BlockSummariesToJSON,
    BlockToBeChangedFromJSON,
    BlockToBeChangedToJSON,
    BlockToCancelFromJSON,
    BlockToCancelToJSON,
    BlockToShiftFromJSON,
    BlockToShiftToJSON,
    BlockValidateFromJSON,
    BlockValidateToJSON,
    BlockWashInfoFromJSON,
    BlockWashInfoToJSON,
    BlockWashSchedulesFromJSON,
    BlockWashSchedulesToJSON,
    BlockWashSchedulesInfoFromJSON,
    BlockWashSchedulesInfoToJSON,
    BorrowedInventoryToReturnFromJSON,
    BorrowedInventoryToReturnToJSON,
    CateringStatusToChangeFromJSON,
    CateringStatusToChangeToJSON,
    ChangedBlockReservationsFromJSON,
    ChangedBlockReservationsToJSON,
    ChangedBlockStatusFromJSON,
    ChangedBlockStatusToJSON,
    ChangedCateringStatusFromJSON,
    ChangedCateringStatusToJSON,
    DefaultBlockCodeDetailsFromJSON,
    DefaultBlockCodeDetailsToJSON,
    ExceptionDetailTypeFromJSON,
    ExceptionDetailTypeToJSON,
    InventoryToBorrowFromJSON,
    InventoryToBorrowToJSON,
    InventoryToBorrowInfoFromJSON,
    InventoryToBorrowInfoToJSON,
    NextBlockStatusFromJSON,
    NextBlockStatusToJSON,
    RateOverrideFromJSON,
    RateOverrideToJSON,
    RateOverrideStatusFromJSON,
    RateOverrideStatusToJSON,
    RecentlyAccessedBlocksFromJSON,
    RecentlyAccessedBlocksToJSON,
    RoomTypeOrderFromJSON,
    RoomTypeOrderToJSON,
    RoomingListFromJSON,
    RoomingListToJSON,
    RoomingListDetailsFromJSON,
    RoomingListDetailsToJSON,
    SalesAllowancesFromJSON,
    SalesAllowancesToJSON,
    ShiftedBlockFromJSON,
    ShiftedBlockToJSON,
    StatusFromJSON,
    StatusToJSON,
    SubAllocationFromJSON,
    SubAllocationToJSON,
    SubBlockFromJSON,
    SubBlockToJSON,
    TourSeriesFromJSON,
    TourSeriesToJSON,
    TracesByDateRangeFromJSON,
    TracesByDateRangeToJSON,
} from '../models/index';

export interface ChangeRateOverrideRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    rateOverride: RateOverride;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteAlternateDatesRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockAccessExclusionRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    allowCancelReservation?: boolean;
    allowCreateReservation?: boolean;
    allowModifyReservation?: boolean;
    excludeFromAvailability?: boolean;
    inactive?: boolean;
    sourceType?: string;
    sourceValue?: string;
    hotelId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockAttachmentRequest {
    attachId: string;
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockOwnersRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockRestrictionRequest {
    blockId: string;
    hotelId: string;
    startDate: string;
    endDate: string;
    code: DeleteBlockRestrictionCodeEnum;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockWashSchedulesRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    markAsRecentlyAccessed?: boolean;
    fetchInstructions?: Set<GetBlockFetchInstructionsEnum>;
    fetchAllocatedRoomTypes?: boolean;
    startDate?: string;
    numberOfDays?: number;
    roomAllocationCriteria?: Set<GetBlockRoomAllocationCriteriaEnum>;
    roomTypes?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockAccessExclusionRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockActivityLogRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    limit?: number;
    offset?: number;
    hotelId?: string;
    module?: GetBlockActivityLogModuleEnum;
    moduleParamsParameterName?: Array<string>;
    moduleParamsParameterValue?: Array<string>;
    activityGroup?: string;
    activityType?: string;
    activityParamsFromDate?: string;
    activityParamsToDate?: string;
    activityParamsSearchText?: string;
    userByIDsUserId?: Array<number>;
    userForIDsUserId?: Array<number>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockAttachmentsRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockAvailabilityRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    overrideRateCode?: boolean;
    arrivalDate?: string;
    nights?: number;
    adults?: number;
    children?: number;
    rooms?: number;
    ratePlanCode?: string;
    existingReservationId?: string;
    existingReservationIdType?: string;
    roomType?: Array<string>;
    fetchAllocatedRoomType?: Set<GetBlockAvailabilityFetchAllocatedRoomTypeEnum>;
    roomTypeCount?: number;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockByExtIdRequest {
    blockExternalId: string;
    externalSystemCode: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    markAsRecentlyAccessed?: boolean;
    fetchInstructions?: Set<GetBlockByExtIdFetchInstructionsEnum>;
    fetchAllocatedRoomTypes?: boolean;
    startDate?: string;
    numberOfDays?: number;
    roomAllocationCriteria?: Set<GetBlockByExtIdRoomAllocationCriteriaEnum>;
    roomTypes?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockDailyStatisticsRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    genericRoomType?: boolean;
    limit?: number;
    offset?: number;
    hotelId?: string;
    end?: string;
    start?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockOwnersRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockPMReservationsRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    postingmaster?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockPMReservationsByExtIdRequest {
    blockExternalId: string;
    externalSystemCode: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    postingmaster?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockRangeInfoRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    genericRoomType?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockReservationsRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    fetchInstructions?: Set<GetBlockReservationsFetchInstructionsEnum>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockRestrictionsRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    startDate?: string;
    endDate?: string;
    duration?: string;
    roomType?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockRevenueChangesRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    limit?: number;
    offset?: number;
    hotelId?: string;
    status?: Array<string>;
    changeEndDate?: string;
    changeStartDate?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockRoomTypesRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    fetchAllocatedRoomTypes?: boolean;
    startDate?: string;
    endDate?: string;
    fetchGenericRoomTypes?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockRoomsStatusRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockStatisticsRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    startDate?: string;
    numberOfDays?: number;
    statisticsInstructions?: Set<GetBlockStatisticsStatisticsInstructionsEnum>;
    roomTypeHotelId?: Array<string>;
    invBlockCode?: Array<string>;
    promotionCode?: Array<string>;
    roomCategory?: Array<string>;
    roomClass?: Array<string>;
    roomQualifierCode?: Array<string>;
    roomQualifierMatchIndicator?: Array<string>;
    roomType?: Array<string>;
    roomViewCode?: Array<string>;
    roomFeatureCode?: Array<string>;
    defaultOccupancy?: number;
    maximumOccupancy?: number;
    noOfPhysicalRooms?: number;
    bookingChannelCode?: Array<string>;
    bookingChannelMappingCode?: Array<string>;
    bookingChannelMappingName?: Array<string>;
    bedTypeCode?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockStatusChangesRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    limit?: number;
    offset?: number;
    hotelId?: string;
    changeEndDate?: string;
    changeStartDate?: string;
    currentStatus?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockWashInfoRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    blockId?: string;
    blockIdType?: string;
    genericRoomType?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockWashSchedulesRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlocksRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    markAsRecentlyAccessed?: boolean;
    limit?: number;
    offset?: number;
    multipleHotelsSearchHotelIds?: Array<string>;
    superSearch?: string;
    blockIdList?: Array<string>;
    blockIdType?: Array<string>;
    externalReferenceIds?: Array<string>;
    externalSystemCodes?: Array<string>;
    blockCode?: string;
    blockName?: string;
    blockOwner?: Array<string>;
    blockStatus?: Array<string>;
    cateringStatus?: Array<string>;
    createdByUser?: string;
    blockStartEndDate?: string;
    blockStartStartDate?: string;
    blockEndEndDate?: string;
    blockEndStartDate?: string;
    reservationArrival?: string;
    reservationDeparture?: string;
    includeShoulderDates?: boolean;
    stayDate?: string;
    blockCreatedOnEndDate?: string;
    blockCreatedOnStartDate?: string;
    decisionEndDate?: string;
    decisionStartDate?: string;
    cutOffEndDate?: string;
    cutOffStartDate?: string;
    category?: Set<GetBlocksCategoryEnum>;
    name?: Array<string>;
    attachedProfileId?: string;
    attachedProfileIdType?: string;
    leads?: boolean;
    tourSeries?: boolean;
    onlyPickupBlocks?: boolean;
    onlyOpportunities?: boolean;
    ratePlanCode?: Array<string>;
    tourCode?: string;
    attributeName?: Array<string>;
    orderType?: Set<GetBlocksOrderTypeEnum>;
    fetchInstructions?: Set<GetBlocksFetchInstructionsEnum>;
    fetchAllocatedRoomTypes?: boolean;
    additionalCriteriaStartDate?: string;
    numberOfDays?: number;
    adults?: number;
    children?: number;
    childAge?: Array<number>;
    bucket1Count?: number;
    bucket2Count?: number;
    bucket3Count?: number;
    bucket4Count?: number;
    bucket5Count?: number;
    existingReservationId?: string;
    existingReservationIdType?: string;
    roomAllocationCriteria?: Set<GetBlocksRoomAllocationCriteriaEnum>;
    roomType?: Array<string>;
    additionalCriteriaRatePlanCode?: string;
    currencyCode?: string;
    customCharUDFsAltname?: Array<string>;
    customCharUDFsName?: Array<string>;
    customCharUDFsValue?: Array<string>;
    customNumericUDFsAltname?: Array<string>;
    customNumericUDFsName?: Array<string>;
    customNumericUDFsValue?: Array<number>;
    customDateUDFsAltname?: Array<string>;
    customDateUDFsName?: Array<string>;
    customDateUDFsValue?: Array<string>;
    accessRestriction?: Set<GetBlocksAccessRestrictionEnum>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetDefaultBlockCodeRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    blockName?: string;
    startDate?: string;
    blockCodeTemplate?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetInventoryToBorrowRequest {
    hotelId: string;
    blockId: string;
    startDate: string;
    requiredRooms: Array<number>;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockIdContext?: string;
    blockIdType?: string;
    existingReservationId?: string;
    existingReservationIdType?: string;
    roomType?: string;
    endDate?: string;
    duration?: string;
    numberOfRooms?: number;
    borrowDate?: Array<string>;
    overrideRateCode?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetNextBlockStatusRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    currentStatus?: string;
    includeCateringStatus?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetRecentlyAccessedBlocksRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetSalesAllowancesRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    ceilingId?: Array<number>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetTracesByDateRangeRequest {
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelIds?: Array<string>;
    beginDate?: string;
    endDate?: string;
    department?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostAlternateDatesRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockAlternateDates: BlockAlternateDates;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostBlockRequest {
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    block: Block;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostBlockOwnersRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockOwnersToAssign: BlockOwnersToAssign;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostBlockPostingMasterRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockPostingMaster: BlockPostingMaster;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostBlockRestrictionRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockRestriction: BlockRestriction;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostBlockValidateRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockValidate: BlockValidate;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostBlockWashSchedulesRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockWashSchedulesInfo: BlockWashSchedulesInfo;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostCancelBlockRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockToCancel: BlockToCancel;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostCopyBlockRequest {
    sourceBlockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockCopy: BlockCopy;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostRoomingListRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    roomingList: RoomingList;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostSubAllocationRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    subAllocation: SubAllocation;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostSubBlockRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    subBlock: SubBlock;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostSubBlockByExtIdRequest {
    blockExternalId: string;
    externalSystemCode: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    subBlock: SubBlock;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostTourSeriesRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    tourSeries: TourSeries;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutAlternateDatesRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockAlternateDates: BlockAlternateDates;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockToBeChanged: BlockToBeChanged;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockAccessExclusionRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockAccessExclusion: BlockAccessExclusion;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockAllocationRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    allocation: Allocation;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockAllocationByExtIdRequest {
    roomType: string;
    blockExternalId: string;
    externalSystemCode: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    allocation: Allocation;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockAllocationRangeRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockAllocationRange: BlockAllocationRange;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockAllocationRangeByExtIdRequest {
    blockExternalId: string;
    externalSystemCode: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockAllocationRange: BlockAllocationRange;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockAllocationWashRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockAllocationWash: BlockAllocationWash;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockByExtIdRequest {
    blockExternalId: string;
    externalSystemCode: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockToBeChanged: BlockToBeChanged;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockCutoffRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockStatus: BlockStatus;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockOwnersRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockOwnersToChange: BlockOwnersToChange;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockRatesRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockStatus: BlockStatus;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockReservationsRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockReservationsToChange: BlockReservationsToChange;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockShiftRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockToShift: BlockToShift;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockStatusRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockStatusToChange: BlockStatusToChange;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockStatusByExtIdRequest {
    blockExternalId: string;
    externalSystemCode: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockStatusToChange: BlockStatusToChange;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockStatusToOpenRequest {
    blockId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockStatus: BlockStatus;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockWashSchedulesRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockWashSchedulesInfo: BlockWashSchedulesInfo;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutCateringStatusRequest {
    eventId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    cateringStatusToChange: CateringStatusToChange;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutClearAllRestrictionsRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    allRestrictions: AllRestrictions;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutContractDefaultsRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockStatus: BlockStatus;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutInventoryRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    inventoryToBorrow: InventoryToBorrow;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutReleasedInventoryRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    borrowedInventoryToReturn: BorrowedInventoryToReturn;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutRoomTypeOrderRequest {
    blockId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    roomTypeOrder: RoomTypeOrder;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutValidateBlockCodeRequest {
    blockCode: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockCodeToValidate: BlockCodeToValidate;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

/**
 * 
 */
export class BlockApi extends runtime.BaseAPI {

    /**
     * Use this API to change rate override. <p><strong>OperationId:</strong>changeRateOverride</p>
     * Change rate override
     */
    async changeRateOverrideRaw(requestParameters: ChangeRateOverrideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RateOverrideStatus>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling changeRateOverride.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling changeRateOverride.');
        }
        
        if (requestParameters.rateOverride === null || requestParameters.rateOverride === undefined) {
            throw new runtime.RequiredError('rateOverride','Required parameter requestParameters.rateOverride was null or undefined when calling changeRateOverride.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/rate/override`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RateOverrideToJSON(requestParameters.rateOverride),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RateOverrideStatusFromJSON(jsonValue));
    }

    /**
     * Use this API to change rate override. <p><strong>OperationId:</strong>changeRateOverride</p>
     * Change rate override
     */
    async changeRateOverride(requestParameters: ChangeRateOverrideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RateOverrideStatus> {
        const response = await this.changeRateOverrideRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete alternate dates for a block. <p><strong>OperationId:</strong>deleteAlternateDates</p>
     * Delete alternate dates for a Block
     */
    async deleteAlternateDatesRaw(requestParameters: DeleteAlternateDatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling deleteAlternateDates.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/alternateDates`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete alternate dates for a block. <p><strong>OperationId:</strong>deleteAlternateDates</p>
     * Delete alternate dates for a Block
     */
    async deleteAlternateDates(requestParameters: DeleteAlternateDatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteAlternateDatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete block, if any reservations attached to the block, you will be unable to delete.  <p><strong>OperationId:</strong>deleteBlock</p>
     * Delete a Block
     */
    async deleteBlockRaw(requestParameters: DeleteBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling deleteBlock.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling deleteBlock.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete block, if any reservations attached to the block, you will be unable to delete.  <p><strong>OperationId:</strong>deleteBlock</p>
     * Delete a Block
     */
    async deleteBlock(requestParameters: DeleteBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete block access exclusion <p><strong>OperationId:</strong>deleteBlockAccessExclusion</p>
     * Delete Block access exclusion
     */
    async deleteBlockAccessExclusionRaw(requestParameters: DeleteBlockAccessExclusionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling deleteBlockAccessExclusion.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.allowCancelReservation !== undefined) {
            queryParameters['allowCancelReservation'] = requestParameters.allowCancelReservation;
        }

        if (requestParameters.allowCreateReservation !== undefined) {
            queryParameters['allowCreateReservation'] = requestParameters.allowCreateReservation;
        }

        if (requestParameters.allowModifyReservation !== undefined) {
            queryParameters['allowModifyReservation'] = requestParameters.allowModifyReservation;
        }

        if (requestParameters.excludeFromAvailability !== undefined) {
            queryParameters['excludeFromAvailability'] = requestParameters.excludeFromAvailability;
        }

        if (requestParameters.inactive !== undefined) {
            queryParameters['inactive'] = requestParameters.inactive;
        }

        if (requestParameters.sourceType !== undefined) {
            queryParameters['sourceType'] = requestParameters.sourceType;
        }

        if (requestParameters.sourceValue !== undefined) {
            queryParameters['sourceValue'] = requestParameters.sourceValue;
        }

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/blockAccessExclusion`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete block access exclusion <p><strong>OperationId:</strong>deleteBlockAccessExclusion</p>
     * Delete Block access exclusion
     */
    async deleteBlockAccessExclusion(requestParameters: DeleteBlockAccessExclusionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockAccessExclusionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API remove block attachments. <p><strong>OperationId:</strong>deleteBlockAttachment</p>
     * Delete Block Attachment
     */
    async deleteBlockAttachmentRaw(requestParameters: DeleteBlockAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.attachId === null || requestParameters.attachId === undefined) {
            throw new runtime.RequiredError('attachId','Required parameter requestParameters.attachId was null or undefined when calling deleteBlockAttachment.');
        }
        
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling deleteBlockAttachment.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/attachments/{attachId}`.replace(`{${"attachId"}}`, encodeURIComponent(String(requestParameters.attachId))).replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API remove block attachments. <p><strong>OperationId:</strong>deleteBlockAttachment</p>
     * Delete Block Attachment
     */
    async deleteBlockAttachment(requestParameters: DeleteBlockAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockAttachmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete a block owner. <p><strong>OperationId:</strong>deleteBlockOwners</p>
     * Delete a Block owner
     */
    async deleteBlockOwnersRaw(requestParameters: DeleteBlockOwnersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling deleteBlockOwners.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/owners`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete a block owner. <p><strong>OperationId:</strong>deleteBlockOwners</p>
     * Delete a Block owner
     */
    async deleteBlockOwners(requestParameters: DeleteBlockOwnersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockOwnersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete block restrictions. <p><strong>OperationId:</strong>deleteBlockRestriction</p>
     * Delete Block Restriction
     */
    async deleteBlockRestrictionRaw(requestParameters: DeleteBlockRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling deleteBlockRestriction.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling deleteBlockRestriction.');
        }
        
        if (requestParameters.startDate === null || requestParameters.startDate === undefined) {
            throw new runtime.RequiredError('startDate','Required parameter requestParameters.startDate was null or undefined when calling deleteBlockRestriction.');
        }
        
        if (requestParameters.endDate === null || requestParameters.endDate === undefined) {
            throw new runtime.RequiredError('endDate','Required parameter requestParameters.endDate was null or undefined when calling deleteBlockRestriction.');
        }
        
        if (requestParameters.code === null || requestParameters.code === undefined) {
            throw new runtime.RequiredError('code','Required parameter requestParameters.code was null or undefined when calling deleteBlockRestriction.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = requestParameters.startDate;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = requestParameters.endDate;
        }

        if (requestParameters.code !== undefined) {
            queryParameters['code'] = requestParameters.code;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/restrictions`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete block restrictions. <p><strong>OperationId:</strong>deleteBlockRestriction</p>
     * Delete Block Restriction
     */
    async deleteBlockRestriction(requestParameters: DeleteBlockRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockRestrictionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to remove block wash schedules based on the HotelCode, Block ID and Wash Date. <p><strong>OperationId:</strong>deleteBlockWashSchedules</p>
     * Remove Block Wash Schedules
     */
    async deleteBlockWashSchedulesRaw(requestParameters: DeleteBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling deleteBlockWashSchedules.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/washSchedules`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to remove block wash schedules based on the HotelCode, Block ID and Wash Date. <p><strong>OperationId:</strong>deleteBlockWashSchedules</p>
     * Remove Block Wash Schedules
     */
    async deleteBlockWashSchedules(requestParameters: DeleteBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockWashSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve a specific block.  You will need to know the blockID in the request; if you don\'t know it, please go ahead and use getBlocks API first.  The response will include detailed information about the block. <p><strong>OperationId:</strong>getBlock</p>
     * Get a Block By ID
     */
    async getBlockRaw(requestParameters: GetBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Block>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlock.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getBlock.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.markAsRecentlyAccessed !== undefined) {
            queryParameters['markAsRecentlyAccessed'] = requestParameters.markAsRecentlyAccessed;
        }

        if (requestParameters.fetchInstructions) {
            queryParameters['fetchInstructions'] = requestParameters.fetchInstructions;
        }

        if (requestParameters.fetchAllocatedRoomTypes !== undefined) {
            queryParameters['fetchAllocatedRoomTypes'] = requestParameters.fetchAllocatedRoomTypes;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = requestParameters.startDate;
        }

        if (requestParameters.numberOfDays !== undefined) {
            queryParameters['numberOfDays'] = requestParameters.numberOfDays;
        }

        if (requestParameters.roomAllocationCriteria) {
            queryParameters['roomAllocationCriteria'] = requestParameters.roomAllocationCriteria;
        }

        if (requestParameters.roomTypes) {
            queryParameters['roomTypes'] = requestParameters.roomTypes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve a specific block.  You will need to know the blockID in the request; if you don\'t know it, please go ahead and use getBlocks API first.  The response will include detailed information about the block. <p><strong>OperationId:</strong>getBlock</p>
     * Get a Block By ID
     */
    async getBlock(requestParameters: GetBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Block> {
        const response = await this.getBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API retrieves block exclusion information. <p><strong>OperationId:</strong>getBlockAccessExclusion</p>
     * Get Block exclusion information
     */
    async getBlockAccessExclusionRaw(requestParameters: GetBlockAccessExclusionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockAccessExclusionInfo>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockAccessExclusion.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/blockAccessExclusion`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockAccessExclusionInfoFromJSON(jsonValue));
    }

    /**
     * This API retrieves block exclusion information. <p><strong>OperationId:</strong>getBlockAccessExclusion</p>
     * Get Block exclusion information
     */
    async getBlockAccessExclusion(requestParameters: GetBlockAccessExclusionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockAccessExclusionInfo> {
        const response = await this.getBlockAccessExclusionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to facilitate retrieving the block activity log. <p><strong>OperationId:</strong>getBlockActivityLog</p>
     * Get the Block activity log
     */
    async getBlockActivityLogRaw(requestParameters: GetBlockActivityLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockActivityLog>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.module !== undefined) {
            queryParameters['module'] = requestParameters.module;
        }

        if (requestParameters.moduleParamsParameterName) {
            queryParameters['moduleParamsParameterName'] = requestParameters.moduleParamsParameterName;
        }

        if (requestParameters.moduleParamsParameterValue) {
            queryParameters['moduleParamsParameterValue'] = requestParameters.moduleParamsParameterValue;
        }

        if (requestParameters.activityGroup !== undefined) {
            queryParameters['activityGroup'] = requestParameters.activityGroup;
        }

        if (requestParameters.activityType !== undefined) {
            queryParameters['activityType'] = requestParameters.activityType;
        }

        if (requestParameters.activityParamsFromDate !== undefined) {
            queryParameters['activityParamsFromDate'] = requestParameters.activityParamsFromDate;
        }

        if (requestParameters.activityParamsToDate !== undefined) {
            queryParameters['activityParamsToDate'] = requestParameters.activityParamsToDate;
        }

        if (requestParameters.activityParamsSearchText !== undefined) {
            queryParameters['activityParamsSearchText'] = requestParameters.activityParamsSearchText;
        }

        if (requestParameters.userByIDsUserId) {
            queryParameters['userByIDsUserId'] = requestParameters.userByIDsUserId;
        }

        if (requestParameters.userForIDsUserId) {
            queryParameters['userForIDsUserId'] = requestParameters.userForIDsUserId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blockActivityLog`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockActivityLogFromJSON(jsonValue));
    }

    /**
     * Use this API to facilitate retrieving the block activity log. <p><strong>OperationId:</strong>getBlockActivityLog</p>
     * Get the Block activity log
     */
    async getBlockActivityLog(requestParameters: GetBlockActivityLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockActivityLog> {
        const response = await this.getBlockActivityLogRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve block attachments. <p><strong>OperationId:</strong>getBlockAttachments</p>
     * Get Block Attachments
     */
    async getBlockAttachmentsRaw(requestParameters: GetBlockAttachmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockAttachments>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockAttachments.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/attachments`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockAttachmentsFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve block attachments. <p><strong>OperationId:</strong>getBlockAttachments</p>
     * Get Block Attachments
     */
    async getBlockAttachments(requestParameters: GetBlockAttachmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockAttachments> {
        const response = await this.getBlockAttachmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to search for availability on an OPERA block.  You will need to know the block ID.  Once you know what rooms and rates are available you can proceed to post a block reservation. <p><strong>OperationId:</strong>getBlockAvailability</p>
     * Get Block AvailaBility
     */
    async getBlockAvailabilityRaw(requestParameters: GetBlockAvailabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockAvailability>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockAvailability.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getBlockAvailability.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.overrideRateCode !== undefined) {
            queryParameters['overrideRateCode'] = requestParameters.overrideRateCode;
        }

        if (requestParameters.arrivalDate !== undefined) {
            queryParameters['arrivalDate'] = requestParameters.arrivalDate;
        }

        if (requestParameters.nights !== undefined) {
            queryParameters['nights'] = requestParameters.nights;
        }

        if (requestParameters.adults !== undefined) {
            queryParameters['adults'] = requestParameters.adults;
        }

        if (requestParameters.children !== undefined) {
            queryParameters['children'] = requestParameters.children;
        }

        if (requestParameters.rooms !== undefined) {
            queryParameters['rooms'] = requestParameters.rooms;
        }

        if (requestParameters.ratePlanCode !== undefined) {
            queryParameters['ratePlanCode'] = requestParameters.ratePlanCode;
        }

        if (requestParameters.existingReservationId !== undefined) {
            queryParameters['existingReservationId'] = requestParameters.existingReservationId;
        }

        if (requestParameters.existingReservationIdType !== undefined) {
            queryParameters['existingReservationIdType'] = requestParameters.existingReservationIdType;
        }

        if (requestParameters.roomType) {
            queryParameters['roomType'] = requestParameters.roomType;
        }

        if (requestParameters.fetchAllocatedRoomType) {
            queryParameters['fetchAllocatedRoomType'] = requestParameters.fetchAllocatedRoomType;
        }

        if (requestParameters.roomTypeCount !== undefined) {
            queryParameters['roomTypeCount'] = requestParameters.roomTypeCount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/availability`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockAvailabilityFromJSON(jsonValue));
    }

    /**
     * Use this API to search for availability on an OPERA block.  You will need to know the block ID.  Once you know what rooms and rates are available you can proceed to post a block reservation. <p><strong>OperationId:</strong>getBlockAvailability</p>
     * Get Block AvailaBility
     */
    async getBlockAvailability(requestParameters: GetBlockAvailabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockAvailability> {
        const response = await this.getBlockAvailabilityRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve a specific block.  You will need to know the blockID in the request; if you don\'t know it, please go ahead and use getBlocks API first.  The response will include detailed information about the block. <p><strong>OperationId:</strong>getBlockByExtId</p>
     * Get a Block By ID
     */
    async getBlockByExtIdRaw(requestParameters: GetBlockByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Block>> {
        if (requestParameters.blockExternalId === null || requestParameters.blockExternalId === undefined) {
            throw new runtime.RequiredError('blockExternalId','Required parameter requestParameters.blockExternalId was null or undefined when calling getBlockByExtId.');
        }
        
        if (requestParameters.externalSystemCode === null || requestParameters.externalSystemCode === undefined) {
            throw new runtime.RequiredError('externalSystemCode','Required parameter requestParameters.externalSystemCode was null or undefined when calling getBlockByExtId.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getBlockByExtId.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.markAsRecentlyAccessed !== undefined) {
            queryParameters['markAsRecentlyAccessed'] = requestParameters.markAsRecentlyAccessed;
        }

        if (requestParameters.fetchInstructions) {
            queryParameters['fetchInstructions'] = requestParameters.fetchInstructions;
        }

        if (requestParameters.fetchAllocatedRoomTypes !== undefined) {
            queryParameters['fetchAllocatedRoomTypes'] = requestParameters.fetchAllocatedRoomTypes;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = requestParameters.startDate;
        }

        if (requestParameters.numberOfDays !== undefined) {
            queryParameters['numberOfDays'] = requestParameters.numberOfDays;
        }

        if (requestParameters.roomAllocationCriteria) {
            queryParameters['roomAllocationCriteria'] = requestParameters.roomAllocationCriteria;
        }

        if (requestParameters.roomTypes) {
            queryParameters['roomTypes'] = requestParameters.roomTypes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}`.replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve a specific block.  You will need to know the blockID in the request; if you don\'t know it, please go ahead and use getBlocks API first.  The response will include detailed information about the block. <p><strong>OperationId:</strong>getBlockByExtId</p>
     * Get a Block By ID
     */
    async getBlockByExtId(requestParameters: GetBlockByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Block> {
        const response = await this.getBlockByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve block daily statistics for the given date range and hotel ID. It returns allocated, picked up, and available number of room nights per block, per day, per room type.<p><strong>OperationId:</strong>getBlockDailyStatistics</p>
     * Get Block Daily Statistics
     */
    async getBlockDailyStatisticsRaw(requestParameters: GetBlockDailyStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockDailyStatistics>> {
        const queryParameters: any = {};

        if (requestParameters.genericRoomType !== undefined) {
            queryParameters['genericRoomType'] = requestParameters.genericRoomType;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.end !== undefined) {
            queryParameters['end'] = requestParameters.end;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/dailyStatistics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockDailyStatisticsFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve block daily statistics for the given date range and hotel ID. It returns allocated, picked up, and available number of room nights per block, per day, per room type.<p><strong>OperationId:</strong>getBlockDailyStatistics</p>
     * Get Block Daily Statistics
     */
    async getBlockDailyStatistics(requestParameters: GetBlockDailyStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockDailyStatistics> {
        const response = await this.getBlockDailyStatisticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve block owners. <p><strong>OperationId:</strong>getBlockOwners</p>
     * Get Block owners
     */
    async getBlockOwnersRaw(requestParameters: GetBlockOwnersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockOwners>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockOwners.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/owners`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockOwnersFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve block owners. <p><strong>OperationId:</strong>getBlockOwners</p>
     * Get Block owners
     */
    async getBlockOwners(requestParameters: GetBlockOwnersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockOwners> {
        const response = await this.getBlockOwnersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve PM (Posting Master) reservations for a block. <p><strong>OperationId:</strong>getBlockPMReservations</p>
     * Get Posting Master Reservations for a Block
     */
    async getBlockPMReservationsRaw(requestParameters: GetBlockPMReservationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockPMReservations>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockPMReservations.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getBlockPMReservations.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.postingmaster !== undefined) {
            queryParameters['postingmaster'] = requestParameters.postingmaster;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/postingMaster/reservations`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockPMReservationsFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve PM (Posting Master) reservations for a block. <p><strong>OperationId:</strong>getBlockPMReservations</p>
     * Get Posting Master Reservations for a Block
     */
    async getBlockPMReservations(requestParameters: GetBlockPMReservationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockPMReservations> {
        const response = await this.getBlockPMReservationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve PM (Posting Master) reservations for a block. <p><strong>OperationId:</strong>getBlockPMReservationsByExtId</p>
     * Get Posting Master Reservations for a Block
     */
    async getBlockPMReservationsByExtIdRaw(requestParameters: GetBlockPMReservationsByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockPMReservations>> {
        if (requestParameters.blockExternalId === null || requestParameters.blockExternalId === undefined) {
            throw new runtime.RequiredError('blockExternalId','Required parameter requestParameters.blockExternalId was null or undefined when calling getBlockPMReservationsByExtId.');
        }
        
        if (requestParameters.externalSystemCode === null || requestParameters.externalSystemCode === undefined) {
            throw new runtime.RequiredError('externalSystemCode','Required parameter requestParameters.externalSystemCode was null or undefined when calling getBlockPMReservationsByExtId.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getBlockPMReservationsByExtId.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.postingmaster !== undefined) {
            queryParameters['postingmaster'] = requestParameters.postingmaster;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/postingMaster/reservations`.replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockPMReservationsFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve PM (Posting Master) reservations for a block. <p><strong>OperationId:</strong>getBlockPMReservationsByExtId</p>
     * Get Posting Master Reservations for a Block
     */
    async getBlockPMReservationsByExtId(requestParameters: GetBlockPMReservationsByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockPMReservations> {
        const response = await this.getBlockPMReservationsByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Request for updating block allocation for a range of dates. <p><strong>OperationId:</strong>getBlockRangeInfo</p>
     * Get Block Range Information
     */
    async getBlockRangeInfoRaw(requestParameters: GetBlockRangeInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockRangeInfo>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockRangeInfo.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getBlockRangeInfo.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.genericRoomType !== undefined) {
            queryParameters['genericRoomType'] = requestParameters.genericRoomType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/allocationRange`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockRangeInfoFromJSON(jsonValue));
    }

    /**
     * Request for updating block allocation for a range of dates. <p><strong>OperationId:</strong>getBlockRangeInfo</p>
     * Get Block Range Information
     */
    async getBlockRangeInfo(requestParameters: GetBlockRangeInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockRangeInfo> {
        const response = await this.getBlockRangeInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to  retrieve all reservations created for the given block ID. <p><strong>OperationId:</strong>getBlockReservations</p>
     * Retrieves all reservations created for the Block
     */
    async getBlockReservationsRaw(requestParameters: GetBlockReservationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockReservations>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockReservations.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.fetchInstructions) {
            queryParameters['fetchInstructions'] = requestParameters.fetchInstructions;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/reservations`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockReservationsFromJSON(jsonValue));
    }

    /**
     * Use this API to  retrieve all reservations created for the given block ID. <p><strong>OperationId:</strong>getBlockReservations</p>
     * Retrieves all reservations created for the Block
     */
    async getBlockReservations(requestParameters: GetBlockReservationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockReservations> {
        const response = await this.getBlockReservationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API retrieves block restrictions. <p><strong>OperationId:</strong>getBlockRestrictions</p>
     * Get Block restrictions 
     */
    async getBlockRestrictionsRaw(requestParameters: GetBlockRestrictionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockRestrictions>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockRestrictions.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = requestParameters.startDate;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = requestParameters.endDate;
        }

        if (requestParameters.duration !== undefined) {
            queryParameters['duration'] = requestParameters.duration;
        }

        if (requestParameters.roomType) {
            queryParameters['roomType'] = requestParameters.roomType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/restrictions`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockRestrictionsFromJSON(jsonValue));
    }

    /**
     * This API retrieves block restrictions. <p><strong>OperationId:</strong>getBlockRestrictions</p>
     * Get Block restrictions 
     */
    async getBlockRestrictions(requestParameters: GetBlockRestrictionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockRestrictions> {
        const response = await this.getBlockRestrictionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API will fetch revenue changes for a specific block recorded in the revenue change log for a specified date range. Please note that the revenue changes are delta changes only and single records do not represent a total summary of the block revenue per date. <p><strong>OperationId:</strong>getBlockRevenueChanges</p>
     * Fetch Block Revenue Changes
     */
    async getBlockRevenueChangesRaw(requestParameters: GetBlockRevenueChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockRevenueChanges>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockRevenueChanges.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.status) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.changeEndDate !== undefined) {
            queryParameters['changeEndDate'] = requestParameters.changeEndDate;
        }

        if (requestParameters.changeStartDate !== undefined) {
            queryParameters['changeStartDate'] = requestParameters.changeStartDate;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/revenueActivityLog`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockRevenueChangesFromJSON(jsonValue));
    }

    /**
     * This API will fetch revenue changes for a specific block recorded in the revenue change log for a specified date range. Please note that the revenue changes are delta changes only and single records do not represent a total summary of the block revenue per date. <p><strong>OperationId:</strong>getBlockRevenueChanges</p>
     * Fetch Block Revenue Changes
     */
    async getBlockRevenueChanges(requestParameters: GetBlockRevenueChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockRevenueChanges> {
        const response = await this.getBlockRevenueChangesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve room types for a block based on search criteria <p><strong>OperationId:</strong>getBlockRoomTypes</p>
     * Get Bock Room Types
     */
    async getBlockRoomTypesRaw(requestParameters: GetBlockRoomTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockRoomTypes>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockRoomTypes.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.fetchAllocatedRoomTypes !== undefined) {
            queryParameters['fetchAllocatedRoomTypes'] = requestParameters.fetchAllocatedRoomTypes;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = requestParameters.startDate;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = requestParameters.endDate;
        }

        if (requestParameters.fetchGenericRoomTypes !== undefined) {
            queryParameters['fetchGenericRoomTypes'] = requestParameters.fetchGenericRoomTypes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/roomTypes`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockRoomTypesFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve room types for a block based on search criteria <p><strong>OperationId:</strong>getBlockRoomTypes</p>
     * Get Bock Room Types
     */
    async getBlockRoomTypes(requestParameters: GetBlockRoomTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockRoomTypes> {
        const response = await this.getBlockRoomTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API facilitates retrieving room status for the block. <p><strong>OperationId:</strong>getBlockRoomsStatus</p>
     * Get room status for a Block
     */
    async getBlockRoomsStatusRaw(requestParameters: GetBlockRoomsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockRoomsStatus>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockRoomsStatus.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/roomsStatus`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockRoomsStatusFromJSON(jsonValue));
    }

    /**
     * This API facilitates retrieving room status for the block. <p><strong>OperationId:</strong>getBlockRoomsStatus</p>
     * Get room status for a Block
     */
    async getBlockRoomsStatus(requestParameters: GetBlockRoomsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockRoomsStatus> {
        const response = await this.getBlockRoomsStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to API retrieve detailed block statistics <p><strong>OperationId:</strong>getBlockStatistics</p>
     * Get Block Statistics
     */
    async getBlockStatisticsRaw(requestParameters: GetBlockStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockStatistics>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockStatistics.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = requestParameters.startDate;
        }

        if (requestParameters.numberOfDays !== undefined) {
            queryParameters['numberOfDays'] = requestParameters.numberOfDays;
        }

        if (requestParameters.statisticsInstructions) {
            queryParameters['statisticsInstructions'] = requestParameters.statisticsInstructions;
        }

        if (requestParameters.roomTypeHotelId) {
            queryParameters['roomTypeHotelId'] = requestParameters.roomTypeHotelId;
        }

        if (requestParameters.invBlockCode) {
            queryParameters['invBlockCode'] = requestParameters.invBlockCode;
        }

        if (requestParameters.promotionCode) {
            queryParameters['promotionCode'] = requestParameters.promotionCode;
        }

        if (requestParameters.roomCategory) {
            queryParameters['roomCategory'] = requestParameters.roomCategory;
        }

        if (requestParameters.roomClass) {
            queryParameters['roomClass'] = requestParameters.roomClass;
        }

        if (requestParameters.roomQualifierCode) {
            queryParameters['roomQualifierCode'] = requestParameters.roomQualifierCode;
        }

        if (requestParameters.roomQualifierMatchIndicator) {
            queryParameters['roomQualifierMatchIndicator'] = requestParameters.roomQualifierMatchIndicator;
        }

        if (requestParameters.roomType) {
            queryParameters['roomType'] = requestParameters.roomType;
        }

        if (requestParameters.roomViewCode) {
            queryParameters['roomViewCode'] = requestParameters.roomViewCode;
        }

        if (requestParameters.roomFeatureCode) {
            queryParameters['roomFeatureCode'] = requestParameters.roomFeatureCode;
        }

        if (requestParameters.defaultOccupancy !== undefined) {
            queryParameters['defaultOccupancy'] = requestParameters.defaultOccupancy;
        }

        if (requestParameters.maximumOccupancy !== undefined) {
            queryParameters['maximumOccupancy'] = requestParameters.maximumOccupancy;
        }

        if (requestParameters.noOfPhysicalRooms !== undefined) {
            queryParameters['noOfPhysicalRooms'] = requestParameters.noOfPhysicalRooms;
        }

        if (requestParameters.bookingChannelCode) {
            queryParameters['bookingChannelCode'] = requestParameters.bookingChannelCode;
        }

        if (requestParameters.bookingChannelMappingCode) {
            queryParameters['bookingChannelMappingCode'] = requestParameters.bookingChannelMappingCode;
        }

        if (requestParameters.bookingChannelMappingName) {
            queryParameters['bookingChannelMappingName'] = requestParameters.bookingChannelMappingName;
        }

        if (requestParameters.bedTypeCode) {
            queryParameters['bedTypeCode'] = requestParameters.bedTypeCode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/statistics`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockStatisticsFromJSON(jsonValue));
    }

    /**
     * Use this API to API retrieve detailed block statistics <p><strong>OperationId:</strong>getBlockStatistics</p>
     * Get Block Statistics
     */
    async getBlockStatistics(requestParameters: GetBlockStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockStatistics> {
        const response = await this.getBlockStatisticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve block status change log based on the HotelCode and Block ID. <p><strong>OperationId:</strong>getBlockStatusChanges</p>
     * Get Block Status Activity Log
     */
    async getBlockStatusChangesRaw(requestParameters: GetBlockStatusChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockStatusChanges>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockStatusChanges.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.changeEndDate !== undefined) {
            queryParameters['changeEndDate'] = requestParameters.changeEndDate;
        }

        if (requestParameters.changeStartDate !== undefined) {
            queryParameters['changeStartDate'] = requestParameters.changeStartDate;
        }

        if (requestParameters.currentStatus) {
            queryParameters['currentStatus'] = requestParameters.currentStatus;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/statusActivityLog`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockStatusChangesFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve block status change log based on the HotelCode and Block ID. <p><strong>OperationId:</strong>getBlockStatusChanges</p>
     * Get Block Status Activity Log
     */
    async getBlockStatusChanges(requestParameters: GetBlockStatusChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockStatusChanges> {
        const response = await this.getBlockStatusChangesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API retrieves block information needed to perform block wash operation. <p><strong>OperationId:</strong>getBlockWashInfo</p>
     * Get Block Wash Information
     */
    async getBlockWashInfoRaw(requestParameters: GetBlockWashInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockWashInfo>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.blockId !== undefined) {
            queryParameters['blockId'] = requestParameters.blockId;
        }

        if (requestParameters.blockIdType !== undefined) {
            queryParameters['blockIdType'] = requestParameters.blockIdType;
        }

        if (requestParameters.genericRoomType !== undefined) {
            queryParameters['genericRoomType'] = requestParameters.genericRoomType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blockWash`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockWashInfoFromJSON(jsonValue));
    }

    /**
     * This API retrieves block information needed to perform block wash operation. <p><strong>OperationId:</strong>getBlockWashInfo</p>
     * Get Block Wash Information
     */
    async getBlockWashInfo(requestParameters: GetBlockWashInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockWashInfo> {
        const response = await this.getBlockWashInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve the information regarding block wash schedule based on the parameter HotelCode and Block ID. <p><strong>OperationId:</strong>getBlockWashSchedules</p>
     * Get Block Wash Schedule
     */
    async getBlockWashSchedulesRaw(requestParameters: GetBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockWashSchedules>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getBlockWashSchedules.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/washSchedules`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockWashSchedulesFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve the information regarding block wash schedule based on the parameter HotelCode and Block ID. <p><strong>OperationId:</strong>getBlockWashSchedules</p>
     * Get Block Wash Schedule
     */
    async getBlockWashSchedules(requestParameters: GetBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockWashSchedules> {
        const response = await this.getBlockWashSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve a list of blocks for requested query parameters. A wide range of query parameters is available to support various persona requirements, so it is recommended to include, at least, the hotel block date range, stay date range, and/or number of days as query parameters. You can use more query parameters to narrow your results. This API is not designed to support sync between two systems or initial upload of data. If x-hubid is used as a header, it returns matching data from multiple hotels within the same chain. <p><strong>OperationId:</strong>getBlocks</p>
     * Get Blocks
     */
    async getBlocksRaw(requestParameters: GetBlocksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockSummaries>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.markAsRecentlyAccessed !== undefined) {
            queryParameters['markAsRecentlyAccessed'] = requestParameters.markAsRecentlyAccessed;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.multipleHotelsSearchHotelIds) {
            queryParameters['multipleHotelsSearchHotelIds'] = requestParameters.multipleHotelsSearchHotelIds;
        }

        if (requestParameters.superSearch !== undefined) {
            queryParameters['superSearch'] = requestParameters.superSearch;
        }

        if (requestParameters.blockIdList) {
            queryParameters['blockIdList'] = requestParameters.blockIdList;
        }

        if (requestParameters.blockIdType) {
            queryParameters['blockIdType'] = requestParameters.blockIdType;
        }

        if (requestParameters.externalReferenceIds) {
            queryParameters['externalReferenceIds'] = requestParameters.externalReferenceIds;
        }

        if (requestParameters.externalSystemCodes) {
            queryParameters['externalSystemCodes'] = requestParameters.externalSystemCodes;
        }

        if (requestParameters.blockCode !== undefined) {
            queryParameters['blockCode'] = requestParameters.blockCode;
        }

        if (requestParameters.blockName !== undefined) {
            queryParameters['blockName'] = requestParameters.blockName;
        }

        if (requestParameters.blockOwner) {
            queryParameters['blockOwner'] = requestParameters.blockOwner;
        }

        if (requestParameters.blockStatus) {
            queryParameters['blockStatus'] = requestParameters.blockStatus;
        }

        if (requestParameters.cateringStatus) {
            queryParameters['cateringStatus'] = requestParameters.cateringStatus;
        }

        if (requestParameters.createdByUser !== undefined) {
            queryParameters['createdByUser'] = requestParameters.createdByUser;
        }

        if (requestParameters.blockStartEndDate !== undefined) {
            queryParameters['blockStartEndDate'] = requestParameters.blockStartEndDate;
        }

        if (requestParameters.blockStartStartDate !== undefined) {
            queryParameters['blockStartStartDate'] = requestParameters.blockStartStartDate;
        }

        if (requestParameters.blockEndEndDate !== undefined) {
            queryParameters['blockEndEndDate'] = requestParameters.blockEndEndDate;
        }

        if (requestParameters.blockEndStartDate !== undefined) {
            queryParameters['blockEndStartDate'] = requestParameters.blockEndStartDate;
        }

        if (requestParameters.reservationArrival !== undefined) {
            queryParameters['reservationArrival'] = requestParameters.reservationArrival;
        }

        if (requestParameters.reservationDeparture !== undefined) {
            queryParameters['reservationDeparture'] = requestParameters.reservationDeparture;
        }

        if (requestParameters.includeShoulderDates !== undefined) {
            queryParameters['includeShoulderDates'] = requestParameters.includeShoulderDates;
        }

        if (requestParameters.stayDate !== undefined) {
            queryParameters['stayDate'] = requestParameters.stayDate;
        }

        if (requestParameters.blockCreatedOnEndDate !== undefined) {
            queryParameters['blockCreatedOnEndDate'] = requestParameters.blockCreatedOnEndDate;
        }

        if (requestParameters.blockCreatedOnStartDate !== undefined) {
            queryParameters['blockCreatedOnStartDate'] = requestParameters.blockCreatedOnStartDate;
        }

        if (requestParameters.decisionEndDate !== undefined) {
            queryParameters['decisionEndDate'] = requestParameters.decisionEndDate;
        }

        if (requestParameters.decisionStartDate !== undefined) {
            queryParameters['decisionStartDate'] = requestParameters.decisionStartDate;
        }

        if (requestParameters.cutOffEndDate !== undefined) {
            queryParameters['cutOffEndDate'] = requestParameters.cutOffEndDate;
        }

        if (requestParameters.cutOffStartDate !== undefined) {
            queryParameters['cutOffStartDate'] = requestParameters.cutOffStartDate;
        }

        if (requestParameters.category) {
            queryParameters['category'] = requestParameters.category;
        }

        if (requestParameters.name) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.attachedProfileId !== undefined) {
            queryParameters['attachedProfileId'] = requestParameters.attachedProfileId;
        }

        if (requestParameters.attachedProfileIdType !== undefined) {
            queryParameters['attachedProfileIdType'] = requestParameters.attachedProfileIdType;
        }

        if (requestParameters.leads !== undefined) {
            queryParameters['leads'] = requestParameters.leads;
        }

        if (requestParameters.tourSeries !== undefined) {
            queryParameters['tourSeries'] = requestParameters.tourSeries;
        }

        if (requestParameters.onlyPickupBlocks !== undefined) {
            queryParameters['onlyPickupBlocks'] = requestParameters.onlyPickupBlocks;
        }

        if (requestParameters.onlyOpportunities !== undefined) {
            queryParameters['onlyOpportunities'] = requestParameters.onlyOpportunities;
        }

        if (requestParameters.ratePlanCode) {
            queryParameters['ratePlanCode'] = requestParameters.ratePlanCode;
        }

        if (requestParameters.tourCode !== undefined) {
            queryParameters['tourCode'] = requestParameters.tourCode;
        }

        if (requestParameters.attributeName) {
            queryParameters['attributeName'] = requestParameters.attributeName;
        }

        if (requestParameters.orderType) {
            queryParameters['orderType'] = requestParameters.orderType;
        }

        if (requestParameters.fetchInstructions) {
            queryParameters['fetchInstructions'] = requestParameters.fetchInstructions;
        }

        if (requestParameters.fetchAllocatedRoomTypes !== undefined) {
            queryParameters['fetchAllocatedRoomTypes'] = requestParameters.fetchAllocatedRoomTypes;
        }

        if (requestParameters.additionalCriteriaStartDate !== undefined) {
            queryParameters['additionalCriteriaStartDate'] = requestParameters.additionalCriteriaStartDate;
        }

        if (requestParameters.numberOfDays !== undefined) {
            queryParameters['numberOfDays'] = requestParameters.numberOfDays;
        }

        if (requestParameters.adults !== undefined) {
            queryParameters['adults'] = requestParameters.adults;
        }

        if (requestParameters.children !== undefined) {
            queryParameters['children'] = requestParameters.children;
        }

        if (requestParameters.childAge) {
            queryParameters['childAge'] = requestParameters.childAge;
        }

        if (requestParameters.bucket1Count !== undefined) {
            queryParameters['bucket1Count'] = requestParameters.bucket1Count;
        }

        if (requestParameters.bucket2Count !== undefined) {
            queryParameters['bucket2Count'] = requestParameters.bucket2Count;
        }

        if (requestParameters.bucket3Count !== undefined) {
            queryParameters['bucket3Count'] = requestParameters.bucket3Count;
        }

        if (requestParameters.bucket4Count !== undefined) {
            queryParameters['bucket4Count'] = requestParameters.bucket4Count;
        }

        if (requestParameters.bucket5Count !== undefined) {
            queryParameters['bucket5Count'] = requestParameters.bucket5Count;
        }

        if (requestParameters.existingReservationId !== undefined) {
            queryParameters['existingReservationId'] = requestParameters.existingReservationId;
        }

        if (requestParameters.existingReservationIdType !== undefined) {
            queryParameters['existingReservationIdType'] = requestParameters.existingReservationIdType;
        }

        if (requestParameters.roomAllocationCriteria) {
            queryParameters['roomAllocationCriteria'] = requestParameters.roomAllocationCriteria;
        }

        if (requestParameters.roomType) {
            queryParameters['roomType'] = requestParameters.roomType;
        }

        if (requestParameters.additionalCriteriaRatePlanCode !== undefined) {
            queryParameters['additionalCriteriaRatePlanCode'] = requestParameters.additionalCriteriaRatePlanCode;
        }

        if (requestParameters.currencyCode !== undefined) {
            queryParameters['currencyCode'] = requestParameters.currencyCode;
        }

        if (requestParameters.customCharUDFsAltname) {
            queryParameters['customCharUDFsAltname'] = requestParameters.customCharUDFsAltname;
        }

        if (requestParameters.customCharUDFsName) {
            queryParameters['customCharUDFsName'] = requestParameters.customCharUDFsName;
        }

        if (requestParameters.customCharUDFsValue) {
            queryParameters['customCharUDFsValue'] = requestParameters.customCharUDFsValue;
        }

        if (requestParameters.customNumericUDFsAltname) {
            queryParameters['customNumericUDFsAltname'] = requestParameters.customNumericUDFsAltname;
        }

        if (requestParameters.customNumericUDFsName) {
            queryParameters['customNumericUDFsName'] = requestParameters.customNumericUDFsName;
        }

        if (requestParameters.customNumericUDFsValue) {
            queryParameters['customNumericUDFsValue'] = requestParameters.customNumericUDFsValue;
        }

        if (requestParameters.customDateUDFsAltname) {
            queryParameters['customDateUDFsAltname'] = requestParameters.customDateUDFsAltname;
        }

        if (requestParameters.customDateUDFsName) {
            queryParameters['customDateUDFsName'] = requestParameters.customDateUDFsName;
        }

        if (requestParameters.customDateUDFsValue) {
            queryParameters['customDateUDFsValue'] = requestParameters.customDateUDFsValue;
        }

        if (requestParameters.accessRestriction) {
            queryParameters['accessRestriction'] = requestParameters.accessRestriction;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockSummariesFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve a list of blocks for requested query parameters. A wide range of query parameters is available to support various persona requirements, so it is recommended to include, at least, the hotel block date range, stay date range, and/or number of days as query parameters. You can use more query parameters to narrow your results. This API is not designed to support sync between two systems or initial upload of data. If x-hubid is used as a header, it returns matching data from multiple hotels within the same chain. <p><strong>OperationId:</strong>getBlocks</p>
     * Get Blocks
     */
    async getBlocks(requestParameters: GetBlocksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockSummaries> {
        const response = await this.getBlocksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve a default block code based on template. <p><strong>OperationId:</strong>getDefaultBlockCode</p>
     * Get default Block Code
     */
    async getDefaultBlockCodeRaw(requestParameters: GetDefaultBlockCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DefaultBlockCodeDetails>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.blockName !== undefined) {
            queryParameters['blockName'] = requestParameters.blockName;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = requestParameters.startDate;
        }

        if (requestParameters.blockCodeTemplate !== undefined) {
            queryParameters['blockCodeTemplate'] = requestParameters.blockCodeTemplate;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/defaultBlockCode`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultBlockCodeDetailsFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve a default block code based on template. <p><strong>OperationId:</strong>getDefaultBlockCode</p>
     * Get default Block Code
     */
    async getDefaultBlockCode(requestParameters: GetDefaultBlockCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DefaultBlockCodeDetails> {
        const response = await this.getDefaultBlockCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve borrowable inventory for the requested dates when encountering an insufficient number of rooms in a block for a specific room type, or for overall inventory. This operations would usually be used when attempting to pick up a reservation against a block, and the block inventory does not have enough rooms left to support the reservation pick up. <p><strong>OperationId:</strong>getInventoryToBorrow</p>
     * Get inventory to Borrow
     */
    async getInventoryToBorrowRaw(requestParameters: GetInventoryToBorrowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryToBorrowInfo>> {
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getInventoryToBorrow.');
        }
        
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling getInventoryToBorrow.');
        }
        
        if (requestParameters.startDate === null || requestParameters.startDate === undefined) {
            throw new runtime.RequiredError('startDate','Required parameter requestParameters.startDate was null or undefined when calling getInventoryToBorrow.');
        }
        
        if (requestParameters.requiredRooms === null || requestParameters.requiredRooms === undefined) {
            throw new runtime.RequiredError('requiredRooms','Required parameter requestParameters.requiredRooms was null or undefined when calling getInventoryToBorrow.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.blockId !== undefined) {
            queryParameters['blockId'] = requestParameters.blockId;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = requestParameters.startDate;
        }

        if (requestParameters.requiredRooms) {
            queryParameters['requiredRooms'] = requestParameters.requiredRooms;
        }

        if (requestParameters.blockIdContext !== undefined) {
            queryParameters['blockIdContext'] = requestParameters.blockIdContext;
        }

        if (requestParameters.blockIdType !== undefined) {
            queryParameters['blockIdType'] = requestParameters.blockIdType;
        }

        if (requestParameters.existingReservationId !== undefined) {
            queryParameters['existingReservationId'] = requestParameters.existingReservationId;
        }

        if (requestParameters.existingReservationIdType !== undefined) {
            queryParameters['existingReservationIdType'] = requestParameters.existingReservationIdType;
        }

        if (requestParameters.roomType !== undefined) {
            queryParameters['roomType'] = requestParameters.roomType;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = requestParameters.endDate;
        }

        if (requestParameters.duration !== undefined) {
            queryParameters['duration'] = requestParameters.duration;
        }

        if (requestParameters.numberOfRooms !== undefined) {
            queryParameters['numberOfRooms'] = requestParameters.numberOfRooms;
        }

        if (requestParameters.borrowDate) {
            queryParameters['borrowDate'] = requestParameters.borrowDate;
        }

        if (requestParameters.overrideRateCode !== undefined) {
            queryParameters['overrideRateCode'] = requestParameters.overrideRateCode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/inventoryToBorrow`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryToBorrowInfoFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve borrowable inventory for the requested dates when encountering an insufficient number of rooms in a block for a specific room type, or for overall inventory. This operations would usually be used when attempting to pick up a reservation against a block, and the block inventory does not have enough rooms left to support the reservation pick up. <p><strong>OperationId:</strong>getInventoryToBorrow</p>
     * Get inventory to Borrow
     */
    async getInventoryToBorrow(requestParameters: GetInventoryToBorrowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryToBorrowInfo> {
        const response = await this.getInventoryToBorrowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve next set of statuses and their next statuses for the current status passed in the request. <p><strong>OperationId:</strong>getNextBlockStatus</p>
     * Get Next Block Status
     */
    async getNextBlockStatusRaw(requestParameters: GetNextBlockStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NextBlockStatus>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.currentStatus !== undefined) {
            queryParameters['currentStatus'] = requestParameters.currentStatus;
        }

        if (requestParameters.includeCateringStatus !== undefined) {
            queryParameters['includeCateringStatus'] = requestParameters.includeCateringStatus;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NextBlockStatusFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve next set of statuses and their next statuses for the current status passed in the request. <p><strong>OperationId:</strong>getNextBlockStatus</p>
     * Get Next Block Status
     */
    async getNextBlockStatus(requestParameters: GetNextBlockStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NextBlockStatus> {
        const response = await this.getNextBlockStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API retrieves recently accessed blocks. <p><strong>OperationId:</strong>getRecentlyAccessedBlocks</p>
     * Get recently accessed Blocks
     */
    async getRecentlyAccessedBlocksRaw(requestParameters: GetRecentlyAccessedBlocksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecentlyAccessedBlocks>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/recentlyAccessedBlocks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecentlyAccessedBlocksFromJSON(jsonValue));
    }

    /**
     * This API retrieves recently accessed blocks. <p><strong>OperationId:</strong>getRecentlyAccessedBlocks</p>
     * Get recently accessed Blocks
     */
    async getRecentlyAccessedBlocks(requestParameters: GetRecentlyAccessedBlocksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecentlyAccessedBlocks> {
        const response = await this.getRecentlyAccessedBlocksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve the Sales Allowance of max amount of rooms that can be sold. <p><strong>OperationId:</strong>getSalesAllowances</p>
     * Get Sales allowances
     */
    async getSalesAllowancesRaw(requestParameters: GetSalesAllowancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SalesAllowances>> {
        const queryParameters: any = {};

        if (requestParameters.ceilingId) {
            queryParameters['ceilingId'] = requestParameters.ceilingId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/salesAllowances`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SalesAllowancesFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve the Sales Allowance of max amount of rooms that can be sold. <p><strong>OperationId:</strong>getSalesAllowances</p>
     * Get Sales allowances
     */
    async getSalesAllowances(requestParameters: GetSalesAllowancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SalesAllowances> {
        const response = await this.getSalesAllowancesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You can use this API to get traces for Reservations and Blocks. <p><strong>OperationId:</strong>getTracesByDateRange</p>
     * Get Traces By Date Range
     */
    async getTracesByDateRangeRaw(requestParameters: GetTracesByDateRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TracesByDateRange>> {
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getTracesByDateRange.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.hotelIds) {
            queryParameters['hotelIds'] = requestParameters.hotelIds;
        }

        if (requestParameters.beginDate !== undefined) {
            queryParameters['beginDate'] = requestParameters.beginDate;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = requestParameters.endDate;
        }

        if (requestParameters.department) {
            queryParameters['department'] = requestParameters.department;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/tracesByDateRange`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TracesByDateRangeFromJSON(jsonValue));
    }

    /**
     * You can use this API to get traces for Reservations and Blocks. <p><strong>OperationId:</strong>getTracesByDateRange</p>
     * Get Traces By Date Range
     */
    async getTracesByDateRange(requestParameters: GetTracesByDateRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TracesByDateRange> {
        const response = await this.getTracesByDateRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create alternate dates for a block. <p><strong>OperationId:</strong>postAlternateDates</p>
     * Create alternate dates for a Block
     */
    async postAlternateDatesRaw(requestParameters: PostAlternateDatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling postAlternateDates.');
        }
        
        if (requestParameters.blockAlternateDates === null || requestParameters.blockAlternateDates === undefined) {
            throw new runtime.RequiredError('blockAlternateDates','Required parameter requestParameters.blockAlternateDates was null or undefined when calling postAlternateDates.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/alternateDates`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockAlternateDatesToJSON(requestParameters.blockAlternateDates),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create alternate dates for a block. <p><strong>OperationId:</strong>postAlternateDates</p>
     * Create alternate dates for a Block
     */
    async postAlternateDates(requestParameters: PostAlternateDatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postAlternateDatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create a new group block in OPERA Cloud. You must first use the ListOfValues APIs to find block attributes, such as Block Status, Room Types, and so on. Knowing this list of values helps ensure a successful postBlock. <p><strong>OperationId:</strong>postBlock</p>
     * Create a Block
     */
    async postBlockRaw(requestParameters: PostBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling postBlock.');
        }
        
        if (requestParameters.block === null || requestParameters.block === undefined) {
            throw new runtime.RequiredError('block','Required parameter requestParameters.block was null or undefined when calling postBlock.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/block`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockToJSON(requestParameters.block),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create a new group block in OPERA Cloud. You must first use the ListOfValues APIs to find block attributes, such as Block Status, Room Types, and so on. Knowing this list of values helps ensure a successful postBlock. <p><strong>OperationId:</strong>postBlock</p>
     * Create a Block
     */
    async postBlock(requestParameters: PostBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to assign block owners. <p><strong>OperationId:</strong>postBlockOwners</p>
     * Assign a Block owner
     */
    async postBlockOwnersRaw(requestParameters: PostBlockOwnersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling postBlockOwners.');
        }
        
        if (requestParameters.blockOwnersToAssign === null || requestParameters.blockOwnersToAssign === undefined) {
            throw new runtime.RequiredError('blockOwnersToAssign','Required parameter requestParameters.blockOwnersToAssign was null or undefined when calling postBlockOwners.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/owners`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockOwnersToAssignToJSON(requestParameters.blockOwnersToAssign),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to assign block owners. <p><strong>OperationId:</strong>postBlockOwners</p>
     * Assign a Block owner
     */
    async postBlockOwners(requestParameters: PostBlockOwnersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postBlockOwnersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create a new posting Master reservation against a block in OPERA.  The block status in OPERA needs to be \'Open for Pick up\' to successfully post a BlockPostingMaster reservation. <p><strong>OperationId:</strong>postBlockPostingMaster</p>
     * Create Block posting master
     */
    async postBlockPostingMasterRaw(requestParameters: PostBlockPostingMasterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling postBlockPostingMaster.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling postBlockPostingMaster.');
        }
        
        if (requestParameters.blockPostingMaster === null || requestParameters.blockPostingMaster === undefined) {
            throw new runtime.RequiredError('blockPostingMaster','Required parameter requestParameters.blockPostingMaster was null or undefined when calling postBlockPostingMaster.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/postingMaster`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockPostingMasterToJSON(requestParameters.blockPostingMaster),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create a new posting Master reservation against a block in OPERA.  The block status in OPERA needs to be \'Open for Pick up\' to successfully post a BlockPostingMaster reservation. <p><strong>OperationId:</strong>postBlockPostingMaster</p>
     * Create Block posting master
     */
    async postBlockPostingMaster(requestParameters: PostBlockPostingMasterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postBlockPostingMasterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create block restrictions. <p><strong>OperationId:</strong>postBlockRestriction</p>
     * Create Block Restriction
     */
    async postBlockRestrictionRaw(requestParameters: PostBlockRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling postBlockRestriction.');
        }
        
        if (requestParameters.blockRestriction === null || requestParameters.blockRestriction === undefined) {
            throw new runtime.RequiredError('blockRestriction','Required parameter requestParameters.blockRestriction was null or undefined when calling postBlockRestriction.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/restrictions`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockRestrictionToJSON(requestParameters.blockRestriction),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create block restrictions. <p><strong>OperationId:</strong>postBlockRestriction</p>
     * Create Block Restriction
     */
    async postBlockRestriction(requestParameters: PostBlockRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postBlockRestrictionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to validate if block rate code has overlapping blocks and also validates and creates block details. <p><strong>OperationId:</strong>postBlockValidate</p>
     * Validate Block
     */
    async postBlockValidateRaw(requestParameters: PostBlockValidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockValidate === null || requestParameters.blockValidate === undefined) {
            throw new runtime.RequiredError('blockValidate','Required parameter requestParameters.blockValidate was null or undefined when calling postBlockValidate.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/actions/validate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockValidateToJSON(requestParameters.blockValidate),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to validate if block rate code has overlapping blocks and also validates and creates block details. <p><strong>OperationId:</strong>postBlockValidate</p>
     * Validate Block
     */
    async postBlockValidate(requestParameters: PostBlockValidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postBlockValidateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API creates new block wash schedules based on Wash Date, Room Type, Occupancy detail, Sell limit and Wash by percent value. <p><strong>OperationId:</strong>postBlockWashSchedules</p>
     * Create Block Wash Schedules
     */
    async postBlockWashSchedulesRaw(requestParameters: PostBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling postBlockWashSchedules.');
        }
        
        if (requestParameters.blockWashSchedulesInfo === null || requestParameters.blockWashSchedulesInfo === undefined) {
            throw new runtime.RequiredError('blockWashSchedulesInfo','Required parameter requestParameters.blockWashSchedulesInfo was null or undefined when calling postBlockWashSchedules.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/washSchedules`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockWashSchedulesInfoToJSON(requestParameters.blockWashSchedulesInfo),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API creates new block wash schedules based on Wash Date, Room Type, Occupancy detail, Sell limit and Wash by percent value. <p><strong>OperationId:</strong>postBlockWashSchedules</p>
     * Create Block Wash Schedules
     */
    async postBlockWashSchedules(requestParameters: PostBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postBlockWashSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to complete a cancellation of the block. <p><strong>OperationId:</strong>postCancelBlock</p>
     * Cancel the Block
     */
    async postCancelBlockRaw(requestParameters: PostCancelBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling postCancelBlock.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling postCancelBlock.');
        }
        
        if (requestParameters.blockToCancel === null || requestParameters.blockToCancel === undefined) {
            throw new runtime.RequiredError('blockToCancel','Required parameter requestParameters.blockToCancel was null or undefined when calling postCancelBlock.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/cancellations`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockToCancelToJSON(requestParameters.blockToCancel),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to complete a cancellation of the block. <p><strong>OperationId:</strong>postCancelBlock</p>
     * Cancel the Block
     */
    async postCancelBlock(requestParameters: PostCancelBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postCancelBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to copy the a block. The block copied (Source block) will serve as a template for the new one. <p><strong>OperationId:</strong>postCopyBlock</p>
     * Copy a Block
     */
    async postCopyBlockRaw(requestParameters: PostCopyBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.sourceBlockId === null || requestParameters.sourceBlockId === undefined) {
            throw new runtime.RequiredError('sourceBlockId','Required parameter requestParameters.sourceBlockId was null or undefined when calling postCopyBlock.');
        }
        
        if (requestParameters.blockCopy === null || requestParameters.blockCopy === undefined) {
            throw new runtime.RequiredError('blockCopy','Required parameter requestParameters.blockCopy was null or undefined when calling postCopyBlock.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{sourceBlockId}/copy`.replace(`{${"sourceBlockId"}}`, encodeURIComponent(String(requestParameters.sourceBlockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockCopyToJSON(requestParameters.blockCopy),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to copy the a block. The block copied (Source block) will serve as a template for the new one. <p><strong>OperationId:</strong>postCopyBlock</p>
     * Copy a Block
     */
    async postCopyBlock(requestParameters: PostCopyBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postCopyBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create a Reservation Rooming List. <p><strong>OperationId:</strong>postRoomingList</p>
     * Create Block Rooming List Reservations
     */
    async postRoomingListRaw(requestParameters: PostRoomingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoomingListDetails>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling postRoomingList.');
        }
        
        if (requestParameters.roomingList === null || requestParameters.roomingList === undefined) {
            throw new runtime.RequiredError('roomingList','Required parameter requestParameters.roomingList was null or undefined when calling postRoomingList.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/roomingList`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RoomingListToJSON(requestParameters.roomingList),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoomingListDetailsFromJSON(jsonValue));
    }

    /**
     * Use this API to create a Reservation Rooming List. <p><strong>OperationId:</strong>postRoomingList</p>
     * Create Block Rooming List Reservations
     */
    async postRoomingList(requestParameters: PostRoomingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoomingListDetails> {
        const response = await this.postRoomingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create sub allocation. <p><strong>OperationId:</strong>postSubAllocation</p>
     * Create Sub allocation
     */
    async postSubAllocationRaw(requestParameters: PostSubAllocationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.subAllocation === null || requestParameters.subAllocation === undefined) {
            throw new runtime.RequiredError('subAllocation','Required parameter requestParameters.subAllocation was null or undefined when calling postSubAllocation.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/allocation`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SubAllocationToJSON(requestParameters.subAllocation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create sub allocation. <p><strong>OperationId:</strong>postSubAllocation</p>
     * Create Sub allocation
     */
    async postSubAllocation(requestParameters: PostSubAllocationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postSubAllocationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this when you want to create a sub block.You will need to know the OPERA Block ID, which you want this sub block to fall under. <p><strong>OperationId:</strong>postSubBlock</p>
     * Create a sub-Block
     */
    async postSubBlockRaw(requestParameters: PostSubBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling postSubBlock.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling postSubBlock.');
        }
        
        if (requestParameters.subBlock === null || requestParameters.subBlock === undefined) {
            throw new runtime.RequiredError('subBlock','Required parameter requestParameters.subBlock was null or undefined when calling postSubBlock.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/subBlocks`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SubBlockToJSON(requestParameters.subBlock),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this when you want to create a sub block.You will need to know the OPERA Block ID, which you want this sub block to fall under. <p><strong>OperationId:</strong>postSubBlock</p>
     * Create a sub-Block
     */
    async postSubBlock(requestParameters: PostSubBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postSubBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this when you want to create a sub block.You will need to know the OPERA Block ID, which you want this sub block to fall under. <p><strong>OperationId:</strong>postSubBlockByExtId</p>
     * Create a sub-Block
     */
    async postSubBlockByExtIdRaw(requestParameters: PostSubBlockByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockExternalId === null || requestParameters.blockExternalId === undefined) {
            throw new runtime.RequiredError('blockExternalId','Required parameter requestParameters.blockExternalId was null or undefined when calling postSubBlockByExtId.');
        }
        
        if (requestParameters.externalSystemCode === null || requestParameters.externalSystemCode === undefined) {
            throw new runtime.RequiredError('externalSystemCode','Required parameter requestParameters.externalSystemCode was null or undefined when calling postSubBlockByExtId.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling postSubBlockByExtId.');
        }
        
        if (requestParameters.subBlock === null || requestParameters.subBlock === undefined) {
            throw new runtime.RequiredError('subBlock','Required parameter requestParameters.subBlock was null or undefined when calling postSubBlockByExtId.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/subBlocks`.replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SubBlockToJSON(requestParameters.subBlock),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this when you want to create a sub block.You will need to know the OPERA Block ID, which you want this sub block to fall under. <p><strong>OperationId:</strong>postSubBlockByExtId</p>
     * Create a sub-Block
     */
    async postSubBlockByExtId(requestParameters: PostSubBlockByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postSubBlockByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create a block tour series. <p><strong>OperationId:</strong>postTourSeries</p>
     * Create a Block tour series
     */
    async postTourSeriesRaw(requestParameters: PostTourSeriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling postTourSeries.');
        }
        
        if (requestParameters.tourSeries === null || requestParameters.tourSeries === undefined) {
            throw new runtime.RequiredError('tourSeries','Required parameter requestParameters.tourSeries was null or undefined when calling postTourSeries.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/tourSeries`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TourSeriesToJSON(requestParameters.tourSeries),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create a block tour series. <p><strong>OperationId:</strong>postTourSeries</p>
     * Create a Block tour series
     */
    async postTourSeries(requestParameters: PostTourSeriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postTourSeriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to change alternate dates for a block. <p><strong>OperationId:</strong>putAlternateDates</p>
     * Change alternate dates for a Block
     */
    async putAlternateDatesRaw(requestParameters: PutAlternateDatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putAlternateDates.');
        }
        
        if (requestParameters.blockAlternateDates === null || requestParameters.blockAlternateDates === undefined) {
            throw new runtime.RequiredError('blockAlternateDates','Required parameter requestParameters.blockAlternateDates was null or undefined when calling putAlternateDates.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/alternateDates`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockAlternateDatesToJSON(requestParameters.blockAlternateDates),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to change alternate dates for a block. <p><strong>OperationId:</strong>putAlternateDates</p>
     * Change alternate dates for a Block
     */
    async putAlternateDates(requestParameters: PutAlternateDatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putAlternateDatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to update an existing group block in OPERA Cloud. This API allows update of block header information, such as description, market segment, source code, rate code, and other details, but does not include updates for room grid or events, which have their own update API calls. <p><strong>OperationId:</strong>putBlock</p>
     * Change a Block
     */
    async putBlockRaw(requestParameters: PutBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockChanged>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putBlock.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling putBlock.');
        }
        
        if (requestParameters.blockToBeChanged === null || requestParameters.blockToBeChanged === undefined) {
            throw new runtime.RequiredError('blockToBeChanged','Required parameter requestParameters.blockToBeChanged was null or undefined when calling putBlock.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockToBeChangedToJSON(requestParameters.blockToBeChanged),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockChangedFromJSON(jsonValue));
    }

    /**
     * Use this API to update an existing group block in OPERA Cloud. This API allows update of block header information, such as description, market segment, source code, rate code, and other details, but does not include updates for room grid or events, which have their own update API calls. <p><strong>OperationId:</strong>putBlock</p>
     * Change a Block
     */
    async putBlock(requestParameters: PutBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockChanged> {
        const response = await this.putBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Us this API to create/change block access exclusion information. <p><strong>OperationId:</strong>putBlockAccessExclusion</p>
     * Set Block Exclusion information
     */
    async putBlockAccessExclusionRaw(requestParameters: PutBlockAccessExclusionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putBlockAccessExclusion.');
        }
        
        if (requestParameters.blockAccessExclusion === null || requestParameters.blockAccessExclusion === undefined) {
            throw new runtime.RequiredError('blockAccessExclusion','Required parameter requestParameters.blockAccessExclusion was null or undefined when calling putBlockAccessExclusion.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/blockAccessExclusion`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockAccessExclusionToJSON(requestParameters.blockAccessExclusion),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Us this API to create/change block access exclusion information. <p><strong>OperationId:</strong>putBlockAccessExclusion</p>
     * Set Block Exclusion information
     */
    async putBlockAccessExclusion(requestParameters: PutBlockAccessExclusionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockAccessExclusionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to add block room type allocations and rates to a specified Block. <p><strong>OperationId:</strong>putBlockAllocation</p>
     * Set Block Allocation  
     */
    async putBlockAllocationRaw(requestParameters: PutBlockAllocationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putBlockAllocation.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling putBlockAllocation.');
        }
        
        if (requestParameters.allocation === null || requestParameters.allocation === undefined) {
            throw new runtime.RequiredError('allocation','Required parameter requestParameters.allocation was null or undefined when calling putBlockAllocation.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/allocation`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AllocationToJSON(requestParameters.allocation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to add block room type allocations and rates to a specified Block. <p><strong>OperationId:</strong>putBlockAllocation</p>
     * Set Block Allocation  
     */
    async putBlockAllocation(requestParameters: PutBlockAllocationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockAllocationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to add block room type allocations and rates to a specified Block. <p><strong>OperationId:</strong>putBlockAllocationByExtId</p>
     * Set Block Allocation  
     */
    async putBlockAllocationByExtIdRaw(requestParameters: PutBlockAllocationByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.roomType === null || requestParameters.roomType === undefined) {
            throw new runtime.RequiredError('roomType','Required parameter requestParameters.roomType was null or undefined when calling putBlockAllocationByExtId.');
        }
        
        if (requestParameters.blockExternalId === null || requestParameters.blockExternalId === undefined) {
            throw new runtime.RequiredError('blockExternalId','Required parameter requestParameters.blockExternalId was null or undefined when calling putBlockAllocationByExtId.');
        }
        
        if (requestParameters.externalSystemCode === null || requestParameters.externalSystemCode === undefined) {
            throw new runtime.RequiredError('externalSystemCode','Required parameter requestParameters.externalSystemCode was null or undefined when calling putBlockAllocationByExtId.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling putBlockAllocationByExtId.');
        }
        
        if (requestParameters.allocation === null || requestParameters.allocation === undefined) {
            throw new runtime.RequiredError('allocation','Required parameter requestParameters.allocation was null or undefined when calling putBlockAllocationByExtId.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/allocation/roomTypes/{roomType}`.replace(`{${"roomType"}}`, encodeURIComponent(String(requestParameters.roomType))).replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AllocationToJSON(requestParameters.allocation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to add block room type allocations and rates to a specified Block. <p><strong>OperationId:</strong>putBlockAllocationByExtId</p>
     * Set Block Allocation  
     */
    async putBlockAllocationByExtId(requestParameters: PutBlockAllocationByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockAllocationByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to set block allocation for a range of dates for a list of room types. <p><strong>OperationId:</strong>putBlockAllocationRange</p>
     * Set Block Allocation Range
     */
    async putBlockAllocationRangeRaw(requestParameters: PutBlockAllocationRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putBlockAllocationRange.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling putBlockAllocationRange.');
        }
        
        if (requestParameters.blockAllocationRange === null || requestParameters.blockAllocationRange === undefined) {
            throw new runtime.RequiredError('blockAllocationRange','Required parameter requestParameters.blockAllocationRange was null or undefined when calling putBlockAllocationRange.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/allocationRange`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockAllocationRangeToJSON(requestParameters.blockAllocationRange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to set block allocation for a range of dates for a list of room types. <p><strong>OperationId:</strong>putBlockAllocationRange</p>
     * Set Block Allocation Range
     */
    async putBlockAllocationRange(requestParameters: PutBlockAllocationRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockAllocationRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to set block allocation for a range of dates for a list of room types. <p><strong>OperationId:</strong>putBlockAllocationRangeByExtId</p>
     * Set Block Allocation Range
     */
    async putBlockAllocationRangeByExtIdRaw(requestParameters: PutBlockAllocationRangeByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockExternalId === null || requestParameters.blockExternalId === undefined) {
            throw new runtime.RequiredError('blockExternalId','Required parameter requestParameters.blockExternalId was null or undefined when calling putBlockAllocationRangeByExtId.');
        }
        
        if (requestParameters.externalSystemCode === null || requestParameters.externalSystemCode === undefined) {
            throw new runtime.RequiredError('externalSystemCode','Required parameter requestParameters.externalSystemCode was null or undefined when calling putBlockAllocationRangeByExtId.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling putBlockAllocationRangeByExtId.');
        }
        
        if (requestParameters.blockAllocationRange === null || requestParameters.blockAllocationRange === undefined) {
            throw new runtime.RequiredError('blockAllocationRange','Required parameter requestParameters.blockAllocationRange was null or undefined when calling putBlockAllocationRangeByExtId.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/allocationRange`.replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockAllocationRangeToJSON(requestParameters.blockAllocationRange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to set block allocation for a range of dates for a list of room types. <p><strong>OperationId:</strong>putBlockAllocationRangeByExtId</p>
     * Set Block Allocation Range
     */
    async putBlockAllocationRangeByExtId(requestParameters: PutBlockAllocationRangeByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockAllocationRangeByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API removes block allocation to a range of dates for a set of room types. <p><strong>OperationId:</strong>putBlockAllocationWash</p>
     * Update Block Allocation Wash
     */
    async putBlockAllocationWashRaw(requestParameters: PutBlockAllocationWashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockAllocationWash === null || requestParameters.blockAllocationWash === undefined) {
            throw new runtime.RequiredError('blockAllocationWash','Required parameter requestParameters.blockAllocationWash was null or undefined when calling putBlockAllocationWash.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blockWash`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockAllocationWashToJSON(requestParameters.blockAllocationWash),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API removes block allocation to a range of dates for a set of room types. <p><strong>OperationId:</strong>putBlockAllocationWash</p>
     * Update Block Allocation Wash
     */
    async putBlockAllocationWash(requestParameters: PutBlockAllocationWashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockAllocationWashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You can use this API to update an existing block.  You must know the block ID for the request message.  Use getBlocks if you dont already know the block ID. <p><strong>OperationId:</strong>putBlockByExtId</p>
     * Change a Block
     */
    async putBlockByExtIdRaw(requestParameters: PutBlockByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockChanged>> {
        if (requestParameters.blockExternalId === null || requestParameters.blockExternalId === undefined) {
            throw new runtime.RequiredError('blockExternalId','Required parameter requestParameters.blockExternalId was null or undefined when calling putBlockByExtId.');
        }
        
        if (requestParameters.externalSystemCode === null || requestParameters.externalSystemCode === undefined) {
            throw new runtime.RequiredError('externalSystemCode','Required parameter requestParameters.externalSystemCode was null or undefined when calling putBlockByExtId.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling putBlockByExtId.');
        }
        
        if (requestParameters.blockToBeChanged === null || requestParameters.blockToBeChanged === undefined) {
            throw new runtime.RequiredError('blockToBeChanged','Required parameter requestParameters.blockToBeChanged was null or undefined when calling putBlockByExtId.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}`.replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockToBeChangedToJSON(requestParameters.blockToBeChanged),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockChangedFromJSON(jsonValue));
    }

    /**
     * You can use this API to update an existing block.  You must know the block ID for the request message.  Use getBlocks if you dont already know the block ID. <p><strong>OperationId:</strong>putBlockByExtId</p>
     * Change a Block
     */
    async putBlockByExtId(requestParameters: PutBlockByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockChanged> {
        const response = await this.putBlockByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API cuts off block allocation effective current date. <p><strong>OperationId:</strong>putBlockCutoff</p>
     * Block Cut Off
     */
    async putBlockCutoffRaw(requestParameters: PutBlockCutoffRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putBlockCutoff.');
        }
        
        if (requestParameters.blockStatus === null || requestParameters.blockStatus === undefined) {
            throw new runtime.RequiredError('blockStatus','Required parameter requestParameters.blockStatus was null or undefined when calling putBlockCutoff.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/blockCutOff`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockStatusToJSON(requestParameters.blockStatus),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API cuts off block allocation effective current date. <p><strong>OperationId:</strong>putBlockCutoff</p>
     * Block Cut Off
     */
    async putBlockCutoff(requestParameters: PutBlockCutoffRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockCutoffRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to change block owners. <p><strong>OperationId:</strong>putBlockOwners</p>
     * Change Block owners
     */
    async putBlockOwnersRaw(requestParameters: PutBlockOwnersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putBlockOwners.');
        }
        
        if (requestParameters.blockOwnersToChange === null || requestParameters.blockOwnersToChange === undefined) {
            throw new runtime.RequiredError('blockOwnersToChange','Required parameter requestParameters.blockOwnersToChange was null or undefined when calling putBlockOwners.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/owners`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockOwnersToChangeToJSON(requestParameters.blockOwnersToChange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to change block owners. <p><strong>OperationId:</strong>putBlockOwners</p>
     * Change Block owners
     */
    async putBlockOwners(requestParameters: PutBlockOwnersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockOwnersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to refreshes block rates. <p><strong>OperationId:</strong>putBlockRates</p>
     * Refreshes Block rates
     */
    async putBlockRatesRaw(requestParameters: PutBlockRatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putBlockRates.');
        }
        
        if (requestParameters.blockStatus === null || requestParameters.blockStatus === undefined) {
            throw new runtime.RequiredError('blockStatus','Required parameter requestParameters.blockStatus was null or undefined when calling putBlockRates.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/rates`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockStatusToJSON(requestParameters.blockStatus),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to refreshes block rates. <p><strong>OperationId:</strong>putBlockRates</p>
     * Refreshes Block rates
     */
    async putBlockRates(requestParameters: PutBlockRatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockRatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to make changes to block reservations. <p><strong>OperationId:</strong>putBlockReservations</p>
     * Change Block reservations
     */
    async putBlockReservationsRaw(requestParameters: PutBlockReservationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangedBlockReservations>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putBlockReservations.');
        }
        
        if (requestParameters.blockReservationsToChange === null || requestParameters.blockReservationsToChange === undefined) {
            throw new runtime.RequiredError('blockReservationsToChange','Required parameter requestParameters.blockReservationsToChange was null or undefined when calling putBlockReservations.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/reservations`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockReservationsToChangeToJSON(requestParameters.blockReservationsToChange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChangedBlockReservationsFromJSON(jsonValue));
    }

    /**
     * Use this API to make changes to block reservations. <p><strong>OperationId:</strong>putBlockReservations</p>
     * Change Block reservations
     */
    async putBlockReservations(requestParameters: PutBlockReservationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangedBlockReservations> {
        const response = await this.putBlockReservationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to move or shift the dates of a block in OPERA.  <p><strong>OperationId:</strong>putBlockShift</p>
     * Shifts the Block start date
     */
    async putBlockShiftRaw(requestParameters: PutBlockShiftRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShiftedBlock>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putBlockShift.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling putBlockShift.');
        }
        
        if (requestParameters.blockToShift === null || requestParameters.blockToShift === undefined) {
            throw new runtime.RequiredError('blockToShift','Required parameter requestParameters.blockToShift was null or undefined when calling putBlockShift.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/shifts`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockToShiftToJSON(requestParameters.blockToShift),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShiftedBlockFromJSON(jsonValue));
    }

    /**
     * Use this API to move or shift the dates of a block in OPERA.  <p><strong>OperationId:</strong>putBlockShift</p>
     * Shifts the Block start date
     */
    async putBlockShift(requestParameters: PutBlockShiftRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShiftedBlock> {
        const response = await this.putBlockShiftRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this to change the status of a block in Opera.  To know a hotels Block status codes, use the List Of Values API - BlockStatuses.  Also note, you can only change the status in a particular order, for example INQ to DEF, but not DEF to INQ. <p><strong>OperationId:</strong>putBlockStatus</p>
     * Change the Status of a Block
     */
    async putBlockStatusRaw(requestParameters: PutBlockStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangedBlockStatus>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putBlockStatus.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling putBlockStatus.');
        }
        
        if (requestParameters.blockStatusToChange === null || requestParameters.blockStatusToChange === undefined) {
            throw new runtime.RequiredError('blockStatusToChange','Required parameter requestParameters.blockStatusToChange was null or undefined when calling putBlockStatus.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/status`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockStatusToChangeToJSON(requestParameters.blockStatusToChange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChangedBlockStatusFromJSON(jsonValue));
    }

    /**
     * Use this to change the status of a block in Opera.  To know a hotels Block status codes, use the List Of Values API - BlockStatuses.  Also note, you can only change the status in a particular order, for example INQ to DEF, but not DEF to INQ. <p><strong>OperationId:</strong>putBlockStatus</p>
     * Change the Status of a Block
     */
    async putBlockStatus(requestParameters: PutBlockStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangedBlockStatus> {
        const response = await this.putBlockStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this to change the status of a block in Opera.  To know a hotels Block status codes, use the List Of Values API - BlockStatuses.  Also note, you can only change the status in a particular order, for example INQ to DEF, but not DEF to INQ. <p><strong>OperationId:</strong>putBlockStatusByExtId</p>
     * Change the Status of a Block
     */
    async putBlockStatusByExtIdRaw(requestParameters: PutBlockStatusByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangedBlockStatus>> {
        if (requestParameters.blockExternalId === null || requestParameters.blockExternalId === undefined) {
            throw new runtime.RequiredError('blockExternalId','Required parameter requestParameters.blockExternalId was null or undefined when calling putBlockStatusByExtId.');
        }
        
        if (requestParameters.externalSystemCode === null || requestParameters.externalSystemCode === undefined) {
            throw new runtime.RequiredError('externalSystemCode','Required parameter requestParameters.externalSystemCode was null or undefined when calling putBlockStatusByExtId.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling putBlockStatusByExtId.');
        }
        
        if (requestParameters.blockStatusToChange === null || requestParameters.blockStatusToChange === undefined) {
            throw new runtime.RequiredError('blockStatusToChange','Required parameter requestParameters.blockStatusToChange was null or undefined when calling putBlockStatusByExtId.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/status`.replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockStatusToChangeToJSON(requestParameters.blockStatusToChange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChangedBlockStatusFromJSON(jsonValue));
    }

    /**
     * Use this to change the status of a block in Opera.  To know a hotels Block status codes, use the List Of Values API - BlockStatuses.  Also note, you can only change the status in a particular order, for example INQ to DEF, but not DEF to INQ. <p><strong>OperationId:</strong>putBlockStatusByExtId</p>
     * Change the Status of a Block
     */
    async putBlockStatusByExtId(requestParameters: PutBlockStatusByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangedBlockStatus> {
        const response = await this.putBlockStatusByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to transition booking status in allotment header to an Open for Pickup Status, which ready to receive reservation bookings. <p><strong>OperationId:</strong>putBlockStatusToOpen</p>
     * Change Block status to Open
     */
    async putBlockStatusToOpenRaw(requestParameters: PutBlockStatusToOpenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putBlockStatusToOpen.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling putBlockStatusToOpen.');
        }
        
        if (requestParameters.blockStatus === null || requestParameters.blockStatus === undefined) {
            throw new runtime.RequiredError('blockStatus','Required parameter requestParameters.blockStatus was null or undefined when calling putBlockStatusToOpen.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/openStatus`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockStatusToJSON(requestParameters.blockStatus),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to transition booking status in allotment header to an Open for Pickup Status, which ready to receive reservation bookings. <p><strong>OperationId:</strong>putBlockStatusToOpen</p>
     * Change Block status to Open
     */
    async putBlockStatusToOpen(requestParameters: PutBlockStatusToOpenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockStatusToOpenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API changes block wash schedules Wash Date, Room Type, Occupancy detail, Sell limit and Wash by percent value. <p><strong>OperationId:</strong>putBlockWashSchedules</p>
     * Change Block Wash Schedules
     */
    async putBlockWashSchedulesRaw(requestParameters: PutBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putBlockWashSchedules.');
        }
        
        if (requestParameters.blockWashSchedulesInfo === null || requestParameters.blockWashSchedulesInfo === undefined) {
            throw new runtime.RequiredError('blockWashSchedulesInfo','Required parameter requestParameters.blockWashSchedulesInfo was null or undefined when calling putBlockWashSchedules.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/washSchedules`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockWashSchedulesInfoToJSON(requestParameters.blockWashSchedulesInfo),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API changes block wash schedules Wash Date, Room Type, Occupancy detail, Sell limit and Wash by percent value. <p><strong>OperationId:</strong>putBlockWashSchedules</p>
     * Change Block Wash Schedules
     */
    async putBlockWashSchedules(requestParameters: PutBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockWashSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to update catering status. <p><strong>OperationId:</strong>putCateringStatus</p>
     * Change Catering Status
     */
    async putCateringStatusRaw(requestParameters: PutCateringStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangedCateringStatus>> {
        if (requestParameters.eventId === null || requestParameters.eventId === undefined) {
            throw new runtime.RequiredError('eventId','Required parameter requestParameters.eventId was null or undefined when calling putCateringStatus.');
        }
        
        if (requestParameters.cateringStatusToChange === null || requestParameters.cateringStatusToChange === undefined) {
            throw new runtime.RequiredError('cateringStatusToChange','Required parameter requestParameters.cateringStatusToChange was null or undefined when calling putCateringStatus.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/caterings/{eventId}/cateringStatus`.replace(`{${"eventId"}}`, encodeURIComponent(String(requestParameters.eventId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CateringStatusToChangeToJSON(requestParameters.cateringStatusToChange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChangedCateringStatusFromJSON(jsonValue));
    }

    /**
     * Use this API to update catering status. <p><strong>OperationId:</strong>putCateringStatus</p>
     * Change Catering Status
     */
    async putCateringStatus(requestParameters: PutCateringStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangedCateringStatus> {
        const response = await this.putCateringStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API clears all block restrictions for a given date. <p><strong>OperationId:</strong>putClearAllRestrictions</p>
     * Clear-All Block Restrictions 
     */
    async putClearAllRestrictionsRaw(requestParameters: PutClearAllRestrictionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putClearAllRestrictions.');
        }
        
        if (requestParameters.allRestrictions === null || requestParameters.allRestrictions === undefined) {
            throw new runtime.RequiredError('allRestrictions','Required parameter requestParameters.allRestrictions was null or undefined when calling putClearAllRestrictions.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/restrictions`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AllRestrictionsToJSON(requestParameters.allRestrictions),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API clears all block restrictions for a given date. <p><strong>OperationId:</strong>putClearAllRestrictions</p>
     * Clear-All Block Restrictions 
     */
    async putClearAllRestrictions(requestParameters: PutClearAllRestrictionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putClearAllRestrictionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to set the contract defaults. <p><strong>OperationId:</strong>putContractDefaults</p>
     * Set Contract Defaults
     */
    async putContractDefaultsRaw(requestParameters: PutContractDefaultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockStatus === null || requestParameters.blockStatus === undefined) {
            throw new runtime.RequiredError('blockStatus','Required parameter requestParameters.blockStatus was null or undefined when calling putContractDefaults.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/contractDefaults`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockStatusToJSON(requestParameters.blockStatus),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to set the contract defaults. <p><strong>OperationId:</strong>putContractDefaults</p>
     * Set Contract Defaults
     */
    async putContractDefaults(requestParameters: PutContractDefaultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putContractDefaultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to borrow inventory from the block or house when you encounter an insufficient number of rooms for block a reservation. <p><strong>OperationId:</strong>putInventory</p>
     * Borrow Inventory
     */
    async putInventoryRaw(requestParameters: PutInventoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.inventoryToBorrow === null || requestParameters.inventoryToBorrow === undefined) {
            throw new runtime.RequiredError('inventoryToBorrow','Required parameter requestParameters.inventoryToBorrow was null or undefined when calling putInventory.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/inventory`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: InventoryToBorrowToJSON(requestParameters.inventoryToBorrow),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to borrow inventory from the block or house when you encounter an insufficient number of rooms for block a reservation. <p><strong>OperationId:</strong>putInventory</p>
     * Borrow Inventory
     */
    async putInventory(requestParameters: PutInventoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putInventoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to return the previously borrowed inventory on the block back to the original source from which it was borrowed. The original source can be a room type or house inventory, as indicated in the request. <p><strong>OperationId:</strong>putReleasedInventory</p>
     * Return Borrowed Inventory
     */
    async putReleasedInventoryRaw(requestParameters: PutReleasedInventoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.borrowedInventoryToReturn === null || requestParameters.borrowedInventoryToReturn === undefined) {
            throw new runtime.RequiredError('borrowedInventoryToReturn','Required parameter requestParameters.borrowedInventoryToReturn was null or undefined when calling putReleasedInventory.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/inventoryReleased`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BorrowedInventoryToReturnToJSON(requestParameters.borrowedInventoryToReturn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to return the previously borrowed inventory on the block back to the original source from which it was borrowed. The original source can be a room type or house inventory, as indicated in the request. <p><strong>OperationId:</strong>putReleasedInventory</p>
     * Return Borrowed Inventory
     */
    async putReleasedInventory(requestParameters: PutReleasedInventoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putReleasedInventoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to set room type order for a block. <p><strong>OperationId:</strong>putRoomTypeOrder</p>
     * Set room type order for a Block
     */
    async putRoomTypeOrderRaw(requestParameters: PutRoomTypeOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockId === null || requestParameters.blockId === undefined) {
            throw new runtime.RequiredError('blockId','Required parameter requestParameters.blockId was null or undefined when calling putRoomTypeOrder.');
        }
        
        if (requestParameters.roomTypeOrder === null || requestParameters.roomTypeOrder === undefined) {
            throw new runtime.RequiredError('roomTypeOrder','Required parameter requestParameters.roomTypeOrder was null or undefined when calling putRoomTypeOrder.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/roomTypeOrder`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RoomTypeOrderToJSON(requestParameters.roomTypeOrder),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to set room type order for a block. <p><strong>OperationId:</strong>putRoomTypeOrder</p>
     * Set room type order for a Block
     */
    async putRoomTypeOrder(requestParameters: PutRoomTypeOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putRoomTypeOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API validates the block code for the following if applicable - Unique block code/ Start of inventory week/ Block code template. <p><strong>OperationId:</strong>putValidateBlockCode</p>
     * Validate Block Code
     */
    async putValidateBlockCodeRaw(requestParameters: PutValidateBlockCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.blockCode === null || requestParameters.blockCode === undefined) {
            throw new runtime.RequiredError('blockCode','Required parameter requestParameters.blockCode was null or undefined when calling putValidateBlockCode.');
        }
        
        if (requestParameters.blockCodeToValidate === null || requestParameters.blockCodeToValidate === undefined) {
            throw new runtime.RequiredError('blockCodeToValidate','Required parameter requestParameters.blockCodeToValidate was null or undefined when calling putValidateBlockCode.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockCode}/actions/validate`.replace(`{${"blockCode"}}`, encodeURIComponent(String(requestParameters.blockCode))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BlockCodeToValidateToJSON(requestParameters.blockCodeToValidate),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API validates the block code for the following if applicable - Unique block code/ Start of inventory week/ Block code template. <p><strong>OperationId:</strong>putValidateBlockCode</p>
     * Validate Block Code
     */
    async putValidateBlockCode(requestParameters: PutValidateBlockCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putValidateBlockCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const DeleteBlockRestrictionCodeEnum = {
    Closed: 'Closed',
    ClosedForArrival: 'ClosedForArrival',
    ClosedForDeparture: 'ClosedForDeparture',
    MinimumStayThrough: 'MinimumStayThrough',
    MaximumStayThrough: 'MaximumStayThrough',
    MinimumLengthOfStay: 'MinimumLengthOfStay',
    MaximumLengthOfStay: 'MaximumLengthOfStay',
    LosNotAvailable: 'LOSNotAvailable',
    MinimumAdvanceBooking: 'MinimumAdvanceBooking',
    MaximumAdvanceBooking: 'MaximumAdvanceBooking',
    Open: 'Open',
    OpenForArrival: 'OpenForArrival',
    OpenForDeparture: 'OpenForDeparture'
} as const;
export type DeleteBlockRestrictionCodeEnum = typeof DeleteBlockRestrictionCodeEnum[keyof typeof DeleteBlockRestrictionCodeEnum];
/**
 * @export
 */
export const GetBlockFetchInstructionsEnum = {
    AccessExclusions: 'AccessExclusions',
    Aliases: 'Aliases',
    AlternateDates: 'AlternateDates',
    Attachments: 'Attachments',
    Block: 'Block',
    BlockNextStatuses: 'BlockNextStatuses',
    BlockStatusHistory: 'BlockStatusHistory',
    CatNextStatuses: 'CatNextStatuses',
    CatStatusHistory: 'CatStatusHistory',
    CentralSalesLeads: 'CentralSalesLeads',
    Comments: 'Comments',
    DateProtect: 'DateProtect',
    ExternalReferences: 'ExternalReferences',
    GenericRateGrid: 'GenericRateGrid',
    Header: 'Header',
    Indicators: 'Indicators',
    InventoryItems: 'InventoryItems',
    Owners: 'Owners',
    Packages: 'Packages',
    Policies: 'Policies',
    PrimaryOwners: 'PrimaryOwners',
    PrimaryProfiles: 'PrimaryProfiles',
    PrimaryRates: 'PrimaryRates',
    Profiles: 'Profiles',
    RateGrid: 'RateGrid',
    RateProgram: 'RateProgram',
    Rates: 'Rates',
    Restrictions: 'Restrictions',
    SellMessages: 'SellMessages',
    Statistics: 'Statistics',
    SummaryStatistics: 'SummaryStatistics',
    Traces: 'Traces',
    WashSchedules: 'WashSchedules'
} as const;
export type GetBlockFetchInstructionsEnum = typeof GetBlockFetchInstructionsEnum[keyof typeof GetBlockFetchInstructionsEnum];
/**
 * @export
 */
export const GetBlockRoomAllocationCriteriaEnum = {
    Initial: 'Initial',
    Actual: 'Actual',
    Rates: 'Rates',
    Pickup: 'Pickup',
    Contract: 'Contract',
    Available: 'Available',
    Pickupperc: 'Pickupperc',
    Changes: 'Changes',
    Released: 'Released',
    Houseavailability: 'Houseavailability',
    SellLimit: 'SellLimit',
    AvailableSellLimit: 'AvailableSellLimit',
    MasterAllocInitial: 'MasterAllocInitial',
    Allocated: 'Allocated',
    SubAllocResv: 'SubAllocResv',
    CutoffDate: 'CutoffDate'
} as const;
export type GetBlockRoomAllocationCriteriaEnum = typeof GetBlockRoomAllocationCriteriaEnum[keyof typeof GetBlockRoomAllocationCriteriaEnum];
/**
 * @export
 */
export const GetBlockActivityLogModuleEnum = {
    Reservation: 'Reservation',
    Contract: 'Contract',
    Allotment: 'Allotment',
    Outlookview: 'Outlookview',
    Profile: 'Profile',
    Accountreceivables: 'Accountreceivables',
    GdsConvRateCodes: 'GdsConvRateCodes',
    RateCode: 'RateCode',
    Billing: 'Billing',
    Activity: 'Activity'
} as const;
export type GetBlockActivityLogModuleEnum = typeof GetBlockActivityLogModuleEnum[keyof typeof GetBlockActivityLogModuleEnum];
/**
 * @export
 */
export const GetBlockAvailabilityFetchAllocatedRoomTypeEnum = {
    Allocated: 'Allocated',
    Available: 'Available',
    GenericAllocated: 'GenericAllocated',
    GenericAvailable: 'GenericAvailable'
} as const;
export type GetBlockAvailabilityFetchAllocatedRoomTypeEnum = typeof GetBlockAvailabilityFetchAllocatedRoomTypeEnum[keyof typeof GetBlockAvailabilityFetchAllocatedRoomTypeEnum];
/**
 * @export
 */
export const GetBlockByExtIdFetchInstructionsEnum = {
    AccessExclusions: 'AccessExclusions',
    Aliases: 'Aliases',
    AlternateDates: 'AlternateDates',
    Attachments: 'Attachments',
    Block: 'Block',
    BlockNextStatuses: 'BlockNextStatuses',
    BlockStatusHistory: 'BlockStatusHistory',
    CatNextStatuses: 'CatNextStatuses',
    CatStatusHistory: 'CatStatusHistory',
    CentralSalesLeads: 'CentralSalesLeads',
    Comments: 'Comments',
    DateProtect: 'DateProtect',
    ExternalReferences: 'ExternalReferences',
    GenericRateGrid: 'GenericRateGrid',
    Header: 'Header',
    Indicators: 'Indicators',
    InventoryItems: 'InventoryItems',
    Owners: 'Owners',
    Packages: 'Packages',
    Policies: 'Policies',
    PrimaryOwners: 'PrimaryOwners',
    PrimaryProfiles: 'PrimaryProfiles',
    PrimaryRates: 'PrimaryRates',
    Profiles: 'Profiles',
    RateGrid: 'RateGrid',
    RateProgram: 'RateProgram',
    Rates: 'Rates',
    Restrictions: 'Restrictions',
    SellMessages: 'SellMessages',
    Statistics: 'Statistics',
    SummaryStatistics: 'SummaryStatistics',
    Traces: 'Traces',
    WashSchedules: 'WashSchedules'
} as const;
export type GetBlockByExtIdFetchInstructionsEnum = typeof GetBlockByExtIdFetchInstructionsEnum[keyof typeof GetBlockByExtIdFetchInstructionsEnum];
/**
 * @export
 */
export const GetBlockByExtIdRoomAllocationCriteriaEnum = {
    Initial: 'Initial',
    Actual: 'Actual',
    Rates: 'Rates',
    Pickup: 'Pickup',
    Contract: 'Contract',
    Available: 'Available',
    Pickupperc: 'Pickupperc',
    Changes: 'Changes',
    Released: 'Released',
    Houseavailability: 'Houseavailability',
    SellLimit: 'SellLimit',
    AvailableSellLimit: 'AvailableSellLimit',
    MasterAllocInitial: 'MasterAllocInitial',
    Allocated: 'Allocated',
    SubAllocResv: 'SubAllocResv',
    CutoffDate: 'CutoffDate'
} as const;
export type GetBlockByExtIdRoomAllocationCriteriaEnum = typeof GetBlockByExtIdRoomAllocationCriteriaEnum[keyof typeof GetBlockByExtIdRoomAllocationCriteriaEnum];
/**
 * @export
 */
export const GetBlockReservationsFetchInstructionsEnum = {
    Reservation: 'Reservation',
    Comments: 'Comments',
    GuestComments: 'GuestComments',
    Packages: 'Packages',
    InventoryItems: 'InventoryItems',
    ReservationPaymentMethods: 'ReservationPaymentMethods',
    RoutingInstructions: 'RoutingInstructions',
    Preferences: 'Preferences',
    Memberships: 'Memberships',
    Alerts: 'Alerts',
    Traces: 'Traces',
    ConfirmationLetters: 'ConfirmationLetters',
    CallHistory: 'CallHistory',
    FixedCharges: 'FixedCharges',
    GuestMessages: 'GuestMessages',
    ReservationPolicies: 'ReservationPolicies',
    Indicators: 'Indicators',
    LinkedReservations: 'LinkedReservations',
    RevenuesAndBalances: 'RevenuesAndBalances',
    GuestLastStay: 'GuestLastStay',
    ECoupons: 'ECoupons',
    TrackItItems: 'TrackItItems',
    TotalCostOfStay: 'TotalCostOfStay',
    ReservationAwards: 'ReservationAwards',
    WebRegistrationCards: 'WebRegistrationCards',
    ServiceRequests: 'ServiceRequests',
    ReservationActivities: 'ReservationActivities',
    ScheduledActivities: 'ScheduledActivities',
    PrepaidCards: 'PrepaidCards',
    Shares: 'Shares',
    Attachments: 'Attachments',
    Locators: 'Locators',
    ProfileAwards: 'ProfileAwards',
    TransactionDiversions: 'TransactionDiversions',
    Tickets: 'Tickets',
    GuestMemberships: 'GuestMemberships',
    ECertificates: 'ECertificates',
    UpsellInfo: 'UpsellInfo',
    RoomAssignedByAi: 'RoomAssignedByAI',
    CustomNameValue: 'CustomNameValue',
    CustomChargeExemptions: 'CustomChargeExemptions'
} as const;
export type GetBlockReservationsFetchInstructionsEnum = typeof GetBlockReservationsFetchInstructionsEnum[keyof typeof GetBlockReservationsFetchInstructionsEnum];
/**
 * @export
 */
export const GetBlockStatisticsStatisticsInstructionsEnum = {
    Contract: 'Contract',
    Initial: 'Initial',
    Actual: 'Actual',
    Pickup: 'Pickup',
    Available: 'Available',
    Change: 'Change',
    Rates: 'Rates',
    Totalavailable: 'Totalavailable',
    Tentativereservations: 'Tentativereservations',
    Pickuppersons: 'Pickuppersons',
    Roomrevenue: 'Roomrevenue',
    Totalrevenue: 'Totalrevenue',
    Avgroomrate: 'Avgroomrate'
} as const;
export type GetBlockStatisticsStatisticsInstructionsEnum = typeof GetBlockStatisticsStatisticsInstructionsEnum[keyof typeof GetBlockStatisticsStatisticsInstructionsEnum];
/**
 * @export
 */
export const GetBlocksCategoryEnum = {
    Group: 'Group',
    Source: 'Source',
    Agent: 'Agent',
    Contact: 'Contact',
    Company: 'Company',
    Account: 'Account'
} as const;
export type GetBlocksCategoryEnum = typeof GetBlocksCategoryEnum[keyof typeof GetBlocksCategoryEnum];
/**
 * @export
 */
export const GetBlocksOrderTypeEnum = {
    Asc: 'Asc',
    Desc: 'Desc'
} as const;
export type GetBlocksOrderTypeEnum = typeof GetBlocksOrderTypeEnum[keyof typeof GetBlocksOrderTypeEnum];
/**
 * @export
 */
export const GetBlocksFetchInstructionsEnum = {
    AccessExclusions: 'AccessExclusions',
    Aliases: 'Aliases',
    AlternateDates: 'AlternateDates',
    Attachments: 'Attachments',
    Block: 'Block',
    BlockNextStatuses: 'BlockNextStatuses',
    BlockStatusHistory: 'BlockStatusHistory',
    CatNextStatuses: 'CatNextStatuses',
    CatStatusHistory: 'CatStatusHistory',
    CentralSalesLeads: 'CentralSalesLeads',
    Comments: 'Comments',
    DateProtect: 'DateProtect',
    ExternalReferences: 'ExternalReferences',
    GenericRateGrid: 'GenericRateGrid',
    Header: 'Header',
    Indicators: 'Indicators',
    InventoryItems: 'InventoryItems',
    Owners: 'Owners',
    Packages: 'Packages',
    Policies: 'Policies',
    PrimaryOwners: 'PrimaryOwners',
    PrimaryProfiles: 'PrimaryProfiles',
    PrimaryRates: 'PrimaryRates',
    Profiles: 'Profiles',
    RateGrid: 'RateGrid',
    RateProgram: 'RateProgram',
    Rates: 'Rates',
    Restrictions: 'Restrictions',
    SellMessages: 'SellMessages',
    Statistics: 'Statistics',
    SummaryStatistics: 'SummaryStatistics',
    Traces: 'Traces',
    WashSchedules: 'WashSchedules'
} as const;
export type GetBlocksFetchInstructionsEnum = typeof GetBlocksFetchInstructionsEnum[keyof typeof GetBlocksFetchInstructionsEnum];
/**
 * @export
 */
export const GetBlocksRoomAllocationCriteriaEnum = {
    Initial: 'Initial',
    Actual: 'Actual',
    Rates: 'Rates',
    Pickup: 'Pickup',
    Contract: 'Contract',
    Available: 'Available',
    Pickupperc: 'Pickupperc',
    Changes: 'Changes',
    Released: 'Released',
    Houseavailability: 'Houseavailability',
    SellLimit: 'SellLimit',
    AvailableSellLimit: 'AvailableSellLimit',
    MasterAllocInitial: 'MasterAllocInitial',
    Allocated: 'Allocated',
    SubAllocResv: 'SubAllocResv',
    CutoffDate: 'CutoffDate'
} as const;
export type GetBlocksRoomAllocationCriteriaEnum = typeof GetBlocksRoomAllocationCriteriaEnum[keyof typeof GetBlocksRoomAllocationCriteriaEnum];
/**
 * @export
 */
export const GetBlocksAccessRestrictionEnum = {
    Availability: 'Availability',
    Create: 'Create',
    Modify: 'Modify',
    Cancel: 'Cancel'
} as const;
export type GetBlocksAccessRestrictionEnum = typeof GetBlocksAccessRestrictionEnum[keyof typeof GetBlocksAccessRestrictionEnum];
