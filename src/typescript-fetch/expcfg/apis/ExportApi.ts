/* tslint:disable */
/* eslint-disable */
/**
 * OPERA Cloud Export Configuration API
 * APIs catering to the managing export master data configuration. <br /><The exports feature in OPERA Cloud provides the ability to create and export data files, such as back office data, to third-party interfaces and receiving systems.<br /><br /> Compatible with OPERA Cloud release 24.4.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2024 Oracle and/or its affiliates.</p>
 *
 * The version of the OpenAPI document: 24.4
 * Contact: hospitality_apis_ww_grp@oracle.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ExceptionDetailType,
  ExportActivityLog,
  ExportColumnsAndFunctionsDetails,
  ExportMappingCodes,
  ExportMappingCodesDetails,
  ExportMappingCodesToLink,
  ExportMappingLinkedCodes,
  ExportMappingLinkedTypes,
  ExportMappingLinkedTypesDetails,
  ExportMappings,
  ExportMappingsDetails,
  ExportSchedulesCriteria,
  ExportSchedulesDetails,
  ExportSchedulesStatus,
  ExportSchedulesToBeChanged,
  ExportsAvailable,
  FetchExportMappingCodes,
  FetchExportMappings,
  GeneratedExports,
  Status,
} from '../models/index';
import {
    ExceptionDetailTypeFromJSON,
    ExceptionDetailTypeToJSON,
    ExportActivityLogFromJSON,
    ExportActivityLogToJSON,
    ExportColumnsAndFunctionsDetailsFromJSON,
    ExportColumnsAndFunctionsDetailsToJSON,
    ExportMappingCodesFromJSON,
    ExportMappingCodesToJSON,
    ExportMappingCodesDetailsFromJSON,
    ExportMappingCodesDetailsToJSON,
    ExportMappingCodesToLinkFromJSON,
    ExportMappingCodesToLinkToJSON,
    ExportMappingLinkedCodesFromJSON,
    ExportMappingLinkedCodesToJSON,
    ExportMappingLinkedTypesFromJSON,
    ExportMappingLinkedTypesToJSON,
    ExportMappingLinkedTypesDetailsFromJSON,
    ExportMappingLinkedTypesDetailsToJSON,
    ExportMappingsFromJSON,
    ExportMappingsToJSON,
    ExportMappingsDetailsFromJSON,
    ExportMappingsDetailsToJSON,
    ExportSchedulesCriteriaFromJSON,
    ExportSchedulesCriteriaToJSON,
    ExportSchedulesDetailsFromJSON,
    ExportSchedulesDetailsToJSON,
    ExportSchedulesStatusFromJSON,
    ExportSchedulesStatusToJSON,
    ExportSchedulesToBeChangedFromJSON,
    ExportSchedulesToBeChangedToJSON,
    ExportsAvailableFromJSON,
    ExportsAvailableToJSON,
    FetchExportMappingCodesFromJSON,
    FetchExportMappingCodesToJSON,
    FetchExportMappingsFromJSON,
    FetchExportMappingsToJSON,
    GeneratedExportsFromJSON,
    GeneratedExportsToJSON,
    StatusFromJSON,
    StatusToJSON,
} from '../models/index';

export interface ChangeExportSchedulesRequest {
    hotelId: string;
    exportFileId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportSchedulesToBeChanged: ExportSchedulesToBeChanged;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface ChangeExportSchedulesByChainRequest {
    exportFileId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportSchedulesToBeChanged: ExportSchedulesToBeChanged;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteExistingExportMappingsRequest {
    exportMappingId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteExportMappingCodesRequest {
    mappingTypeCode: string;
    exportMappingId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportActivityLogRequest {
    hotelId: string;
    activityType: string;
    fromDate: string;
    toDate: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    limit?: number;
    offset?: number;
    module?: GetExportActivityLogModuleEnum;
    parameterName?: Array<string>;
    parameterValue?: Array<string>;
    activityGroup?: string;
    searchText?: string;
    userByIds?: Array<number>;
    userForIds?: Array<number>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportColumnsAndFunctionsRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    fetchDbColumns?: boolean;
    fetchOperaApis?: boolean;
    fetchPrePostProcedures?: boolean;
    dataSource?: string;
    exportFileId?: string;
    category?: GetExportColumnsAndFunctionsCategoryEnum;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportMappingCodesRequest {
    exportMappingTypeId: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportMappingCodesToLinkRequest {
    configType: string;
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    code?: string;
    description?: string;
    limit?: number;
    offset?: number;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportMappingLinkedCodesRequest {
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    id?: string;
    idExtension?: number;
    idContext?: string;
    type?: string;
    codeToLink?: string;
    configType?: GetExportMappingLinkedCodesConfigTypeEnum;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportMappingsRequest {
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportMappingConfigs?: Set<GetExportMappingsExportMappingConfigsEnum>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportMappingsByChainRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    exportMappingConfigs?: Set<GetExportMappingsByChainExportMappingConfigsEnum>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportSchedulesRequest {
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    timeZone?: string;
    exportFileId?: string;
    idExtension?: number;
    idContext?: string;
    type?: string;
    exportGroup?: GetExportSchedulesExportGroupEnum;
    exportName?: string;
    startDate?: string;
    endDate?: string;
    frequency?: GetExportSchedulesFrequencyEnum;
    includeInactive?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportsAvailableRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    fetchColumns?: boolean;
    fetchDataSetup?: boolean;
    fetchDestinationSetup?: boolean;
    fetchGenerateConfiguration?: boolean;
    limit?: number;
    exportFileId?: string;
    idExtension?: number;
    idContext?: string;
    type?: string;
    hotelIds?: Array<string>;
    fileGroup?: GetExportsAvailableFileGroupEnum;
    includeInactive?: boolean;
    match?: string;
    includeComponents?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportsGeneratedRequest {
    exportFileId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportDataId?: string;
    limit?: number;
    offset?: number;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostExportMappingCodesRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportMappingCodes: ExportMappingCodes;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostExportMappingsRequest {
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportMappings: ExportMappings;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostExportSchedulesRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportSchedulesCriteria: ExportSchedulesCriteria;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutExportMappingCodesRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportMappingCodes: ExportMappingCodes;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutExportMappingLinkedTypesRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportMappingLinkedTypes: ExportMappingLinkedTypes;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutExportMappingsRequest {
    hotelId: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportMappings: ExportMappings;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface RemoveExportSchedulesRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    jobNames?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

/**
 * 
 */
export class ExportApi extends runtime.BaseAPI {

    /**
     * Use this API to update export schedules based on the exportFileId and exportSchedulesToBeChanged. <p><strong>OperationId:</strong>changeExportSchedules</p>
     * Operation to change export schedules.
     */
    async changeExportSchedulesRaw(requestParameters: ChangeExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportSchedulesStatus>> {
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling changeExportSchedules.');
        }
        
        if (requestParameters.exportFileId === null || requestParameters.exportFileId === undefined) {
            throw new runtime.RequiredError('exportFileId','Required parameter requestParameters.exportFileId was null or undefined when calling changeExportSchedules.');
        }
        
        if (requestParameters.exportSchedulesToBeChanged === null || requestParameters.exportSchedulesToBeChanged === undefined) {
            throw new runtime.RequiredError('exportSchedulesToBeChanged','Required parameter requestParameters.exportSchedulesToBeChanged was null or undefined when calling changeExportSchedules.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportSchedules/{exportFileId}`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))).replace(`{${"exportFileId"}}`, encodeURIComponent(String(requestParameters.exportFileId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ExportSchedulesToBeChangedToJSON(requestParameters.exportSchedulesToBeChanged),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportSchedulesStatusFromJSON(jsonValue));
    }

    /**
     * Use this API to update export schedules based on the exportFileId and exportSchedulesToBeChanged. <p><strong>OperationId:</strong>changeExportSchedules</p>
     * Operation to change export schedules.
     */
    async changeExportSchedules(requestParameters: ChangeExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportSchedulesStatus> {
        const response = await this.changeExportSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>changeExportSchedulesByChain</p>
     * Operation to change export schedules.
     */
    async changeExportSchedulesByChainRaw(requestParameters: ChangeExportSchedulesByChainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportSchedulesStatus>> {
        if (requestParameters.exportFileId === null || requestParameters.exportFileId === undefined) {
            throw new runtime.RequiredError('exportFileId','Required parameter requestParameters.exportFileId was null or undefined when calling changeExportSchedulesByChain.');
        }
        
        if (requestParameters.exportSchedulesToBeChanged === null || requestParameters.exportSchedulesToBeChanged === undefined) {
            throw new runtime.RequiredError('exportSchedulesToBeChanged','Required parameter requestParameters.exportSchedulesToBeChanged was null or undefined when calling changeExportSchedulesByChain.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportSchedules/{exportFileId}`.replace(`{${"exportFileId"}}`, encodeURIComponent(String(requestParameters.exportFileId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ExportSchedulesToBeChangedToJSON(requestParameters.exportSchedulesToBeChanged),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportSchedulesStatusFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>changeExportSchedulesByChain</p>
     * Operation to change export schedules.
     */
    async changeExportSchedulesByChain(requestParameters: ChangeExportSchedulesByChainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportSchedulesStatus> {
        const response = await this.changeExportSchedulesByChainRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete export mappings for a specific property based on the exportMappingId and the hotelId. <p><strong>OperationId:</strong>deleteExistingExportMappings</p>
     * Operation to remove export mappings.
     */
    async deleteExistingExportMappingsRaw(requestParameters: DeleteExistingExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.exportMappingId === null || requestParameters.exportMappingId === undefined) {
            throw new runtime.RequiredError('exportMappingId','Required parameter requestParameters.exportMappingId was null or undefined when calling deleteExistingExportMappings.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling deleteExistingExportMappings.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappingId/{exportMappingId}/exportMappings`.replace(`{${"exportMappingId"}}`, encodeURIComponent(String(requestParameters.exportMappingId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete export mappings for a specific property based on the exportMappingId and the hotelId. <p><strong>OperationId:</strong>deleteExistingExportMappings</p>
     * Operation to remove export mappings.
     */
    async deleteExistingExportMappings(requestParameters: DeleteExistingExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteExistingExportMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>deleteExportMappingCodes</p>
     * Operation to remove export mapping codes.
     */
    async deleteExportMappingCodesRaw(requestParameters: DeleteExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.mappingTypeCode === null || requestParameters.mappingTypeCode === undefined) {
            throw new runtime.RequiredError('mappingTypeCode','Required parameter requestParameters.mappingTypeCode was null or undefined when calling deleteExportMappingCodes.');
        }
        
        if (requestParameters.exportMappingId === null || requestParameters.exportMappingId === undefined) {
            throw new runtime.RequiredError('exportMappingId','Required parameter requestParameters.exportMappingId was null or undefined when calling deleteExportMappingCodes.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling deleteExportMappingCodes.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappings/{exportMappingId}/mappingTypes/{mappingTypeCode}/exportMappingCodes`.replace(`{${"mappingTypeCode"}}`, encodeURIComponent(String(requestParameters.mappingTypeCode))).replace(`{${"exportMappingId"}}`, encodeURIComponent(String(requestParameters.exportMappingId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>deleteExportMappingCodes</p>
     * Operation to remove export mapping codes.
     */
    async deleteExportMappingCodes(requestParameters: DeleteExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteExportMappingCodesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to return activity logs for export data for a specific property based on search criteria such as hotelId, activityType, fromDate, toDate, limit, offset, module, parameterName, parameterValue, activityGroup, searchText, userByIds, userForIds.  <p><strong>OperationId:</strong>getExportActivityLog</p> <p>The maximum allowable limit for this API is <strong>25</strong>.</p>
     * Operation to fetch activity logs for Export Data.
     */
    async getExportActivityLogRaw(requestParameters: GetExportActivityLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportActivityLog>> {
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getExportActivityLog.');
        }
        
        if (requestParameters.activityType === null || requestParameters.activityType === undefined) {
            throw new runtime.RequiredError('activityType','Required parameter requestParameters.activityType was null or undefined when calling getExportActivityLog.');
        }
        
        if (requestParameters.fromDate === null || requestParameters.fromDate === undefined) {
            throw new runtime.RequiredError('fromDate','Required parameter requestParameters.fromDate was null or undefined when calling getExportActivityLog.');
        }
        
        if (requestParameters.toDate === null || requestParameters.toDate === undefined) {
            throw new runtime.RequiredError('toDate','Required parameter requestParameters.toDate was null or undefined when calling getExportActivityLog.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.activityType !== undefined) {
            queryParameters['activityType'] = requestParameters.activityType;
        }

        if (requestParameters.fromDate !== undefined) {
            queryParameters['fromDate'] = requestParameters.fromDate;
        }

        if (requestParameters.toDate !== undefined) {
            queryParameters['toDate'] = requestParameters.toDate;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.module !== undefined) {
            queryParameters['module'] = requestParameters.module;
        }

        if (requestParameters.parameterName) {
            queryParameters['parameterName'] = requestParameters.parameterName;
        }

        if (requestParameters.parameterValue) {
            queryParameters['parameterValue'] = requestParameters.parameterValue;
        }

        if (requestParameters.activityGroup !== undefined) {
            queryParameters['activityGroup'] = requestParameters.activityGroup;
        }

        if (requestParameters.searchText !== undefined) {
            queryParameters['searchText'] = requestParameters.searchText;
        }

        if (requestParameters.userByIds) {
            queryParameters['userByIds'] = requestParameters.userByIds;
        }

        if (requestParameters.userForIds) {
            queryParameters['userForIds'] = requestParameters.userForIds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportActivityLog`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportActivityLogFromJSON(jsonValue));
    }

    /**
     * Use this API to return activity logs for export data for a specific property based on search criteria such as hotelId, activityType, fromDate, toDate, limit, offset, module, parameterName, parameterValue, activityGroup, searchText, userByIds, userForIds.  <p><strong>OperationId:</strong>getExportActivityLog</p> <p>The maximum allowable limit for this API is <strong>25</strong>.</p>
     * Operation to fetch activity logs for Export Data.
     */
    async getExportActivityLog(requestParameters: GetExportActivityLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportActivityLog> {
        const response = await this.getExportActivityLogRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to return export columns and functions based on search criteria such as fetchDbColumns, fetchOperaApis, fetchPrePostProcedures, dataSource, exportFileId, category. <p><strong>OperationId:</strong>getExportColumnsAndFunctions</p>
     * Operation to fetch export columns and functions.
     */
    async getExportColumnsAndFunctionsRaw(requestParameters: GetExportColumnsAndFunctionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportColumnsAndFunctionsDetails>> {
        const queryParameters: any = {};

        if (requestParameters.fetchDbColumns !== undefined) {
            queryParameters['fetchDbColumns'] = requestParameters.fetchDbColumns;
        }

        if (requestParameters.fetchOperaApis !== undefined) {
            queryParameters['fetchOperaApis'] = requestParameters.fetchOperaApis;
        }

        if (requestParameters.fetchPrePostProcedures !== undefined) {
            queryParameters['fetchPrePostProcedures'] = requestParameters.fetchPrePostProcedures;
        }

        if (requestParameters.dataSource !== undefined) {
            queryParameters['dataSource'] = requestParameters.dataSource;
        }

        if (requestParameters.exportFileId !== undefined) {
            queryParameters['exportFileId'] = requestParameters.exportFileId;
        }

        if (requestParameters.category !== undefined) {
            queryParameters['category'] = requestParameters.category;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/columnsAndFunctions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportColumnsAndFunctionsDetailsFromJSON(jsonValue));
    }

    /**
     * Use this API to return export columns and functions based on search criteria such as fetchDbColumns, fetchOperaApis, fetchPrePostProcedures, dataSource, exportFileId, category. <p><strong>OperationId:</strong>getExportColumnsAndFunctions</p>
     * Operation to fetch export columns and functions.
     */
    async getExportColumnsAndFunctions(requestParameters: GetExportColumnsAndFunctionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportColumnsAndFunctionsDetails> {
        const response = await this.getExportColumnsAndFunctionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingCodes</p>
     * Operation to fetch export mapping codes.
     */
    async getExportMappingCodesRaw(requestParameters: GetExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchExportMappingCodes>> {
        if (requestParameters.exportMappingTypeId === null || requestParameters.exportMappingTypeId === undefined) {
            throw new runtime.RequiredError('exportMappingTypeId','Required parameter requestParameters.exportMappingTypeId was null or undefined when calling getExportMappingCodes.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getExportMappingCodes.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappingTypes/{exportMappingTypeId}/exportMappingCodes`.replace(`{${"exportMappingTypeId"}}`, encodeURIComponent(String(requestParameters.exportMappingTypeId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchExportMappingCodesFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingCodes</p>
     * Operation to fetch export mapping codes.
     */
    async getExportMappingCodes(requestParameters: GetExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchExportMappingCodes> {
        const response = await this.getExportMappingCodesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingCodesToLink</p>
     * Operation to fetch export mapping codes to link.
     */
    async getExportMappingCodesToLinkRaw(requestParameters: GetExportMappingCodesToLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportMappingCodesToLink>> {
        if (requestParameters.configType === null || requestParameters.configType === undefined) {
            throw new runtime.RequiredError('configType','Required parameter requestParameters.configType was null or undefined when calling getExportMappingCodesToLink.');
        }
        
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getExportMappingCodesToLink.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.code !== undefined) {
            queryParameters['code'] = requestParameters.code;
        }

        if (requestParameters.description !== undefined) {
            queryParameters['description'] = requestParameters.description;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/configTypes/{configType}/exportMappingCodesToLink`.replace(`{${"configType"}}`, encodeURIComponent(String(requestParameters.configType))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportMappingCodesToLinkFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingCodesToLink</p>
     * Operation to fetch export mapping codes to link.
     */
    async getExportMappingCodesToLink(requestParameters: GetExportMappingCodesToLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportMappingCodesToLink> {
        const response = await this.getExportMappingCodesToLinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingLinkedCodes</p>
     * Operation to fetch export mapping linked codes.
     */
    async getExportMappingLinkedCodesRaw(requestParameters: GetExportMappingLinkedCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportMappingLinkedCodes>> {
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getExportMappingLinkedCodes.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.idExtension !== undefined) {
            queryParameters['idExtension'] = requestParameters.idExtension;
        }

        if (requestParameters.idContext !== undefined) {
            queryParameters['idContext'] = requestParameters.idContext;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.codeToLink !== undefined) {
            queryParameters['codeToLink'] = requestParameters.codeToLink;
        }

        if (requestParameters.configType !== undefined) {
            queryParameters['configType'] = requestParameters.configType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappings/linkedCodes`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportMappingLinkedCodesFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingLinkedCodes</p>
     * Operation to fetch export mapping linked codes.
     */
    async getExportMappingLinkedCodes(requestParameters: GetExportMappingLinkedCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportMappingLinkedCodes> {
        const response = await this.getExportMappingLinkedCodesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappings</p>
     * Operation to fetch export mappings.
     */
    async getExportMappingsRaw(requestParameters: GetExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchExportMappings>> {
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getExportMappings.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.exportMappingConfigs) {
            queryParameters['exportMappingConfigs'] = requestParameters.exportMappingConfigs;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappings`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchExportMappingsFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappings</p>
     * Operation to fetch export mappings.
     */
    async getExportMappings(requestParameters: GetExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchExportMappings> {
        const response = await this.getExportMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingsByChain</p>
     * Operation to fetch export mappings by chain.
     */
    async getExportMappingsByChainRaw(requestParameters: GetExportMappingsByChainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchExportMappings>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.exportMappingConfigs) {
            queryParameters['exportMappingConfigs'] = requestParameters.exportMappingConfigs;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportMappings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchExportMappingsFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingsByChain</p>
     * Operation to fetch export mappings by chain.
     */
    async getExportMappingsByChain(requestParameters: GetExportMappingsByChainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchExportMappings> {
        const response = await this.getExportMappingsByChainRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to return export schedules for a specific property based on search criteria such as hotelId, timeZone, exportFileId, idExtension, idContext, type, exportGroup, exportName, startDate, endDate, frequency, includeInactive.  <p><strong>OperationId:</strong>getExportSchedules</p>
     * Operation to fetch export schedules.
     */
    async getExportSchedulesRaw(requestParameters: GetExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportSchedulesDetails>> {
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling getExportSchedules.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.timeZone !== undefined) {
            queryParameters['timeZone'] = requestParameters.timeZone;
        }

        if (requestParameters.exportFileId !== undefined) {
            queryParameters['exportFileId'] = requestParameters.exportFileId;
        }

        if (requestParameters.idExtension !== undefined) {
            queryParameters['idExtension'] = requestParameters.idExtension;
        }

        if (requestParameters.idContext !== undefined) {
            queryParameters['idContext'] = requestParameters.idContext;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.exportGroup !== undefined) {
            queryParameters['exportGroup'] = requestParameters.exportGroup;
        }

        if (requestParameters.exportName !== undefined) {
            queryParameters['exportName'] = requestParameters.exportName;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = requestParameters.startDate;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = requestParameters.endDate;
        }

        if (requestParameters.frequency !== undefined) {
            queryParameters['frequency'] = requestParameters.frequency;
        }

        if (requestParameters.includeInactive !== undefined) {
            queryParameters['includeInactive'] = requestParameters.includeInactive;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportSchedules`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportSchedulesDetailsFromJSON(jsonValue));
    }

    /**
     * Use this API to return export schedules for a specific property based on search criteria such as hotelId, timeZone, exportFileId, idExtension, idContext, type, exportGroup, exportName, startDate, endDate, frequency, includeInactive.  <p><strong>OperationId:</strong>getExportSchedules</p>
     * Operation to fetch export schedules.
     */
    async getExportSchedules(requestParameters: GetExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportSchedulesDetails> {
        const response = await this.getExportSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to return available exports based on search criteria such as fetchColumns, fetchDataSetup, fetchDestinationSetup, fetchGenerateConfiguration, limit, exportFileId, idExtension, idContext, type, hotelIds, fileGroup, includeInactive, includeComponents. <p><strong>OperationId:</strong>getExportsAvailable</p>
     * Operation to fetch exports available.
     */
    async getExportsAvailableRaw(requestParameters: GetExportsAvailableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportsAvailable>> {
        const queryParameters: any = {};

        if (requestParameters.fetchColumns !== undefined) {
            queryParameters['fetchColumns'] = requestParameters.fetchColumns;
        }

        if (requestParameters.fetchDataSetup !== undefined) {
            queryParameters['fetchDataSetup'] = requestParameters.fetchDataSetup;
        }

        if (requestParameters.fetchDestinationSetup !== undefined) {
            queryParameters['fetchDestinationSetup'] = requestParameters.fetchDestinationSetup;
        }

        if (requestParameters.fetchGenerateConfiguration !== undefined) {
            queryParameters['fetchGenerateConfiguration'] = requestParameters.fetchGenerateConfiguration;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.exportFileId !== undefined) {
            queryParameters['exportFileId'] = requestParameters.exportFileId;
        }

        if (requestParameters.idExtension !== undefined) {
            queryParameters['idExtension'] = requestParameters.idExtension;
        }

        if (requestParameters.idContext !== undefined) {
            queryParameters['idContext'] = requestParameters.idContext;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.hotelIds) {
            queryParameters['hotelIds'] = requestParameters.hotelIds;
        }

        if (requestParameters.fileGroup !== undefined) {
            queryParameters['fileGroup'] = requestParameters.fileGroup;
        }

        if (requestParameters.includeInactive !== undefined) {
            queryParameters['includeInactive'] = requestParameters.includeInactive;
        }

        if (requestParameters.match !== undefined) {
            queryParameters['match'] = requestParameters.match;
        }

        if (requestParameters.includeComponents !== undefined) {
            queryParameters['includeComponents'] = requestParameters.includeComponents;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/availableExports`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportsAvailableFromJSON(jsonValue));
    }

    /**
     * Use this API to return available exports based on search criteria such as fetchColumns, fetchDataSetup, fetchDestinationSetup, fetchGenerateConfiguration, limit, exportFileId, idExtension, idContext, type, hotelIds, fileGroup, includeInactive, includeComponents. <p><strong>OperationId:</strong>getExportsAvailable</p>
     * Operation to fetch exports available.
     */
    async getExportsAvailable(requestParameters: GetExportsAvailableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportsAvailable> {
        const response = await this.getExportsAvailableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>getExportsGenerated</p> <p>The maximum allowable limit for this API is <strong>25</strong>.</p>
     * Operation to fetch exports generated.
     */
    async getExportsGeneratedRaw(requestParameters: GetExportsGeneratedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GeneratedExports>> {
        if (requestParameters.exportFileId === null || requestParameters.exportFileId === undefined) {
            throw new runtime.RequiredError('exportFileId','Required parameter requestParameters.exportFileId was null or undefined when calling getExportsGenerated.');
        }
        
        const queryParameters: any = {};

        if (requestParameters.exportDataId !== undefined) {
            queryParameters['exportDataId'] = requestParameters.exportDataId;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/{exportFileId}/generatedExports`.replace(`{${"exportFileId"}}`, encodeURIComponent(String(requestParameters.exportFileId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GeneratedExportsFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>getExportsGenerated</p> <p>The maximum allowable limit for this API is <strong>25</strong>.</p>
     * Operation to fetch exports generated.
     */
    async getExportsGenerated(requestParameters: GetExportsGeneratedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GeneratedExports> {
        const response = await this.getExportsGeneratedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>postExportMappingCodes</p>
     * Operation to create export mapping codes.
     */
    async postExportMappingCodesRaw(requestParameters: PostExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.exportMappingCodes === null || requestParameters.exportMappingCodes === undefined) {
            throw new runtime.RequiredError('exportMappingCodes','Required parameter requestParameters.exportMappingCodes was null or undefined when calling postExportMappingCodes.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportMappingCodes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExportMappingCodesToJSON(requestParameters.exportMappingCodes),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>postExportMappingCodes</p>
     * Operation to create export mapping codes.
     */
    async postExportMappingCodes(requestParameters: PostExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postExportMappingCodesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>postExportMappings</p>
     * Operation to create export mappings.
     */
    async postExportMappingsRaw(requestParameters: PostExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling postExportMappings.');
        }
        
        if (requestParameters.exportMappings === null || requestParameters.exportMappings === undefined) {
            throw new runtime.RequiredError('exportMappings','Required parameter requestParameters.exportMappings was null or undefined when calling postExportMappings.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappings`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExportMappingsToJSON(requestParameters.exportMappings),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>postExportMappings</p>
     * Operation to create export mappings.
     */
    async postExportMappings(requestParameters: PostExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postExportMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create export schedules. <p><strong>OperationId:</strong>postExportSchedules</p>
     * Operation to create export schedules.
     */
    async postExportSchedulesRaw(requestParameters: PostExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        if (requestParameters.exportSchedulesCriteria === null || requestParameters.exportSchedulesCriteria === undefined) {
            throw new runtime.RequiredError('exportSchedulesCriteria','Required parameter requestParameters.exportSchedulesCriteria was null or undefined when calling postExportSchedules.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportSchedules`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExportSchedulesCriteriaToJSON(requestParameters.exportSchedulesCriteria),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create export schedules. <p><strong>OperationId:</strong>postExportSchedules</p>
     * Operation to create export schedules.
     */
    async postExportSchedules(requestParameters: PostExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postExportSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>putExportMappingCodes</p>
     * Operation to update export mapping codes.
     */
    async putExportMappingCodesRaw(requestParameters: PutExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportMappingCodesDetails>> {
        if (requestParameters.exportMappingCodes === null || requestParameters.exportMappingCodes === undefined) {
            throw new runtime.RequiredError('exportMappingCodes','Required parameter requestParameters.exportMappingCodes was null or undefined when calling putExportMappingCodes.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportMappingCodes`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ExportMappingCodesToJSON(requestParameters.exportMappingCodes),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportMappingCodesDetailsFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>putExportMappingCodes</p>
     * Operation to update export mapping codes.
     */
    async putExportMappingCodes(requestParameters: PutExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportMappingCodesDetails> {
        const response = await this.putExportMappingCodesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>putExportMappingLinkedTypes</p>
     * Operation to update export mapping linked types.
     */
    async putExportMappingLinkedTypesRaw(requestParameters: PutExportMappingLinkedTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportMappingLinkedTypesDetails>> {
        if (requestParameters.exportMappingLinkedTypes === null || requestParameters.exportMappingLinkedTypes === undefined) {
            throw new runtime.RequiredError('exportMappingLinkedTypes','Required parameter requestParameters.exportMappingLinkedTypes was null or undefined when calling putExportMappingLinkedTypes.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportMappingLinkedTypes`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ExportMappingLinkedTypesToJSON(requestParameters.exportMappingLinkedTypes),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportMappingLinkedTypesDetailsFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>putExportMappingLinkedTypes</p>
     * Operation to update export mapping linked types.
     */
    async putExportMappingLinkedTypes(requestParameters: PutExportMappingLinkedTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportMappingLinkedTypesDetails> {
        const response = await this.putExportMappingLinkedTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>putExportMappings</p>
     * Operation to update export mappings.
     */
    async putExportMappingsRaw(requestParameters: PutExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportMappingsDetails>> {
        if (requestParameters.hotelId === null || requestParameters.hotelId === undefined) {
            throw new runtime.RequiredError('hotelId','Required parameter requestParameters.hotelId was null or undefined when calling putExportMappings.');
        }
        
        if (requestParameters.exportMappings === null || requestParameters.exportMappings === undefined) {
            throw new runtime.RequiredError('exportMappings','Required parameter requestParameters.exportMappings was null or undefined when calling putExportMappings.');
        }
        
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappings`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ExportMappingsToJSON(requestParameters.exportMappings),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportMappingsDetailsFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>putExportMappings</p>
     * Operation to update export mappings.
     */
    async putExportMappings(requestParameters: PutExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportMappingsDetails> {
        const response = await this.putExportMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete export schedules based on the jobNames. <p><strong>OperationId:</strong>removeExportSchedules</p>
     * Operation to remove export schedules.
     */
    async removeExportSchedulesRaw(requestParameters: RemoveExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        if (requestParameters.jobNames) {
            queryParameters['jobNames'] = requestParameters.jobNames;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportSchedules`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete export schedules based on the jobNames. <p><strong>OperationId:</strong>removeExportSchedules</p>
     * Operation to remove export schedules.
     */
    async removeExportSchedules(requestParameters: RemoveExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.removeExportSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetExportActivityLogModuleEnum = {
    Reservation: 'Reservation',
    Contract: 'Contract',
    Allotment: 'Allotment',
    Outlookview: 'Outlookview',
    Profile: 'Profile',
    Accountreceivables: 'Accountreceivables',
    GdsConvRateCodes: 'GdsConvRateCodes',
    RateCode: 'RateCode',
    Billing: 'Billing',
    Activity: 'Activity'
} as const;
export type GetExportActivityLogModuleEnum = typeof GetExportActivityLogModuleEnum[keyof typeof GetExportActivityLogModuleEnum];
/**
 * @export
 */
export const GetExportColumnsAndFunctionsCategoryEnum = {
    Exports: 'Exports',
    CustomNumbers: 'CustomNumbers'
} as const;
export type GetExportColumnsAndFunctionsCategoryEnum = typeof GetExportColumnsAndFunctionsCategoryEnum[keyof typeof GetExportColumnsAndFunctionsCategoryEnum];
/**
 * @export
 */
export const GetExportMappingLinkedCodesConfigTypeEnum = {
    TransactionCodes: 'TransactionCodes',
    MarketCodes: 'MarketCodes',
    PackageCodes: 'PackageCodes',
    PaymentMethods: 'PaymentMethods',
    ProfileIdTypes: 'ProfileIdTypes',
    StatisticCodes: 'StatisticCodes',
    PropertyCodes: 'PropertyCodes',
    CountryCodes: 'CountryCodes',
    NationalityCodes: 'NationalityCodes',
    StateCodes: 'StateCodes',
    DistrictCodes: 'DistrictCodes',
    CityCodes: 'CityCodes',
    CountryCities: 'CountryCities',
    PurposeOfStayCodes: 'PurposeOfStayCodes',
    TransportationCodes: 'TransportationCodes',
    CancelReasons: 'CancelReasons',
    Gender: 'Gender',
    RoomTypes: 'RoomTypes',
    IdCountryCodes: 'IdCountryCodes'
} as const;
export type GetExportMappingLinkedCodesConfigTypeEnum = typeof GetExportMappingLinkedCodesConfigTypeEnum[keyof typeof GetExportMappingLinkedCodesConfigTypeEnum];
/**
 * @export
 */
export const GetExportMappingsExportMappingConfigsEnum = {
    TransactionCodes: 'TransactionCodes',
    MarketCodes: 'MarketCodes',
    PackageCodes: 'PackageCodes',
    PaymentMethods: 'PaymentMethods',
    ProfileIdTypes: 'ProfileIdTypes',
    StatisticCodes: 'StatisticCodes',
    PropertyCodes: 'PropertyCodes',
    CountryCodes: 'CountryCodes',
    NationalityCodes: 'NationalityCodes',
    StateCodes: 'StateCodes',
    DistrictCodes: 'DistrictCodes',
    CityCodes: 'CityCodes',
    CountryCities: 'CountryCities',
    PurposeOfStayCodes: 'PurposeOfStayCodes',
    TransportationCodes: 'TransportationCodes',
    CancelReasons: 'CancelReasons',
    Gender: 'Gender',
    RoomTypes: 'RoomTypes',
    IdCountryCodes: 'IdCountryCodes'
} as const;
export type GetExportMappingsExportMappingConfigsEnum = typeof GetExportMappingsExportMappingConfigsEnum[keyof typeof GetExportMappingsExportMappingConfigsEnum];
/**
 * @export
 */
export const GetExportMappingsByChainExportMappingConfigsEnum = {
    TransactionCodes: 'TransactionCodes',
    MarketCodes: 'MarketCodes',
    PackageCodes: 'PackageCodes',
    PaymentMethods: 'PaymentMethods',
    ProfileIdTypes: 'ProfileIdTypes',
    StatisticCodes: 'StatisticCodes',
    PropertyCodes: 'PropertyCodes',
    CountryCodes: 'CountryCodes',
    NationalityCodes: 'NationalityCodes',
    StateCodes: 'StateCodes',
    DistrictCodes: 'DistrictCodes',
    CityCodes: 'CityCodes',
    CountryCities: 'CountryCities',
    PurposeOfStayCodes: 'PurposeOfStayCodes',
    TransportationCodes: 'TransportationCodes',
    CancelReasons: 'CancelReasons',
    Gender: 'Gender',
    RoomTypes: 'RoomTypes',
    IdCountryCodes: 'IdCountryCodes'
} as const;
export type GetExportMappingsByChainExportMappingConfigsEnum = typeof GetExportMappingsByChainExportMappingConfigsEnum[keyof typeof GetExportMappingsByChainExportMappingConfigsEnum];
/**
 * @export
 */
export const GetExportSchedulesExportGroupEnum = {
    Miscellaneous: 'Miscellaneous',
    Memberships: 'Memberships',
    Country: 'Country',
    BackOffice: 'BackOffice'
} as const;
export type GetExportSchedulesExportGroupEnum = typeof GetExportSchedulesExportGroupEnum[keyof typeof GetExportSchedulesExportGroupEnum];
/**
 * @export
 */
export const GetExportSchedulesFrequencyEnum = {
    Once: 'Once',
    Hourly: 'Hourly',
    Daily: 'Daily',
    Weekly: 'Weekly',
    Monthly: 'Monthly',
    EndOfDay: 'EndOfDay'
} as const;
export type GetExportSchedulesFrequencyEnum = typeof GetExportSchedulesFrequencyEnum[keyof typeof GetExportSchedulesFrequencyEnum];
/**
 * @export
 */
export const GetExportsAvailableFileGroupEnum = {
    Miscellaneous: 'Miscellaneous',
    Memberships: 'Memberships',
    Country: 'Country',
    Delphi: 'Delphi',
    BackOffice: 'BackOffice',
    BackOfficeRevenue: 'BackOfficeRevenue',
    BackOfficeCityLedger: 'BackOfficeCityLedger',
    BackOfficeMarketStatistics: 'BackOfficeMarketStatistics',
    BackOfficeDailyStatistics: 'BackOfficeDailyStatistics',
    CommissionEft: 'CommissionEft'
} as const;
export type GetExportsAvailableFileGroupEnum = typeof GetExportsAvailableFileGroupEnum[keyof typeof GetExportsAvailableFileGroupEnum];
