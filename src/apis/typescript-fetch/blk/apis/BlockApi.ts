/* tslint:disable */
/* eslint-disable */
/**
 * OPERA Cloud Block API
 * APIs to cater for Business Block functionality in OPERA Cloud. <br /><br /> A block is a group of rooms held for guests who are attending an event, meeting, or function. You can create blocks for family reunions, business conferences, weddings, and so on. You can also set aside rooms for the event (block).<br /><br /> Compatible with OPERA Cloud release 22.3.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>
 *
 * The version of the OpenAPI document: 22.3.0.0
 * Contact: hospitality_apis_ww_grp@oracle.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Block,
  BlockAccessExclusionInfo,
  BlockActivityLog,
  BlockAttachments,
  BlockAvailability,
  BlockChanged,
  BlockDailyStatistics,
  BlockOwners,
  BlockPMReservations,
  BlockRangeInfo,
  BlockReservations,
  BlockRestrictions,
  BlockRevenueChanges,
  BlockRoomTypes,
  BlockRoomsStatus,
  BlockStatistics,
  BlockStatusChanges,
  BlockSummaries,
  BlockWashInfo,
  BlockWashSchedules,
  ChangeRateOverrideRequest,
  ChangedBlockReservations,
  ChangedBlockStatus,
  ChangedCateringStatus,
  DefaultBlockCodeDetails,
  ExceptionDetailType,
  InventoryToBorrowInfo,
  NextBlockStatus,
  OperaVersion,
  PostBlockOwnersRequest,
  PostBlockPostingMasterRequest,
  PostBlockRequest,
  PostBlockRestrictionRequest,
  PostBlockValidateRequest,
  PostCancelBlockRequest,
  PostCopyBlockRequest,
  PostRoomingListRequest,
  PostSubAllocationRequest,
  PostSubBlockRequest,
  PostTourSeriesRequest,
  PutAlternateDatesRequest,
  PutBlockAccessExclusionRequest,
  PutBlockAllocationRangeRequest,
  PutBlockAllocationRequest,
  PutBlockAllocationWashRequest,
  PutBlockCutoffRequest,
  PutBlockOwnersRequest,
  PutBlockRequest,
  PutBlockReservationsRequest,
  PutBlockShiftRequest,
  PutBlockStatusRequest,
  PutBlockWashSchedulesRequest,
  PutCateringStatusRequest,
  PutClearAllRestrictionsRequest,
  PutInventoryRequest,
  PutReleasedInventoryRequest,
  PutRoomTypeOrderRequest,
  PutValidateBlockCodeRequest,
  RateOverrideStatus,
  RecentlyAccessedBlocks,
  RoomingListDetails,
  SalesAllowances,
  ShiftedBlock,
  Status,
  TracesByDateRange,
} from '../models';
import {
    BlockFromJSON,
    BlockToJSON,
    BlockAccessExclusionInfoFromJSON,
    BlockAccessExclusionInfoToJSON,
    BlockActivityLogFromJSON,
    BlockActivityLogToJSON,
    BlockAttachmentsFromJSON,
    BlockAttachmentsToJSON,
    BlockAvailabilityFromJSON,
    BlockAvailabilityToJSON,
    BlockChangedFromJSON,
    BlockChangedToJSON,
    BlockDailyStatisticsFromJSON,
    BlockDailyStatisticsToJSON,
    BlockOwnersFromJSON,
    BlockOwnersToJSON,
    BlockPMReservationsFromJSON,
    BlockPMReservationsToJSON,
    BlockRangeInfoFromJSON,
    BlockRangeInfoToJSON,
    BlockReservationsFromJSON,
    BlockReservationsToJSON,
    BlockRestrictionsFromJSON,
    BlockRestrictionsToJSON,
    BlockRevenueChangesFromJSON,
    BlockRevenueChangesToJSON,
    BlockRoomTypesFromJSON,
    BlockRoomTypesToJSON,
    BlockRoomsStatusFromJSON,
    BlockRoomsStatusToJSON,
    BlockStatisticsFromJSON,
    BlockStatisticsToJSON,
    BlockStatusChangesFromJSON,
    BlockStatusChangesToJSON,
    BlockSummariesFromJSON,
    BlockSummariesToJSON,
    BlockWashInfoFromJSON,
    BlockWashInfoToJSON,
    BlockWashSchedulesFromJSON,
    BlockWashSchedulesToJSON,
    ChangeRateOverrideRequestFromJSON,
    ChangeRateOverrideRequestToJSON,
    ChangedBlockReservationsFromJSON,
    ChangedBlockReservationsToJSON,
    ChangedBlockStatusFromJSON,
    ChangedBlockStatusToJSON,
    ChangedCateringStatusFromJSON,
    ChangedCateringStatusToJSON,
    DefaultBlockCodeDetailsFromJSON,
    DefaultBlockCodeDetailsToJSON,
    ExceptionDetailTypeFromJSON,
    ExceptionDetailTypeToJSON,
    InventoryToBorrowInfoFromJSON,
    InventoryToBorrowInfoToJSON,
    NextBlockStatusFromJSON,
    NextBlockStatusToJSON,
    OperaVersionFromJSON,
    OperaVersionToJSON,
    PostBlockOwnersRequestFromJSON,
    PostBlockOwnersRequestToJSON,
    PostBlockPostingMasterRequestFromJSON,
    PostBlockPostingMasterRequestToJSON,
    PostBlockRequestFromJSON,
    PostBlockRequestToJSON,
    PostBlockRestrictionRequestFromJSON,
    PostBlockRestrictionRequestToJSON,
    PostBlockValidateRequestFromJSON,
    PostBlockValidateRequestToJSON,
    PostCancelBlockRequestFromJSON,
    PostCancelBlockRequestToJSON,
    PostCopyBlockRequestFromJSON,
    PostCopyBlockRequestToJSON,
    PostRoomingListRequestFromJSON,
    PostRoomingListRequestToJSON,
    PostSubAllocationRequestFromJSON,
    PostSubAllocationRequestToJSON,
    PostSubBlockRequestFromJSON,
    PostSubBlockRequestToJSON,
    PostTourSeriesRequestFromJSON,
    PostTourSeriesRequestToJSON,
    PutAlternateDatesRequestFromJSON,
    PutAlternateDatesRequestToJSON,
    PutBlockAccessExclusionRequestFromJSON,
    PutBlockAccessExclusionRequestToJSON,
    PutBlockAllocationRangeRequestFromJSON,
    PutBlockAllocationRangeRequestToJSON,
    PutBlockAllocationRequestFromJSON,
    PutBlockAllocationRequestToJSON,
    PutBlockAllocationWashRequestFromJSON,
    PutBlockAllocationWashRequestToJSON,
    PutBlockCutoffRequestFromJSON,
    PutBlockCutoffRequestToJSON,
    PutBlockOwnersRequestFromJSON,
    PutBlockOwnersRequestToJSON,
    PutBlockRequestFromJSON,
    PutBlockRequestToJSON,
    PutBlockReservationsRequestFromJSON,
    PutBlockReservationsRequestToJSON,
    PutBlockShiftRequestFromJSON,
    PutBlockShiftRequestToJSON,
    PutBlockStatusRequestFromJSON,
    PutBlockStatusRequestToJSON,
    PutBlockWashSchedulesRequestFromJSON,
    PutBlockWashSchedulesRequestToJSON,
    PutCateringStatusRequestFromJSON,
    PutCateringStatusRequestToJSON,
    PutClearAllRestrictionsRequestFromJSON,
    PutClearAllRestrictionsRequestToJSON,
    PutInventoryRequestFromJSON,
    PutInventoryRequestToJSON,
    PutReleasedInventoryRequestFromJSON,
    PutReleasedInventoryRequestToJSON,
    PutRoomTypeOrderRequestFromJSON,
    PutRoomTypeOrderRequestToJSON,
    PutValidateBlockCodeRequestFromJSON,
    PutValidateBlockCodeRequestToJSON,
    RateOverrideStatusFromJSON,
    RateOverrideStatusToJSON,
    RecentlyAccessedBlocksFromJSON,
    RecentlyAccessedBlocksToJSON,
    RoomingListDetailsFromJSON,
    RoomingListDetailsToJSON,
    SalesAllowancesFromJSON,
    SalesAllowancesToJSON,
    ShiftedBlockFromJSON,
    ShiftedBlockToJSON,
    StatusFromJSON,
    StatusToJSON,
    TracesByDateRangeFromJSON,
    TracesByDateRangeToJSON,
} from '../models';

export interface ChangeRateOverrideOperationRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    rateOverride?: ChangeRateOverrideRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteAlternateDatesRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockAccessExclusionRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    allowCancelReservation?: boolean;
    allowCreateReservation?: boolean;
    allowModifyReservation?: boolean;
    excludeFromAvailability?: boolean;
    inactive?: boolean;
    sourceType?: string;
    sourceValue?: string;
    hotelId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockAttachmentRequest {
    attachId?: string;
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockOwnersRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockRestrictionRequest {
    blockId?: string;
    hotelId?: string;
    startDate?: Date;
    endDate?: Date;
    code?: DeleteBlockRestrictionCodeEnum;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockServiceCacheRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteBlockWashSchedulesRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    markAsRecentlyAccessed?: boolean;
    fetchInstructions?: Set<GetBlockFetchInstructionsEnum>;
    fetchAllocatedRoomTypes?: boolean;
    startDate?: Date;
    numberOfDays?: number;
    roomAllocationCriteria?: Set<GetBlockRoomAllocationCriteriaEnum>;
    roomTypes?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockAccessExclusionRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockActivityLogRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    limit?: number;
    offset?: number;
    hotelId?: string;
    module?: GetBlockActivityLogModuleEnum;
    moduleParamsParameterName?: Array<string>;
    moduleParamsParameterValue?: Array<string>;
    activityGroup?: string;
    activityType?: string;
    activityParamsFromDate?: Date;
    activityParamsToDate?: Date;
    activityParamsSearchText?: string;
    userByIDsUserId?: Array<number>;
    userForIDsUserId?: Array<number>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockAttachmentsRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockAvailabilityRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    overrideRateCode?: boolean;
    arrivalDate?: Date;
    nights?: number;
    adults?: number;
    children?: number;
    rooms?: number;
    ratePlanCode?: string;
    existingReservationId?: string;
    existingReservationIdType?: string;
    roomType?: Array<string>;
    fetchAllocatedRoomType?: Set<GetBlockAvailabilityFetchAllocatedRoomTypeEnum>;
    roomTypeCount?: number;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockByExtIdRequest {
    blockExternalId?: string;
    externalSystemCode?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    markAsRecentlyAccessed?: boolean;
    fetchInstructions?: Set<GetBlockByExtIdFetchInstructionsEnum>;
    fetchAllocatedRoomTypes?: boolean;
    startDate?: Date;
    numberOfDays?: number;
    roomAllocationCriteria?: Set<GetBlockByExtIdRoomAllocationCriteriaEnum>;
    roomTypes?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockDailyStatisticsRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    genericRoomType?: boolean;
    limit?: number;
    offset?: number;
    hotelId?: string;
    end?: Date;
    start?: Date;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockOwnersRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockPMReservationsRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    postingmaster?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockPMReservationsByExtIdRequest {
    blockExternalId?: string;
    externalSystemCode?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    postingmaster?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockRangeInfoRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    genericRoomType?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockReservationsRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    fetchInstructions?: Set<GetBlockReservationsFetchInstructionsEnum>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockRestrictionsRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    startDate?: Date;
    endDate?: Date;
    duration?: string;
    roomType?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockRevenueChangesRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    limit?: number;
    offset?: number;
    hotelId?: string;
    status?: Array<string>;
    changeEndDate?: Date;
    changeStartDate?: Date;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockRoomTypesRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    fetchAllocatedRoomTypes?: boolean;
    startDate?: Date;
    endDate?: Date;
    fetchGenericRoomTypes?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockRoomsStatusRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockStatisticsRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    startDate?: Date;
    numberOfDays?: number;
    statisticsInstructions?: Set<GetBlockStatisticsStatisticsInstructionsEnum>;
    roomTypeHotelId?: Array<string>;
    invBlockCode?: Array<string>;
    promotionCode?: Array<string>;
    roomCategory?: Array<string>;
    roomClass?: Array<string>;
    roomQualifierCode?: Array<string>;
    roomQualifierMatchIndicator?: Array<string>;
    roomType?: Array<string>;
    roomViewCode?: Array<string>;
    roomFeatureCode?: Array<string>;
    defaultOccupancy?: number;
    maximumOccupancy?: number;
    noOfPhysicalRooms?: number;
    bookingChannelCode?: Array<string>;
    bookingChannelMappingCode?: Array<string>;
    bookingChannelMappingName?: Array<string>;
    bedTypeCode?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockStatusChangesRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    limit?: number;
    offset?: number;
    hotelId?: string;
    changeEndDate?: Date;
    changeStartDate?: Date;
    currentStatus?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockWashInfoRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    blockId?: string;
    blockIdType?: string;
    genericRoomType?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlockWashSchedulesRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetBlocksRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    markAsRecentlyAccessed?: boolean;
    limit?: number;
    offset?: number;
    multipleHotelsSearchHotelIds?: Array<string>;
    superSearch?: string;
    blockIdList?: Array<string>;
    blockIdType?: Array<string>;
    externalReferenceIds?: Array<string>;
    externalSystemCodes?: Array<string>;
    blockCode?: string;
    blockName?: string;
    blockOwner?: Array<string>;
    blockStatus?: Array<string>;
    cateringStatus?: Array<string>;
    createdByUser?: string;
    blockStartEndDate?: Date;
    blockStartStartDate?: Date;
    blockEndEndDate?: Date;
    blockEndStartDate?: Date;
    reservationArrival?: Date;
    reservationDeparture?: Date;
    includeShoulderDates?: boolean;
    stayDate?: Date;
    blockCreatedOnEndDate?: Date;
    blockCreatedOnStartDate?: Date;
    decisionEndDate?: Date;
    decisionStartDate?: Date;
    cutOffEndDate?: Date;
    cutOffStartDate?: Date;
    category?: Set<GetBlocksCategoryEnum>;
    name?: Array<string>;
    attachedProfileId?: string;
    attachedProfileIdType?: string;
    leads?: boolean;
    tourSeries?: boolean;
    onlyPickupBlocks?: boolean;
    onlyOpportunities?: boolean;
    ratePlanCode?: Array<string>;
    tourCode?: string;
    attributeName?: Array<string>;
    orderType?: Set<GetBlocksOrderTypeEnum>;
    fetchInstructions?: Set<GetBlocksFetchInstructionsEnum>;
    fetchAllocatedRoomTypes?: boolean;
    additionalCriteriaStartDate?: Date;
    numberOfDays?: number;
    adults?: number;
    children?: number;
    childAge?: Array<number>;
    bucket1Count?: number;
    bucket2Count?: number;
    bucket3Count?: number;
    bucket4Count?: number;
    bucket5Count?: number;
    existingReservationId?: string;
    existingReservationIdType?: string;
    roomAllocationCriteria?: Set<GetBlocksRoomAllocationCriteriaEnum>;
    roomType?: Array<string>;
    additionalCriteriaRatePlanCode?: string;
    currencyCode?: string;
    customCharUDFsAltname?: Array<string>;
    customCharUDFsName?: Array<string>;
    customCharUDFsValue?: Array<string>;
    customNumericUDFsAltname?: Array<string>;
    customNumericUDFsName?: Array<string>;
    customNumericUDFsValue?: Array<number>;
    customDateUDFsAltname?: Array<string>;
    customDateUDFsName?: Array<string>;
    customDateUDFsValue?: Array<Date>;
    accessRestriction?: Set<GetBlocksAccessRestrictionEnum>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetDefaultBlockCodeRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    blockName?: string;
    startDate?: Date;
    blockCodeTemplate?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetInventoryToBorrowRequest {
    hotelId?: string;
    blockId?: string;
    startDate?: Date;
    requiredRooms?: Array<number>;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockIdContext?: string;
    blockIdType?: string;
    existingReservationId?: string;
    existingReservationIdType?: string;
    roomType?: string;
    endDate?: Date;
    duration?: string;
    numberOfRooms?: number;
    borrowDate?: Array<Date>;
    overrideRateCode?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetNextBlockStatusRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    currentStatus?: string;
    includeCateringStatus?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetRecentlyAccessedBlocksRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetSalesAllowancesRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    ceilingId?: Array<number>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetTracesByDateRangeRequest {
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelIds?: Array<string>;
    beginDate?: Date;
    endDate?: Date;
    department?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PingBlockServiceRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostAlternateDatesRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockAlternateDates?: PutAlternateDatesRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostBlockOperationRequest {
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    block?: PostBlockRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostBlockOwnersOperationRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockOwnersToAssign?: PostBlockOwnersRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostBlockPostingMasterOperationRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockPostingMaster?: PostBlockPostingMasterRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostBlockRestrictionOperationRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockRestriction?: PostBlockRestrictionRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostBlockValidateOperationRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockValidate?: PostBlockValidateRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostBlockWashSchedulesRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockWashSchedulesInfo?: PutBlockWashSchedulesRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostCancelBlockOperationRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockToCancel?: PostCancelBlockRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostCopyBlockOperationRequest {
    sourceBlockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockCopy?: PostCopyBlockRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostRoomingListOperationRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    roomingList?: PostRoomingListRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostSubAllocationOperationRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    subAllocation?: PostSubAllocationRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostSubBlockOperationRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    subBlock?: PostSubBlockRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostSubBlockByExtIdRequest {
    blockExternalId?: string;
    externalSystemCode?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    subBlock?: PostSubBlockRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostTourSeriesOperationRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    tourSeries?: PostTourSeriesRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutAlternateDatesOperationRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockAlternateDates?: PutAlternateDatesRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockOperationRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockToBeChanged?: PutBlockRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockAccessExclusionOperationRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockAccessExclusion?: PutBlockAccessExclusionRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockAllocationOperationRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    allocation?: PutBlockAllocationRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockAllocationByExtIdRequest {
    roomType?: string;
    blockExternalId?: string;
    externalSystemCode?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    allocation?: PutBlockAllocationRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockAllocationRangeOperationRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockAllocationRange?: PutBlockAllocationRangeRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockAllocationRangeByExtIdRequest {
    blockExternalId?: string;
    externalSystemCode?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockAllocationRange?: PutBlockAllocationRangeRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockAllocationWashOperationRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockAllocationWash?: PutBlockAllocationWashRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockByExtIdRequest {
    blockExternalId?: string;
    externalSystemCode?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockToBeChanged?: PutBlockRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockCutoffOperationRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockStatus?: PutBlockCutoffRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockOwnersOperationRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockOwnersToChange?: PutBlockOwnersRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockRatesRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockStatus?: PutBlockCutoffRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockReservationsOperationRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockReservationsToChange?: PutBlockReservationsRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockShiftOperationRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockToShift?: PutBlockShiftRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockStatusOperationRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockStatusToChange?: PutBlockStatusRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockStatusByExtIdRequest {
    blockExternalId?: string;
    externalSystemCode?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockStatusToChange?: PutBlockStatusRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockStatusToOpenRequest {
    blockId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockStatus?: PutBlockCutoffRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutBlockWashSchedulesOperationRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockWashSchedulesInfo?: PutBlockWashSchedulesRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutCateringStatusOperationRequest {
    eventId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    cateringStatusToChange?: PutCateringStatusRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutClearAllRestrictionsOperationRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    allRestrictions?: PutClearAllRestrictionsRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutContractDefaultsRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockStatus?: PutBlockCutoffRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutInventoryOperationRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    inventoryToBorrow?: PutInventoryRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutReleasedInventoryOperationRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    borrowedInventoryToReturn?: PutReleasedInventoryRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutRoomTypeOrderOperationRequest {
    blockId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    roomTypeOrder?: PutRoomTypeOrderRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutValidateBlockCodeOperationRequest {
    blockCode?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    blockCodeToValidate?: PutValidateBlockCodeRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

/**
 * 
 */
export class BlockApi extends runtime.BaseAPI {

    /**
     * Use this API to change rate override. <p><strong>OperationId:</strong>changeRateOverride</p>
     * Change rate override
     */
    async changeRateOverrideRaw(requestParameters: ChangeRateOverrideOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RateOverrideStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/rate/override`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ChangeRateOverrideRequestToJSON(requestParameters.rateOverride),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RateOverrideStatusFromJSON(jsonValue));
    }

    /**
     * Use this API to change rate override. <p><strong>OperationId:</strong>changeRateOverride</p>
     * Change rate override
     */
    async changeRateOverride(requestParameters: ChangeRateOverrideOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RateOverrideStatus> {
        const response = await this.changeRateOverrideRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete alternate dates for a block. <p><strong>OperationId:</strong>deleteAlternateDates</p>
     * Delete alternate dates for a Block
     */
    async deleteAlternateDatesRaw(requestParameters: DeleteAlternateDatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/alternateDates`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete alternate dates for a block. <p><strong>OperationId:</strong>deleteAlternateDates</p>
     * Delete alternate dates for a Block
     */
    async deleteAlternateDates(requestParameters: DeleteAlternateDatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteAlternateDatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete block, if any reservations attached to the block, you will be unable to delete.  <p><strong>OperationId:</strong>deleteBlock</p>
     * Delete a Block
     */
    async deleteBlockRaw(requestParameters: DeleteBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete block, if any reservations attached to the block, you will be unable to delete.  <p><strong>OperationId:</strong>deleteBlock</p>
     * Delete a Block
     */
    async deleteBlock(requestParameters: DeleteBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete block access exclusion <p><strong>OperationId:</strong>deleteBlockAccessExclusion</p>
     * Delete Block access exclusion
     */
    async deleteBlockAccessExclusionRaw(requestParameters: DeleteBlockAccessExclusionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        if (requestParameters.allowCancelReservation !== undefined) {
            queryParameters['allowCancelReservation'] = requestParameters.allowCancelReservation;
        }

        if (requestParameters.allowCreateReservation !== undefined) {
            queryParameters['allowCreateReservation'] = requestParameters.allowCreateReservation;
        }

        if (requestParameters.allowModifyReservation !== undefined) {
            queryParameters['allowModifyReservation'] = requestParameters.allowModifyReservation;
        }

        if (requestParameters.excludeFromAvailability !== undefined) {
            queryParameters['excludeFromAvailability'] = requestParameters.excludeFromAvailability;
        }

        if (requestParameters.inactive !== undefined) {
            queryParameters['inactive'] = requestParameters.inactive;
        }

        if (requestParameters.sourceType !== undefined) {
            queryParameters['sourceType'] = requestParameters.sourceType;
        }

        if (requestParameters.sourceValue !== undefined) {
            queryParameters['sourceValue'] = requestParameters.sourceValue;
        }

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/blockAccessExclusion`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete block access exclusion <p><strong>OperationId:</strong>deleteBlockAccessExclusion</p>
     * Delete Block access exclusion
     */
    async deleteBlockAccessExclusion(requestParameters: DeleteBlockAccessExclusionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockAccessExclusionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API remove block attachments. <p><strong>OperationId:</strong>deleteBlockAttachment</p>
     * Delete Block Attachment
     */
    async deleteBlockAttachmentRaw(requestParameters: DeleteBlockAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/attachments/{attachId}`.replace(`{${"attachId"}}`, encodeURIComponent(String(requestParameters.attachId))).replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API remove block attachments. <p><strong>OperationId:</strong>deleteBlockAttachment</p>
     * Delete Block Attachment
     */
    async deleteBlockAttachment(requestParameters: DeleteBlockAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockAttachmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete a block owner. <p><strong>OperationId:</strong>deleteBlockOwners</p>
     * Delete a Block owner
     */
    async deleteBlockOwnersRaw(requestParameters: DeleteBlockOwnersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/owners`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete a block owner. <p><strong>OperationId:</strong>deleteBlockOwners</p>
     * Delete a Block owner
     */
    async deleteBlockOwners(requestParameters: DeleteBlockOwnersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockOwnersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete block restrictions. <p><strong>OperationId:</strong>deleteBlockRestriction</p>
     * Delete Block Restriction
     */
    async deleteBlockRestrictionRaw(requestParameters: DeleteBlockRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = (requestParameters.startDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = (requestParameters.endDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.code !== undefined) {
            queryParameters['code'] = requestParameters.code;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/restrictions`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete block restrictions. <p><strong>OperationId:</strong>deleteBlockRestriction</p>
     * Delete Block Restriction
     */
    async deleteBlockRestriction(requestParameters: DeleteBlockRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockRestrictionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API deletes the block service cache. <p><strong>OperationId:</strong>deleteBlockServiceCache</p>
     * Delete Block service cache
     */
    async deleteBlockServiceCacheRaw(requestParameters: DeleteBlockServiceCacheRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/services/block/cache`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API deletes the block service cache. <p><strong>OperationId:</strong>deleteBlockServiceCache</p>
     * Delete Block service cache
     */
    async deleteBlockServiceCache(requestParameters: DeleteBlockServiceCacheRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockServiceCacheRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to remove block wash schedules based on the HotelCode, Block ID and Wash Date. <p><strong>OperationId:</strong>deleteBlockWashSchedules</p>
     * Remove Block Wash Schedules
     */
    async deleteBlockWashSchedulesRaw(requestParameters: DeleteBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/washSchedules`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to remove block wash schedules based on the HotelCode, Block ID and Wash Date. <p><strong>OperationId:</strong>deleteBlockWashSchedules</p>
     * Remove Block Wash Schedules
     */
    async deleteBlockWashSchedules(requestParameters: DeleteBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteBlockWashSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve a specific block.  You will need to know the blockID in the request; if you don\'t know it, please go ahead and use getBlocks API first.  The response will include detailed information about the block. <p><strong>OperationId:</strong>getBlock</p>
     * Get a Block By ID
     */
    async getBlockRaw(requestParameters: GetBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Block>> {
        const queryParameters: any = {};

        if (requestParameters.markAsRecentlyAccessed !== undefined) {
            queryParameters['markAsRecentlyAccessed'] = requestParameters.markAsRecentlyAccessed;
        }

        if (requestParameters.fetchInstructions) {
            queryParameters['fetchInstructions'] = requestParameters.fetchInstructions;
        }

        if (requestParameters.fetchAllocatedRoomTypes !== undefined) {
            queryParameters['fetchAllocatedRoomTypes'] = requestParameters.fetchAllocatedRoomTypes;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = (requestParameters.startDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.numberOfDays !== undefined) {
            queryParameters['numberOfDays'] = requestParameters.numberOfDays;
        }

        if (requestParameters.roomAllocationCriteria) {
            queryParameters['roomAllocationCriteria'] = requestParameters.roomAllocationCriteria;
        }

        if (requestParameters.roomTypes) {
            queryParameters['roomTypes'] = requestParameters.roomTypes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve a specific block.  You will need to know the blockID in the request; if you don\'t know it, please go ahead and use getBlocks API first.  The response will include detailed information about the block. <p><strong>OperationId:</strong>getBlock</p>
     * Get a Block By ID
     */
    async getBlock(requestParameters: GetBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Block> {
        const response = await this.getBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API retrieves block exclusion information. <p><strong>OperationId:</strong>getBlockAccessExclusion</p>
     * Get Block exclusion information
     */
    async getBlockAccessExclusionRaw(requestParameters: GetBlockAccessExclusionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockAccessExclusionInfo>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/blockAccessExclusion`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockAccessExclusionInfoFromJSON(jsonValue));
    }

    /**
     * This API retrieves block exclusion information. <p><strong>OperationId:</strong>getBlockAccessExclusion</p>
     * Get Block exclusion information
     */
    async getBlockAccessExclusion(requestParameters: GetBlockAccessExclusionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockAccessExclusionInfo> {
        const response = await this.getBlockAccessExclusionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to facilitate retrieving the block activity log. <p><strong>OperationId:</strong>getBlockActivityLog</p>
     * Get the Block activity log
     */
    async getBlockActivityLogRaw(requestParameters: GetBlockActivityLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockActivityLog>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.module !== undefined) {
            queryParameters['module'] = requestParameters.module;
        }

        if (requestParameters.moduleParamsParameterName) {
            queryParameters['moduleParamsParameterName'] = requestParameters.moduleParamsParameterName;
        }

        if (requestParameters.moduleParamsParameterValue) {
            queryParameters['moduleParamsParameterValue'] = requestParameters.moduleParamsParameterValue;
        }

        if (requestParameters.activityGroup !== undefined) {
            queryParameters['activityGroup'] = requestParameters.activityGroup;
        }

        if (requestParameters.activityType !== undefined) {
            queryParameters['activityType'] = requestParameters.activityType;
        }

        if (requestParameters.activityParamsFromDate !== undefined) {
            queryParameters['activityParamsFromDate'] = (requestParameters.activityParamsFromDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.activityParamsToDate !== undefined) {
            queryParameters['activityParamsToDate'] = (requestParameters.activityParamsToDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.activityParamsSearchText !== undefined) {
            queryParameters['activityParamsSearchText'] = requestParameters.activityParamsSearchText;
        }

        if (requestParameters.userByIDsUserId) {
            queryParameters['userByIDsUserId'] = requestParameters.userByIDsUserId;
        }

        if (requestParameters.userForIDsUserId) {
            queryParameters['userForIDsUserId'] = requestParameters.userForIDsUserId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blockActivityLog`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockActivityLogFromJSON(jsonValue));
    }

    /**
     * Use this API to facilitate retrieving the block activity log. <p><strong>OperationId:</strong>getBlockActivityLog</p>
     * Get the Block activity log
     */
    async getBlockActivityLog(requestParameters: GetBlockActivityLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockActivityLog> {
        const response = await this.getBlockActivityLogRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve block attachments. <p><strong>OperationId:</strong>getBlockAttachments</p>
     * Get Block Attachments
     */
    async getBlockAttachmentsRaw(requestParameters: GetBlockAttachmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockAttachments>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/attachments`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockAttachmentsFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve block attachments. <p><strong>OperationId:</strong>getBlockAttachments</p>
     * Get Block Attachments
     */
    async getBlockAttachments(requestParameters: GetBlockAttachmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockAttachments> {
        const response = await this.getBlockAttachmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to search for availability on an OPERA block.  You will need to know the block ID.  Once you know what rooms and rates are available you can proceed to post a block reservation. <p><strong>OperationId:</strong>getBlockAvailability</p>
     * Get Block AvailaBility
     */
    async getBlockAvailabilityRaw(requestParameters: GetBlockAvailabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockAvailability>> {
        const queryParameters: any = {};

        if (requestParameters.overrideRateCode !== undefined) {
            queryParameters['overrideRateCode'] = requestParameters.overrideRateCode;
        }

        if (requestParameters.arrivalDate !== undefined) {
            queryParameters['arrivalDate'] = (requestParameters.arrivalDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.nights !== undefined) {
            queryParameters['nights'] = requestParameters.nights;
        }

        if (requestParameters.adults !== undefined) {
            queryParameters['adults'] = requestParameters.adults;
        }

        if (requestParameters.children !== undefined) {
            queryParameters['children'] = requestParameters.children;
        }

        if (requestParameters.rooms !== undefined) {
            queryParameters['rooms'] = requestParameters.rooms;
        }

        if (requestParameters.ratePlanCode !== undefined) {
            queryParameters['ratePlanCode'] = requestParameters.ratePlanCode;
        }

        if (requestParameters.existingReservationId !== undefined) {
            queryParameters['existingReservationId'] = requestParameters.existingReservationId;
        }

        if (requestParameters.existingReservationIdType !== undefined) {
            queryParameters['existingReservationIdType'] = requestParameters.existingReservationIdType;
        }

        if (requestParameters.roomType) {
            queryParameters['roomType'] = requestParameters.roomType;
        }

        if (requestParameters.fetchAllocatedRoomType) {
            queryParameters['fetchAllocatedRoomType'] = requestParameters.fetchAllocatedRoomType;
        }

        if (requestParameters.roomTypeCount !== undefined) {
            queryParameters['roomTypeCount'] = requestParameters.roomTypeCount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/availability`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockAvailabilityFromJSON(jsonValue));
    }

    /**
     * Use this API to search for availability on an OPERA block.  You will need to know the block ID.  Once you know what rooms and rates are available you can proceed to post a block reservation. <p><strong>OperationId:</strong>getBlockAvailability</p>
     * Get Block AvailaBility
     */
    async getBlockAvailability(requestParameters: GetBlockAvailabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockAvailability> {
        const response = await this.getBlockAvailabilityRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve a specific block.  You will need to know the blockID in the request; if you don\'t know it, please go ahead and use getBlocks API first.  The response will include detailed information about the block. <p><strong>OperationId:</strong>getBlockByExtId</p>
     * Get a Block By ID
     */
    async getBlockByExtIdRaw(requestParameters: GetBlockByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Block>> {
        const queryParameters: any = {};

        if (requestParameters.markAsRecentlyAccessed !== undefined) {
            queryParameters['markAsRecentlyAccessed'] = requestParameters.markAsRecentlyAccessed;
        }

        if (requestParameters.fetchInstructions) {
            queryParameters['fetchInstructions'] = requestParameters.fetchInstructions;
        }

        if (requestParameters.fetchAllocatedRoomTypes !== undefined) {
            queryParameters['fetchAllocatedRoomTypes'] = requestParameters.fetchAllocatedRoomTypes;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = (requestParameters.startDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.numberOfDays !== undefined) {
            queryParameters['numberOfDays'] = requestParameters.numberOfDays;
        }

        if (requestParameters.roomAllocationCriteria) {
            queryParameters['roomAllocationCriteria'] = requestParameters.roomAllocationCriteria;
        }

        if (requestParameters.roomTypes) {
            queryParameters['roomTypes'] = requestParameters.roomTypes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}`.replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve a specific block.  You will need to know the blockID in the request; if you don\'t know it, please go ahead and use getBlocks API first.  The response will include detailed information about the block. <p><strong>OperationId:</strong>getBlockByExtId</p>
     * Get a Block By ID
     */
    async getBlockByExtId(requestParameters: GetBlockByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Block> {
        const response = await this.getBlockByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve block daily statistics for the given date range and hotel ID. It returns allocated, picked up, and available number of room nights per block, per day, per room type.<p><strong>OperationId:</strong>getBlockDailyStatistics</p>
     * Get Block Daily Statistics
     */
    async getBlockDailyStatisticsRaw(requestParameters: GetBlockDailyStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockDailyStatistics>> {
        const queryParameters: any = {};

        if (requestParameters.genericRoomType !== undefined) {
            queryParameters['genericRoomType'] = requestParameters.genericRoomType;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.end !== undefined) {
            queryParameters['end'] = (requestParameters.end as any).toISOString().substr(0,10);
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = (requestParameters.start as any).toISOString().substr(0,10);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/dailyStatistics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockDailyStatisticsFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve block daily statistics for the given date range and hotel ID. It returns allocated, picked up, and available number of room nights per block, per day, per room type.<p><strong>OperationId:</strong>getBlockDailyStatistics</p>
     * Get Block Daily Statistics
     */
    async getBlockDailyStatistics(requestParameters: GetBlockDailyStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockDailyStatistics> {
        const response = await this.getBlockDailyStatisticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve block owners. <p><strong>OperationId:</strong>getBlockOwners</p>
     * Get Block owners
     */
    async getBlockOwnersRaw(requestParameters: GetBlockOwnersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockOwners>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/owners`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockOwnersFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve block owners. <p><strong>OperationId:</strong>getBlockOwners</p>
     * Get Block owners
     */
    async getBlockOwners(requestParameters: GetBlockOwnersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockOwners> {
        const response = await this.getBlockOwnersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve PM (Posting Master) reservations for a block. <p><strong>OperationId:</strong>getBlockPMReservations</p>
     * Get Posting Master Reservations for a Block
     */
    async getBlockPMReservationsRaw(requestParameters: GetBlockPMReservationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockPMReservations>> {
        const queryParameters: any = {};

        if (requestParameters.postingmaster !== undefined) {
            queryParameters['postingmaster'] = requestParameters.postingmaster;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/postingMaster/reservations`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockPMReservationsFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve PM (Posting Master) reservations for a block. <p><strong>OperationId:</strong>getBlockPMReservations</p>
     * Get Posting Master Reservations for a Block
     */
    async getBlockPMReservations(requestParameters: GetBlockPMReservationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockPMReservations> {
        const response = await this.getBlockPMReservationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve PM (Posting Master) reservations for a block. <p><strong>OperationId:</strong>getBlockPMReservationsByExtId</p>
     * Get Posting Master Reservations for a Block
     */
    async getBlockPMReservationsByExtIdRaw(requestParameters: GetBlockPMReservationsByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockPMReservations>> {
        const queryParameters: any = {};

        if (requestParameters.postingmaster !== undefined) {
            queryParameters['postingmaster'] = requestParameters.postingmaster;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/postingMaster/reservations`.replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockPMReservationsFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve PM (Posting Master) reservations for a block. <p><strong>OperationId:</strong>getBlockPMReservationsByExtId</p>
     * Get Posting Master Reservations for a Block
     */
    async getBlockPMReservationsByExtId(requestParameters: GetBlockPMReservationsByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockPMReservations> {
        const response = await this.getBlockPMReservationsByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Request for updating block allocation for a range of dates. <p><strong>OperationId:</strong>getBlockRangeInfo</p>
     * Get Block Range Information
     */
    async getBlockRangeInfoRaw(requestParameters: GetBlockRangeInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockRangeInfo>> {
        const queryParameters: any = {};

        if (requestParameters.genericRoomType !== undefined) {
            queryParameters['genericRoomType'] = requestParameters.genericRoomType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/allocationRange`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockRangeInfoFromJSON(jsonValue));
    }

    /**
     * Request for updating block allocation for a range of dates. <p><strong>OperationId:</strong>getBlockRangeInfo</p>
     * Get Block Range Information
     */
    async getBlockRangeInfo(requestParameters: GetBlockRangeInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockRangeInfo> {
        const response = await this.getBlockRangeInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to  retrieve all reservations created for the block. <p><strong>OperationId:</strong>getBlockReservations</p>
     * Retrieves all reservations created for the Block
     */
    async getBlockReservationsRaw(requestParameters: GetBlockReservationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockReservations>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.fetchInstructions) {
            queryParameters['fetchInstructions'] = requestParameters.fetchInstructions;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/reservations`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockReservationsFromJSON(jsonValue));
    }

    /**
     * Use this API to  retrieve all reservations created for the block. <p><strong>OperationId:</strong>getBlockReservations</p>
     * Retrieves all reservations created for the Block
     */
    async getBlockReservations(requestParameters: GetBlockReservationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockReservations> {
        const response = await this.getBlockReservationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API retrieves block restrictions. <p><strong>OperationId:</strong>getBlockRestrictions</p>
     * Get Block restrictions 
     */
    async getBlockRestrictionsRaw(requestParameters: GetBlockRestrictionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockRestrictions>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = (requestParameters.startDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = (requestParameters.endDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.duration !== undefined) {
            queryParameters['duration'] = requestParameters.duration;
        }

        if (requestParameters.roomType) {
            queryParameters['roomType'] = requestParameters.roomType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/restrictions`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockRestrictionsFromJSON(jsonValue));
    }

    /**
     * This API retrieves block restrictions. <p><strong>OperationId:</strong>getBlockRestrictions</p>
     * Get Block restrictions 
     */
    async getBlockRestrictions(requestParameters: GetBlockRestrictionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockRestrictions> {
        const response = await this.getBlockRestrictionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API will fetch revenue changes for a specific block recorded in the revenue change log for a specified date range. Please note that the revenue changes are delta changes only and single records do not represent a total summary of the block revenue per date. <p><strong>OperationId:</strong>getBlockRevenueChanges</p>
     * Fetch Block Revenue Changes
     */
    async getBlockRevenueChangesRaw(requestParameters: GetBlockRevenueChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockRevenueChanges>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.status) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.changeEndDate !== undefined) {
            queryParameters['changeEndDate'] = (requestParameters.changeEndDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.changeStartDate !== undefined) {
            queryParameters['changeStartDate'] = (requestParameters.changeStartDate as any).toISOString().substr(0,10);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/revenueActivityLog`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockRevenueChangesFromJSON(jsonValue));
    }

    /**
     * This API will fetch revenue changes for a specific block recorded in the revenue change log for a specified date range. Please note that the revenue changes are delta changes only and single records do not represent a total summary of the block revenue per date. <p><strong>OperationId:</strong>getBlockRevenueChanges</p>
     * Fetch Block Revenue Changes
     */
    async getBlockRevenueChanges(requestParameters: GetBlockRevenueChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockRevenueChanges> {
        const response = await this.getBlockRevenueChangesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve room types for a block based on search criteria <p><strong>OperationId:</strong>getBlockRoomTypes</p>
     * Get Bock Room Types
     */
    async getBlockRoomTypesRaw(requestParameters: GetBlockRoomTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockRoomTypes>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.fetchAllocatedRoomTypes !== undefined) {
            queryParameters['fetchAllocatedRoomTypes'] = requestParameters.fetchAllocatedRoomTypes;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = (requestParameters.startDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = (requestParameters.endDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.fetchGenericRoomTypes !== undefined) {
            queryParameters['fetchGenericRoomTypes'] = requestParameters.fetchGenericRoomTypes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/roomTypes`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockRoomTypesFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve room types for a block based on search criteria <p><strong>OperationId:</strong>getBlockRoomTypes</p>
     * Get Bock Room Types
     */
    async getBlockRoomTypes(requestParameters: GetBlockRoomTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockRoomTypes> {
        const response = await this.getBlockRoomTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API facilitates retrieving room status for the block. <p><strong>OperationId:</strong>getBlockRoomsStatus</p>
     * Get room status for a Block
     */
    async getBlockRoomsStatusRaw(requestParameters: GetBlockRoomsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockRoomsStatus>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/roomsStatus`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockRoomsStatusFromJSON(jsonValue));
    }

    /**
     * This API facilitates retrieving room status for the block. <p><strong>OperationId:</strong>getBlockRoomsStatus</p>
     * Get room status for a Block
     */
    async getBlockRoomsStatus(requestParameters: GetBlockRoomsStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockRoomsStatus> {
        const response = await this.getBlockRoomsStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to API retrieve detailed block statistics <p><strong>OperationId:</strong>getBlockStatistics</p>
     * Get Block Statistics
     */
    async getBlockStatisticsRaw(requestParameters: GetBlockStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockStatistics>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = (requestParameters.startDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.numberOfDays !== undefined) {
            queryParameters['numberOfDays'] = requestParameters.numberOfDays;
        }

        if (requestParameters.statisticsInstructions) {
            queryParameters['statisticsInstructions'] = requestParameters.statisticsInstructions;
        }

        if (requestParameters.roomTypeHotelId) {
            queryParameters['roomTypeHotelId'] = requestParameters.roomTypeHotelId;
        }

        if (requestParameters.invBlockCode) {
            queryParameters['invBlockCode'] = requestParameters.invBlockCode;
        }

        if (requestParameters.promotionCode) {
            queryParameters['promotionCode'] = requestParameters.promotionCode;
        }

        if (requestParameters.roomCategory) {
            queryParameters['roomCategory'] = requestParameters.roomCategory;
        }

        if (requestParameters.roomClass) {
            queryParameters['roomClass'] = requestParameters.roomClass;
        }

        if (requestParameters.roomQualifierCode) {
            queryParameters['roomQualifierCode'] = requestParameters.roomQualifierCode;
        }

        if (requestParameters.roomQualifierMatchIndicator) {
            queryParameters['roomQualifierMatchIndicator'] = requestParameters.roomQualifierMatchIndicator;
        }

        if (requestParameters.roomType) {
            queryParameters['roomType'] = requestParameters.roomType;
        }

        if (requestParameters.roomViewCode) {
            queryParameters['roomViewCode'] = requestParameters.roomViewCode;
        }

        if (requestParameters.roomFeatureCode) {
            queryParameters['roomFeatureCode'] = requestParameters.roomFeatureCode;
        }

        if (requestParameters.defaultOccupancy !== undefined) {
            queryParameters['defaultOccupancy'] = requestParameters.defaultOccupancy;
        }

        if (requestParameters.maximumOccupancy !== undefined) {
            queryParameters['maximumOccupancy'] = requestParameters.maximumOccupancy;
        }

        if (requestParameters.noOfPhysicalRooms !== undefined) {
            queryParameters['noOfPhysicalRooms'] = requestParameters.noOfPhysicalRooms;
        }

        if (requestParameters.bookingChannelCode) {
            queryParameters['bookingChannelCode'] = requestParameters.bookingChannelCode;
        }

        if (requestParameters.bookingChannelMappingCode) {
            queryParameters['bookingChannelMappingCode'] = requestParameters.bookingChannelMappingCode;
        }

        if (requestParameters.bookingChannelMappingName) {
            queryParameters['bookingChannelMappingName'] = requestParameters.bookingChannelMappingName;
        }

        if (requestParameters.bedTypeCode) {
            queryParameters['bedTypeCode'] = requestParameters.bedTypeCode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/statistics`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockStatisticsFromJSON(jsonValue));
    }

    /**
     * Use this API to API retrieve detailed block statistics <p><strong>OperationId:</strong>getBlockStatistics</p>
     * Get Block Statistics
     */
    async getBlockStatistics(requestParameters: GetBlockStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockStatistics> {
        const response = await this.getBlockStatisticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve block status change log based on the HotelCode and Block ID. <p><strong>OperationId:</strong>getBlockStatusChanges</p>
     * Get Block Status Activity Log
     */
    async getBlockStatusChangesRaw(requestParameters: GetBlockStatusChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockStatusChanges>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.changeEndDate !== undefined) {
            queryParameters['changeEndDate'] = (requestParameters.changeEndDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.changeStartDate !== undefined) {
            queryParameters['changeStartDate'] = (requestParameters.changeStartDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.currentStatus) {
            queryParameters['currentStatus'] = requestParameters.currentStatus;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/statusActivityLog`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockStatusChangesFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve block status change log based on the HotelCode and Block ID. <p><strong>OperationId:</strong>getBlockStatusChanges</p>
     * Get Block Status Activity Log
     */
    async getBlockStatusChanges(requestParameters: GetBlockStatusChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockStatusChanges> {
        const response = await this.getBlockStatusChangesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API retrieves block information needed to perform block wash operation. <p><strong>OperationId:</strong>getBlockWashInfo</p>
     * Get Block Wash Information
     */
    async getBlockWashInfoRaw(requestParameters: GetBlockWashInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockWashInfo>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.blockId !== undefined) {
            queryParameters['blockId'] = requestParameters.blockId;
        }

        if (requestParameters.blockIdType !== undefined) {
            queryParameters['blockIdType'] = requestParameters.blockIdType;
        }

        if (requestParameters.genericRoomType !== undefined) {
            queryParameters['genericRoomType'] = requestParameters.genericRoomType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blockWash`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockWashInfoFromJSON(jsonValue));
    }

    /**
     * This API retrieves block information needed to perform block wash operation. <p><strong>OperationId:</strong>getBlockWashInfo</p>
     * Get Block Wash Information
     */
    async getBlockWashInfo(requestParameters: GetBlockWashInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockWashInfo> {
        const response = await this.getBlockWashInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve the information regarding block wash schedule based on the parameter HotelCode and Block ID. <p><strong>OperationId:</strong>getBlockWashSchedules</p>
     * Get Block Wash Schedule
     */
    async getBlockWashSchedulesRaw(requestParameters: GetBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockWashSchedules>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/washSchedules`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockWashSchedulesFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve the information regarding block wash schedule based on the parameter HotelCode and Block ID. <p><strong>OperationId:</strong>getBlockWashSchedules</p>
     * Get Block Wash Schedule
     */
    async getBlockWashSchedules(requestParameters: GetBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockWashSchedules> {
        const response = await this.getBlockWashSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve blocks.  You can use the query parameters to narrow down your results. <p><strong>OperationId:</strong>getBlocks</p>
     * Get Blocks
     */
    async getBlocksRaw(requestParameters: GetBlocksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockSummaries>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.markAsRecentlyAccessed !== undefined) {
            queryParameters['markAsRecentlyAccessed'] = requestParameters.markAsRecentlyAccessed;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.multipleHotelsSearchHotelIds) {
            queryParameters['multipleHotelsSearchHotelIds'] = requestParameters.multipleHotelsSearchHotelIds;
        }

        if (requestParameters.superSearch !== undefined) {
            queryParameters['superSearch'] = requestParameters.superSearch;
        }

        if (requestParameters.blockIdList) {
            queryParameters['blockIdList'] = requestParameters.blockIdList;
        }

        if (requestParameters.blockIdType) {
            queryParameters['blockIdType'] = requestParameters.blockIdType;
        }

        if (requestParameters.externalReferenceIds) {
            queryParameters['externalReferenceIds'] = requestParameters.externalReferenceIds;
        }

        if (requestParameters.externalSystemCodes) {
            queryParameters['externalSystemCodes'] = requestParameters.externalSystemCodes;
        }

        if (requestParameters.blockCode !== undefined) {
            queryParameters['blockCode'] = requestParameters.blockCode;
        }

        if (requestParameters.blockName !== undefined) {
            queryParameters['blockName'] = requestParameters.blockName;
        }

        if (requestParameters.blockOwner) {
            queryParameters['blockOwner'] = requestParameters.blockOwner;
        }

        if (requestParameters.blockStatus) {
            queryParameters['blockStatus'] = requestParameters.blockStatus;
        }

        if (requestParameters.cateringStatus) {
            queryParameters['cateringStatus'] = requestParameters.cateringStatus;
        }

        if (requestParameters.createdByUser !== undefined) {
            queryParameters['createdByUser'] = requestParameters.createdByUser;
        }

        if (requestParameters.blockStartEndDate !== undefined) {
            queryParameters['blockStartEndDate'] = (requestParameters.blockStartEndDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.blockStartStartDate !== undefined) {
            queryParameters['blockStartStartDate'] = (requestParameters.blockStartStartDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.blockEndEndDate !== undefined) {
            queryParameters['blockEndEndDate'] = (requestParameters.blockEndEndDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.blockEndStartDate !== undefined) {
            queryParameters['blockEndStartDate'] = (requestParameters.blockEndStartDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.reservationArrival !== undefined) {
            queryParameters['reservationArrival'] = (requestParameters.reservationArrival as any).toISOString().substr(0,10);
        }

        if (requestParameters.reservationDeparture !== undefined) {
            queryParameters['reservationDeparture'] = (requestParameters.reservationDeparture as any).toISOString().substr(0,10);
        }

        if (requestParameters.includeShoulderDates !== undefined) {
            queryParameters['includeShoulderDates'] = requestParameters.includeShoulderDates;
        }

        if (requestParameters.stayDate !== undefined) {
            queryParameters['stayDate'] = (requestParameters.stayDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.blockCreatedOnEndDate !== undefined) {
            queryParameters['blockCreatedOnEndDate'] = (requestParameters.blockCreatedOnEndDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.blockCreatedOnStartDate !== undefined) {
            queryParameters['blockCreatedOnStartDate'] = (requestParameters.blockCreatedOnStartDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.decisionEndDate !== undefined) {
            queryParameters['decisionEndDate'] = (requestParameters.decisionEndDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.decisionStartDate !== undefined) {
            queryParameters['decisionStartDate'] = (requestParameters.decisionStartDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.cutOffEndDate !== undefined) {
            queryParameters['cutOffEndDate'] = (requestParameters.cutOffEndDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.cutOffStartDate !== undefined) {
            queryParameters['cutOffStartDate'] = (requestParameters.cutOffStartDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.category) {
            queryParameters['category'] = requestParameters.category;
        }

        if (requestParameters.name) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.attachedProfileId !== undefined) {
            queryParameters['attachedProfileId'] = requestParameters.attachedProfileId;
        }

        if (requestParameters.attachedProfileIdType !== undefined) {
            queryParameters['attachedProfileIdType'] = requestParameters.attachedProfileIdType;
        }

        if (requestParameters.leads !== undefined) {
            queryParameters['leads'] = requestParameters.leads;
        }

        if (requestParameters.tourSeries !== undefined) {
            queryParameters['tourSeries'] = requestParameters.tourSeries;
        }

        if (requestParameters.onlyPickupBlocks !== undefined) {
            queryParameters['onlyPickupBlocks'] = requestParameters.onlyPickupBlocks;
        }

        if (requestParameters.onlyOpportunities !== undefined) {
            queryParameters['onlyOpportunities'] = requestParameters.onlyOpportunities;
        }

        if (requestParameters.ratePlanCode) {
            queryParameters['ratePlanCode'] = requestParameters.ratePlanCode;
        }

        if (requestParameters.tourCode !== undefined) {
            queryParameters['tourCode'] = requestParameters.tourCode;
        }

        if (requestParameters.attributeName) {
            queryParameters['attributeName'] = requestParameters.attributeName;
        }

        if (requestParameters.orderType) {
            queryParameters['orderType'] = requestParameters.orderType;
        }

        if (requestParameters.fetchInstructions) {
            queryParameters['fetchInstructions'] = requestParameters.fetchInstructions;
        }

        if (requestParameters.fetchAllocatedRoomTypes !== undefined) {
            queryParameters['fetchAllocatedRoomTypes'] = requestParameters.fetchAllocatedRoomTypes;
        }

        if (requestParameters.additionalCriteriaStartDate !== undefined) {
            queryParameters['additionalCriteriaStartDate'] = (requestParameters.additionalCriteriaStartDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.numberOfDays !== undefined) {
            queryParameters['numberOfDays'] = requestParameters.numberOfDays;
        }

        if (requestParameters.adults !== undefined) {
            queryParameters['adults'] = requestParameters.adults;
        }

        if (requestParameters.children !== undefined) {
            queryParameters['children'] = requestParameters.children;
        }

        if (requestParameters.childAge) {
            queryParameters['childAge'] = requestParameters.childAge;
        }

        if (requestParameters.bucket1Count !== undefined) {
            queryParameters['bucket1Count'] = requestParameters.bucket1Count;
        }

        if (requestParameters.bucket2Count !== undefined) {
            queryParameters['bucket2Count'] = requestParameters.bucket2Count;
        }

        if (requestParameters.bucket3Count !== undefined) {
            queryParameters['bucket3Count'] = requestParameters.bucket3Count;
        }

        if (requestParameters.bucket4Count !== undefined) {
            queryParameters['bucket4Count'] = requestParameters.bucket4Count;
        }

        if (requestParameters.bucket5Count !== undefined) {
            queryParameters['bucket5Count'] = requestParameters.bucket5Count;
        }

        if (requestParameters.existingReservationId !== undefined) {
            queryParameters['existingReservationId'] = requestParameters.existingReservationId;
        }

        if (requestParameters.existingReservationIdType !== undefined) {
            queryParameters['existingReservationIdType'] = requestParameters.existingReservationIdType;
        }

        if (requestParameters.roomAllocationCriteria) {
            queryParameters['roomAllocationCriteria'] = requestParameters.roomAllocationCriteria;
        }

        if (requestParameters.roomType) {
            queryParameters['roomType'] = requestParameters.roomType;
        }

        if (requestParameters.additionalCriteriaRatePlanCode !== undefined) {
            queryParameters['additionalCriteriaRatePlanCode'] = requestParameters.additionalCriteriaRatePlanCode;
        }

        if (requestParameters.currencyCode !== undefined) {
            queryParameters['currencyCode'] = requestParameters.currencyCode;
        }

        if (requestParameters.customCharUDFsAltname) {
            queryParameters['customCharUDFsAltname'] = requestParameters.customCharUDFsAltname;
        }

        if (requestParameters.customCharUDFsName) {
            queryParameters['customCharUDFsName'] = requestParameters.customCharUDFsName;
        }

        if (requestParameters.customCharUDFsValue) {
            queryParameters['customCharUDFsValue'] = requestParameters.customCharUDFsValue;
        }

        if (requestParameters.customNumericUDFsAltname) {
            queryParameters['customNumericUDFsAltname'] = requestParameters.customNumericUDFsAltname;
        }

        if (requestParameters.customNumericUDFsName) {
            queryParameters['customNumericUDFsName'] = requestParameters.customNumericUDFsName;
        }

        if (requestParameters.customNumericUDFsValue) {
            queryParameters['customNumericUDFsValue'] = requestParameters.customNumericUDFsValue;
        }

        if (requestParameters.customDateUDFsAltname) {
            queryParameters['customDateUDFsAltname'] = requestParameters.customDateUDFsAltname;
        }

        if (requestParameters.customDateUDFsName) {
            queryParameters['customDateUDFsName'] = requestParameters.customDateUDFsName;
        }

        if (requestParameters.customDateUDFsValue) {
            queryParameters['customDateUDFsValue'] = requestParameters.customDateUDFsValue;
        }

        if (requestParameters.accessRestriction) {
            queryParameters['accessRestriction'] = requestParameters.accessRestriction;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockSummariesFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve blocks.  You can use the query parameters to narrow down your results. <p><strong>OperationId:</strong>getBlocks</p>
     * Get Blocks
     */
    async getBlocks(requestParameters: GetBlocksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockSummaries> {
        const response = await this.getBlocksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve a default block code based on template. <p><strong>OperationId:</strong>getDefaultBlockCode</p>
     * Get default Block Code
     */
    async getDefaultBlockCodeRaw(requestParameters: GetDefaultBlockCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DefaultBlockCodeDetails>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.blockName !== undefined) {
            queryParameters['blockName'] = requestParameters.blockName;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = (requestParameters.startDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.blockCodeTemplate !== undefined) {
            queryParameters['blockCodeTemplate'] = requestParameters.blockCodeTemplate;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/defaultBlockCode`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultBlockCodeDetailsFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve a default block code based on template. <p><strong>OperationId:</strong>getDefaultBlockCode</p>
     * Get default Block Code
     */
    async getDefaultBlockCode(requestParameters: GetDefaultBlockCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DefaultBlockCodeDetails> {
        const response = await this.getDefaultBlockCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve borrowable inventory for the requested dates when encountering an insufficient number of rooms in a block for a specific room type, or for overall inventory. This operations would usually be used when attempting to pick up a reservation against a block, and the block inventory does not have enough rooms left to support the reservation pick up. <p><strong>OperationId:</strong>getInventoryToBorrow</p>
     * Get inventory to Borrow
     */
    async getInventoryToBorrowRaw(requestParameters: GetInventoryToBorrowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryToBorrowInfo>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.blockId !== undefined) {
            queryParameters['blockId'] = requestParameters.blockId;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = (requestParameters.startDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.requiredRooms) {
            queryParameters['requiredRooms'] = requestParameters.requiredRooms;
        }

        if (requestParameters.blockIdContext !== undefined) {
            queryParameters['blockIdContext'] = requestParameters.blockIdContext;
        }

        if (requestParameters.blockIdType !== undefined) {
            queryParameters['blockIdType'] = requestParameters.blockIdType;
        }

        if (requestParameters.existingReservationId !== undefined) {
            queryParameters['existingReservationId'] = requestParameters.existingReservationId;
        }

        if (requestParameters.existingReservationIdType !== undefined) {
            queryParameters['existingReservationIdType'] = requestParameters.existingReservationIdType;
        }

        if (requestParameters.roomType !== undefined) {
            queryParameters['roomType'] = requestParameters.roomType;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = (requestParameters.endDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.duration !== undefined) {
            queryParameters['duration'] = requestParameters.duration;
        }

        if (requestParameters.numberOfRooms !== undefined) {
            queryParameters['numberOfRooms'] = requestParameters.numberOfRooms;
        }

        if (requestParameters.borrowDate) {
            queryParameters['borrowDate'] = requestParameters.borrowDate;
        }

        if (requestParameters.overrideRateCode !== undefined) {
            queryParameters['overrideRateCode'] = requestParameters.overrideRateCode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/inventoryToBorrow`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryToBorrowInfoFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve borrowable inventory for the requested dates when encountering an insufficient number of rooms in a block for a specific room type, or for overall inventory. This operations would usually be used when attempting to pick up a reservation against a block, and the block inventory does not have enough rooms left to support the reservation pick up. <p><strong>OperationId:</strong>getInventoryToBorrow</p>
     * Get inventory to Borrow
     */
    async getInventoryToBorrow(requestParameters: GetInventoryToBorrowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryToBorrowInfo> {
        const response = await this.getInventoryToBorrowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve next set of statuses and their next statuses for the current status passed in the request. <p><strong>OperationId:</strong>getNextBlockStatus</p>
     * Get Next Block Status
     */
    async getNextBlockStatusRaw(requestParameters: GetNextBlockStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NextBlockStatus>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.currentStatus !== undefined) {
            queryParameters['currentStatus'] = requestParameters.currentStatus;
        }

        if (requestParameters.includeCateringStatus !== undefined) {
            queryParameters['includeCateringStatus'] = requestParameters.includeCateringStatus;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NextBlockStatusFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve next set of statuses and their next statuses for the current status passed in the request. <p><strong>OperationId:</strong>getNextBlockStatus</p>
     * Get Next Block Status
     */
    async getNextBlockStatus(requestParameters: GetNextBlockStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NextBlockStatus> {
        const response = await this.getNextBlockStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API retrieves recently accessed blocks. <p><strong>OperationId:</strong>getRecentlyAccessedBlocks</p>
     * Get recently accessed Blocks
     */
    async getRecentlyAccessedBlocksRaw(requestParameters: GetRecentlyAccessedBlocksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecentlyAccessedBlocks>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/recentlyAccessedBlocks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecentlyAccessedBlocksFromJSON(jsonValue));
    }

    /**
     * This API retrieves recently accessed blocks. <p><strong>OperationId:</strong>getRecentlyAccessedBlocks</p>
     * Get recently accessed Blocks
     */
    async getRecentlyAccessedBlocks(requestParameters: GetRecentlyAccessedBlocksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecentlyAccessedBlocks> {
        const response = await this.getRecentlyAccessedBlocksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to retrieve the Sales Allowance of max amount of rooms that can be sold. <p><strong>OperationId:</strong>getSalesAllowances</p>
     * Get Sales allowances
     */
    async getSalesAllowancesRaw(requestParameters: GetSalesAllowancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SalesAllowances>> {
        const queryParameters: any = {};

        if (requestParameters.ceilingId) {
            queryParameters['ceilingId'] = requestParameters.ceilingId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/salesAllowances`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SalesAllowancesFromJSON(jsonValue));
    }

    /**
     * Use this API to retrieve the Sales Allowance of max amount of rooms that can be sold. <p><strong>OperationId:</strong>getSalesAllowances</p>
     * Get Sales allowances
     */
    async getSalesAllowances(requestParameters: GetSalesAllowancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SalesAllowances> {
        const response = await this.getSalesAllowancesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You can use this API to get traces for Reservations and Blocks. <p><strong>OperationId:</strong>getTracesByDateRange</p>
     * Get Traces By Date Range
     */
    async getTracesByDateRangeRaw(requestParameters: GetTracesByDateRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TracesByDateRange>> {
        const queryParameters: any = {};

        if (requestParameters.hotelIds) {
            queryParameters['hotelIds'] = requestParameters.hotelIds;
        }

        if (requestParameters.beginDate !== undefined) {
            queryParameters['beginDate'] = (requestParameters.beginDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = (requestParameters.endDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.department) {
            queryParameters['department'] = requestParameters.department;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/tracesByDateRange`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TracesByDateRangeFromJSON(jsonValue));
    }

    /**
     * You can use this API to get traces for Reservations and Blocks. <p><strong>OperationId:</strong>getTracesByDateRange</p>
     * Get Traces By Date Range
     */
    async getTracesByDateRange(requestParameters: GetTracesByDateRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TracesByDateRange> {
        const response = await this.getTracesByDateRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to ping and retrieve block service status. <p><strong>OperationId:</strong>pingBlockService</p>
     * This API retrieves the Block service version
     */
    async pingBlockServiceRaw(requestParameters: PingBlockServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OperaVersion>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/services/block/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OperaVersionFromJSON(jsonValue));
    }

    /**
     * Use this API to ping and retrieve block service status. <p><strong>OperationId:</strong>pingBlockService</p>
     * This API retrieves the Block service version
     */
    async pingBlockService(requestParameters: PingBlockServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OperaVersion> {
        const response = await this.pingBlockServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create alternate dates for a block. <p><strong>OperationId:</strong>postAlternateDates</p>
     * Create alternate dates for a Block
     */
    async postAlternateDatesRaw(requestParameters: PostAlternateDatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/alternateDates`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PutAlternateDatesRequestToJSON(requestParameters.blockAlternateDates),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create alternate dates for a block. <p><strong>OperationId:</strong>postAlternateDates</p>
     * Create alternate dates for a Block
     */
    async postAlternateDates(requestParameters: PostAlternateDatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postAlternateDatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create a new group block in OPERA Cloud. You must first use the ListOfValues APIs to find block attributes, such as Block Status, Room Types, and so on. Knowing this list of values helps ensure a successful postBlock. <p><strong>OperationId:</strong>postBlock</p>
     * Create a Block
     */
    async postBlockRaw(requestParameters: PostBlockOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/block`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostBlockRequestToJSON(requestParameters.block),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create a new group block in OPERA Cloud. You must first use the ListOfValues APIs to find block attributes, such as Block Status, Room Types, and so on. Knowing this list of values helps ensure a successful postBlock. <p><strong>OperationId:</strong>postBlock</p>
     * Create a Block
     */
    async postBlock(requestParameters: PostBlockOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to assign block owners. <p><strong>OperationId:</strong>postBlockOwners</p>
     * Assign a Block owner
     */
    async postBlockOwnersRaw(requestParameters: PostBlockOwnersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/owners`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostBlockOwnersRequestToJSON(requestParameters.blockOwnersToAssign),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to assign block owners. <p><strong>OperationId:</strong>postBlockOwners</p>
     * Assign a Block owner
     */
    async postBlockOwners(requestParameters: PostBlockOwnersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postBlockOwnersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create a new posting Master reservation against a block in OPERA.  The block status in OPERA needs to be \'Open for Pick up\' to successfully post a BlockPostingMaster reservation. <p><strong>OperationId:</strong>postBlockPostingMaster</p>
     * Create Block posting master
     */
    async postBlockPostingMasterRaw(requestParameters: PostBlockPostingMasterOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/postingMaster`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostBlockPostingMasterRequestToJSON(requestParameters.blockPostingMaster),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create a new posting Master reservation against a block in OPERA.  The block status in OPERA needs to be \'Open for Pick up\' to successfully post a BlockPostingMaster reservation. <p><strong>OperationId:</strong>postBlockPostingMaster</p>
     * Create Block posting master
     */
    async postBlockPostingMaster(requestParameters: PostBlockPostingMasterOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postBlockPostingMasterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create block restrictions. <p><strong>OperationId:</strong>postBlockRestriction</p>
     * Create Block Restriction
     */
    async postBlockRestrictionRaw(requestParameters: PostBlockRestrictionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/restrictions`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostBlockRestrictionRequestToJSON(requestParameters.blockRestriction),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create block restrictions. <p><strong>OperationId:</strong>postBlockRestriction</p>
     * Create Block Restriction
     */
    async postBlockRestriction(requestParameters: PostBlockRestrictionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postBlockRestrictionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to validate if block rate code has overlapping blocks and also validates and creates block details. <p><strong>OperationId:</strong>postBlockValidate</p>
     * Validate Block
     */
    async postBlockValidateRaw(requestParameters: PostBlockValidateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/actions/validate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostBlockValidateRequestToJSON(requestParameters.blockValidate),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to validate if block rate code has overlapping blocks and also validates and creates block details. <p><strong>OperationId:</strong>postBlockValidate</p>
     * Validate Block
     */
    async postBlockValidate(requestParameters: PostBlockValidateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postBlockValidateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API creates new block wash schedules based on Wash Date, Room Type, Occupancy detail, Sell limit and Wash by percent value. <p><strong>OperationId:</strong>postBlockWashSchedules</p>
     * Create Block Wash Schedules
     */
    async postBlockWashSchedulesRaw(requestParameters: PostBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/washSchedules`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockWashSchedulesRequestToJSON(requestParameters.blockWashSchedulesInfo),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API creates new block wash schedules based on Wash Date, Room Type, Occupancy detail, Sell limit and Wash by percent value. <p><strong>OperationId:</strong>postBlockWashSchedules</p>
     * Create Block Wash Schedules
     */
    async postBlockWashSchedules(requestParameters: PostBlockWashSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postBlockWashSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to complete a cancellation of the block. <p><strong>OperationId:</strong>postCancelBlock</p>
     * Cancel the Block
     */
    async postCancelBlockRaw(requestParameters: PostCancelBlockOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/cancellations`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostCancelBlockRequestToJSON(requestParameters.blockToCancel),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to complete a cancellation of the block. <p><strong>OperationId:</strong>postCancelBlock</p>
     * Cancel the Block
     */
    async postCancelBlock(requestParameters: PostCancelBlockOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postCancelBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to copy the a block. The block copied (Source block) will serve as a template for the new one. <p><strong>OperationId:</strong>postCopyBlock</p>
     * Copy a Block
     */
    async postCopyBlockRaw(requestParameters: PostCopyBlockOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{sourceBlockId}/copy`.replace(`{${"sourceBlockId"}}`, encodeURIComponent(String(requestParameters.sourceBlockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostCopyBlockRequestToJSON(requestParameters.blockCopy),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to copy the a block. The block copied (Source block) will serve as a template for the new one. <p><strong>OperationId:</strong>postCopyBlock</p>
     * Copy a Block
     */
    async postCopyBlock(requestParameters: PostCopyBlockOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postCopyBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create a Reservation Rooming List. <p><strong>OperationId:</strong>postRoomingList</p>
     * Create Block Rooming List Reservations
     */
    async postRoomingListRaw(requestParameters: PostRoomingListOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoomingListDetails>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/roomingList`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostRoomingListRequestToJSON(requestParameters.roomingList),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoomingListDetailsFromJSON(jsonValue));
    }

    /**
     * Use this API to create a Reservation Rooming List. <p><strong>OperationId:</strong>postRoomingList</p>
     * Create Block Rooming List Reservations
     */
    async postRoomingList(requestParameters: PostRoomingListOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoomingListDetails> {
        const response = await this.postRoomingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create sub allocation. <p><strong>OperationId:</strong>postSubAllocation</p>
     * Create Sub allocation
     */
    async postSubAllocationRaw(requestParameters: PostSubAllocationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/allocation`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostSubAllocationRequestToJSON(requestParameters.subAllocation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create sub allocation. <p><strong>OperationId:</strong>postSubAllocation</p>
     * Create Sub allocation
     */
    async postSubAllocation(requestParameters: PostSubAllocationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postSubAllocationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this when you want to create a sub block.You will need to know the OPERA Block ID, which you want this sub block to fall under. <p><strong>OperationId:</strong>postSubBlock</p>
     * Create a sub-Block
     */
    async postSubBlockRaw(requestParameters: PostSubBlockOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/subBlocks`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostSubBlockRequestToJSON(requestParameters.subBlock),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this when you want to create a sub block.You will need to know the OPERA Block ID, which you want this sub block to fall under. <p><strong>OperationId:</strong>postSubBlock</p>
     * Create a sub-Block
     */
    async postSubBlock(requestParameters: PostSubBlockOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postSubBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this when you want to create a sub block.You will need to know the OPERA Block ID, which you want this sub block to fall under. <p><strong>OperationId:</strong>postSubBlockByExtId</p>
     * Create a sub-Block
     */
    async postSubBlockByExtIdRaw(requestParameters: PostSubBlockByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/subBlocks`.replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostSubBlockRequestToJSON(requestParameters.subBlock),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this when you want to create a sub block.You will need to know the OPERA Block ID, which you want this sub block to fall under. <p><strong>OperationId:</strong>postSubBlockByExtId</p>
     * Create a sub-Block
     */
    async postSubBlockByExtId(requestParameters: PostSubBlockByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postSubBlockByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create a block tour series. <p><strong>OperationId:</strong>postTourSeries</p>
     * Create a Block tour series
     */
    async postTourSeriesRaw(requestParameters: PostTourSeriesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/tourSeries`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostTourSeriesRequestToJSON(requestParameters.tourSeries),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create a block tour series. <p><strong>OperationId:</strong>postTourSeries</p>
     * Create a Block tour series
     */
    async postTourSeries(requestParameters: PostTourSeriesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postTourSeriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to change alternate dates for a block. <p><strong>OperationId:</strong>putAlternateDates</p>
     * Change alternate dates for a Block
     */
    async putAlternateDatesRaw(requestParameters: PutAlternateDatesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/alternateDates`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutAlternateDatesRequestToJSON(requestParameters.blockAlternateDates),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to change alternate dates for a block. <p><strong>OperationId:</strong>putAlternateDates</p>
     * Change alternate dates for a Block
     */
    async putAlternateDates(requestParameters: PutAlternateDatesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putAlternateDatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to update an existing group block in OPERA Cloud. This API allows update of block header information, such as description, market segment, source code, rate code, and other details, but does not include updates for room grid or events, which have their own update API calls. <p><strong>OperationId:</strong>putBlock</p>
     * Change a Block
     */
    async putBlockRaw(requestParameters: PutBlockOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockChanged>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockRequestToJSON(requestParameters.blockToBeChanged),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockChangedFromJSON(jsonValue));
    }

    /**
     * Use this API to update an existing group block in OPERA Cloud. This API allows update of block header information, such as description, market segment, source code, rate code, and other details, but does not include updates for room grid or events, which have their own update API calls. <p><strong>OperationId:</strong>putBlock</p>
     * Change a Block
     */
    async putBlock(requestParameters: PutBlockOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockChanged> {
        const response = await this.putBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Us this API to create/change block access exclusion information. <p><strong>OperationId:</strong>putBlockAccessExclusion</p>
     * Set Block Exclusion information
     */
    async putBlockAccessExclusionRaw(requestParameters: PutBlockAccessExclusionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/blockAccessExclusion`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockAccessExclusionRequestToJSON(requestParameters.blockAccessExclusion),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Us this API to create/change block access exclusion information. <p><strong>OperationId:</strong>putBlockAccessExclusion</p>
     * Set Block Exclusion information
     */
    async putBlockAccessExclusion(requestParameters: PutBlockAccessExclusionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockAccessExclusionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to add block room type allocations and rates to a specified Block. <p><strong>OperationId:</strong>putBlockAllocation</p>
     * Set Block Allocation  
     */
    async putBlockAllocationRaw(requestParameters: PutBlockAllocationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/allocation`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockAllocationRequestToJSON(requestParameters.allocation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to add block room type allocations and rates to a specified Block. <p><strong>OperationId:</strong>putBlockAllocation</p>
     * Set Block Allocation  
     */
    async putBlockAllocation(requestParameters: PutBlockAllocationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockAllocationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to add block room type allocations and rates to a specified Block. <p><strong>OperationId:</strong>putBlockAllocationByExtId</p>
     * Set Block Allocation  
     */
    async putBlockAllocationByExtIdRaw(requestParameters: PutBlockAllocationByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/allocation/roomTypes/{roomType}`.replace(`{${"roomType"}}`, encodeURIComponent(String(requestParameters.roomType))).replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockAllocationRequestToJSON(requestParameters.allocation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to add block room type allocations and rates to a specified Block. <p><strong>OperationId:</strong>putBlockAllocationByExtId</p>
     * Set Block Allocation  
     */
    async putBlockAllocationByExtId(requestParameters: PutBlockAllocationByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockAllocationByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to set block allocation for a range of dates for a list of room types. <p><strong>OperationId:</strong>putBlockAllocationRange</p>
     * Set Block Allocation Range
     */
    async putBlockAllocationRangeRaw(requestParameters: PutBlockAllocationRangeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/allocationRange`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockAllocationRangeRequestToJSON(requestParameters.blockAllocationRange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to set block allocation for a range of dates for a list of room types. <p><strong>OperationId:</strong>putBlockAllocationRange</p>
     * Set Block Allocation Range
     */
    async putBlockAllocationRange(requestParameters: PutBlockAllocationRangeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockAllocationRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to set block allocation for a range of dates for a list of room types. <p><strong>OperationId:</strong>putBlockAllocationRangeByExtId</p>
     * Set Block Allocation Range
     */
    async putBlockAllocationRangeByExtIdRaw(requestParameters: PutBlockAllocationRangeByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/allocationRange`.replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockAllocationRangeRequestToJSON(requestParameters.blockAllocationRange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to set block allocation for a range of dates for a list of room types. <p><strong>OperationId:</strong>putBlockAllocationRangeByExtId</p>
     * Set Block Allocation Range
     */
    async putBlockAllocationRangeByExtId(requestParameters: PutBlockAllocationRangeByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockAllocationRangeByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API removes block allocation to a range of dates for a set of room types. <p><strong>OperationId:</strong>putBlockAllocationWash</p>
     * Update Block Allocation Wash
     */
    async putBlockAllocationWashRaw(requestParameters: PutBlockAllocationWashOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blockWash`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockAllocationWashRequestToJSON(requestParameters.blockAllocationWash),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API removes block allocation to a range of dates for a set of room types. <p><strong>OperationId:</strong>putBlockAllocationWash</p>
     * Update Block Allocation Wash
     */
    async putBlockAllocationWash(requestParameters: PutBlockAllocationWashOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockAllocationWashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You can use this API to update an existing block.  You must know the block ID for the request message.  Use getBlocks if you dont already know the block ID. <p><strong>OperationId:</strong>putBlockByExtId</p>
     * Change a Block
     */
    async putBlockByExtIdRaw(requestParameters: PutBlockByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockChanged>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}`.replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockRequestToJSON(requestParameters.blockToBeChanged),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockChangedFromJSON(jsonValue));
    }

    /**
     * You can use this API to update an existing block.  You must know the block ID for the request message.  Use getBlocks if you dont already know the block ID. <p><strong>OperationId:</strong>putBlockByExtId</p>
     * Change a Block
     */
    async putBlockByExtId(requestParameters: PutBlockByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockChanged> {
        const response = await this.putBlockByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API cuts off block allocation effective current date. <p><strong>OperationId:</strong>putBlockCutoff</p>
     * Block Cut Off
     */
    async putBlockCutoffRaw(requestParameters: PutBlockCutoffOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/blockCutOff`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockCutoffRequestToJSON(requestParameters.blockStatus),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API cuts off block allocation effective current date. <p><strong>OperationId:</strong>putBlockCutoff</p>
     * Block Cut Off
     */
    async putBlockCutoff(requestParameters: PutBlockCutoffOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockCutoffRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to change block owners. <p><strong>OperationId:</strong>putBlockOwners</p>
     * Change Block owners
     */
    async putBlockOwnersRaw(requestParameters: PutBlockOwnersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/owners`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockOwnersRequestToJSON(requestParameters.blockOwnersToChange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to change block owners. <p><strong>OperationId:</strong>putBlockOwners</p>
     * Change Block owners
     */
    async putBlockOwners(requestParameters: PutBlockOwnersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockOwnersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to refreshes block rates. <p><strong>OperationId:</strong>putBlockRates</p>
     * Refreshes Block rates
     */
    async putBlockRatesRaw(requestParameters: PutBlockRatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/rates`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockCutoffRequestToJSON(requestParameters.blockStatus),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to refreshes block rates. <p><strong>OperationId:</strong>putBlockRates</p>
     * Refreshes Block rates
     */
    async putBlockRates(requestParameters: PutBlockRatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockRatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to make changes to block reservations. <p><strong>OperationId:</strong>putBlockReservations</p>
     * Change Block reservations
     */
    async putBlockReservationsRaw(requestParameters: PutBlockReservationsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangedBlockReservations>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/reservations`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockReservationsRequestToJSON(requestParameters.blockReservationsToChange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChangedBlockReservationsFromJSON(jsonValue));
    }

    /**
     * Use this API to make changes to block reservations. <p><strong>OperationId:</strong>putBlockReservations</p>
     * Change Block reservations
     */
    async putBlockReservations(requestParameters: PutBlockReservationsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangedBlockReservations> {
        const response = await this.putBlockReservationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to move or shift the dates of a block in OPERA.  <p><strong>OperationId:</strong>putBlockShift</p>
     * Shifts the Block start date
     */
    async putBlockShiftRaw(requestParameters: PutBlockShiftOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShiftedBlock>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/shifts`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockShiftRequestToJSON(requestParameters.blockToShift),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShiftedBlockFromJSON(jsonValue));
    }

    /**
     * Use this API to move or shift the dates of a block in OPERA.  <p><strong>OperationId:</strong>putBlockShift</p>
     * Shifts the Block start date
     */
    async putBlockShift(requestParameters: PutBlockShiftOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShiftedBlock> {
        const response = await this.putBlockShiftRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this to change the status of a block in Opera.  To know a hotels Block status codes, use the List Of Values API - BlockStatuses.  Also note, you can only change the status in a particular order, for example INQ to DEF, but not DEF to INQ. <p><strong>OperationId:</strong>putBlockStatus</p>
     * Change the Status of a Block
     */
    async putBlockStatusRaw(requestParameters: PutBlockStatusOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangedBlockStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/status`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockStatusRequestToJSON(requestParameters.blockStatusToChange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChangedBlockStatusFromJSON(jsonValue));
    }

    /**
     * Use this to change the status of a block in Opera.  To know a hotels Block status codes, use the List Of Values API - BlockStatuses.  Also note, you can only change the status in a particular order, for example INQ to DEF, but not DEF to INQ. <p><strong>OperationId:</strong>putBlockStatus</p>
     * Change the Status of a Block
     */
    async putBlockStatus(requestParameters: PutBlockStatusOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangedBlockStatus> {
        const response = await this.putBlockStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this to change the status of a block in Opera.  To know a hotels Block status codes, use the List Of Values API - BlockStatuses.  Also note, you can only change the status in a particular order, for example INQ to DEF, but not DEF to INQ. <p><strong>OperationId:</strong>putBlockStatusByExtId</p>
     * Change the Status of a Block
     */
    async putBlockStatusByExtIdRaw(requestParameters: PutBlockStatusByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangedBlockStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/status`.replace(`{${"blockExternalId"}}`, encodeURIComponent(String(requestParameters.blockExternalId))).replace(`{${"externalSystemCode"}}`, encodeURIComponent(String(requestParameters.externalSystemCode))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockStatusRequestToJSON(requestParameters.blockStatusToChange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChangedBlockStatusFromJSON(jsonValue));
    }

    /**
     * Use this to change the status of a block in Opera.  To know a hotels Block status codes, use the List Of Values API - BlockStatuses.  Also note, you can only change the status in a particular order, for example INQ to DEF, but not DEF to INQ. <p><strong>OperationId:</strong>putBlockStatusByExtId</p>
     * Change the Status of a Block
     */
    async putBlockStatusByExtId(requestParameters: PutBlockStatusByExtIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangedBlockStatus> {
        const response = await this.putBlockStatusByExtIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to transition booking status in allotment header to an Open for Pickup Status, which ready to receive reservation bookings. <p><strong>OperationId:</strong>putBlockStatusToOpen</p>
     * Change Block status to Open
     */
    async putBlockStatusToOpenRaw(requestParameters: PutBlockStatusToOpenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/blocks/{blockId}/openStatus`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockCutoffRequestToJSON(requestParameters.blockStatus),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to transition booking status in allotment header to an Open for Pickup Status, which ready to receive reservation bookings. <p><strong>OperationId:</strong>putBlockStatusToOpen</p>
     * Change Block status to Open
     */
    async putBlockStatusToOpen(requestParameters: PutBlockStatusToOpenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockStatusToOpenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API changes block wash schedules Wash Date, Room Type, Occupancy detail, Sell limit and Wash by percent value. <p><strong>OperationId:</strong>putBlockWashSchedules</p>
     * Change Block Wash Schedules
     */
    async putBlockWashSchedulesRaw(requestParameters: PutBlockWashSchedulesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/washSchedules`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockWashSchedulesRequestToJSON(requestParameters.blockWashSchedulesInfo),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API changes block wash schedules Wash Date, Room Type, Occupancy detail, Sell limit and Wash by percent value. <p><strong>OperationId:</strong>putBlockWashSchedules</p>
     * Change Block Wash Schedules
     */
    async putBlockWashSchedules(requestParameters: PutBlockWashSchedulesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putBlockWashSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to update catering status. <p><strong>OperationId:</strong>putCateringStatus</p>
     * Change Catering Status
     */
    async putCateringStatusRaw(requestParameters: PutCateringStatusOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangedCateringStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/caterings/{eventId}/cateringStatus`.replace(`{${"eventId"}}`, encodeURIComponent(String(requestParameters.eventId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutCateringStatusRequestToJSON(requestParameters.cateringStatusToChange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChangedCateringStatusFromJSON(jsonValue));
    }

    /**
     * Use this API to update catering status. <p><strong>OperationId:</strong>putCateringStatus</p>
     * Change Catering Status
     */
    async putCateringStatus(requestParameters: PutCateringStatusOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangedCateringStatus> {
        const response = await this.putCateringStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API clears all block restrictions for a given date. <p><strong>OperationId:</strong>putClearAllRestrictions</p>
     * Clear-All Block Restrictions 
     */
    async putClearAllRestrictionsRaw(requestParameters: PutClearAllRestrictionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/restrictions`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutClearAllRestrictionsRequestToJSON(requestParameters.allRestrictions),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API clears all block restrictions for a given date. <p><strong>OperationId:</strong>putClearAllRestrictions</p>
     * Clear-All Block Restrictions 
     */
    async putClearAllRestrictions(requestParameters: PutClearAllRestrictionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putClearAllRestrictionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to set the contract defaults. <p><strong>OperationId:</strong>putContractDefaults</p>
     * Set Contract Defaults
     */
    async putContractDefaultsRaw(requestParameters: PutContractDefaultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/contractDefaults`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutBlockCutoffRequestToJSON(requestParameters.blockStatus),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to set the contract defaults. <p><strong>OperationId:</strong>putContractDefaults</p>
     * Set Contract Defaults
     */
    async putContractDefaults(requestParameters: PutContractDefaultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putContractDefaultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to borrow inventory from the block or house when you encounter an insufficient number of rooms for block a reservation. <p><strong>OperationId:</strong>putInventory</p>
     * Borrow Inventory
     */
    async putInventoryRaw(requestParameters: PutInventoryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/inventory`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutInventoryRequestToJSON(requestParameters.inventoryToBorrow),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to borrow inventory from the block or house when you encounter an insufficient number of rooms for block a reservation. <p><strong>OperationId:</strong>putInventory</p>
     * Borrow Inventory
     */
    async putInventory(requestParameters: PutInventoryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putInventoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to return the previously borrowed inventory on the block back to the original source from which it was borrowed. The original source can be a room type or house inventory, as indicated in the request. <p><strong>OperationId:</strong>putReleasedInventory</p>
     * Return Borrowed Inventory
     */
    async putReleasedInventoryRaw(requestParameters: PutReleasedInventoryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/inventoryReleased`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutReleasedInventoryRequestToJSON(requestParameters.borrowedInventoryToReturn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to return the previously borrowed inventory on the block back to the original source from which it was borrowed. The original source can be a room type or house inventory, as indicated in the request. <p><strong>OperationId:</strong>putReleasedInventory</p>
     * Return Borrowed Inventory
     */
    async putReleasedInventory(requestParameters: PutReleasedInventoryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putReleasedInventoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to set room type order for a block. <p><strong>OperationId:</strong>putRoomTypeOrder</p>
     * Set room type order for a Block
     */
    async putRoomTypeOrderRaw(requestParameters: PutRoomTypeOrderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockId}/roomTypeOrder`.replace(`{${"blockId"}}`, encodeURIComponent(String(requestParameters.blockId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutRoomTypeOrderRequestToJSON(requestParameters.roomTypeOrder),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to set room type order for a block. <p><strong>OperationId:</strong>putRoomTypeOrder</p>
     * Set room type order for a Block
     */
    async putRoomTypeOrder(requestParameters: PutRoomTypeOrderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putRoomTypeOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This API validates the block code for the following if applicable - Unique block code/ Start of inventory week/ Block code template. <p><strong>OperationId:</strong>putValidateBlockCode</p>
     * Validate Block Code
     */
    async putValidateBlockCodeRaw(requestParameters: PutValidateBlockCodeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/blocks/{blockCode}/actions/validate`.replace(`{${"blockCode"}}`, encodeURIComponent(String(requestParameters.blockCode))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutValidateBlockCodeRequestToJSON(requestParameters.blockCodeToValidate),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * This API validates the block code for the following if applicable - Unique block code/ Start of inventory week/ Block code template. <p><strong>OperationId:</strong>putValidateBlockCode</p>
     * Validate Block Code
     */
    async putValidateBlockCode(requestParameters: PutValidateBlockCodeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.putValidateBlockCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const DeleteBlockRestrictionCodeEnum = {
    Closed: 'Closed',
    ClosedForArrival: 'ClosedForArrival',
    ClosedForDeparture: 'ClosedForDeparture',
    MinimumStayThrough: 'MinimumStayThrough',
    MaximumStayThrough: 'MaximumStayThrough',
    MinimumLengthOfStay: 'MinimumLengthOfStay',
    MaximumLengthOfStay: 'MaximumLengthOfStay',
    LosNotAvailable: 'LOSNotAvailable',
    MinimumAdvanceBooking: 'MinimumAdvanceBooking',
    MaximumAdvanceBooking: 'MaximumAdvanceBooking',
    Open: 'Open',
    OpenForArrival: 'OpenForArrival',
    OpenForDeparture: 'OpenForDeparture'
} as const;
export type DeleteBlockRestrictionCodeEnum = typeof DeleteBlockRestrictionCodeEnum[keyof typeof DeleteBlockRestrictionCodeEnum];
/**
 * @export
 */
export const GetBlockFetchInstructionsEnum = {
    AccessExclusions: 'AccessExclusions',
    Aliases: 'Aliases',
    AlternateDates: 'AlternateDates',
    Attachments: 'Attachments',
    Block: 'Block',
    BlockNextStatuses: 'BlockNextStatuses',
    BlockStatusHistory: 'BlockStatusHistory',
    CatNextStatuses: 'CatNextStatuses',
    CatStatusHistory: 'CatStatusHistory',
    Comments: 'Comments',
    DateProtect: 'DateProtect',
    ExternalReferences: 'ExternalReferences',
    GenericRateGrid: 'GenericRateGrid',
    Header: 'Header',
    Indicators: 'Indicators',
    InventoryItems: 'InventoryItems',
    Owners: 'Owners',
    Packages: 'Packages',
    Policies: 'Policies',
    PrimaryOwners: 'PrimaryOwners',
    PrimaryProfiles: 'PrimaryProfiles',
    PrimaryRates: 'PrimaryRates',
    Profiles: 'Profiles',
    RateGrid: 'RateGrid',
    RateProgram: 'RateProgram',
    Rates: 'Rates',
    Restrictions: 'Restrictions',
    SellMessages: 'SellMessages',
    Statistics: 'Statistics',
    SummaryStatistics: 'SummaryStatistics',
    Traces: 'Traces',
    WashSchedules: 'WashSchedules'
} as const;
export type GetBlockFetchInstructionsEnum = typeof GetBlockFetchInstructionsEnum[keyof typeof GetBlockFetchInstructionsEnum];
/**
 * @export
 */
export const GetBlockRoomAllocationCriteriaEnum = {
    Initial: 'Initial',
    Actual: 'Actual',
    Rates: 'Rates',
    Pickup: 'Pickup',
    Contract: 'Contract',
    Available: 'Available',
    Pickupperc: 'Pickupperc',
    Changes: 'Changes',
    Released: 'Released',
    Houseavailability: 'Houseavailability',
    SellLimit: 'SellLimit',
    AvailableSellLimit: 'AvailableSellLimit',
    MasterAllocInitial: 'MasterAllocInitial',
    Allocated: 'Allocated',
    SubAllocResv: 'SubAllocResv',
    CutoffDate: 'CutoffDate'
} as const;
export type GetBlockRoomAllocationCriteriaEnum = typeof GetBlockRoomAllocationCriteriaEnum[keyof typeof GetBlockRoomAllocationCriteriaEnum];
/**
 * @export
 */
export const GetBlockActivityLogModuleEnum = {
    Reservation: 'Reservation',
    Contract: 'Contract',
    Allotment: 'Allotment',
    Outlookview: 'Outlookview',
    Profile: 'Profile',
    Accountreceivables: 'Accountreceivables',
    GdsConvRateCodes: 'GdsConvRateCodes',
    RateCode: 'RateCode',
    Billing: 'Billing',
    Activity: 'Activity'
} as const;
export type GetBlockActivityLogModuleEnum = typeof GetBlockActivityLogModuleEnum[keyof typeof GetBlockActivityLogModuleEnum];
/**
 * @export
 */
export const GetBlockAvailabilityFetchAllocatedRoomTypeEnum = {
    Allocated: 'Allocated',
    Available: 'Available',
    GenericAllocated: 'GenericAllocated',
    GenericAvailable: 'GenericAvailable'
} as const;
export type GetBlockAvailabilityFetchAllocatedRoomTypeEnum = typeof GetBlockAvailabilityFetchAllocatedRoomTypeEnum[keyof typeof GetBlockAvailabilityFetchAllocatedRoomTypeEnum];
/**
 * @export
 */
export const GetBlockByExtIdFetchInstructionsEnum = {
    AccessExclusions: 'AccessExclusions',
    Aliases: 'Aliases',
    AlternateDates: 'AlternateDates',
    Attachments: 'Attachments',
    Block: 'Block',
    BlockNextStatuses: 'BlockNextStatuses',
    BlockStatusHistory: 'BlockStatusHistory',
    CatNextStatuses: 'CatNextStatuses',
    CatStatusHistory: 'CatStatusHistory',
    Comments: 'Comments',
    DateProtect: 'DateProtect',
    ExternalReferences: 'ExternalReferences',
    GenericRateGrid: 'GenericRateGrid',
    Header: 'Header',
    Indicators: 'Indicators',
    InventoryItems: 'InventoryItems',
    Owners: 'Owners',
    Packages: 'Packages',
    Policies: 'Policies',
    PrimaryOwners: 'PrimaryOwners',
    PrimaryProfiles: 'PrimaryProfiles',
    PrimaryRates: 'PrimaryRates',
    Profiles: 'Profiles',
    RateGrid: 'RateGrid',
    RateProgram: 'RateProgram',
    Rates: 'Rates',
    Restrictions: 'Restrictions',
    SellMessages: 'SellMessages',
    Statistics: 'Statistics',
    SummaryStatistics: 'SummaryStatistics',
    Traces: 'Traces',
    WashSchedules: 'WashSchedules'
} as const;
export type GetBlockByExtIdFetchInstructionsEnum = typeof GetBlockByExtIdFetchInstructionsEnum[keyof typeof GetBlockByExtIdFetchInstructionsEnum];
/**
 * @export
 */
export const GetBlockByExtIdRoomAllocationCriteriaEnum = {
    Initial: 'Initial',
    Actual: 'Actual',
    Rates: 'Rates',
    Pickup: 'Pickup',
    Contract: 'Contract',
    Available: 'Available',
    Pickupperc: 'Pickupperc',
    Changes: 'Changes',
    Released: 'Released',
    Houseavailability: 'Houseavailability',
    SellLimit: 'SellLimit',
    AvailableSellLimit: 'AvailableSellLimit',
    MasterAllocInitial: 'MasterAllocInitial',
    Allocated: 'Allocated',
    SubAllocResv: 'SubAllocResv',
    CutoffDate: 'CutoffDate'
} as const;
export type GetBlockByExtIdRoomAllocationCriteriaEnum = typeof GetBlockByExtIdRoomAllocationCriteriaEnum[keyof typeof GetBlockByExtIdRoomAllocationCriteriaEnum];
/**
 * @export
 */
export const GetBlockReservationsFetchInstructionsEnum = {
    Reservation: 'Reservation',
    Comments: 'Comments',
    GuestComments: 'GuestComments',
    Packages: 'Packages',
    InventoryItems: 'InventoryItems',
    ReservationPaymentMethods: 'ReservationPaymentMethods',
    RoutingInstructions: 'RoutingInstructions',
    Preferences: 'Preferences',
    Memberships: 'Memberships',
    Alerts: 'Alerts',
    Traces: 'Traces',
    ConfirmationLetters: 'ConfirmationLetters',
    CallHistory: 'CallHistory',
    FixedCharges: 'FixedCharges',
    GuestMessages: 'GuestMessages',
    ReservationPolicies: 'ReservationPolicies',
    Indicators: 'Indicators',
    LinkedReservations: 'LinkedReservations',
    RevenuesAndBalances: 'RevenuesAndBalances',
    GuestLastStay: 'GuestLastStay',
    ECoupons: 'ECoupons',
    TrackItItems: 'TrackItItems',
    TotalCostOfStay: 'TotalCostOfStay',
    ReservationAwards: 'ReservationAwards',
    WebRegistrationCards: 'WebRegistrationCards',
    ServiceRequests: 'ServiceRequests',
    ReservationActivities: 'ReservationActivities',
    ScheduledActivities: 'ScheduledActivities',
    PrepaidCards: 'PrepaidCards',
    Shares: 'Shares',
    Attachments: 'Attachments',
    Locators: 'Locators',
    ProfileAwards: 'ProfileAwards',
    TransactionDiversions: 'TransactionDiversions',
    Tickets: 'Tickets',
    GuestMemberships: 'GuestMemberships',
    ECertificates: 'ECertificates',
    UpsellInfo: 'UpsellInfo',
    RoomAssignedByAi: 'RoomAssignedByAI',
    CustomNameValue: 'CustomNameValue',
    CustomChargeExemptions: 'CustomChargeExemptions'
} as const;
export type GetBlockReservationsFetchInstructionsEnum = typeof GetBlockReservationsFetchInstructionsEnum[keyof typeof GetBlockReservationsFetchInstructionsEnum];
/**
 * @export
 */
export const GetBlockStatisticsStatisticsInstructionsEnum = {
    Contract: 'Contract',
    Initial: 'Initial',
    Actual: 'Actual',
    Pickup: 'Pickup',
    Available: 'Available',
    Change: 'Change',
    Rates: 'Rates',
    Totalavailable: 'Totalavailable',
    Tentativereservations: 'Tentativereservations',
    Pickuppersons: 'Pickuppersons',
    Roomrevenue: 'Roomrevenue',
    Totalrevenue: 'Totalrevenue',
    Avgroomrate: 'Avgroomrate'
} as const;
export type GetBlockStatisticsStatisticsInstructionsEnum = typeof GetBlockStatisticsStatisticsInstructionsEnum[keyof typeof GetBlockStatisticsStatisticsInstructionsEnum];
/**
 * @export
 */
export const GetBlocksCategoryEnum = {
    Group: 'Group',
    Source: 'Source',
    Agent: 'Agent',
    Contact: 'Contact',
    Company: 'Company',
    Account: 'Account'
} as const;
export type GetBlocksCategoryEnum = typeof GetBlocksCategoryEnum[keyof typeof GetBlocksCategoryEnum];
/**
 * @export
 */
export const GetBlocksOrderTypeEnum = {
    Asc: 'Asc',
    Desc: 'Desc'
} as const;
export type GetBlocksOrderTypeEnum = typeof GetBlocksOrderTypeEnum[keyof typeof GetBlocksOrderTypeEnum];
/**
 * @export
 */
export const GetBlocksFetchInstructionsEnum = {
    AccessExclusions: 'AccessExclusions',
    Aliases: 'Aliases',
    AlternateDates: 'AlternateDates',
    Attachments: 'Attachments',
    Block: 'Block',
    BlockNextStatuses: 'BlockNextStatuses',
    BlockStatusHistory: 'BlockStatusHistory',
    CatNextStatuses: 'CatNextStatuses',
    CatStatusHistory: 'CatStatusHistory',
    Comments: 'Comments',
    DateProtect: 'DateProtect',
    ExternalReferences: 'ExternalReferences',
    GenericRateGrid: 'GenericRateGrid',
    Header: 'Header',
    Indicators: 'Indicators',
    InventoryItems: 'InventoryItems',
    Owners: 'Owners',
    Packages: 'Packages',
    Policies: 'Policies',
    PrimaryOwners: 'PrimaryOwners',
    PrimaryProfiles: 'PrimaryProfiles',
    PrimaryRates: 'PrimaryRates',
    Profiles: 'Profiles',
    RateGrid: 'RateGrid',
    RateProgram: 'RateProgram',
    Rates: 'Rates',
    Restrictions: 'Restrictions',
    SellMessages: 'SellMessages',
    Statistics: 'Statistics',
    SummaryStatistics: 'SummaryStatistics',
    Traces: 'Traces',
    WashSchedules: 'WashSchedules'
} as const;
export type GetBlocksFetchInstructionsEnum = typeof GetBlocksFetchInstructionsEnum[keyof typeof GetBlocksFetchInstructionsEnum];
/**
 * @export
 */
export const GetBlocksRoomAllocationCriteriaEnum = {
    Initial: 'Initial',
    Actual: 'Actual',
    Rates: 'Rates',
    Pickup: 'Pickup',
    Contract: 'Contract',
    Available: 'Available',
    Pickupperc: 'Pickupperc',
    Changes: 'Changes',
    Released: 'Released',
    Houseavailability: 'Houseavailability',
    SellLimit: 'SellLimit',
    AvailableSellLimit: 'AvailableSellLimit',
    MasterAllocInitial: 'MasterAllocInitial',
    Allocated: 'Allocated',
    SubAllocResv: 'SubAllocResv',
    CutoffDate: 'CutoffDate'
} as const;
export type GetBlocksRoomAllocationCriteriaEnum = typeof GetBlocksRoomAllocationCriteriaEnum[keyof typeof GetBlocksRoomAllocationCriteriaEnum];
/**
 * @export
 */
export const GetBlocksAccessRestrictionEnum = {
    Availability: 'Availability',
    Create: 'Create',
    Modify: 'Modify',
    Cancel: 'Cancel'
} as const;
export type GetBlocksAccessRestrictionEnum = typeof GetBlocksAccessRestrictionEnum[keyof typeof GetBlocksAccessRestrictionEnum];
