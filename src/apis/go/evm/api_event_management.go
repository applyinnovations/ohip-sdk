/*
OPERA Cloud Sales Event Management API

APIs to cater for Event Management functionality in OPERA Cloud. <br /><br />The Events feature in OPERA Cloud is designed to manage any kind of catering activity. Events can be as simple as a one-hour reception or more complex, such as a three-day business meeting with meals, breaks, and specific meeting functionSpaceDetails with setupCode and resource requirements. Any group function can be an Event.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// EventManagementApiService EventManagementApi service
type EventManagementApiService service

type ApiGetEventRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	eventId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetEventRequest) Authorization(authorization string) ApiGetEventRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetEventRequest) XAppKey(xAppKey string) ApiGetEventRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r ApiGetEventRequest) XHotelid(xHotelid string) ApiGetEventRequest {
	r.xHotelid = &xHotelid
	return r
}

// Instruction to fetch all eligible master events for the selected event
func (r ApiGetEventRequest) FetchInstructions(fetchInstructions []string) ApiGetEventRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ApiGetEventRequest) XExternalsystem(xExternalsystem string) ApiGetEventRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetEventRequest) AcceptLanguage(acceptLanguage string) ApiGetEventRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEventRequest) Execute() (*Event, *http.Response, error) {
	return r.ApiService.GetEventExecute(r)
}

/*
GetEvent Get an Event

This API will allow you to retrieve the details of one event by specifying the event ID in the path. Event details such as event type, event description, start date / time and end date time, attendees, function space, setup style, function space rate, and more  will be returned. You can also add fetch instructions to specify what additional event data, such as block information, revenue information, event notes, and master / sub event information you would like returned in the response. If you don&apos;t know the eventID, please use getEvents API to find the event and its respective eventID. <p><strong>OperationId:</strong>getEvent</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId Unique ID of the event
 @param hotelId Unique ID of a hotel
 @return ApiGetEventRequest
*/
func (a *EventManagementApiService) GetEvent(ctx context.Context, eventId string, hotelId string) ApiGetEventRequest {
	return ApiGetEventRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Event
func (a *EventManagementApiService) GetEventExecute(r ApiGetEventRequest) (*Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/events/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventsMultipleHotelsRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	eventStartDate *string
	eventEndDate *string
	blockId *[]string
	eventId *[]string
	category *[]string
	name *[]string
	attachedProfileId *[]string
	eventStatusCodes *[]string
	eventTypeCodes *[]string
	functionSpaceCodes *[]string
	includeInactive *bool
	includeAlternateEvents *bool
	includeSubEvents *bool
	cateringEventOrderBy *string
	fetchInstructions *[]string
	limit *int32
	offset *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetEventsMultipleHotelsRequest) Authorization(authorization string) ApiGetEventsMultipleHotelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetEventsMultipleHotelsRequest) XAppKey(xAppKey string) ApiGetEventsMultipleHotelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r ApiGetEventsMultipleHotelsRequest) XHotelid(xHotelid string) ApiGetEventsMultipleHotelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// This is the Hotel Code of the Event
func (r ApiGetEventsMultipleHotelsRequest) HotelIds(hotelIds []string) ApiGetEventsMultipleHotelsRequest {
	r.hotelIds = &hotelIds
	return r
}

// The starting value of the date range.
func (r ApiGetEventsMultipleHotelsRequest) EventStartDate(eventStartDate string) ApiGetEventsMultipleHotelsRequest {
	r.eventStartDate = &eventStartDate
	return r
}

// The ending value of the date range.
func (r ApiGetEventsMultipleHotelsRequest) EventEndDate(eventEndDate string) ApiGetEventsMultipleHotelsRequest {
	r.eventEndDate = &eventEndDate
	return r
}

// Block ID linked to the Catering Event
func (r ApiGetEventsMultipleHotelsRequest) BlockId(blockId []string) ApiGetEventsMultipleHotelsRequest {
	r.blockId = &blockId
	return r
}

// Unique ID for the catering event
func (r ApiGetEventsMultipleHotelsRequest) EventId(eventId []string) ApiGetEventsMultipleHotelsRequest {
	r.eventId = &eventId
	return r
}

// Simple type for block instructions to be used in requests for fetching blocks. Valid status values are Group, Source, TravelAgent, Contact, Company.
func (r ApiGetEventsMultipleHotelsRequest) Category(category []string) ApiGetEventsMultipleHotelsRequest {
	r.category = &category
	return r
}

// Attached profile name
func (r ApiGetEventsMultipleHotelsRequest) Name(name []string) ApiGetEventsMultipleHotelsRequest {
	r.name = &name
	return r
}

// A unique identifying numeric value assigned to a profile utilized to fetch events associated to blocks linked to the profile.
func (r ApiGetEventsMultipleHotelsRequest) AttachedProfileId(attachedProfileId []string) ApiGetEventsMultipleHotelsRequest {
	r.attachedProfileId = &attachedProfileId
	return r
}

// Status Codes associated with the events to be fetched.
func (r ApiGetEventsMultipleHotelsRequest) EventStatusCodes(eventStatusCodes []string) ApiGetEventsMultipleHotelsRequest {
	r.eventStatusCodes = &eventStatusCodes
	return r
}

// Event Type Codes associated with the events to be fetched.
func (r ApiGetEventsMultipleHotelsRequest) EventTypeCodes(eventTypeCodes []string) ApiGetEventsMultipleHotelsRequest {
	r.eventTypeCodes = &eventTypeCodes
	return r
}

func (r ApiGetEventsMultipleHotelsRequest) FunctionSpaceCodes(functionSpaceCodes []string) ApiGetEventsMultipleHotelsRequest {
	r.functionSpaceCodes = &functionSpaceCodes
	return r
}

// Indicates whether to include inactive events in search result.
func (r ApiGetEventsMultipleHotelsRequest) IncludeInactive(includeInactive bool) ApiGetEventsMultipleHotelsRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates whether to include the alternate events in the search result.
func (r ApiGetEventsMultipleHotelsRequest) IncludeAlternateEvents(includeAlternateEvents bool) ApiGetEventsMultipleHotelsRequest {
	r.includeAlternateEvents = &includeAlternateEvents
	return r
}

// Indicates whether to include the sub events in the search result.
func (r ApiGetEventsMultipleHotelsRequest) IncludeSubEvents(includeSubEvents bool) ApiGetEventsMultipleHotelsRequest {
	r.includeSubEvents = &includeSubEvents
	return r
}

// A collection of supported list of order by for search catering events.
func (r ApiGetEventsMultipleHotelsRequest) CateringEventOrderBy(cateringEventOrderBy string) ApiGetEventsMultipleHotelsRequest {
	r.cateringEventOrderBy = &cateringEventOrderBy
	return r
}

// Instructions to fetch details information about the selected event. The BlocksInfo fetch instructions will retain a limited amount of data for the associated block.  The Indicators instruction will provide a count.
func (r ApiGetEventsMultipleHotelsRequest) FetchInstructions(fetchInstructions []string) ApiGetEventsMultipleHotelsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetEventsMultipleHotelsRequest) Limit(limit int32) ApiGetEventsMultipleHotelsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetEventsMultipleHotelsRequest) Offset(offset int32) ApiGetEventsMultipleHotelsRequest {
	r.offset = &offset
	return r
}

// External system code.
func (r ApiGetEventsMultipleHotelsRequest) XExternalsystem(xExternalsystem string) ApiGetEventsMultipleHotelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetEventsMultipleHotelsRequest) AcceptLanguage(acceptLanguage string) ApiGetEventsMultipleHotelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEventsMultipleHotelsRequest) Execute() (*Events, *http.Response, error) {
	return r.ApiService.GetEventsMultipleHotelsExecute(r)
}

/*
GetEventsMultipleHotels Get Events 

This API fetches catering events for multiple hotels, based on search criteria such as dates, linked block, status, function space, and more. The data returned in the result contains, event type, description, dates and times, attendees, function space, setup style and more. <p><strong>OperationId:</strong>getEventsMultipleHotels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventsMultipleHotelsRequest
*/
func (a *EventManagementApiService) GetEventsMultipleHotels(ctx context.Context) ApiGetEventsMultipleHotelsRequest {
	return ApiGetEventsMultipleHotelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Events
func (a *EventManagementApiService) GetEventsMultipleHotelsExecute(r ApiGetEventsMultipleHotelsRequest) (*Events, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Events
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetEventsMultipleHotels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.eventStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventStartDate", r.eventStartDate, "")
	}
	if r.eventEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventEndDate", r.eventEndDate, "")
	}
	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
	}
	if r.eventId != nil {
		t := *r.eventId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", t, "multi")
		}
	}
	if r.category != nil {
		t := *r.category
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "category", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "category", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.attachedProfileId != nil {
		t := *r.attachedProfileId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", t, "multi")
		}
	}
	if r.eventStatusCodes != nil {
		t := *r.eventStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventStatusCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventStatusCodes", t, "multi")
		}
	}
	if r.eventTypeCodes != nil {
		t := *r.eventTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", t, "multi")
		}
	}
	if r.functionSpaceCodes != nil {
		t := *r.functionSpaceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.includeAlternateEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAlternateEvents", r.includeAlternateEvents, "")
	}
	if r.includeSubEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSubEvents", r.includeSubEvents, "")
	}
	if r.cateringEventOrderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringEventOrderBy", r.cateringEventOrderBy, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventsOneHotelRequest struct {
	ctx context.Context
	ApiService *EventManagementApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eventStartDate *string
	eventEndDate *string
	blockId *[]string
	eventId *[]string
	attachedProfileId *string
	eventStatusCodes *[]string
	eventTypeCodes *[]string
	functionSpaceCodes *[]string
	includeInactive *bool
	includeAlternateEvents *bool
	includeSubEvents *bool
	cateringEventOrderBy *string
	fetchInstructions *[]string
	limit *int32
	offset *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetEventsOneHotelRequest) Authorization(authorization string) ApiGetEventsOneHotelRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetEventsOneHotelRequest) XAppKey(xAppKey string) ApiGetEventsOneHotelRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the eventEndDate user is logged in
func (r ApiGetEventsOneHotelRequest) XHotelid(xHotelid string) ApiGetEventsOneHotelRequest {
	r.xHotelid = &xHotelid
	return r
}

// The starting value of the date range.
func (r ApiGetEventsOneHotelRequest) EventStartDate(eventStartDate string) ApiGetEventsOneHotelRequest {
	r.eventStartDate = &eventStartDate
	return r
}

// The ending value of the date range.
func (r ApiGetEventsOneHotelRequest) EventEndDate(eventEndDate string) ApiGetEventsOneHotelRequest {
	r.eventEndDate = &eventEndDate
	return r
}

// Block ID linked to the Catering Event
func (r ApiGetEventsOneHotelRequest) BlockId(blockId []string) ApiGetEventsOneHotelRequest {
	r.blockId = &blockId
	return r
}

// Unique ID for the catering event
func (r ApiGetEventsOneHotelRequest) EventId(eventId []string) ApiGetEventsOneHotelRequest {
	r.eventId = &eventId
	return r
}

// A unique identifying numeric value assigned to a profile utilized to fetch events associated to blocks linked to the profile.
func (r ApiGetEventsOneHotelRequest) AttachedProfileId(attachedProfileId string) ApiGetEventsOneHotelRequest {
	r.attachedProfileId = &attachedProfileId
	return r
}

// Status Codes associated with the events to be fetched.
func (r ApiGetEventsOneHotelRequest) EventStatusCodes(eventStatusCodes []string) ApiGetEventsOneHotelRequest {
	r.eventStatusCodes = &eventStatusCodes
	return r
}

// Event Type Codes associated with the events to be fetched.
func (r ApiGetEventsOneHotelRequest) EventTypeCodes(eventTypeCodes []string) ApiGetEventsOneHotelRequest {
	r.eventTypeCodes = &eventTypeCodes
	return r
}

func (r ApiGetEventsOneHotelRequest) FunctionSpaceCodes(functionSpaceCodes []string) ApiGetEventsOneHotelRequest {
	r.functionSpaceCodes = &functionSpaceCodes
	return r
}

// Indicates whether to include inactive events in search result.
func (r ApiGetEventsOneHotelRequest) IncludeInactive(includeInactive bool) ApiGetEventsOneHotelRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates whether to include the alternate events in the search result.
func (r ApiGetEventsOneHotelRequest) IncludeAlternateEvents(includeAlternateEvents bool) ApiGetEventsOneHotelRequest {
	r.includeAlternateEvents = &includeAlternateEvents
	return r
}

// Indicates whether to include the sub events in the search result.
func (r ApiGetEventsOneHotelRequest) IncludeSubEvents(includeSubEvents bool) ApiGetEventsOneHotelRequest {
	r.includeSubEvents = &includeSubEvents
	return r
}

// A collection of supported list of order by for search catering events.
func (r ApiGetEventsOneHotelRequest) CateringEventOrderBy(cateringEventOrderBy string) ApiGetEventsOneHotelRequest {
	r.cateringEventOrderBy = &cateringEventOrderBy
	return r
}

// Instruction to fetch all eligible master events for the selected event
func (r ApiGetEventsOneHotelRequest) FetchInstructions(fetchInstructions []string) ApiGetEventsOneHotelRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetEventsOneHotelRequest) Limit(limit int32) ApiGetEventsOneHotelRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetEventsOneHotelRequest) Offset(offset int32) ApiGetEventsOneHotelRequest {
	r.offset = &offset
	return r
}

// External system code.
func (r ApiGetEventsOneHotelRequest) XExternalsystem(xExternalsystem string) ApiGetEventsOneHotelRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetEventsOneHotelRequest) AcceptLanguage(acceptLanguage string) ApiGetEventsOneHotelRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEventsOneHotelRequest) Execute() (*Events, *http.Response, error) {
	return r.ApiService.GetEventsOneHotelExecute(r)
}

/*
GetEventsOneHotel Get Events 

This API fetches catering events for a specific hotel, based on search criteria such as dates, linked block, status, function space, and more. The data returned in the result contains, event type, description, dates and times, attendees, function space, setup style and more. <p><strong>OperationId:</strong>getEventsOneHotel</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of a hotel
 @return ApiGetEventsOneHotelRequest
*/
func (a *EventManagementApiService) GetEventsOneHotel(ctx context.Context, hotelId string) ApiGetEventsOneHotelRequest {
	return ApiGetEventsOneHotelRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Events
func (a *EventManagementApiService) GetEventsOneHotelExecute(r ApiGetEventsOneHotelRequest) (*Events, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Events
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventManagementApiService.GetEventsOneHotel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.eventStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventStartDate", r.eventStartDate, "")
	}
	if r.eventEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventEndDate", r.eventEndDate, "")
	}
	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
	}
	if r.eventId != nil {
		t := *r.eventId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", t, "multi")
		}
	}
	if r.attachedProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", r.attachedProfileId, "")
	}
	if r.eventStatusCodes != nil {
		t := *r.eventStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventStatusCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventStatusCodes", t, "multi")
		}
	}
	if r.eventTypeCodes != nil {
		t := *r.eventTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", t, "multi")
		}
	}
	if r.functionSpaceCodes != nil {
		t := *r.functionSpaceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.includeAlternateEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAlternateEvents", r.includeAlternateEvents, "")
	}
	if r.includeSubEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSubEvents", r.includeSubEvents, "")
	}
	if r.cateringEventOrderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringEventOrderBy", r.cateringEventOrderBy, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
