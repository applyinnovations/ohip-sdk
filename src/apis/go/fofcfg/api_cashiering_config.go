/*
OPERA Cloud Front Desk Configuration API

APIs to cater for Front Desk Configuration in OPERA Cloud. Here you can find operations to get, post, put and delete front desk codes such as commission codes, transaction groups, codes & subgroups, articles, payment methods and credit card types.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fofcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// CashieringConfigApiService CashieringConfigApi service
type CashieringConfigApiService service

type CashieringConfigApiChangeCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	compTypesToBeChanged *ChangeCompTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiChangeCompTypesRequest) Authorization(authorization string) CashieringConfigApiChangeCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiChangeCompTypesRequest) XAppKey(xAppKey string) CashieringConfigApiChangeCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiChangeCompTypesRequest) XHotelid(xHotelid string) CashieringConfigApiChangeCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Comp Types.
func (r CashieringConfigApiChangeCompTypesRequest) CompTypesToBeChanged(compTypesToBeChanged ChangeCompTypesRequest) CashieringConfigApiChangeCompTypesRequest {
	r.compTypesToBeChanged = &compTypesToBeChanged
	return r
}

// External system code.
func (r CashieringConfigApiChangeCompTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiChangeCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiChangeCompTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiChangeCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiChangeCompTypesRequest) Execute() (*CompTypesStatus, *http.Response, error) {
	return r.ApiService.ChangeCompTypesExecute(r)
}

/*
ChangeCompTypes Operation to Change Comp Types.

Operation to Change Comp Types. <p><strong>OperationId:</strong>changeCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiChangeCompTypesRequest
*/
func (a *CashieringConfigApiService) ChangeCompTypes(ctx context.Context) CashieringConfigApiChangeCompTypesRequest {
	return CashieringConfigApiChangeCompTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CompTypesStatus
func (a *CashieringConfigApiService) ChangeCompTypesExecute(r CashieringConfigApiChangeCompTypesRequest) (*CompTypesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompTypesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.ChangeCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioTypeLegendMappingConfigToBeChanged *ChangeFolioTypeLegendMappingConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) Authorization(authorization string) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) XAppKey(xAppKey string) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) XHotelid(xHotelid string) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to edit folio type legend mapping information.
func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) FolioTypeLegendMappingConfigToBeChanged(folioTypeLegendMappingConfigToBeChanged ChangeFolioTypeLegendMappingConfigRequest) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	r.folioTypeLegendMappingConfigToBeChanged = &folioTypeLegendMappingConfigToBeChanged
	return r
}

// External system code.
func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) Execute() (*FolioTypeLegendMappingConfigStatus, *http.Response, error) {
	return r.ApiService.ChangeFolioTypeLegendMappingConfigExecute(r)
}

/*
ChangeFolioTypeLegendMappingConfig Operation to change folio type legend mappings config.

Operation to change folio type legend mappings config. <p><strong>OperationId:</strong>changeFolioTypeLegendMappingConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest
*/
func (a *CashieringConfigApiService) ChangeFolioTypeLegendMappingConfig(ctx context.Context) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	return CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolioTypeLegendMappingConfigStatus
func (a *CashieringConfigApiService) ChangeFolioTypeLegendMappingConfigExecute(r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) (*FolioTypeLegendMappingConfigStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypeLegendMappingConfigStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.ChangeFolioTypeLegendMappingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypeLegendMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioTypeLegendMappingConfigToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCode *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) AdjustmentCode(adjustmentCode string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.adjustmentCode = &adjustmentCode
	return r
}

// Hotel where the code is configured.
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) HotelId(hotelId string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAdjustmentCodesExecute(r)
}

/*
DeleteAdjustmentCodes Operation to delete AdjustmentCodes.

Operation to remove Adjustment Codes. <p><strong>OperationId:</strong>deleteAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteAdjustmentCodesRequest
*/
func (a *CashieringConfigApiService) DeleteAdjustmentCodes(ctx context.Context) CashieringConfigApiDeleteAdjustmentCodesRequest {
	return CashieringConfigApiDeleteAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteAdjustmentCodesExecute(r CashieringConfigApiDeleteAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adjustmentCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustmentCode", r.adjustmentCode, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *string
	articleCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	articleHotelId *[]string
	inactive *[]bool
	orderSequence *[]float32
	description *[]string
	transactionCode *[]string
	amount *float32
	currencyCode *string
	availableForPostIt *bool
	color *string
	universalProductCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r CashieringConfigApiDeleteArticlesRequest) HotelId(hotelId string) CashieringConfigApiDeleteArticlesRequest {
	r.hotelId = &hotelId
	return r
}

// Unique code of the article.
func (r CashieringConfigApiDeleteArticlesRequest) ArticleCodes(articleCodes []string) CashieringConfigApiDeleteArticlesRequest {
	r.articleCodes = &articleCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteArticlesRequest) Authorization(authorization string) CashieringConfigApiDeleteArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiDeleteArticlesRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteArticlesRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code to which the article belongs.
func (r CashieringConfigApiDeleteArticlesRequest) ArticleHotelId(articleHotelId []string) CashieringConfigApiDeleteArticlesRequest {
	r.articleHotelId = &articleHotelId
	return r
}

// Indicates whether the article is inactive or not.
func (r CashieringConfigApiDeleteArticlesRequest) Inactive(inactive []bool) CashieringConfigApiDeleteArticlesRequest {
	r.inactive = &inactive
	return r
}

// Display Order sequence.
func (r CashieringConfigApiDeleteArticlesRequest) OrderSequence(orderSequence []float32) CashieringConfigApiDeleteArticlesRequest {
	r.orderSequence = &orderSequence
	return r
}

// Description of the article.
func (r CashieringConfigApiDeleteArticlesRequest) Description(description []string) CashieringConfigApiDeleteArticlesRequest {
	r.description = &description
	return r
}

// Transaction code to which the article belongs.
func (r CashieringConfigApiDeleteArticlesRequest) TransactionCode(transactionCode []string) CashieringConfigApiDeleteArticlesRequest {
	r.transactionCode = &transactionCode
	return r
}

// A monetary amount.
func (r CashieringConfigApiDeleteArticlesRequest) Amount(amount float32) CashieringConfigApiDeleteArticlesRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringConfigApiDeleteArticlesRequest) CurrencyCode(currencyCode string) CashieringConfigApiDeleteArticlesRequest {
	r.currencyCode = &currencyCode
	return r
}

// Indicates whether the article is available for post it.
func (r CashieringConfigApiDeleteArticlesRequest) AvailableForPostIt(availableForPostIt bool) CashieringConfigApiDeleteArticlesRequest {
	r.availableForPostIt = &availableForPostIt
	return r
}

// Color configuration type. This color configuration provides a visual category of entities.
func (r CashieringConfigApiDeleteArticlesRequest) Color(color string) CashieringConfigApiDeleteArticlesRequest {
	r.color = &color
	return r
}

// Unique Universal product code of the article.
func (r CashieringConfigApiDeleteArticlesRequest) UniversalProductCode(universalProductCode []string) CashieringConfigApiDeleteArticlesRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// External system code.
func (r CashieringConfigApiDeleteArticlesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteArticlesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteArticlesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteArticlesExecute(r)
}

/*
DeleteArticles Operation to delete Articles.

Operation to remove articles. <p><strong>OperationId:</strong>deleteArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteArticlesRequest
*/
func (a *CashieringConfigApiService) DeleteArticles(ctx context.Context) CashieringConfigApiDeleteArticlesRequest {
	return CashieringConfigApiDeleteArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteArticlesExecute(r CashieringConfigApiDeleteArticlesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	{
		t := *r.articleCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", t, "multi")
		}
	}
	if r.articleHotelId != nil {
		t := *r.articleHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelId", t, "multi")
		}
	}
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
	}
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.availableForPostIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableForPostIt", r.availableForPostIt, "")
	}
	if r.color != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "color", r.color, "")
	}
	if r.universalProductCode != nil {
		t := *r.universalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteAuthorizationConfigRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomType *[]string
	roomClassHotelId *string
	roomClassCode *string
	sourceCodeHotelId *string
	sourceCode *string
	rateCategory *string
	rateCode *[]string
	guaranteeCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with authorization rule
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) HotelId(hotelId []string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) Authorization(authorization string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Authorization rule Room type.
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) RoomType(roomType []string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.roomType = &roomType
	return r
}

func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) RoomClassHotelId(roomClassHotelId string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.roomClassHotelId = &roomClassHotelId
	return r
}

func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) RoomClassCode(roomClassCode string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.roomClassCode = &roomClassCode
	return r
}

func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) SourceCodeHotelId(sourceCodeHotelId string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.sourceCodeHotelId = &sourceCodeHotelId
	return r
}

func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) SourceCode(sourceCode string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.sourceCode = &sourceCode
	return r
}

// Rate category Code.
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) RateCategory(rateCategory string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.rateCategory = &rateCategory
	return r
}

// Rate code associated to this rule.
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) RateCode(rateCode []string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.rateCode = &rateCode
	return r
}

// Guarantee code associated to this rule.
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) GuaranteeCode(guaranteeCode []string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// External system code.
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAuthorizationConfigRuleExecute(r)
}

/*
DeleteAuthorizationConfigRule Operation to delete AuthorizationConfigRule.

 <p><strong>OperationId:</strong>deleteAuthorizationConfigRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteAuthorizationConfigRuleRequest
*/
func (a *CashieringConfigApiService) DeleteAuthorizationConfigRule(ctx context.Context) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	return CashieringConfigApiDeleteAuthorizationConfigRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteAuthorizationConfigRuleExecute(r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteAuthorizationConfigRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClassHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassHotelId", r.roomClassHotelId, "")
	}
	if r.roomClassCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCode", r.roomClassCode, "")
	}
	if r.sourceCodeHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodeHotelId", r.sourceCodeHotelId, "")
	}
	if r.sourceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCode", r.sourceCode, "")
	}
	if r.rateCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", r.rateCategory, "")
	}
	if r.rateCode != nil {
		t := *r.rateCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", t, "multi")
		}
	}
	if r.guaranteeCode != nil {
		t := *r.guaranteeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroup *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) Authorization(authorization string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) AuthorizerGroup(authorizerGroup string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.authorizerGroup = &authorizerGroup
	return r
}

// Hotel where the code is configured.
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) HotelId(hotelId string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAuthorizerGroupsExecute(r)
}

/*
DeleteAuthorizerGroups Operation to delete AuthorizerGroups.

Operation to remove Authorizer Groups. <p><strong>OperationId:</strong>deleteAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteAuthorizerGroupsRequest
*/
func (a *CashieringConfigApiService) DeleteAuthorizerGroups(ctx context.Context) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	return CashieringConfigApiDeleteAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteAuthorizerGroupsExecute(r CashieringConfigApiDeleteAuthorizerGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.authorizerGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerGroup", r.authorizerGroup, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyExchangeServiceTaxCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with currency exchange service tax
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) HotelId(hotelId []string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Currency exchange service tax code
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) CurrencyExchangeServiceTaxCode(currencyExchangeServiceTaxCode []string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.currencyExchangeServiceTaxCode = &currencyExchangeServiceTaxCode
	return r
}

// External system code.
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCurrencyExchangeServiceTaxesExecute(r)
}

/*
DeleteCurrencyExchangeServiceTaxes Operation to delete CurrencyExchangeServiceTaxes.

Operation to remove currency exchange service taxes. <p><strong>OperationId:</strong>deleteCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigApiService) DeleteCurrencyExchangeServiceTaxes(ctx context.Context) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	return CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteCurrencyExchangeServiceTaxesExecute(r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.currencyExchangeServiceTaxCode != nil {
		t := *r.currencyExchangeServiceTaxCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyExchangeServiceTaxCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyExchangeServiceTaxCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) HotelId(hotelId []string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) Code(code []string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.code = &code
	return r
}

// External system code.
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteExpenseArrangementCodesExecute(r)
}

/*
DeleteExpenseArrangementCodes Operation to delete ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>deleteExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteExpenseArrangementCodesRequest
*/
func (a *CashieringConfigApiService) DeleteExpenseArrangementCodes(ctx context.Context) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	return CashieringConfigApiDeleteExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteExpenseArrangementCodesExecute(r CashieringConfigApiDeleteExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	partner *[]string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) Authorization(authorization string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Code of the Hotel.
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) HotelId(hotelId []string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.hotelId = &hotelId
	return r
}

// Fiscal folio parameter associated with Partner.
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) Partner(partner []string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.partner = &partner
	return r
}

// Code of the Fiscal Folio Parameter.
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) Code(code []string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.code = &code
	return r
}

// External system code.
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteFiscalFolioParametersExecute(r)
}

/*
DeleteFiscalFolioParameters Operation to delete FiscalFolioParameters.

Operation to remove Fiscal Folio Parameters. <p><strong>OperationId:</strong>deleteFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteFiscalFolioParametersRequest
*/
func (a *CashieringConfigApiService) DeleteFiscalFolioParameters(ctx context.Context) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	return CashieringConfigApiDeleteFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteFiscalFolioParametersExecute(r CashieringConfigApiDeleteFiscalFolioParametersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalFolioParameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.partner != nil {
		t := *r.partner
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partner", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partner", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetAdjustmentCodesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetAdjustmentCodesRequest) AdjustmentCodes(adjustmentCodes []string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.adjustmentCodes = &adjustmentCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetAdjustmentCodesRequest) WildCard(wildCard string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetAdjustmentCodesRequest) Execute() (*AdjustmentCodes, *http.Response, error) {
	return r.ApiService.GetAdjustmentCodesExecute(r)
}

/*
GetAdjustmentCodes Operation to fetch AdjustmentCodes.

Operation to fetch Adjustment Codes. <p><strong>OperationId:</strong>getAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetAdjustmentCodesRequest
*/
func (a *CashieringConfigApiService) GetAdjustmentCodes(ctx context.Context) CashieringConfigApiGetAdjustmentCodesRequest {
	return CashieringConfigApiGetAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdjustmentCodes
func (a *CashieringConfigApiService) GetAdjustmentCodesExecute(r CashieringConfigApiGetAdjustmentCodesRequest) (*AdjustmentCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdjustmentCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.adjustmentCodes != nil {
		t := *r.adjustmentCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "adjustmentCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "adjustmentCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionCodes *[]string
	articleCodes *[]string
	universalProductCode *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetArticlesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetArticlesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetArticlesRequest) Authorization(authorization string) CashieringConfigApiGetArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetArticlesRequest) XAppKey(xAppKey string) CashieringConfigApiGetArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetArticlesRequest) XHotelid(xHotelid string) CashieringConfigApiGetArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigApiGetArticlesRequest) TransactionCodes(transactionCodes []string) CashieringConfigApiGetArticlesRequest {
	r.transactionCodes = &transactionCodes
	return r
}

func (r CashieringConfigApiGetArticlesRequest) ArticleCodes(articleCodes []string) CashieringConfigApiGetArticlesRequest {
	r.articleCodes = &articleCodes
	return r
}

// Unique Universal product code search criteria.
func (r CashieringConfigApiGetArticlesRequest) UniversalProductCode(universalProductCode string) CashieringConfigApiGetArticlesRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// Indicator that tells whether to include inactive articles in search results.
func (r CashieringConfigApiGetArticlesRequest) IncludeInactive(includeInactive bool) CashieringConfigApiGetArticlesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r CashieringConfigApiGetArticlesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetArticlesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetArticlesRequest) Execute() (*ArticlesInfo, *http.Response, error) {
	return r.ApiService.GetArticlesExecute(r)
}

/*
GetArticles Get articles

Use this API to return articles for one or multiple properties based on search criteria such as hotelIds, transactionCodes, articleCodes, etc. One transaction code can sometimes serve as an umbrella for multiple articles, which can be posted using that transaction code.  For example, a single mini bar food transaction code might cover potato chips, crackers, peanuts, pretzels, and so on.<p><strong>OperationId:</strong>getArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetArticlesRequest
*/
func (a *CashieringConfigApiService) GetArticles(ctx context.Context) CashieringConfigApiGetArticlesRequest {
	return CashieringConfigApiGetArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArticlesInfo
func (a *CashieringConfigApiService) GetArticlesExecute(r CashieringConfigApiGetArticlesRequest) (*ArticlesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArticlesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
	}
	if r.articleCodes != nil {
		t := *r.articleCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", t, "multi")
		}
	}
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroupsCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetAuthorizerGroupsRequest) HotelIds(hotelIds []string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetAuthorizerGroupsRequest) Authorization(authorization string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetAuthorizerGroupsRequest) XAppKey(xAppKey string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetAuthorizerGroupsRequest) XHotelid(xHotelid string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetAuthorizerGroupsRequest) AuthorizerGroupsCodes(authorizerGroupsCodes []string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.authorizerGroupsCodes = &authorizerGroupsCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetAuthorizerGroupsRequest) WildCard(wildCard string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetAuthorizerGroupsRequest) Execute() (*AuthorizerGroups, *http.Response, error) {
	return r.ApiService.GetAuthorizerGroupsExecute(r)
}

/*
GetAuthorizerGroups Operation to fetch AuthorizerGroups.

Operation to fetch Authorizer Groups. <p><strong>OperationId:</strong>getAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetAuthorizerGroupsRequest
*/
func (a *CashieringConfigApiService) GetAuthorizerGroups(ctx context.Context) CashieringConfigApiGetAuthorizerGroupsRequest {
	return CashieringConfigApiGetAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthorizerGroups
func (a *CashieringConfigApiService) GetAuthorizerGroupsExecute(r CashieringConfigApiGetAuthorizerGroupsRequest) (*AuthorizerGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizerGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.authorizerGroupsCodes != nil {
		t := *r.authorizerGroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerGroupsCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerGroupsCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetAvailableCashierNumberRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetAvailableCashierNumberRequest) Authorization(authorization string) CashieringConfigApiGetAvailableCashierNumberRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetAvailableCashierNumberRequest) XAppKey(xAppKey string) CashieringConfigApiGetAvailableCashierNumberRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetAvailableCashierNumberRequest) XHotelid(xHotelid string) CashieringConfigApiGetAvailableCashierNumberRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigApiGetAvailableCashierNumberRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetAvailableCashierNumberRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetAvailableCashierNumberRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetAvailableCashierNumberRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetAvailableCashierNumberRequest) Execute() (*CashierNumber, *http.Response, error) {
	return r.ApiService.GetAvailableCashierNumberExecute(r)
}

/*
GetAvailableCashierNumber Operation to fetch AvailableCashierNumber.

The operation returns a next available Cashier Number to be used while creating a new Cashier. <p><strong>OperationId:</strong>getAvailableCashierNumber</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetAvailableCashierNumberRequest
*/
func (a *CashieringConfigApiService) GetAvailableCashierNumber(ctx context.Context) CashieringConfigApiGetAvailableCashierNumberRequest {
	return CashieringConfigApiGetAvailableCashierNumberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CashierNumber
func (a *CashieringConfigApiService) GetAvailableCashierNumberExecute(r CashieringConfigApiGetAvailableCashierNumberRequest) (*CashierNumber, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierNumber
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetAvailableCashierNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers/nextAvailable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetCashiersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	cashierIDs *[]float32
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	name *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Numberic code for cashier ID.
func (r CashieringConfigApiGetCashiersRequest) CashierIDs(cashierIDs []float32) CashieringConfigApiGetCashiersRequest {
	r.cashierIDs = &cashierIDs
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetCashiersRequest) Authorization(authorization string) CashieringConfigApiGetCashiersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetCashiersRequest) XAppKey(xAppKey string) CashieringConfigApiGetCashiersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetCashiersRequest) XHotelid(xHotelid string) CashieringConfigApiGetCashiersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r CashieringConfigApiGetCashiersRequest) Limit(limit int32) CashieringConfigApiGetCashiersRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r CashieringConfigApiGetCashiersRequest) Offset(offset int32) CashieringConfigApiGetCashiersRequest {
	r.offset = &offset
	return r
}

// Partial name of a cashier.
func (r CashieringConfigApiGetCashiersRequest) Name(name string) CashieringConfigApiGetCashiersRequest {
	r.name = &name
	return r
}

// Indicator that tells whether to include inactive cashiers in search results.
func (r CashieringConfigApiGetCashiersRequest) IncludeInactive(includeInactive bool) CashieringConfigApiGetCashiersRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r CashieringConfigApiGetCashiersRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetCashiersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetCashiersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetCashiersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetCashiersRequest) Execute() (*CashiersDetails, *http.Response, error) {
	return r.ApiService.GetCashiersExecute(r)
}

/*
GetCashiers Get cashiers

Use this API to return Cashier information based on search criteria such as cashierIDs, limit, name. <p><strong>OperationId:</strong>getCashiers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetCashiersRequest
*/
func (a *CashieringConfigApiService) GetCashiers(ctx context.Context) CashieringConfigApiGetCashiersRequest {
	return CashieringConfigApiGetCashiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CashiersDetails
func (a *CashieringConfigApiService) GetCashiersExecute(r CashieringConfigApiGetCashiersRequest) (*CashiersDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashiersDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetCashiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashierDetails/cashiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.cashierIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cashierIDs", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cashierIDs", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	compTypeCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetCompTypesRequest) Authorization(authorization string) CashieringConfigApiGetCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetCompTypesRequest) XAppKey(xAppKey string) CashieringConfigApiGetCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetCompTypesRequest) XHotelid(xHotelid string) CashieringConfigApiGetCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Code is used to identify the CompType.
func (r CashieringConfigApiGetCompTypesRequest) CompTypeCode(compTypeCode string) CashieringConfigApiGetCompTypesRequest {
	r.compTypeCode = &compTypeCode
	return r
}

// External system code.
func (r CashieringConfigApiGetCompTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetCompTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetCompTypesRequest) Execute() (*CompTypesDetails, *http.Response, error) {
	return r.ApiService.GetCompTypesExecute(r)
}

/*
GetCompTypes Operation to Fetch Comp Types.

Operation to Fetch Comp TYpes. <p><strong>OperationId:</strong>getCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the source hotel in OPERA
 @return CashieringConfigApiGetCompTypesRequest
*/
func (a *CashieringConfigApiService) GetCompTypes(ctx context.Context, hotelId string) CashieringConfigApiGetCompTypesRequest {
	return CashieringConfigApiGetCompTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompTypesDetails
func (a *CashieringConfigApiService) GetCompTypesExecute(r CashieringConfigApiGetCompTypesRequest) (*CompTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.compTypeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compTypeCode", r.compTypeCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	codes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) Codes(codes []string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.codes = &codes
	return r
}

// External system code.
func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) Execute() (*CurrencyExchangeServiceTaxes, *http.Response, error) {
	return r.ApiService.GetCurrencyExchangeServiceTaxesExecute(r)
}

/*
GetCurrencyExchangeServiceTaxes Operation to fetch CurrencyExchangeServiceTaxes.

Operation to fetch currency exchange service taxes. <p><strong>OperationId:</strong>getCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigApiService) GetCurrencyExchangeServiceTaxes(ctx context.Context) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	return CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CurrencyExchangeServiceTaxes
func (a *CashieringConfigApiService) GetCurrencyExchangeServiceTaxesExecute(r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) (*CurrencyExchangeServiceTaxes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CurrencyExchangeServiceTaxes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetDailyPlanCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTransactionCodes *bool
	arrangementCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetDailyPlanCodesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetDailyPlanCodesRequest) Authorization(authorization string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetDailyPlanCodesRequest) XAppKey(xAppKey string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetDailyPlanCodesRequest) XHotelid(xHotelid string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A flag that determines whether or not to fetch associated transaction codes. Fetches only the arrangement codes when this flag is true.
func (r CashieringConfigApiGetDailyPlanCodesRequest) IncludeTransactionCodes(includeTransactionCodes bool) CashieringConfigApiGetDailyPlanCodesRequest {
	r.includeTransactionCodes = &includeTransactionCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetDailyPlanCodesRequest) ArrangementCodes(arrangementCodes []string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.arrangementCodes = &arrangementCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetDailyPlanCodesRequest) WildCard(wildCard string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetDailyPlanCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetDailyPlanCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetDailyPlanCodesRequest) Execute() (*DailyPlanCodes, *http.Response, error) {
	return r.ApiService.GetDailyPlanCodesExecute(r)
}

/*
GetDailyPlanCodes Operation to fetch DailyPlanCodes.

 <p><strong>OperationId:</strong>getDailyPlanCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetDailyPlanCodesRequest
*/
func (a *CashieringConfigApiService) GetDailyPlanCodes(ctx context.Context) CashieringConfigApiGetDailyPlanCodesRequest {
	return CashieringConfigApiGetDailyPlanCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DailyPlanCodes
func (a *CashieringConfigApiService) GetDailyPlanCodesExecute(r CashieringConfigApiGetDailyPlanCodesRequest) (*DailyPlanCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailyPlanCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetDailyPlanCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dailyPlanCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionCodes", r.includeTransactionCodes, "")
	}
	if r.arrangementCodes != nil {
		t := *r.arrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTransactionCodes *bool
	arrangementCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetExpenseArrangementCodesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A flag that determines whether or not to fetch associated transaction codes. Fetches only the arrangement codes when this flag is true.
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) IncludeTransactionCodes(includeTransactionCodes bool) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.includeTransactionCodes = &includeTransactionCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) ArrangementCodes(arrangementCodes []string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.arrangementCodes = &arrangementCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) WildCard(wildCard string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetExpenseArrangementCodesRequest) Execute() (*ExpenseArrangementCodes, *http.Response, error) {
	return r.ApiService.GetExpenseArrangementCodesExecute(r)
}

/*
GetExpenseArrangementCodes Operation to fetch ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>getExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetExpenseArrangementCodesRequest
*/
func (a *CashieringConfigApiService) GetExpenseArrangementCodes(ctx context.Context) CashieringConfigApiGetExpenseArrangementCodesRequest {
	return CashieringConfigApiGetExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExpenseArrangementCodes
func (a *CashieringConfigApiService) GetExpenseArrangementCodesExecute(r CashieringConfigApiGetExpenseArrangementCodesRequest) (*ExpenseArrangementCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExpenseArrangementCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionCodes", r.includeTransactionCodes, "")
	}
	if r.arrangementCodes != nil {
		t := *r.arrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	codes *[]string
	wildCard *string
	internal *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetFiscalFolioParametersRequest) HotelIds(hotelIds []string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetFiscalFolioParametersRequest) Authorization(authorization string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetFiscalFolioParametersRequest) XAppKey(xAppKey string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetFiscalFolioParametersRequest) XHotelid(xHotelid string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigApiGetFiscalFolioParametersRequest) Code(code []string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.code = &code
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetFiscalFolioParametersRequest) Codes(codes []string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetFiscalFolioParametersRequest) WildCard(wildCard string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.wildCard = &wildCard
	return r
}

// Indicates whether the Fiscal Folio Parameter is user created or from seed data. Set this true to see the standard Fiscal Folio Parameters that are seeded along with the manually created Fiscal Folio Parameters.
func (r CashieringConfigApiGetFiscalFolioParametersRequest) Internal(internal bool) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.internal = &internal
	return r
}

// External system code.
func (r CashieringConfigApiGetFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetFiscalFolioParametersRequest) Execute() (*FiscalFolioParameters, *http.Response, error) {
	return r.ApiService.GetFiscalFolioParametersExecute(r)
}

/*
GetFiscalFolioParameters Operation to fetch FiscalFolioParameters.

Operation to fetch Fiscal Folio Parameters. <p><strong>OperationId:</strong>getFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetFiscalFolioParametersRequest
*/
func (a *CashieringConfigApiService) GetFiscalFolioParameters(ctx context.Context) CashieringConfigApiGetFiscalFolioParametersRequest {
	return CashieringConfigApiGetFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FiscalFolioParameters
func (a *CashieringConfigApiService) GetFiscalFolioParametersExecute(r CashieringConfigApiGetFiscalFolioParametersRequest) (*FiscalFolioParameters, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalFolioParameters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalFolioParameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.internal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internal", r.internal, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *string
	legendCode *string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with folio type legend mapping
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) HotelId(hotelId string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.hotelId = &hotelId
	return r
}

// Legend code to which folio types attached.
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) LegendCode(legendCode string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.legendCode = &legendCode
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) Authorization(authorization string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) XAppKey(xAppKey string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) XHotelid(xHotelid string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Folio type to be searched.
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) FolioType(folioType string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.folioType = &folioType
	return r
}

// External system code.
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) Execute() (*FolioTypeLegendMappingsConfigDetails, *http.Response, error) {
	return r.ApiService.GetFolioTypeLegendMappingsConfigExecute(r)
}

/*
GetFolioTypeLegendMappingsConfig Operation to fetch folio type legend mappings config.

Operation to fetch folio type legend mappings config. <p><strong>OperationId:</strong>getFolioTypeLegendMappingsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest
*/
func (a *CashieringConfigApiService) GetFolioTypeLegendMappingsConfig(ctx context.Context) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	return CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolioTypeLegendMappingsConfigDetails
func (a *CashieringConfigApiService) GetFolioTypeLegendMappingsConfigExecute(r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) (*FolioTypeLegendMappingsConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypeLegendMappingsConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetFolioTypeLegendMappingsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypeLegendMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "legendCode", r.legendCode, "")
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetFuturePastExchangeRatesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	currencyCode string
	hotelId string
	exchangeTypes *string
	authorization *string
	xAppKey *string
	xHotelid *string
	dateRangeStart *string
	dateRangeEnd *string
	xExternalsystem *string
	acceptLanguage *string
}

// E-certificate conversion.
func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) ExchangeTypes(exchangeTypes string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.exchangeTypes = &exchangeTypes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) Authorization(authorization string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) XAppKey(xAppKey string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) XHotelid(xHotelid string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) DateRangeStart(dateRangeStart string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.dateRangeStart = &dateRangeStart
	return r
}

func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) DateRangeEnd(dateRangeEnd string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.dateRangeEnd = &dateRangeEnd
	return r
}

// External system code.
func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) Execute() ([]ExchangeRateType, *http.Response, error) {
	return r.ApiService.GetFuturePastExchangeRatesExecute(r)
}

/*
GetFuturePastExchangeRates Operation to fetch FuturePastExchangeRates.

Operation to Fetch Future Past Exchange Rates. <p><strong>OperationId:</strong>getFuturePastExchangeRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyCode Currency Code in OPERA
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigApiGetFuturePastExchangeRatesRequest
*/
func (a *CashieringConfigApiService) GetFuturePastExchangeRates(ctx context.Context, currencyCode string, hotelId string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	return CashieringConfigApiGetFuturePastExchangeRatesRequest{
		ApiService: a,
		ctx: ctx,
		currencyCode: currencyCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return []ExchangeRateType
func (a *CashieringConfigApiService) GetFuturePastExchangeRatesExecute(r CashieringConfigApiGetFuturePastExchangeRatesRequest) ([]ExchangeRateType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ExchangeRateType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetFuturePastExchangeRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exchangeRates/{currencyCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyCode"+"}", url.PathEscape(parameterValueToString(r.currencyCode, "currencyCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.currencyCode) < 1 {
		return localVarReturnValue, nil, reportError("currencyCode must have at least 1 elements")
	}
	if strlen(r.currencyCode) > 2000 {
		return localVarReturnValue, nil, reportError("currencyCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeTypes", r.exchangeTypes, "")
	if r.dateRangeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeStart", r.dateRangeStart, "")
	}
	if r.dateRangeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeEnd", r.dateRangeEnd, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetTaxTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	taxTypeCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetTaxTypesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetTaxTypesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetTaxTypesRequest) Authorization(authorization string) CashieringConfigApiGetTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiGetTaxTypesRequest) XAppKey(xAppKey string) CashieringConfigApiGetTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetTaxTypesRequest) XHotelid(xHotelid string) CashieringConfigApiGetTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetTaxTypesRequest) TaxTypeCodes(taxTypeCodes []string) CashieringConfigApiGetTaxTypesRequest {
	r.taxTypeCodes = &taxTypeCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetTaxTypesRequest) WildCard(wildCard string) CashieringConfigApiGetTaxTypesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetTaxTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetTaxTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetTaxTypesRequest) Execute() (*TaxTypes, *http.Response, error) {
	return r.ApiService.GetTaxTypesExecute(r)
}

/*
GetTaxTypes Operation to fetch TaxTypes.

Operation to fetch Tax Types. <p><strong>OperationId:</strong>getTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetTaxTypesRequest
*/
func (a *CashieringConfigApiService) GetTaxTypes(ctx context.Context) CashieringConfigApiGetTaxTypesRequest {
	return CashieringConfigApiGetTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaxTypes
func (a *CashieringConfigApiService) GetTaxTypesExecute(r CashieringConfigApiGetTaxTypesRequest) (*TaxTypes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelTaxTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.taxTypeCodes != nil {
		t := *r.taxTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodes *PutAdjustmentCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigApiPostAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPostAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPostAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPostAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Adjustment Code Configurations.
func (r CashieringConfigApiPostAdjustmentCodesRequest) AdjustmentCodes(adjustmentCodes PutAdjustmentCodesRequest) CashieringConfigApiPostAdjustmentCodesRequest {
	r.adjustmentCodes = &adjustmentCodes
	return r
}

// External system code.
func (r CashieringConfigApiPostAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAdjustmentCodesExecute(r)
}

/*
PostAdjustmentCodes Operation to create AdjustmentCodes.

Operation to create Adjustment Codes. <p><strong>OperationId:</strong>postAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostAdjustmentCodesRequest
*/
func (a *CashieringConfigApiService) PostAdjustmentCodes(ctx context.Context) CashieringConfigApiPostAdjustmentCodesRequest {
	return CashieringConfigApiPostAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostAdjustmentCodesExecute(r CashieringConfigApiPostAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.adjustmentCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	articles *PutArticlesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostArticlesRequest) Authorization(authorization string) CashieringConfigApiPostArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPostArticlesRequest) XAppKey(xAppKey string) CashieringConfigApiPostArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostArticlesRequest) XHotelid(xHotelid string) CashieringConfigApiPostArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create articles.
func (r CashieringConfigApiPostArticlesRequest) Articles(articles PutArticlesRequest) CashieringConfigApiPostArticlesRequest {
	r.articles = &articles
	return r
}

// External system code.
func (r CashieringConfigApiPostArticlesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostArticlesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostArticlesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostArticlesExecute(r)
}

/*
PostArticles Operation to create Articles.

Operation to create articles. <p><strong>OperationId:</strong>postArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostArticlesRequest
*/
func (a *CashieringConfigApiService) PostArticles(ctx context.Context) CashieringConfigApiPostArticlesRequest {
	return CashieringConfigApiPostArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostArticlesExecute(r CashieringConfigApiPostArticlesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.articles
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostAuthorizationConfigRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizationConfigRules *PutAuthorizationConfigRuleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) Authorization(authorization string) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) XAppKey(xAppKey string) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) XHotelid(xHotelid string) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new authorization rule for given hotel code.
func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) AuthorizationConfigRules(authorizationConfigRules PutAuthorizationConfigRuleRequest) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	r.authorizationConfigRules = &authorizationConfigRules
	return r
}

// External system code.
func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAuthorizationConfigRuleExecute(r)
}

/*
PostAuthorizationConfigRule Operation to create AuthorizationConfigRule.

 <p><strong>OperationId:</strong>postAuthorizationConfigRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostAuthorizationConfigRuleRequest
*/
func (a *CashieringConfigApiService) PostAuthorizationConfigRule(ctx context.Context) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	return CashieringConfigApiPostAuthorizationConfigRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostAuthorizationConfigRuleExecute(r CashieringConfigApiPostAuthorizationConfigRuleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostAuthorizationConfigRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizationConfigRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroups *PostAuthorizerGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostAuthorizerGroupsRequest) Authorization(authorization string) CashieringConfigApiPostAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPostAuthorizerGroupsRequest) XAppKey(xAppKey string) CashieringConfigApiPostAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostAuthorizerGroupsRequest) XHotelid(xHotelid string) CashieringConfigApiPostAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Authorizer Group Configuration.
func (r CashieringConfigApiPostAuthorizerGroupsRequest) AuthorizerGroups(authorizerGroups PostAuthorizerGroupsRequest) CashieringConfigApiPostAuthorizerGroupsRequest {
	r.authorizerGroups = &authorizerGroups
	return r
}

// External system code.
func (r CashieringConfigApiPostAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostAuthorizerGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAuthorizerGroupsExecute(r)
}

/*
PostAuthorizerGroups Operation to create AuthorizerGroups.

Operation to create Authorizer Groups. <p><strong>OperationId:</strong>postAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostAuthorizerGroupsRequest
*/
func (a *CashieringConfigApiService) PostAuthorizerGroups(ctx context.Context) CashieringConfigApiPostAuthorizerGroupsRequest {
	return CashieringConfigApiPostAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostAuthorizerGroupsExecute(r CashieringConfigApiPostAuthorizerGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizerGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostCashiersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	cashiers *PutCashiersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostCashiersRequest) Authorization(authorization string) CashieringConfigApiPostCashiersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPostCashiersRequest) XAppKey(xAppKey string) CashieringConfigApiPostCashiersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostCashiersRequest) XHotelid(xHotelid string) CashieringConfigApiPostCashiersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating cashiers.
func (r CashieringConfigApiPostCashiersRequest) Cashiers(cashiers PutCashiersRequest) CashieringConfigApiPostCashiersRequest {
	r.cashiers = &cashiers
	return r
}

// External system code.
func (r CashieringConfigApiPostCashiersRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostCashiersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostCashiersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostCashiersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostCashiersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCashiersExecute(r)
}

/*
PostCashiers Operation to create Cashiers.

Operation to Create Cashier. <p><strong>OperationId:</strong>postCashiers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostCashiersRequest
*/
func (a *CashieringConfigApiService) PostCashiers(ctx context.Context) CashieringConfigApiPostCashiersRequest {
	return CashieringConfigApiPostCashiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostCashiersExecute(r CashieringConfigApiPostCashiersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostCashiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashiers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	compTypesCriteria *PostCompTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostCompTypesRequest) Authorization(authorization string) CashieringConfigApiPostCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPostCompTypesRequest) XAppKey(xAppKey string) CashieringConfigApiPostCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostCompTypesRequest) XHotelid(xHotelid string) CashieringConfigApiPostCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating CompTypes.
func (r CashieringConfigApiPostCompTypesRequest) CompTypesCriteria(compTypesCriteria PostCompTypesRequest) CashieringConfigApiPostCompTypesRequest {
	r.compTypesCriteria = &compTypesCriteria
	return r
}

// External system code.
func (r CashieringConfigApiPostCompTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostCompTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostCompTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCompTypesExecute(r)
}

/*
PostCompTypes Operation to Create Comp Types

Operation to Create Comp Types <p><strong>OperationId:</strong>postCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostCompTypesRequest
*/
func (a *CashieringConfigApiService) PostCompTypes(ctx context.Context) CashieringConfigApiPostCompTypesRequest {
	return CashieringConfigApiPostCompTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostCompTypesExecute(r CashieringConfigApiPostCompTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyExchangeServiceTaxes *PutCurrencyExchangeServiceTaxesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new currency exchange service taxes
func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) CurrencyExchangeServiceTaxes(currencyExchangeServiceTaxes PutCurrencyExchangeServiceTaxesRequest) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	r.currencyExchangeServiceTaxes = &currencyExchangeServiceTaxes
	return r
}

// External system code.
func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCurrencyExchangeServiceTaxesExecute(r)
}

/*
PostCurrencyExchangeServiceTaxes Operation to create CurrencyExchangeServiceTaxes.

Operation to create currency exchange service taxes. <p><strong>OperationId:</strong>postCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigApiService) PostCurrencyExchangeServiceTaxes(ctx context.Context) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	return CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostCurrencyExchangeServiceTaxesExecute(r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.currencyExchangeServiceTaxes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	expenseArrangementCodes *PutExpenseArrangementCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigApiPostExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPostExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPostExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPostExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new expense arrangement codes.
func (r CashieringConfigApiPostExpenseArrangementCodesRequest) ExpenseArrangementCodes(expenseArrangementCodes PutExpenseArrangementCodesRequest) CashieringConfigApiPostExpenseArrangementCodesRequest {
	r.expenseArrangementCodes = &expenseArrangementCodes
	return r
}

// External system code.
func (r CashieringConfigApiPostExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostExpenseArrangementCodesExecute(r)
}

/*
PostExpenseArrangementCodes Operation to create ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>postExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostExpenseArrangementCodesRequest
*/
func (a *CashieringConfigApiService) PostExpenseArrangementCodes(ctx context.Context) CashieringConfigApiPostExpenseArrangementCodesRequest {
	return CashieringConfigApiPostExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostExpenseArrangementCodesExecute(r CashieringConfigApiPostExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.expenseArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostFolioTypeLegendMappingConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioTypeLegendMappingConfigCriteria *PostFolioTypeLegendMappingConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) Authorization(authorization string) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) XAppKey(xAppKey string) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) XHotelid(xHotelid string) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create folio type legend mapping information.
func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) FolioTypeLegendMappingConfigCriteria(folioTypeLegendMappingConfigCriteria PostFolioTypeLegendMappingConfigRequest) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	r.folioTypeLegendMappingConfigCriteria = &folioTypeLegendMappingConfigCriteria
	return r
}

// External system code.
func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFolioTypeLegendMappingConfigExecute(r)
}

/*
PostFolioTypeLegendMappingConfig Operation to create folio type legend mappings config.

Operation to create folio type legend mappings config. <p><strong>OperationId:</strong>postFolioTypeLegendMappingConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostFolioTypeLegendMappingConfigRequest
*/
func (a *CashieringConfigApiService) PostFolioTypeLegendMappingConfig(ctx context.Context) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	return CashieringConfigApiPostFolioTypeLegendMappingConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostFolioTypeLegendMappingConfigExecute(r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostFolioTypeLegendMappingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypeLegendMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioTypeLegendMappingConfigCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodes *PutAdjustmentCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigApiPutAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPutAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPutAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPutAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Adjustment Code Configurations.
func (r CashieringConfigApiPutAdjustmentCodesRequest) AdjustmentCodes(adjustmentCodes PutAdjustmentCodesRequest) CashieringConfigApiPutAdjustmentCodesRequest {
	r.adjustmentCodes = &adjustmentCodes
	return r
}

// External system code.
func (r CashieringConfigApiPutAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAdjustmentCodesExecute(r)
}

/*
PutAdjustmentCodes Operation to change AdjustmentCodes.

Operation to change Adjustment Codes. <p><strong>OperationId:</strong>putAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutAdjustmentCodesRequest
*/
func (a *CashieringConfigApiService) PutAdjustmentCodes(ctx context.Context) CashieringConfigApiPutAdjustmentCodesRequest {
	return CashieringConfigApiPutAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutAdjustmentCodesExecute(r CashieringConfigApiPutAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.adjustmentCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	articles *PutArticlesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutArticlesRequest) Authorization(authorization string) CashieringConfigApiPutArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPutArticlesRequest) XAppKey(xAppKey string) CashieringConfigApiPutArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutArticlesRequest) XHotelid(xHotelid string) CashieringConfigApiPutArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change articles.
func (r CashieringConfigApiPutArticlesRequest) Articles(articles PutArticlesRequest) CashieringConfigApiPutArticlesRequest {
	r.articles = &articles
	return r
}

// External system code.
func (r CashieringConfigApiPutArticlesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutArticlesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutArticlesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutArticlesExecute(r)
}

/*
PutArticles Operation to change Articles.

Operation to change articles. <p><strong>OperationId:</strong>putArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutArticlesRequest
*/
func (a *CashieringConfigApiService) PutArticles(ctx context.Context) CashieringConfigApiPutArticlesRequest {
	return CashieringConfigApiPutArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutArticlesExecute(r CashieringConfigApiPutArticlesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.articles
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutAuthorizationConfigRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizationConfigRules *PutAuthorizationConfigRuleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) Authorization(authorization string) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) XAppKey(xAppKey string) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) XHotelid(xHotelid string) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change authorization rule.
func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) AuthorizationConfigRules(authorizationConfigRules PutAuthorizationConfigRuleRequest) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	r.authorizationConfigRules = &authorizationConfigRules
	return r
}

// External system code.
func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAuthorizationConfigRuleExecute(r)
}

/*
PutAuthorizationConfigRule Operation to change AuthorizationConfigRule.

 <p><strong>OperationId:</strong>putAuthorizationConfigRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutAuthorizationConfigRuleRequest
*/
func (a *CashieringConfigApiService) PutAuthorizationConfigRule(ctx context.Context) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	return CashieringConfigApiPutAuthorizationConfigRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutAuthorizationConfigRuleExecute(r CashieringConfigApiPutAuthorizationConfigRuleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutAuthorizationConfigRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizationConfigRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroupsToChange *PutAuthorizerGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutAuthorizerGroupsRequest) Authorization(authorization string) CashieringConfigApiPutAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPutAuthorizerGroupsRequest) XAppKey(xAppKey string) CashieringConfigApiPutAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutAuthorizerGroupsRequest) XHotelid(xHotelid string) CashieringConfigApiPutAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Authorizer Group Configuration.
func (r CashieringConfigApiPutAuthorizerGroupsRequest) AuthorizerGroupsToChange(authorizerGroupsToChange PutAuthorizerGroupsRequest) CashieringConfigApiPutAuthorizerGroupsRequest {
	r.authorizerGroupsToChange = &authorizerGroupsToChange
	return r
}

// External system code.
func (r CashieringConfigApiPutAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutAuthorizerGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAuthorizerGroupsExecute(r)
}

/*
PutAuthorizerGroups Operation to change AuthorizerGroups.

Operation to change Authorizer Groups. <p><strong>OperationId:</strong>putAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutAuthorizerGroupsRequest
*/
func (a *CashieringConfigApiService) PutAuthorizerGroups(ctx context.Context) CashieringConfigApiPutAuthorizerGroupsRequest {
	return CashieringConfigApiPutAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutAuthorizerGroupsExecute(r CashieringConfigApiPutAuthorizerGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizerGroupsToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutCashiersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	cashiers *PutCashiersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutCashiersRequest) Authorization(authorization string) CashieringConfigApiPutCashiersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPutCashiersRequest) XAppKey(xAppKey string) CashieringConfigApiPutCashiersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutCashiersRequest) XHotelid(xHotelid string) CashieringConfigApiPutCashiersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request objects for modifying cashiers
func (r CashieringConfigApiPutCashiersRequest) Cashiers(cashiers PutCashiersRequest) CashieringConfigApiPutCashiersRequest {
	r.cashiers = &cashiers
	return r
}

// External system code.
func (r CashieringConfigApiPutCashiersRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutCashiersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutCashiersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutCashiersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutCashiersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCashiersExecute(r)
}

/*
PutCashiers Operation to change CashiersDetails.

This Operation to Change a Cashier. <p><strong>OperationId:</strong>putCashiers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutCashiersRequest
*/
func (a *CashieringConfigApiService) PutCashiers(ctx context.Context) CashieringConfigApiPutCashiersRequest {
	return CashieringConfigApiPutCashiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutCashiersExecute(r CashieringConfigApiPutCashiersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutCashiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashiers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyExchangeServiceTaxes *PutCurrencyExchangeServiceTaxesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing currency exchange service taxes
func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) CurrencyExchangeServiceTaxes(currencyExchangeServiceTaxes PutCurrencyExchangeServiceTaxesRequest) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	r.currencyExchangeServiceTaxes = &currencyExchangeServiceTaxes
	return r
}

// External system code.
func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCurrencyExchangeServiceTaxesExecute(r)
}

/*
PutCurrencyExchangeServiceTaxes Operation to change ExchangeServiceTaxes.

Operation to change currency exchange service taxes. <p><strong>OperationId:</strong>putCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigApiService) PutCurrencyExchangeServiceTaxes(ctx context.Context) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	return CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutCurrencyExchangeServiceTaxesExecute(r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.currencyExchangeServiceTaxes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutDailyPlanCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	dailyPlanCodes *PutDailyPlanCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutDailyPlanCodesRequest) Authorization(authorization string) CashieringConfigApiPutDailyPlanCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPutDailyPlanCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPutDailyPlanCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutDailyPlanCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPutDailyPlanCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing daily plan codes.
func (r CashieringConfigApiPutDailyPlanCodesRequest) DailyPlanCodes(dailyPlanCodes PutDailyPlanCodesRequest) CashieringConfigApiPutDailyPlanCodesRequest {
	r.dailyPlanCodes = &dailyPlanCodes
	return r
}

// External system code.
func (r CashieringConfigApiPutDailyPlanCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutDailyPlanCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutDailyPlanCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutDailyPlanCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutDailyPlanCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutDailyPlanCodesExecute(r)
}

/*
PutDailyPlanCodes Operation to change DailyPlanCodes.

 <p><strong>OperationId:</strong>putDailyPlanCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutDailyPlanCodesRequest
*/
func (a *CashieringConfigApiService) PutDailyPlanCodes(ctx context.Context) CashieringConfigApiPutDailyPlanCodesRequest {
	return CashieringConfigApiPutDailyPlanCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutDailyPlanCodesExecute(r CashieringConfigApiPutDailyPlanCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutDailyPlanCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dailyPlanCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.dailyPlanCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	expenseArrangementCodes *PutExpenseArrangementCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigApiPutExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPutExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPutExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPutExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing expense arrangement codes.
func (r CashieringConfigApiPutExpenseArrangementCodesRequest) ExpenseArrangementCodes(expenseArrangementCodes PutExpenseArrangementCodesRequest) CashieringConfigApiPutExpenseArrangementCodesRequest {
	r.expenseArrangementCodes = &expenseArrangementCodes
	return r
}

// External system code.
func (r CashieringConfigApiPutExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutExpenseArrangementCodesExecute(r)
}

/*
PutExpenseArrangementCodes Operation to change ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>putExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutExpenseArrangementCodesRequest
*/
func (a *CashieringConfigApiService) PutExpenseArrangementCodes(ctx context.Context) CashieringConfigApiPutExpenseArrangementCodesRequest {
	return CashieringConfigApiPutExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutExpenseArrangementCodesExecute(r CashieringConfigApiPutExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.expenseArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalFolioParameters *PutFiscalFolioParametersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutFiscalFolioParametersRequest) Authorization(authorization string) CashieringConfigApiPutFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiPutFiscalFolioParametersRequest) XAppKey(xAppKey string) CashieringConfigApiPutFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutFiscalFolioParametersRequest) XHotelid(xHotelid string) CashieringConfigApiPutFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Fiscal Folio Parameter Configurations.
func (r CashieringConfigApiPutFiscalFolioParametersRequest) FiscalFolioParameters(fiscalFolioParameters PutFiscalFolioParametersRequest) CashieringConfigApiPutFiscalFolioParametersRequest {
	r.fiscalFolioParameters = &fiscalFolioParameters
	return r
}

// External system code.
func (r CashieringConfigApiPutFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutFiscalFolioParametersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutFiscalFolioParametersExecute(r)
}

/*
PutFiscalFolioParameters Operation to change FiscalFolioParameters.

Operation to change Fiscal Folio Parameters. <p><strong>OperationId:</strong>putFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutFiscalFolioParametersRequest
*/
func (a *CashieringConfigApiService) PutFiscalFolioParameters(ctx context.Context) CashieringConfigApiPutFiscalFolioParametersRequest {
	return CashieringConfigApiPutFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutFiscalFolioParametersExecute(r CashieringConfigApiPutFiscalFolioParametersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalFolioParameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalFolioParameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiRemoveCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	compTypesCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiRemoveCompTypesRequest) Authorization(authorization string) CashieringConfigApiRemoveCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiRemoveCompTypesRequest) XAppKey(xAppKey string) CashieringConfigApiRemoveCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiRemoveCompTypesRequest) XHotelid(xHotelid string) CashieringConfigApiRemoveCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigApiRemoveCompTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiRemoveCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiRemoveCompTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiRemoveCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiRemoveCompTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCompTypesExecute(r)
}

/*
RemoveCompTypes Operation to Remove Comp Types.

Operation to Remove Comp Types. <p><strong>OperationId:</strong>removeCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param compTypesCode Comp Types Code to be deleted.
 @return CashieringConfigApiRemoveCompTypesRequest
*/
func (a *CashieringConfigApiService) RemoveCompTypes(ctx context.Context, compTypesCode string) CashieringConfigApiRemoveCompTypesRequest {
	return CashieringConfigApiRemoveCompTypesRequest{
		ApiService: a,
		ctx: ctx,
		compTypesCode: compTypesCode,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) RemoveCompTypesExecute(r CashieringConfigApiRemoveCompTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.RemoveCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compTypes/codes/{compTypesCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"compTypesCode"+"}", url.PathEscape(parameterValueToString(r.compTypesCode, "compTypesCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.compTypesCode) < 1 {
		return localVarReturnValue, nil, reportError("compTypesCode must have at least 1 elements")
	}
	if strlen(r.compTypesCode) > 2000 {
		return localVarReturnValue, nil, reportError("compTypesCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	legendCode string
	folioType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) Authorization(authorization string) CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) XAppKey(xAppKey string) CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) XHotelid(xHotelid string) CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveFolioTypeLegendMappingConfigExecute(r)
}

/*
RemoveFolioTypeLegendMappingConfig Operation to remove folio type legend mappings config.

Operation to remove folio type legend mappings config. <p><strong>OperationId:</strong>removeFolioTypeLegendMappingConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param legendCode Legend Code
 @param folioType Folio Type
 @param hotelId Unique ID of the source hotel in OPERA
 @return CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest
*/
func (a *CashieringConfigApiService) RemoveFolioTypeLegendMappingConfig(ctx context.Context, legendCode string, folioType string, hotelId string) CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest {
	return CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest{
		ApiService: a,
		ctx: ctx,
		legendCode: legendCode,
		folioType: folioType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) RemoveFolioTypeLegendMappingConfigExecute(r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.RemoveFolioTypeLegendMappingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folios/{folioType}/legends/{legendCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"legendCode"+"}", url.PathEscape(parameterValueToString(r.legendCode, "legendCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folioType"+"}", url.PathEscape(parameterValueToString(r.folioType, "folioType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.legendCode) < 1 {
		return localVarReturnValue, nil, reportError("legendCode must have at least 1 elements")
	}
	if strlen(r.legendCode) > 2000 {
		return localVarReturnValue, nil, reportError("legendCode must have less than 2000 elements")
	}
	if strlen(r.folioType) < 1 {
		return localVarReturnValue, nil, reportError("folioType must have at least 1 elements")
	}
	if strlen(r.folioType) > 2000 {
		return localVarReturnValue, nil, reportError("folioType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
