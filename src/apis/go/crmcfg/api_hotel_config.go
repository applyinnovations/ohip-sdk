/*
OPERA Cloud CRM Configuration API

APIs for Customer Relationship Management (profile) configuration, such as creating preferences, or address types.  It also includes Membership Configuration, where you can retrieve membership levels that are configured for a property, or create new membership enrollment codes.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package crmcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HotelConfigApiService HotelConfigApi service
type HotelConfigApiService service

type HotelConfigApiChangeCommunicationTypeRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	communicationTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	communicationTypeToBeChanged *ChangeCommunicationTypeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiChangeCommunicationTypeRequest) Authorization(authorization string) HotelConfigApiChangeCommunicationTypeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiChangeCommunicationTypeRequest) XAppKey(xAppKey string) HotelConfigApiChangeCommunicationTypeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiChangeCommunicationTypeRequest) XHotelid(xHotelid string) HotelConfigApiChangeCommunicationTypeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing an existing Communication Type.
func (r HotelConfigApiChangeCommunicationTypeRequest) CommunicationTypeToBeChanged(communicationTypeToBeChanged ChangeCommunicationTypeRequest) HotelConfigApiChangeCommunicationTypeRequest {
	r.communicationTypeToBeChanged = &communicationTypeToBeChanged
	return r
}

// External system code.
func (r HotelConfigApiChangeCommunicationTypeRequest) XExternalsystem(xExternalsystem string) HotelConfigApiChangeCommunicationTypeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiChangeCommunicationTypeRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiChangeCommunicationTypeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiChangeCommunicationTypeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeCommunicationTypeExecute(r)
}

/*
ChangeCommunicationType Change a  communication type

Use this API to update a  communication type. <p><strong>OperationId:</strong>changeCommunicationType</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param communicationTypeCode Unique Code of communication Types.
 @return HotelConfigApiChangeCommunicationTypeRequest
*/
func (a *HotelConfigApiService) ChangeCommunicationType(ctx context.Context, communicationTypeCode string) HotelConfigApiChangeCommunicationTypeRequest {
	return HotelConfigApiChangeCommunicationTypeRequest{
		ApiService: a,
		ctx: ctx,
		communicationTypeCode: communicationTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) ChangeCommunicationTypeExecute(r HotelConfigApiChangeCommunicationTypeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.ChangeCommunicationType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communicationTypes/{communicationTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"communicationTypeCode"+"}", url.PathEscape(parameterValueToString(r.communicationTypeCode, "communicationTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.communicationTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("communicationTypeCode must have at least 1 elements")
	}
	if strlen(r.communicationTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("communicationTypeCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.communicationTypeToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetCommunicationTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	codes *[]string
	roles *[]string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetCommunicationTypesRequest) Authorization(authorization string) HotelConfigApiGetCommunicationTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetCommunicationTypesRequest) XAppKey(xAppKey string) HotelConfigApiGetCommunicationTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetCommunicationTypesRequest) XHotelid(xHotelid string) HotelConfigApiGetCommunicationTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HotelConfigApiGetCommunicationTypesRequest) Codes(codes []string) HotelConfigApiGetCommunicationTypesRequest {
	r.codes = &codes
	return r
}

// Phone Number Communication Role.
func (r HotelConfigApiGetCommunicationTypesRequest) Roles(roles []string) HotelConfigApiGetCommunicationTypesRequest {
	r.roles = &roles
	return r
}

// Description of the Communication Types to be searched.
func (r HotelConfigApiGetCommunicationTypesRequest) Description(description string) HotelConfigApiGetCommunicationTypesRequest {
	r.description = &description
	return r
}

// External system code.
func (r HotelConfigApiGetCommunicationTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetCommunicationTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetCommunicationTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetCommunicationTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetCommunicationTypesRequest) Execute() (*CommunicationTypesDetails, *http.Response, error) {
	return r.ApiService.GetCommunicationTypesExecute(r)
}

/*
GetCommunicationTypes Get communication types

Use this API to get communication types. <p><strong>OperationId:</strong>getCommunicationTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetCommunicationTypesRequest
*/
func (a *HotelConfigApiService) GetCommunicationTypes(ctx context.Context) HotelConfigApiGetCommunicationTypesRequest {
	return HotelConfigApiGetCommunicationTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CommunicationTypesDetails
func (a *HotelConfigApiService) GetCommunicationTypesExecute(r HotelConfigApiGetCommunicationTypesRequest) (*CommunicationTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CommunicationTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetCommunicationTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communicationTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.roles != nil {
		t := *r.roles
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roles", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roles", t, "multi")
		}
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostCommunicationTypeRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	communicationTypeCriteria *PostCommunicationTypeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostCommunicationTypeRequest) Authorization(authorization string) HotelConfigApiPostCommunicationTypeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostCommunicationTypeRequest) XAppKey(xAppKey string) HotelConfigApiPostCommunicationTypeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostCommunicationTypeRequest) XHotelid(xHotelid string) HotelConfigApiPostCommunicationTypeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new Communication Type.
func (r HotelConfigApiPostCommunicationTypeRequest) CommunicationTypeCriteria(communicationTypeCriteria PostCommunicationTypeRequest) HotelConfigApiPostCommunicationTypeRequest {
	r.communicationTypeCriteria = &communicationTypeCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostCommunicationTypeRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostCommunicationTypeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostCommunicationTypeRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostCommunicationTypeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostCommunicationTypeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCommunicationTypeExecute(r)
}

/*
PostCommunicationType Create a  communication type

Use this API to create a  communication type. <p><strong>OperationId:</strong>postCommunicationType</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiPostCommunicationTypeRequest
*/
func (a *HotelConfigApiService) PostCommunicationType(ctx context.Context) HotelConfigApiPostCommunicationTypeRequest {
	return HotelConfigApiPostCommunicationTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostCommunicationTypeExecute(r HotelConfigApiPostCommunicationTypeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostCommunicationType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communicationTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.communicationTypeCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiRemoveCommunicationTypeRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	communicationTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiRemoveCommunicationTypeRequest) Authorization(authorization string) HotelConfigApiRemoveCommunicationTypeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiRemoveCommunicationTypeRequest) XAppKey(xAppKey string) HotelConfigApiRemoveCommunicationTypeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiRemoveCommunicationTypeRequest) XHotelid(xHotelid string) HotelConfigApiRemoveCommunicationTypeRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigApiRemoveCommunicationTypeRequest) XExternalsystem(xExternalsystem string) HotelConfigApiRemoveCommunicationTypeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiRemoveCommunicationTypeRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiRemoveCommunicationTypeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiRemoveCommunicationTypeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCommunicationTypeExecute(r)
}

/*
RemoveCommunicationType Delete a communication type

Use this API to delete a communication type. <p><strong>OperationId:</strong>removeCommunicationType</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param communicationTypeCode Unique Code of communication Types.
 @return HotelConfigApiRemoveCommunicationTypeRequest
*/
func (a *HotelConfigApiService) RemoveCommunicationType(ctx context.Context, communicationTypeCode string) HotelConfigApiRemoveCommunicationTypeRequest {
	return HotelConfigApiRemoveCommunicationTypeRequest{
		ApiService: a,
		ctx: ctx,
		communicationTypeCode: communicationTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) RemoveCommunicationTypeExecute(r HotelConfigApiRemoveCommunicationTypeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.RemoveCommunicationType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communicationTypes/{communicationTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"communicationTypeCode"+"}", url.PathEscape(parameterValueToString(r.communicationTypeCode, "communicationTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.communicationTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("communicationTypeCode must have at least 1 elements")
	}
	if strlen(r.communicationTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("communicationTypeCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
