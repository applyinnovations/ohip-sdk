/*
OPERA Cloud List of Values Management API

APIs to cater for List of Value functionality in OPERA Cloud. A List of Values in the OPERA Application can be configured by a property.  Then by using these APIs you can retrieve all configured codes.  As an example, Titles is a configurable ListOfValues.  A hotel can specify what titles they wish to use, and thus fetching the LOV for title, you can view the codes that are configured for a property.<br /><br /> Compatible with OPERA Cloud release 21.5.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 21.5.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// LOVApiService LOVApi service
type LOVApiService service

type ApiGetADSEchoTokenLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	errorType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetADSEchoTokenLOVRequest) Authorization(authorization string) ApiGetADSEchoTokenLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetADSEchoTokenLOVRequest) XAppKey(xAppKey string) ApiGetADSEchoTokenLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetADSEchoTokenLOVRequest) XHotelid(xHotelid string) ApiGetADSEchoTokenLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetADSEchoTokenLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetADSEchoTokenLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetADSEchoTokenLOVRequest) ParameterName(parameterName []string) ApiGetADSEchoTokenLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetADSEchoTokenLOVRequest) ParameterValue(parameterValue []string) ApiGetADSEchoTokenLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetADSEchoTokenLOVRequest) XExternalsystem(xExternalsystem string) ApiGetADSEchoTokenLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetADSEchoTokenLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetADSEchoTokenLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetADSEchoTokenLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetADSEchoTokenLOVExecute(r)
}

/*
GetADSEchoTokenLOV Fetch List Of Values for ADSEcho Token

 <p><strong>OperationId:</strong>getADSEchoTokenLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param errorType Value of the parameter 'errorType' which is required to fetch ADSEchoToken LOV
 @return ApiGetADSEchoTokenLOVRequest
*/
func (a *LOVApiService) GetADSEchoTokenLOV(ctx context.Context, errorType string) ApiGetADSEchoTokenLOVRequest {
	return ApiGetADSEchoTokenLOVRequest{
		ApiService: a,
		ctx: ctx,
		errorType: errorType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetADSEchoTokenLOVExecute(r ApiGetADSEchoTokenLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetADSEchoTokenLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/errorType/{errorType}/adsEchoToken"
	localVarPath = strings.Replace(localVarPath, "{"+"errorType"+"}", url.PathEscape(parameterValueToString(r.errorType, "errorType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.errorType) < 1 {
		return localVarReturnValue, nil, reportError("errorType must have at least 1 elements")
	}
	if strlen(r.errorType) > 2000 {
		return localVarReturnValue, nil, reportError("errorType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetADSStatusLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	errorType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetADSStatusLOVRequest) Authorization(authorization string) ApiGetADSStatusLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetADSStatusLOVRequest) XAppKey(xAppKey string) ApiGetADSStatusLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetADSStatusLOVRequest) XHotelid(xHotelid string) ApiGetADSStatusLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetADSStatusLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetADSStatusLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetADSStatusLOVRequest) ParameterName(parameterName []string) ApiGetADSStatusLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetADSStatusLOVRequest) ParameterValue(parameterValue []string) ApiGetADSStatusLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetADSStatusLOVRequest) XExternalsystem(xExternalsystem string) ApiGetADSStatusLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetADSStatusLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetADSStatusLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetADSStatusLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetADSStatusLOVExecute(r)
}

/*
GetADSStatusLOV Fetch List Of Values for ADSStatus

 <p><strong>OperationId:</strong>getADSStatusLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param errorType Value of the parameter 'errorType' which is required to fetch ADSStatus LOV
 @return ApiGetADSStatusLOVRequest
*/
func (a *LOVApiService) GetADSStatusLOV(ctx context.Context, errorType string) ApiGetADSStatusLOVRequest {
	return ApiGetADSStatusLOVRequest{
		ApiService: a,
		ctx: ctx,
		errorType: errorType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetADSStatusLOVExecute(r ApiGetADSStatusLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetADSStatusLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/errorType/{errorType}/adsStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"errorType"+"}", url.PathEscape(parameterValueToString(r.errorType, "errorType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.errorType) < 1 {
		return localVarReturnValue, nil, reportError("errorType must have at least 1 elements")
	}
	if strlen(r.errorType) > 2000 {
		return localVarReturnValue, nil, reportError("errorType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetARAccountTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetARAccountTypesLOVRequest) Authorization(authorization string) ApiGetARAccountTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetARAccountTypesLOVRequest) XAppKey(xAppKey string) ApiGetARAccountTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetARAccountTypesLOVRequest) XHotelid(xHotelid string) ApiGetARAccountTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetARAccountTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetARAccountTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetARAccountTypesLOVRequest) ParameterName(parameterName []string) ApiGetARAccountTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetARAccountTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetARAccountTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetARAccountTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetARAccountTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetARAccountTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetARAccountTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetARAccountTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetARAccountTypesLOVExecute(r)
}

/*
GetARAccountTypesLOV Fetch List Of Values for ARAccount Types

 <p><strong>OperationId:</strong>getARAccountTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ARAccountTypes LOV
 @return ApiGetARAccountTypesLOVRequest
*/
func (a *LOVApiService) GetARAccountTypesLOV(ctx context.Context, hotelId string) ApiGetARAccountTypesLOVRequest {
	return ApiGetARAccountTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetARAccountTypesLOVExecute(r ApiGetARAccountTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetARAccountTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arAccountTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetARCreditCardsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetARCreditCardsLOVRequest) Authorization(authorization string) ApiGetARCreditCardsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetARCreditCardsLOVRequest) XAppKey(xAppKey string) ApiGetARCreditCardsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetARCreditCardsLOVRequest) XHotelid(xHotelid string) ApiGetARCreditCardsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetARCreditCardsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetARCreditCardsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetARCreditCardsLOVRequest) ParameterName(parameterName []string) ApiGetARCreditCardsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetARCreditCardsLOVRequest) ParameterValue(parameterValue []string) ApiGetARCreditCardsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetARCreditCardsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetARCreditCardsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetARCreditCardsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetARCreditCardsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetARCreditCardsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetARCreditCardsLOVExecute(r)
}

/*
GetARCreditCardsLOV Fetch List Of Values for ARCredit Cards

 <p><strong>OperationId:</strong>getARCreditCardsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ARCreditCards LOV
 @return ApiGetARCreditCardsLOVRequest
*/
func (a *LOVApiService) GetARCreditCardsLOV(ctx context.Context, hotelId string) ApiGetARCreditCardsLOVRequest {
	return ApiGetARCreditCardsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetARCreditCardsLOVExecute(r ApiGetARCreditCardsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetARCreditCardsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arCreditCards"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActionTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	module string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetActionTypesLOVRequest) Authorization(authorization string) ApiGetActionTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetActionTypesLOVRequest) XAppKey(xAppKey string) ApiGetActionTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetActionTypesLOVRequest) XHotelid(xHotelid string) ApiGetActionTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetActionTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetActionTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetActionTypesLOVRequest) ParameterName(parameterName []string) ApiGetActionTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetActionTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetActionTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetActionTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetActionTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetActionTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetActionTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetActionTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetActionTypesLOVExecute(r)
}

/*
GetActionTypesLOV Fetch List Of Values for Action Types

 <p><strong>OperationId:</strong>getActionTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param module Value of the parameter 'module' which is required to fetch ActionTypes LOV
 @return ApiGetActionTypesLOVRequest
*/
func (a *LOVApiService) GetActionTypesLOV(ctx context.Context, module string) ApiGetActionTypesLOVRequest {
	return ApiGetActionTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		module: module,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetActionTypesLOVExecute(r ApiGetActionTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetActionTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/module/{module}/actionTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"module"+"}", url.PathEscape(parameterValueToString(r.module, "module")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.module) < 1 {
		return localVarReturnValue, nil, reportError("module must have at least 1 elements")
	}
	if strlen(r.module) > 2000 {
		return localVarReturnValue, nil, reportError("module must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActivitiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetActivitiesLOVRequest) Authorization(authorization string) ApiGetActivitiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetActivitiesLOVRequest) XAppKey(xAppKey string) ApiGetActivitiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetActivitiesLOVRequest) XHotelid(xHotelid string) ApiGetActivitiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetActivitiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetActivitiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetActivitiesLOVRequest) ParameterName(parameterName []string) ApiGetActivitiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetActivitiesLOVRequest) ParameterValue(parameterValue []string) ApiGetActivitiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetActivitiesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetActivitiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetActivitiesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetActivitiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetActivitiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetActivitiesLOVExecute(r)
}

/*
GetActivitiesLOV Fetch List Of Values for Activities

 <p><strong>OperationId:</strong>getActivitiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Activities LOV
 @return ApiGetActivitiesLOVRequest
*/
func (a *LOVApiService) GetActivitiesLOV(ctx context.Context, hotelId string) ApiGetActivitiesLOVRequest {
	return ApiGetActivitiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetActivitiesLOVExecute(r ApiGetActivitiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetActivitiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/activities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActivityConfigTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetActivityConfigTypesLOVRequest) Authorization(authorization string) ApiGetActivityConfigTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetActivityConfigTypesLOVRequest) XAppKey(xAppKey string) ApiGetActivityConfigTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetActivityConfigTypesLOVRequest) XHotelid(xHotelid string) ApiGetActivityConfigTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetActivityConfigTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetActivityConfigTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetActivityConfigTypesLOVRequest) ParameterName(parameterName []string) ApiGetActivityConfigTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetActivityConfigTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetActivityConfigTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetActivityConfigTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetActivityConfigTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetActivityConfigTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetActivityConfigTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetActivityConfigTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetActivityConfigTypesLOVExecute(r)
}

/*
GetActivityConfigTypesLOV Fetch List Of Values for Activity Config Types

 <p><strong>OperationId:</strong>getActivityConfigTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ActivityConfigTypes LOV
 @return ApiGetActivityConfigTypesLOVRequest
*/
func (a *LOVApiService) GetActivityConfigTypesLOV(ctx context.Context, hotelId string) ApiGetActivityConfigTypesLOVRequest {
	return ApiGetActivityConfigTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetActivityConfigTypesLOVExecute(r ApiGetActivityConfigTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetActivityConfigTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/activityConfigTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActivityLocationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetActivityLocationsLOVRequest) Authorization(authorization string) ApiGetActivityLocationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetActivityLocationsLOVRequest) XAppKey(xAppKey string) ApiGetActivityLocationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetActivityLocationsLOVRequest) XHotelid(xHotelid string) ApiGetActivityLocationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetActivityLocationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetActivityLocationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetActivityLocationsLOVRequest) ParameterName(parameterName []string) ApiGetActivityLocationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetActivityLocationsLOVRequest) ParameterValue(parameterValue []string) ApiGetActivityLocationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetActivityLocationsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetActivityLocationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetActivityLocationsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetActivityLocationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetActivityLocationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetActivityLocationsLOVExecute(r)
}

/*
GetActivityLocationsLOV Fetch List Of Values for Activity Locations

 <p><strong>OperationId:</strong>getActivityLocationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ActivityLocations LOV
 @return ApiGetActivityLocationsLOVRequest
*/
func (a *LOVApiService) GetActivityLocationsLOV(ctx context.Context, hotelId string) ApiGetActivityLocationsLOVRequest {
	return ApiGetActivityLocationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetActivityLocationsLOVExecute(r ApiGetActivityLocationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetActivityLocationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/activityLocations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActivityStatusLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetActivityStatusLOVRequest) Authorization(authorization string) ApiGetActivityStatusLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetActivityStatusLOVRequest) XAppKey(xAppKey string) ApiGetActivityStatusLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetActivityStatusLOVRequest) XHotelid(xHotelid string) ApiGetActivityStatusLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetActivityStatusLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetActivityStatusLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetActivityStatusLOVRequest) ParameterName(parameterName []string) ApiGetActivityStatusLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetActivityStatusLOVRequest) ParameterValue(parameterValue []string) ApiGetActivityStatusLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetActivityStatusLOVRequest) XExternalsystem(xExternalsystem string) ApiGetActivityStatusLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetActivityStatusLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetActivityStatusLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetActivityStatusLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetActivityStatusLOVExecute(r)
}

/*
GetActivityStatusLOV Fetch List Of Values for Activity Status

 <p><strong>OperationId:</strong>getActivityStatusLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ActivityStatus LOV
 @return ApiGetActivityStatusLOVRequest
*/
func (a *LOVApiService) GetActivityStatusLOV(ctx context.Context, hotelId string) ApiGetActivityStatusLOVRequest {
	return ApiGetActivityStatusLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetActivityStatusLOVExecute(r ApiGetActivityStatusLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetActivityStatusLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/activityStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActivityTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetActivityTypesLOVRequest) Authorization(authorization string) ApiGetActivityTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetActivityTypesLOVRequest) XAppKey(xAppKey string) ApiGetActivityTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetActivityTypesLOVRequest) XHotelid(xHotelid string) ApiGetActivityTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetActivityTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetActivityTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetActivityTypesLOVRequest) ParameterName(parameterName []string) ApiGetActivityTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetActivityTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetActivityTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetActivityTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetActivityTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetActivityTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetActivityTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetActivityTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetActivityTypesLOVExecute(r)
}

/*
GetActivityTypesLOV Fetch List Of Values for Activity Types

 <p><strong>OperationId:</strong>getActivityTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ActivityTypes LOV
 @return ApiGetActivityTypesLOVRequest
*/
func (a *LOVApiService) GetActivityTypesLOV(ctx context.Context, hotelId string) ApiGetActivityTypesLOVRequest {
	return ApiGetActivityTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetActivityTypesLOVExecute(r ApiGetActivityTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetActivityTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/activityTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAddressFormatElementsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	salesFormat string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAddressFormatElementsLOVRequest) Authorization(authorization string) ApiGetAddressFormatElementsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAddressFormatElementsLOVRequest) XAppKey(xAppKey string) ApiGetAddressFormatElementsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAddressFormatElementsLOVRequest) XHotelid(xHotelid string) ApiGetAddressFormatElementsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAddressFormatElementsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAddressFormatElementsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAddressFormatElementsLOVRequest) ParameterName(parameterName []string) ApiGetAddressFormatElementsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAddressFormatElementsLOVRequest) ParameterValue(parameterValue []string) ApiGetAddressFormatElementsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAddressFormatElementsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAddressFormatElementsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAddressFormatElementsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAddressFormatElementsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAddressFormatElementsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAddressFormatElementsLOVExecute(r)
}

/*
GetAddressFormatElementsLOV Fetch List Of Values for Address Format Elements

 <p><strong>OperationId:</strong>getAddressFormatElementsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param salesFormat Value of the parameter 'salesFormat' which is required to fetch AddressFormatElements LOV
 @return ApiGetAddressFormatElementsLOVRequest
*/
func (a *LOVApiService) GetAddressFormatElementsLOV(ctx context.Context, salesFormat string) ApiGetAddressFormatElementsLOVRequest {
	return ApiGetAddressFormatElementsLOVRequest{
		ApiService: a,
		ctx: ctx,
		salesFormat: salesFormat,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAddressFormatElementsLOVExecute(r ApiGetAddressFormatElementsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAddressFormatElementsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/salesFormat/{salesFormat}/addressFormatElements"
	localVarPath = strings.Replace(localVarPath, "{"+"salesFormat"+"}", url.PathEscape(parameterValueToString(r.salesFormat, "salesFormat")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.salesFormat) < 1 {
		return localVarReturnValue, nil, reportError("salesFormat must have at least 1 elements")
	}
	if strlen(r.salesFormat) > 2000 {
		return localVarReturnValue, nil, reportError("salesFormat must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAgentAccountsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAgentAccountsLOVRequest) Authorization(authorization string) ApiGetAgentAccountsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAgentAccountsLOVRequest) XAppKey(xAppKey string) ApiGetAgentAccountsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAgentAccountsLOVRequest) XHotelid(xHotelid string) ApiGetAgentAccountsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAgentAccountsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAgentAccountsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAgentAccountsLOVRequest) ParameterName(parameterName []string) ApiGetAgentAccountsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAgentAccountsLOVRequest) ParameterValue(parameterValue []string) ApiGetAgentAccountsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAgentAccountsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAgentAccountsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAgentAccountsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAgentAccountsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAgentAccountsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAgentAccountsLOVExecute(r)
}

/*
GetAgentAccountsLOV Fetch List Of Values for Agent Accounts

 <p><strong>OperationId:</strong>getAgentAccountsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AgentAccounts LOV
 @return ApiGetAgentAccountsLOVRequest
*/
func (a *LOVApiService) GetAgentAccountsLOV(ctx context.Context, hotelId string) ApiGetAgentAccountsLOVRequest {
	return ApiGetAgentAccountsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAgentAccountsLOVExecute(r ApiGetAgentAccountsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAgentAccountsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/agentAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAgentSourceCitiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAgentSourceCitiesLOVRequest) Authorization(authorization string) ApiGetAgentSourceCitiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAgentSourceCitiesLOVRequest) XAppKey(xAppKey string) ApiGetAgentSourceCitiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAgentSourceCitiesLOVRequest) XHotelid(xHotelid string) ApiGetAgentSourceCitiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAgentSourceCitiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAgentSourceCitiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAgentSourceCitiesLOVRequest) ParameterName(parameterName []string) ApiGetAgentSourceCitiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAgentSourceCitiesLOVRequest) ParameterValue(parameterValue []string) ApiGetAgentSourceCitiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAgentSourceCitiesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAgentSourceCitiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAgentSourceCitiesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAgentSourceCitiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAgentSourceCitiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAgentSourceCitiesLOVExecute(r)
}

/*
GetAgentSourceCitiesLOV Fetch List Of Values for Agent Source Cities

 <p><strong>OperationId:</strong>getAgentSourceCitiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AgentSourceCities LOV
 @return ApiGetAgentSourceCitiesLOVRequest
*/
func (a *LOVApiService) GetAgentSourceCitiesLOV(ctx context.Context, hotelId string) ApiGetAgentSourceCitiesLOVRequest {
	return ApiGetAgentSourceCitiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAgentSourceCitiesLOVExecute(r ApiGetAgentSourceCitiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAgentSourceCitiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/agentSourceCities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAgentSourceResvCitiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAgentSourceResvCitiesLOVRequest) Authorization(authorization string) ApiGetAgentSourceResvCitiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAgentSourceResvCitiesLOVRequest) XAppKey(xAppKey string) ApiGetAgentSourceResvCitiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAgentSourceResvCitiesLOVRequest) XHotelid(xHotelid string) ApiGetAgentSourceResvCitiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAgentSourceResvCitiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAgentSourceResvCitiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAgentSourceResvCitiesLOVRequest) ParameterName(parameterName []string) ApiGetAgentSourceResvCitiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAgentSourceResvCitiesLOVRequest) ParameterValue(parameterValue []string) ApiGetAgentSourceResvCitiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAgentSourceResvCitiesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAgentSourceResvCitiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAgentSourceResvCitiesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAgentSourceResvCitiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAgentSourceResvCitiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAgentSourceResvCitiesLOVExecute(r)
}

/*
GetAgentSourceResvCitiesLOV Fetch List Of Values for Agent Source Resv Cities

 <p><strong>OperationId:</strong>getAgentSourceResvCitiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AgentSourceResvCities LOV
 @return ApiGetAgentSourceResvCitiesLOVRequest
*/
func (a *LOVApiService) GetAgentSourceResvCitiesLOV(ctx context.Context, hotelId string) ApiGetAgentSourceResvCitiesLOVRequest {
	return ApiGetAgentSourceResvCitiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAgentSourceResvCitiesLOVExecute(r ApiGetAgentSourceResvCitiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAgentSourceResvCitiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/agentSourceResvCities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAlertCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAlertCodesLOVRequest) Authorization(authorization string) ApiGetAlertCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAlertCodesLOVRequest) XAppKey(xAppKey string) ApiGetAlertCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAlertCodesLOVRequest) XHotelid(xHotelid string) ApiGetAlertCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAlertCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAlertCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAlertCodesLOVRequest) ParameterName(parameterName []string) ApiGetAlertCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAlertCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetAlertCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAlertCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAlertCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAlertCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAlertCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAlertCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAlertCodesLOVExecute(r)
}

/*
GetAlertCodesLOV Fetch List Of Values for Alert Codes

 <p><strong>OperationId:</strong>getAlertCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AlertCodes LOV
 @return ApiGetAlertCodesLOVRequest
*/
func (a *LOVApiService) GetAlertCodesLOV(ctx context.Context, hotelId string) ApiGetAlertCodesLOVRequest {
	return ApiGetAlertCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAlertCodesLOVExecute(r ApiGetAlertCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAlertCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/alertCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllRevenueTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	interfaceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAllRevenueTypesLOVRequest) Authorization(authorization string) ApiGetAllRevenueTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAllRevenueTypesLOVRequest) XAppKey(xAppKey string) ApiGetAllRevenueTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAllRevenueTypesLOVRequest) XHotelid(xHotelid string) ApiGetAllRevenueTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAllRevenueTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAllRevenueTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAllRevenueTypesLOVRequest) ParameterName(parameterName []string) ApiGetAllRevenueTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAllRevenueTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetAllRevenueTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAllRevenueTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAllRevenueTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAllRevenueTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAllRevenueTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAllRevenueTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAllRevenueTypesLOVExecute(r)
}

/*
GetAllRevenueTypesLOV Fetch List Of Values for All Revenue Types

 <p><strong>OperationId:</strong>getAllRevenueTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Value of the parameter 'interfaceId' which is required to fetch AllRevenueTypes LOV
 @return ApiGetAllRevenueTypesLOVRequest
*/
func (a *LOVApiService) GetAllRevenueTypesLOV(ctx context.Context, interfaceId string) ApiGetAllRevenueTypesLOVRequest {
	return ApiGetAllRevenueTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAllRevenueTypesLOVExecute(r ApiGetAllRevenueTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAllRevenueTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/interfaceId/{interfaceId}/allRevenueTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllowedHotelInterfaceRightsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	interfaceRowId string
	interfaceType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAllowedHotelInterfaceRightsLOVRequest) Authorization(authorization string) ApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAllowedHotelInterfaceRightsLOVRequest) XAppKey(xAppKey string) ApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAllowedHotelInterfaceRightsLOVRequest) XHotelid(xHotelid string) ApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAllowedHotelInterfaceRightsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAllowedHotelInterfaceRightsLOVRequest) ParameterName(parameterName []string) ApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAllowedHotelInterfaceRightsLOVRequest) ParameterValue(parameterValue []string) ApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAllowedHotelInterfaceRightsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAllowedHotelInterfaceRightsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAllowedHotelInterfaceRightsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAllowedHotelInterfaceRightsLOVExecute(r)
}

/*
GetAllowedHotelInterfaceRightsLOV Fetch List Of Values for Allowed Hotel Interface Rights

 <p><strong>OperationId:</strong>getAllowedHotelInterfaceRightsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceRowId Value of the parameter 'interfaceRowId' which is required to fetch AllowedHotelInterfaceRights LOV
 @param interfaceType Value of the parameter 'interfaceType' which is required to fetch AllowedHotelInterfaceRights LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AllowedHotelInterfaceRights LOV
 @return ApiGetAllowedHotelInterfaceRightsLOVRequest
*/
func (a *LOVApiService) GetAllowedHotelInterfaceRightsLOV(ctx context.Context, interfaceRowId string, interfaceType string, hotelId string) ApiGetAllowedHotelInterfaceRightsLOVRequest {
	return ApiGetAllowedHotelInterfaceRightsLOVRequest{
		ApiService: a,
		ctx: ctx,
		interfaceRowId: interfaceRowId,
		interfaceType: interfaceType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAllowedHotelInterfaceRightsLOVExecute(r ApiGetAllowedHotelInterfaceRightsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAllowedHotelInterfaceRightsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceType/{interfaceType}/interfaceRowId/{interfaceRowId}/allowedHotelInterfaceRights"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceRowId"+"}", url.PathEscape(parameterValueToString(r.interfaceRowId, "interfaceRowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceType"+"}", url.PathEscape(parameterValueToString(r.interfaceType, "interfaceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceRowId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceRowId must have at least 1 elements")
	}
	if strlen(r.interfaceRowId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceRowId must have less than 2000 elements")
	}
	if strlen(r.interfaceType) < 1 {
		return localVarReturnValue, nil, reportError("interfaceType must have at least 1 elements")
	}
	if strlen(r.interfaceType) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAlternateHotelCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAlternateHotelCodesLOVRequest) Authorization(authorization string) ApiGetAlternateHotelCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAlternateHotelCodesLOVRequest) XAppKey(xAppKey string) ApiGetAlternateHotelCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAlternateHotelCodesLOVRequest) XHotelid(xHotelid string) ApiGetAlternateHotelCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAlternateHotelCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAlternateHotelCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAlternateHotelCodesLOVRequest) ParameterName(parameterName []string) ApiGetAlternateHotelCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAlternateHotelCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetAlternateHotelCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAlternateHotelCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAlternateHotelCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAlternateHotelCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAlternateHotelCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAlternateHotelCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAlternateHotelCodesLOVExecute(r)
}

/*
GetAlternateHotelCodesLOV Fetch List Of Values for Alternate Hotel Codes

 <p><strong>OperationId:</strong>getAlternateHotelCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AlternateHotelCodes LOV
 @return ApiGetAlternateHotelCodesLOVRequest
*/
func (a *LOVApiService) GetAlternateHotelCodesLOV(ctx context.Context, hotelId string) ApiGetAlternateHotelCodesLOVRequest {
	return ApiGetAlternateHotelCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAlternateHotelCodesLOVExecute(r ApiGetAlternateHotelCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAlternateHotelCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/alternateHotelCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAmenitiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAmenitiesLOVRequest) Authorization(authorization string) ApiGetAmenitiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAmenitiesLOVRequest) XAppKey(xAppKey string) ApiGetAmenitiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAmenitiesLOVRequest) XHotelid(xHotelid string) ApiGetAmenitiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAmenitiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAmenitiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAmenitiesLOVRequest) ParameterName(parameterName []string) ApiGetAmenitiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAmenitiesLOVRequest) ParameterValue(parameterValue []string) ApiGetAmenitiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAmenitiesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAmenitiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAmenitiesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAmenitiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAmenitiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAmenitiesLOVExecute(r)
}

/*
GetAmenitiesLOV Fetch List Of Values for Amenities

 <p><strong>OperationId:</strong>getAmenitiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Amenities LOV
 @return ApiGetAmenitiesLOVRequest
*/
func (a *LOVApiService) GetAmenitiesLOV(ctx context.Context, hotelId string) ApiGetAmenitiesLOVRequest {
	return ApiGetAmenitiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAmenitiesLOVExecute(r ApiGetAmenitiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAmenitiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/amenities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationModulesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	relModuleName string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetApplicationModulesLOVRequest) Authorization(authorization string) ApiGetApplicationModulesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetApplicationModulesLOVRequest) XAppKey(xAppKey string) ApiGetApplicationModulesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetApplicationModulesLOVRequest) XHotelid(xHotelid string) ApiGetApplicationModulesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetApplicationModulesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetApplicationModulesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetApplicationModulesLOVRequest) ParameterName(parameterName []string) ApiGetApplicationModulesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetApplicationModulesLOVRequest) ParameterValue(parameterValue []string) ApiGetApplicationModulesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetApplicationModulesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetApplicationModulesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetApplicationModulesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetApplicationModulesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetApplicationModulesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetApplicationModulesLOVExecute(r)
}

/*
GetApplicationModulesLOV Fetch List Of Values for Application Modules

 <p><strong>OperationId:</strong>getApplicationModulesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relModuleName Value of the parameter 'relModuleName' which is required to fetch ApplicationModules LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ApplicationModules LOV
 @return ApiGetApplicationModulesLOVRequest
*/
func (a *LOVApiService) GetApplicationModulesLOV(ctx context.Context, relModuleName string, hotelId string) ApiGetApplicationModulesLOVRequest {
	return ApiGetApplicationModulesLOVRequest{
		ApiService: a,
		ctx: ctx,
		relModuleName: relModuleName,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetApplicationModulesLOVExecute(r ApiGetApplicationModulesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetApplicationModulesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/relModuleName/{relModuleName}/applicationModules"
	localVarPath = strings.Replace(localVarPath, "{"+"relModuleName"+"}", url.PathEscape(parameterValueToString(r.relModuleName, "relModuleName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.relModuleName) < 1 {
		return localVarReturnValue, nil, reportError("relModuleName must have at least 1 elements")
	}
	if strlen(r.relModuleName) > 2000 {
		return localVarReturnValue, nil, reportError("relModuleName must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationSettingsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	settingName string
	levelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetApplicationSettingsLOVRequest) Authorization(authorization string) ApiGetApplicationSettingsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetApplicationSettingsLOVRequest) XAppKey(xAppKey string) ApiGetApplicationSettingsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetApplicationSettingsLOVRequest) XHotelid(xHotelid string) ApiGetApplicationSettingsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetApplicationSettingsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetApplicationSettingsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetApplicationSettingsLOVRequest) ParameterName(parameterName []string) ApiGetApplicationSettingsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetApplicationSettingsLOVRequest) ParameterValue(parameterValue []string) ApiGetApplicationSettingsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetApplicationSettingsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetApplicationSettingsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetApplicationSettingsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetApplicationSettingsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetApplicationSettingsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetApplicationSettingsLOVExecute(r)
}

/*
GetApplicationSettingsLOV Fetch List Of Values for Application Settings

 <p><strong>OperationId:</strong>getApplicationSettingsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param settingName Value of the parameter 'settingName' which is required to fetch ApplicationSettings LOV
 @param levelCode Value of the parameter 'levelCode' which is required to fetch ApplicationSettings LOV
 @return ApiGetApplicationSettingsLOVRequest
*/
func (a *LOVApiService) GetApplicationSettingsLOV(ctx context.Context, settingName string, levelCode string) ApiGetApplicationSettingsLOVRequest {
	return ApiGetApplicationSettingsLOVRequest{
		ApiService: a,
		ctx: ctx,
		settingName: settingName,
		levelCode: levelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetApplicationSettingsLOVExecute(r ApiGetApplicationSettingsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetApplicationSettingsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/levelCode/{levelCode}/settingName/{settingName}/applicationSettings"
	localVarPath = strings.Replace(localVarPath, "{"+"settingName"+"}", url.PathEscape(parameterValueToString(r.settingName, "settingName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelCode"+"}", url.PathEscape(parameterValueToString(r.levelCode, "levelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.settingName) < 1 {
		return localVarReturnValue, nil, reportError("settingName must have at least 1 elements")
	}
	if strlen(r.settingName) > 2000 {
		return localVarReturnValue, nil, reportError("settingName must have less than 2000 elements")
	}
	if strlen(r.levelCode) < 1 {
		return localVarReturnValue, nil, reportError("levelCode must have at least 1 elements")
	}
	if strlen(r.levelCode) > 2000 {
		return localVarReturnValue, nil, reportError("levelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArrangementCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetArrangementCodeLOVRequest) Authorization(authorization string) ApiGetArrangementCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetArrangementCodeLOVRequest) XAppKey(xAppKey string) ApiGetArrangementCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetArrangementCodeLOVRequest) XHotelid(xHotelid string) ApiGetArrangementCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetArrangementCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetArrangementCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetArrangementCodeLOVRequest) ParameterName(parameterName []string) ApiGetArrangementCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetArrangementCodeLOVRequest) ParameterValue(parameterValue []string) ApiGetArrangementCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetArrangementCodeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetArrangementCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetArrangementCodeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetArrangementCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetArrangementCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetArrangementCodeLOVExecute(r)
}

/*
GetArrangementCodeLOV Fetch List Of Values for Arrangement Code

 <p><strong>OperationId:</strong>getArrangementCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ArrangementCode LOV
 @return ApiGetArrangementCodeLOVRequest
*/
func (a *LOVApiService) GetArrangementCodeLOV(ctx context.Context, hotelId string) ApiGetArrangementCodeLOVRequest {
	return ApiGetArrangementCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetArrangementCodeLOVExecute(r ApiGetArrangementCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetArrangementCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arrangementCode"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArrangementCodesNumberLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	type_ string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetArrangementCodesNumberLOVRequest) Authorization(authorization string) ApiGetArrangementCodesNumberLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetArrangementCodesNumberLOVRequest) XAppKey(xAppKey string) ApiGetArrangementCodesNumberLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetArrangementCodesNumberLOVRequest) XHotelid(xHotelid string) ApiGetArrangementCodesNumberLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetArrangementCodesNumberLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetArrangementCodesNumberLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetArrangementCodesNumberLOVRequest) ParameterName(parameterName []string) ApiGetArrangementCodesNumberLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetArrangementCodesNumberLOVRequest) ParameterValue(parameterValue []string) ApiGetArrangementCodesNumberLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetArrangementCodesNumberLOVRequest) XExternalsystem(xExternalsystem string) ApiGetArrangementCodesNumberLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetArrangementCodesNumberLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetArrangementCodesNumberLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetArrangementCodesNumberLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetArrangementCodesNumberLOVExecute(r)
}

/*
GetArrangementCodesNumberLOV Fetch List Of Values for Arrangement Codes Number

 <p><strong>OperationId:</strong>getArrangementCodesNumberLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Value of the parameter 'type' which is required to fetch ArrangementCodesNumber LOV
 @return ApiGetArrangementCodesNumberLOVRequest
*/
func (a *LOVApiService) GetArrangementCodesNumberLOV(ctx context.Context, type_ string) ApiGetArrangementCodesNumberLOVRequest {
	return ApiGetArrangementCodesNumberLOVRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetArrangementCodesNumberLOVExecute(r ApiGetArrangementCodesNumberLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetArrangementCodesNumberLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/type/{type}/arrangementCodesNumber"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.type_) < 1 {
		return localVarReturnValue, nil, reportError("type_ must have at least 1 elements")
	}
	if strlen(r.type_) > 2000 {
		return localVarReturnValue, nil, reportError("type_ must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArticleCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetArticleCodesLOVRequest) Authorization(authorization string) ApiGetArticleCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetArticleCodesLOVRequest) XAppKey(xAppKey string) ApiGetArticleCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetArticleCodesLOVRequest) XHotelid(xHotelid string) ApiGetArticleCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetArticleCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetArticleCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetArticleCodesLOVRequest) ParameterName(parameterName []string) ApiGetArticleCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetArticleCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetArticleCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetArticleCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetArticleCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetArticleCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetArticleCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetArticleCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetArticleCodesLOVExecute(r)
}

/*
GetArticleCodesLOV Fetch List Of Values for Article Codes

 <p><strong>OperationId:</strong>getArticleCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ArticleCodes LOV
 @return ApiGetArticleCodesLOVRequest
*/
func (a *LOVApiService) GetArticleCodesLOV(ctx context.Context, hotelId string) ApiGetArticleCodesLOVRequest {
	return ApiGetArticleCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetArticleCodesLOVExecute(r ApiGetArticleCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetArticleCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/articleCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssignRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	room string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAssignRoomsLOVRequest) Authorization(authorization string) ApiGetAssignRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAssignRoomsLOVRequest) XAppKey(xAppKey string) ApiGetAssignRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAssignRoomsLOVRequest) XHotelid(xHotelid string) ApiGetAssignRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAssignRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAssignRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAssignRoomsLOVRequest) ParameterName(parameterName []string) ApiGetAssignRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAssignRoomsLOVRequest) ParameterValue(parameterValue []string) ApiGetAssignRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAssignRoomsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAssignRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAssignRoomsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAssignRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAssignRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAssignRoomsLOVExecute(r)
}

/*
GetAssignRoomsLOV Fetch List Of Values for Assign Rooms

 <p><strong>OperationId:</strong>getAssignRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param room Value of the parameter 'room' which is required to fetch AssignRooms LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AssignRooms LOV
 @return ApiGetAssignRoomsLOVRequest
*/
func (a *LOVApiService) GetAssignRoomsLOV(ctx context.Context, room string, hotelId string) ApiGetAssignRoomsLOVRequest {
	return ApiGetAssignRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		room: room,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAssignRoomsLOVExecute(r ApiGetAssignRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAssignRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/room/{room}/assignRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"room"+"}", url.PathEscape(parameterValueToString(r.room, "room")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.room) < 1 {
		return localVarReturnValue, nil, reportError("room must have at least 1 elements")
	}
	if strlen(r.room) > 2000 {
		return localVarReturnValue, nil, reportError("room must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAttractionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAttractionsLOVRequest) Authorization(authorization string) ApiGetAttractionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAttractionsLOVRequest) XAppKey(xAppKey string) ApiGetAttractionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAttractionsLOVRequest) XHotelid(xHotelid string) ApiGetAttractionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAttractionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAttractionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAttractionsLOVRequest) ParameterName(parameterName []string) ApiGetAttractionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAttractionsLOVRequest) ParameterValue(parameterValue []string) ApiGetAttractionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAttractionsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAttractionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAttractionsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAttractionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAttractionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAttractionsLOVExecute(r)
}

/*
GetAttractionsLOV Fetch List Of Values for Attractions

 <p><strong>OperationId:</strong>getAttractionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Attractions LOV
 @return ApiGetAttractionsLOVRequest
*/
func (a *LOVApiService) GetAttractionsLOV(ctx context.Context, hotelId string) ApiGetAttractionsLOVRequest {
	return ApiGetAttractionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAttractionsLOVExecute(r ApiGetAttractionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAttractionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/attractions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuthorizerLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAuthorizerLOVRequest) Authorization(authorization string) ApiGetAuthorizerLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAuthorizerLOVRequest) XAppKey(xAppKey string) ApiGetAuthorizerLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAuthorizerLOVRequest) XHotelid(xHotelid string) ApiGetAuthorizerLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAuthorizerLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAuthorizerLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAuthorizerLOVRequest) ParameterName(parameterName []string) ApiGetAuthorizerLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAuthorizerLOVRequest) ParameterValue(parameterValue []string) ApiGetAuthorizerLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAuthorizerLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAuthorizerLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAuthorizerLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAuthorizerLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAuthorizerLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAuthorizerLOVExecute(r)
}

/*
GetAuthorizerLOV Fetch List Of Values for Authorizer

 <p><strong>OperationId:</strong>getAuthorizerLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Authorizer LOV
 @return ApiGetAuthorizerLOVRequest
*/
func (a *LOVApiService) GetAuthorizerLOV(ctx context.Context, hotelId string) ApiGetAuthorizerLOVRequest {
	return ApiGetAuthorizerLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAuthorizerLOVExecute(r ApiGetAuthorizerLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAuthorizerLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/authorizer"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutoNumberGeneratorLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	number string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAutoNumberGeneratorLOVRequest) Authorization(authorization string) ApiGetAutoNumberGeneratorLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAutoNumberGeneratorLOVRequest) XAppKey(xAppKey string) ApiGetAutoNumberGeneratorLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAutoNumberGeneratorLOVRequest) XHotelid(xHotelid string) ApiGetAutoNumberGeneratorLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAutoNumberGeneratorLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAutoNumberGeneratorLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAutoNumberGeneratorLOVRequest) ParameterName(parameterName []string) ApiGetAutoNumberGeneratorLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAutoNumberGeneratorLOVRequest) ParameterValue(parameterValue []string) ApiGetAutoNumberGeneratorLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAutoNumberGeneratorLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAutoNumberGeneratorLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAutoNumberGeneratorLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAutoNumberGeneratorLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAutoNumberGeneratorLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAutoNumberGeneratorLOVExecute(r)
}

/*
GetAutoNumberGeneratorLOV Fetch List Of Values for Auto Number Generator

 <p><strong>OperationId:</strong>getAutoNumberGeneratorLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param number Value of the parameter 'number' which is required to fetch AutoNumberGenerator LOV
 @return ApiGetAutoNumberGeneratorLOVRequest
*/
func (a *LOVApiService) GetAutoNumberGeneratorLOV(ctx context.Context, number string) ApiGetAutoNumberGeneratorLOVRequest {
	return ApiGetAutoNumberGeneratorLOVRequest{
		ApiService: a,
		ctx: ctx,
		number: number,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAutoNumberGeneratorLOVExecute(r ApiGetAutoNumberGeneratorLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAutoNumberGeneratorLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/number/{number}/autoNumberGenerator"
	localVarPath = strings.Replace(localVarPath, "{"+"number"+"}", url.PathEscape(parameterValueToString(r.number, "number")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.number) < 1 {
		return localVarReturnValue, nil, reportError("number must have at least 1 elements")
	}
	if strlen(r.number) > 2000 {
		return localVarReturnValue, nil, reportError("number must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutoTraceExpressionFieldsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	traceGroup string
	tableName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAutoTraceExpressionFieldsLOVRequest) Authorization(authorization string) ApiGetAutoTraceExpressionFieldsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAutoTraceExpressionFieldsLOVRequest) XAppKey(xAppKey string) ApiGetAutoTraceExpressionFieldsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAutoTraceExpressionFieldsLOVRequest) XHotelid(xHotelid string) ApiGetAutoTraceExpressionFieldsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAutoTraceExpressionFieldsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAutoTraceExpressionFieldsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAutoTraceExpressionFieldsLOVRequest) ParameterName(parameterName []string) ApiGetAutoTraceExpressionFieldsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAutoTraceExpressionFieldsLOVRequest) ParameterValue(parameterValue []string) ApiGetAutoTraceExpressionFieldsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAutoTraceExpressionFieldsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAutoTraceExpressionFieldsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAutoTraceExpressionFieldsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAutoTraceExpressionFieldsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAutoTraceExpressionFieldsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAutoTraceExpressionFieldsLOVExecute(r)
}

/*
GetAutoTraceExpressionFieldsLOV Fetch List Of Values for Auto Trace Expression Fields

 <p><strong>OperationId:</strong>getAutoTraceExpressionFieldsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param traceGroup Value of the parameter 'traceGroup' which is required to fetch AutoTraceExpressionFields LOV
 @param tableName Value of the parameter 'tableName' which is required to fetch AutoTraceExpressionFields LOV
 @return ApiGetAutoTraceExpressionFieldsLOVRequest
*/
func (a *LOVApiService) GetAutoTraceExpressionFieldsLOV(ctx context.Context, traceGroup string, tableName string) ApiGetAutoTraceExpressionFieldsLOVRequest {
	return ApiGetAutoTraceExpressionFieldsLOVRequest{
		ApiService: a,
		ctx: ctx,
		traceGroup: traceGroup,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAutoTraceExpressionFieldsLOVExecute(r ApiGetAutoTraceExpressionFieldsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAutoTraceExpressionFieldsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/tableName/{tableName}/traceGroup/{traceGroup}/autoTraceExpressionFields"
	localVarPath = strings.Replace(localVarPath, "{"+"traceGroup"+"}", url.PathEscape(parameterValueToString(r.traceGroup, "traceGroup")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.traceGroup) < 1 {
		return localVarReturnValue, nil, reportError("traceGroup must have at least 1 elements")
	}
	if strlen(r.traceGroup) > 2000 {
		return localVarReturnValue, nil, reportError("traceGroup must have less than 2000 elements")
	}
	if strlen(r.tableName) < 1 {
		return localVarReturnValue, nil, reportError("tableName must have at least 1 elements")
	}
	if strlen(r.tableName) > 2000 {
		return localVarReturnValue, nil, reportError("tableName must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvailableExportTemplatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fileGroup string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAvailableExportTemplatesLOVRequest) Authorization(authorization string) ApiGetAvailableExportTemplatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAvailableExportTemplatesLOVRequest) XAppKey(xAppKey string) ApiGetAvailableExportTemplatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAvailableExportTemplatesLOVRequest) XHotelid(xHotelid string) ApiGetAvailableExportTemplatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAvailableExportTemplatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAvailableExportTemplatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAvailableExportTemplatesLOVRequest) ParameterName(parameterName []string) ApiGetAvailableExportTemplatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAvailableExportTemplatesLOVRequest) ParameterValue(parameterValue []string) ApiGetAvailableExportTemplatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAvailableExportTemplatesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAvailableExportTemplatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAvailableExportTemplatesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAvailableExportTemplatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAvailableExportTemplatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAvailableExportTemplatesLOVExecute(r)
}

/*
GetAvailableExportTemplatesLOV Fetch List Of Values for Available Export Templates

 <p><strong>OperationId:</strong>getAvailableExportTemplatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileGroup Value of the parameter 'fileGroup' which is required to fetch AvailableExportTemplates LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AvailableExportTemplates LOV
 @return ApiGetAvailableExportTemplatesLOVRequest
*/
func (a *LOVApiService) GetAvailableExportTemplatesLOV(ctx context.Context, fileGroup string, hotelId string) ApiGetAvailableExportTemplatesLOVRequest {
	return ApiGetAvailableExportTemplatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		fileGroup: fileGroup,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAvailableExportTemplatesLOVExecute(r ApiGetAvailableExportTemplatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAvailableExportTemplatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fileGroup/{fileGroup}/availableExportTemplates"
	localVarPath = strings.Replace(localVarPath, "{"+"fileGroup"+"}", url.PathEscape(parameterValueToString(r.fileGroup, "fileGroup")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fileGroup) < 1 {
		return localVarReturnValue, nil, reportError("fileGroup must have at least 1 elements")
	}
	if strlen(r.fileGroup) > 2000 {
		return localVarReturnValue, nil, reportError("fileGroup must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvailableProfileOwnerRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAvailableProfileOwnerRoomsLOVRequest) Authorization(authorization string) ApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAvailableProfileOwnerRoomsLOVRequest) XAppKey(xAppKey string) ApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAvailableProfileOwnerRoomsLOVRequest) XHotelid(xHotelid string) ApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAvailableProfileOwnerRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAvailableProfileOwnerRoomsLOVRequest) ParameterName(parameterName []string) ApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAvailableProfileOwnerRoomsLOVRequest) ParameterValue(parameterValue []string) ApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAvailableProfileOwnerRoomsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAvailableProfileOwnerRoomsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAvailableProfileOwnerRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAvailableProfileOwnerRoomsLOVExecute(r)
}

/*
GetAvailableProfileOwnerRoomsLOV Fetch List Of Values for Available Profile Owner Rooms

 <p><strong>OperationId:</strong>getAvailableProfileOwnerRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AvailableProfileOwnerRooms LOV
 @return ApiGetAvailableProfileOwnerRoomsLOVRequest
*/
func (a *LOVApiService) GetAvailableProfileOwnerRoomsLOV(ctx context.Context, hotelId string) ApiGetAvailableProfileOwnerRoomsLOVRequest {
	return ApiGetAvailableProfileOwnerRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAvailableProfileOwnerRoomsLOVExecute(r ApiGetAvailableProfileOwnerRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAvailableProfileOwnerRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/availableProfileOwnerRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvailableRoomComponentsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomNumber string
	roomType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAvailableRoomComponentsLOVRequest) Authorization(authorization string) ApiGetAvailableRoomComponentsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAvailableRoomComponentsLOVRequest) XAppKey(xAppKey string) ApiGetAvailableRoomComponentsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAvailableRoomComponentsLOVRequest) XHotelid(xHotelid string) ApiGetAvailableRoomComponentsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAvailableRoomComponentsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAvailableRoomComponentsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAvailableRoomComponentsLOVRequest) ParameterName(parameterName []string) ApiGetAvailableRoomComponentsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAvailableRoomComponentsLOVRequest) ParameterValue(parameterValue []string) ApiGetAvailableRoomComponentsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAvailableRoomComponentsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAvailableRoomComponentsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAvailableRoomComponentsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAvailableRoomComponentsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAvailableRoomComponentsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAvailableRoomComponentsLOVExecute(r)
}

/*
GetAvailableRoomComponentsLOV Fetch List Of Values for Available Room Components

 <p><strong>OperationId:</strong>getAvailableRoomComponentsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomNumber Value of the parameter 'roomNumber' which is required to fetch AvailableRoomComponents LOV
 @param roomType Value of the parameter 'roomType' which is required to fetch AvailableRoomComponents LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AvailableRoomComponents LOV
 @return ApiGetAvailableRoomComponentsLOVRequest
*/
func (a *LOVApiService) GetAvailableRoomComponentsLOV(ctx context.Context, roomNumber string, roomType string, hotelId string) ApiGetAvailableRoomComponentsLOVRequest {
	return ApiGetAvailableRoomComponentsLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomNumber: roomNumber,
		roomType: roomType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAvailableRoomComponentsLOVExecute(r ApiGetAvailableRoomComponentsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAvailableRoomComponentsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomType/{roomType}/roomNumber/{roomNumber}/availableRoomComponents"
	localVarPath = strings.Replace(localVarPath, "{"+"roomNumber"+"}", url.PathEscape(parameterValueToString(r.roomNumber, "roomNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roomType"+"}", url.PathEscape(parameterValueToString(r.roomType, "roomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomNumber) < 1 {
		return localVarReturnValue, nil, reportError("roomNumber must have at least 1 elements")
	}
	if strlen(r.roomNumber) > 2000 {
		return localVarReturnValue, nil, reportError("roomNumber must have less than 2000 elements")
	}
	if strlen(r.roomType) < 1 {
		return localVarReturnValue, nil, reportError("roomType must have at least 1 elements")
	}
	if strlen(r.roomType) > 2000 {
		return localVarReturnValue, nil, reportError("roomType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvailableRoomTypeComponentsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAvailableRoomTypeComponentsLOVRequest) Authorization(authorization string) ApiGetAvailableRoomTypeComponentsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAvailableRoomTypeComponentsLOVRequest) XAppKey(xAppKey string) ApiGetAvailableRoomTypeComponentsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAvailableRoomTypeComponentsLOVRequest) XHotelid(xHotelid string) ApiGetAvailableRoomTypeComponentsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAvailableRoomTypeComponentsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAvailableRoomTypeComponentsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAvailableRoomTypeComponentsLOVRequest) ParameterName(parameterName []string) ApiGetAvailableRoomTypeComponentsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAvailableRoomTypeComponentsLOVRequest) ParameterValue(parameterValue []string) ApiGetAvailableRoomTypeComponentsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAvailableRoomTypeComponentsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAvailableRoomTypeComponentsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAvailableRoomTypeComponentsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAvailableRoomTypeComponentsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAvailableRoomTypeComponentsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAvailableRoomTypeComponentsLOVExecute(r)
}

/*
GetAvailableRoomTypeComponentsLOV Fetch List Of Values for Available Room Type Components

 <p><strong>OperationId:</strong>getAvailableRoomTypeComponentsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomType Value of the parameter 'roomType' which is required to fetch AvailableRoomTypeComponents LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AvailableRoomTypeComponents LOV
 @return ApiGetAvailableRoomTypeComponentsLOVRequest
*/
func (a *LOVApiService) GetAvailableRoomTypeComponentsLOV(ctx context.Context, roomType string, hotelId string) ApiGetAvailableRoomTypeComponentsLOVRequest {
	return ApiGetAvailableRoomTypeComponentsLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomType: roomType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAvailableRoomTypeComponentsLOVExecute(r ApiGetAvailableRoomTypeComponentsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAvailableRoomTypeComponentsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomType/{roomType}/availableRoomTypeComponents"
	localVarPath = strings.Replace(localVarPath, "{"+"roomType"+"}", url.PathEscape(parameterValueToString(r.roomType, "roomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomType) < 1 {
		return localVarReturnValue, nil, reportError("roomType must have at least 1 elements")
	}
	if strlen(r.roomType) > 2000 {
		return localVarReturnValue, nil, reportError("roomType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvailableScriptLanguagesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAvailableScriptLanguagesLOVRequest) Authorization(authorization string) ApiGetAvailableScriptLanguagesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAvailableScriptLanguagesLOVRequest) XAppKey(xAppKey string) ApiGetAvailableScriptLanguagesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAvailableScriptLanguagesLOVRequest) XHotelid(xHotelid string) ApiGetAvailableScriptLanguagesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAvailableScriptLanguagesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAvailableScriptLanguagesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAvailableScriptLanguagesLOVRequest) ParameterName(parameterName []string) ApiGetAvailableScriptLanguagesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAvailableScriptLanguagesLOVRequest) ParameterValue(parameterValue []string) ApiGetAvailableScriptLanguagesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAvailableScriptLanguagesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAvailableScriptLanguagesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAvailableScriptLanguagesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAvailableScriptLanguagesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAvailableScriptLanguagesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAvailableScriptLanguagesLOVExecute(r)
}

/*
GetAvailableScriptLanguagesLOV Fetch List Of Values for Available Script Languages

 <p><strong>OperationId:</strong>getAvailableScriptLanguagesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AvailableScriptLanguages LOV
 @return ApiGetAvailableScriptLanguagesLOVRequest
*/
func (a *LOVApiService) GetAvailableScriptLanguagesLOV(ctx context.Context, hotelId string) ApiGetAvailableScriptLanguagesLOVRequest {
	return ApiGetAvailableScriptLanguagesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAvailableScriptLanguagesLOVExecute(r ApiGetAvailableScriptLanguagesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAvailableScriptLanguagesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/availableScriptLanguages"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAwardCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAwardCodesLOVRequest) Authorization(authorization string) ApiGetAwardCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAwardCodesLOVRequest) XAppKey(xAppKey string) ApiGetAwardCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAwardCodesLOVRequest) XHotelid(xHotelid string) ApiGetAwardCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAwardCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAwardCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAwardCodesLOVRequest) ParameterName(parameterName []string) ApiGetAwardCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAwardCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetAwardCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAwardCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAwardCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAwardCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAwardCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAwardCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAwardCodesLOVExecute(r)
}

/*
GetAwardCodesLOV Fetch List Of Values for Award Codes

 <p><strong>OperationId:</strong>getAwardCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AwardCodes LOV
 @return ApiGetAwardCodesLOVRequest
*/
func (a *LOVApiService) GetAwardCodesLOV(ctx context.Context, hotelId string) ApiGetAwardCodesLOVRequest {
	return ApiGetAwardCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAwardCodesLOVExecute(r ApiGetAwardCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAwardCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/awardCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAwardCodesMultiHotelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAwardCodesMultiHotelLOVRequest) Authorization(authorization string) ApiGetAwardCodesMultiHotelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAwardCodesMultiHotelLOVRequest) XAppKey(xAppKey string) ApiGetAwardCodesMultiHotelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAwardCodesMultiHotelLOVRequest) XHotelid(xHotelid string) ApiGetAwardCodesMultiHotelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAwardCodesMultiHotelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAwardCodesMultiHotelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAwardCodesMultiHotelLOVRequest) ParameterName(parameterName []string) ApiGetAwardCodesMultiHotelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAwardCodesMultiHotelLOVRequest) ParameterValue(parameterValue []string) ApiGetAwardCodesMultiHotelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAwardCodesMultiHotelLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAwardCodesMultiHotelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAwardCodesMultiHotelLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAwardCodesMultiHotelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAwardCodesMultiHotelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAwardCodesMultiHotelLOVExecute(r)
}

/*
GetAwardCodesMultiHotelLOV Fetch List Of Values for Award Codes Multi Hotel

 <p><strong>OperationId:</strong>getAwardCodesMultiHotelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AwardCodesMultiHotel LOV
 @return ApiGetAwardCodesMultiHotelLOVRequest
*/
func (a *LOVApiService) GetAwardCodesMultiHotelLOV(ctx context.Context, hotelId string) ApiGetAwardCodesMultiHotelLOVRequest {
	return ApiGetAwardCodesMultiHotelLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAwardCodesMultiHotelLOVExecute(r ApiGetAwardCodesMultiHotelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAwardCodesMultiHotelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/awardCodesMultiHotel"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAwardMktgCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetAwardMktgCodesLOVRequest) Authorization(authorization string) ApiGetAwardMktgCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetAwardMktgCodesLOVRequest) XAppKey(xAppKey string) ApiGetAwardMktgCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetAwardMktgCodesLOVRequest) XHotelid(xHotelid string) ApiGetAwardMktgCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetAwardMktgCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetAwardMktgCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetAwardMktgCodesLOVRequest) ParameterName(parameterName []string) ApiGetAwardMktgCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetAwardMktgCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetAwardMktgCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetAwardMktgCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetAwardMktgCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetAwardMktgCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetAwardMktgCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetAwardMktgCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAwardMktgCodesLOVExecute(r)
}

/*
GetAwardMktgCodesLOV Fetch List Of Values for Award Mktg Codes

 <p><strong>OperationId:</strong>getAwardMktgCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AwardMktgCodes LOV
 @return ApiGetAwardMktgCodesLOVRequest
*/
func (a *LOVApiService) GetAwardMktgCodesLOV(ctx context.Context, hotelId string) ApiGetAwardMktgCodesLOVRequest {
	return ApiGetAwardMktgCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAwardMktgCodesLOVExecute(r ApiGetAwardMktgCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAwardMktgCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/awardMktgCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankAccountsForReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBankAccountsForReportsLOVRequest) Authorization(authorization string) ApiGetBankAccountsForReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBankAccountsForReportsLOVRequest) XAppKey(xAppKey string) ApiGetBankAccountsForReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBankAccountsForReportsLOVRequest) XHotelid(xHotelid string) ApiGetBankAccountsForReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBankAccountsForReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBankAccountsForReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBankAccountsForReportsLOVRequest) ParameterName(parameterName []string) ApiGetBankAccountsForReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBankAccountsForReportsLOVRequest) ParameterValue(parameterValue []string) ApiGetBankAccountsForReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBankAccountsForReportsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBankAccountsForReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBankAccountsForReportsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBankAccountsForReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBankAccountsForReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBankAccountsForReportsLOVExecute(r)
}

/*
GetBankAccountsForReportsLOV Fetch List Of Values for Bank Accounts For Reports

 <p><strong>OperationId:</strong>getBankAccountsForReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BankAccountsForReports LOV
 @return ApiGetBankAccountsForReportsLOVRequest
*/
func (a *LOVApiService) GetBankAccountsForReportsLOV(ctx context.Context, hotelId string) ApiGetBankAccountsForReportsLOVRequest {
	return ApiGetBankAccountsForReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBankAccountsForReportsLOVExecute(r ApiGetBankAccountsForReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBankAccountsForReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/bankAccountsForReports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankAccountsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBankAccountsLOVRequest) Authorization(authorization string) ApiGetBankAccountsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBankAccountsLOVRequest) XAppKey(xAppKey string) ApiGetBankAccountsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBankAccountsLOVRequest) XHotelid(xHotelid string) ApiGetBankAccountsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBankAccountsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBankAccountsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBankAccountsLOVRequest) ParameterName(parameterName []string) ApiGetBankAccountsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBankAccountsLOVRequest) ParameterValue(parameterValue []string) ApiGetBankAccountsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBankAccountsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBankAccountsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBankAccountsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBankAccountsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBankAccountsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBankAccountsLOVExecute(r)
}

/*
GetBankAccountsLOV Fetch List Of Values for Bank Accounts

 <p><strong>OperationId:</strong>getBankAccountsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BankAccounts LOV
 @return ApiGetBankAccountsLOVRequest
*/
func (a *LOVApiService) GetBankAccountsLOV(ctx context.Context, hotelId string) ApiGetBankAccountsLOVRequest {
	return ApiGetBankAccountsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBankAccountsLOVExecute(r ApiGetBankAccountsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBankAccountsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/bankAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBanquetPrintingMethodLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBanquetPrintingMethodLOVRequest) Authorization(authorization string) ApiGetBanquetPrintingMethodLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBanquetPrintingMethodLOVRequest) XAppKey(xAppKey string) ApiGetBanquetPrintingMethodLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBanquetPrintingMethodLOVRequest) XHotelid(xHotelid string) ApiGetBanquetPrintingMethodLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBanquetPrintingMethodLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBanquetPrintingMethodLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBanquetPrintingMethodLOVRequest) ParameterName(parameterName []string) ApiGetBanquetPrintingMethodLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBanquetPrintingMethodLOVRequest) ParameterValue(parameterValue []string) ApiGetBanquetPrintingMethodLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBanquetPrintingMethodLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBanquetPrintingMethodLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBanquetPrintingMethodLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBanquetPrintingMethodLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBanquetPrintingMethodLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBanquetPrintingMethodLOVExecute(r)
}

/*
GetBanquetPrintingMethodLOV Fetch List Of Values for Banquet Printing Method

 <p><strong>OperationId:</strong>getBanquetPrintingMethodLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BanquetPrintingMethod LOV
 @return ApiGetBanquetPrintingMethodLOVRequest
*/
func (a *LOVApiService) GetBanquetPrintingMethodLOV(ctx context.Context, hotelId string) ApiGetBanquetPrintingMethodLOVRequest {
	return ApiGetBanquetPrintingMethodLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBanquetPrintingMethodLOVExecute(r ApiGetBanquetPrintingMethodLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBanquetPrintingMethodLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/banquetPrintingMethod"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBillingInstructionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBillingInstructionsLOVRequest) Authorization(authorization string) ApiGetBillingInstructionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBillingInstructionsLOVRequest) XAppKey(xAppKey string) ApiGetBillingInstructionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBillingInstructionsLOVRequest) XHotelid(xHotelid string) ApiGetBillingInstructionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBillingInstructionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBillingInstructionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBillingInstructionsLOVRequest) ParameterName(parameterName []string) ApiGetBillingInstructionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBillingInstructionsLOVRequest) ParameterValue(parameterValue []string) ApiGetBillingInstructionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBillingInstructionsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBillingInstructionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBillingInstructionsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBillingInstructionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBillingInstructionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBillingInstructionsLOVExecute(r)
}

/*
GetBillingInstructionsLOV Fetch List Of Values for Billing Instructions

 <p><strong>OperationId:</strong>getBillingInstructionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BillingInstructions LOV
 @return ApiGetBillingInstructionsLOVRequest
*/
func (a *LOVApiService) GetBillingInstructionsLOV(ctx context.Context, hotelId string) ApiGetBillingInstructionsLOVRequest {
	return ApiGetBillingInstructionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBillingInstructionsLOVExecute(r ApiGetBillingInstructionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBillingInstructionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/billingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockBookingStatusesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockBookingStatusesLOVRequest) Authorization(authorization string) ApiGetBlockBookingStatusesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockBookingStatusesLOVRequest) XAppKey(xAppKey string) ApiGetBlockBookingStatusesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockBookingStatusesLOVRequest) XHotelid(xHotelid string) ApiGetBlockBookingStatusesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockBookingStatusesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockBookingStatusesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockBookingStatusesLOVRequest) ParameterName(parameterName []string) ApiGetBlockBookingStatusesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockBookingStatusesLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockBookingStatusesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockBookingStatusesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockBookingStatusesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockBookingStatusesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockBookingStatusesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockBookingStatusesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockBookingStatusesLOVExecute(r)
}

/*
GetBlockBookingStatusesLOV Fetch List Of Values for Block Booking Statuses

 <p><strong>OperationId:</strong>getBlockBookingStatusesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Value of the parameter 'blockId' which is required to fetch BlockBookingStatuses LOV
 @return ApiGetBlockBookingStatusesLOVRequest
*/
func (a *LOVApiService) GetBlockBookingStatusesLOV(ctx context.Context, blockId string) ApiGetBlockBookingStatusesLOVRequest {
	return ApiGetBlockBookingStatusesLOVRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockBookingStatusesLOVExecute(r ApiGetBlockBookingStatusesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockBookingStatusesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/blockId/{blockId}/blockBookingStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockCatNextStatusesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	catStatus string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockCatNextStatusesLOVRequest) Authorization(authorization string) ApiGetBlockCatNextStatusesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockCatNextStatusesLOVRequest) XAppKey(xAppKey string) ApiGetBlockCatNextStatusesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockCatNextStatusesLOVRequest) XHotelid(xHotelid string) ApiGetBlockCatNextStatusesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockCatNextStatusesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockCatNextStatusesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockCatNextStatusesLOVRequest) ParameterName(parameterName []string) ApiGetBlockCatNextStatusesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockCatNextStatusesLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockCatNextStatusesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockCatNextStatusesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockCatNextStatusesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockCatNextStatusesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockCatNextStatusesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockCatNextStatusesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockCatNextStatusesLOVExecute(r)
}

/*
GetBlockCatNextStatusesLOV Fetch List Of Values for Block Cat Next Statuses

 <p><strong>OperationId:</strong>getBlockCatNextStatusesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catStatus Value of the parameter 'catStatus' which is required to fetch BlockCatNextStatuses LOV
 @return ApiGetBlockCatNextStatusesLOVRequest
*/
func (a *LOVApiService) GetBlockCatNextStatusesLOV(ctx context.Context, catStatus string) ApiGetBlockCatNextStatusesLOVRequest {
	return ApiGetBlockCatNextStatusesLOVRequest{
		ApiService: a,
		ctx: ctx,
		catStatus: catStatus,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockCatNextStatusesLOVExecute(r ApiGetBlockCatNextStatusesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockCatNextStatusesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/catStatus/{catStatus}/blockCatNextStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"catStatus"+"}", url.PathEscape(parameterValueToString(r.catStatus, "catStatus")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catStatus) < 1 {
		return localVarReturnValue, nil, reportError("catStatus must have at least 1 elements")
	}
	if strlen(r.catStatus) > 2000 {
		return localVarReturnValue, nil, reportError("catStatus must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockCodesByArrivalDateLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	arrivalDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockCodesByArrivalDateLOVRequest) Authorization(authorization string) ApiGetBlockCodesByArrivalDateLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockCodesByArrivalDateLOVRequest) XAppKey(xAppKey string) ApiGetBlockCodesByArrivalDateLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockCodesByArrivalDateLOVRequest) XHotelid(xHotelid string) ApiGetBlockCodesByArrivalDateLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockCodesByArrivalDateLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockCodesByArrivalDateLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockCodesByArrivalDateLOVRequest) ParameterName(parameterName []string) ApiGetBlockCodesByArrivalDateLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockCodesByArrivalDateLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockCodesByArrivalDateLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockCodesByArrivalDateLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockCodesByArrivalDateLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockCodesByArrivalDateLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockCodesByArrivalDateLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockCodesByArrivalDateLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockCodesByArrivalDateLOVExecute(r)
}

/*
GetBlockCodesByArrivalDateLOV Fetch List Of Values for Block Codes By Arrival Date

 <p><strong>OperationId:</strong>getBlockCodesByArrivalDateLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param arrivalDate Value of the parameter 'arrivalDate' which is required to fetch BlockCodesByArrivalDate LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockCodesByArrivalDate LOV
 @return ApiGetBlockCodesByArrivalDateLOVRequest
*/
func (a *LOVApiService) GetBlockCodesByArrivalDateLOV(ctx context.Context, arrivalDate string, hotelId string) ApiGetBlockCodesByArrivalDateLOVRequest {
	return ApiGetBlockCodesByArrivalDateLOVRequest{
		ApiService: a,
		ctx: ctx,
		arrivalDate: arrivalDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockCodesByArrivalDateLOVExecute(r ApiGetBlockCodesByArrivalDateLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockCodesByArrivalDateLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arrivalDate/{arrivalDate}/blockCodesByArrivalDate"
	localVarPath = strings.Replace(localVarPath, "{"+"arrivalDate"+"}", url.PathEscape(parameterValueToString(r.arrivalDate, "arrivalDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.arrivalDate) < 1 {
		return localVarReturnValue, nil, reportError("arrivalDate must have at least 1 elements")
	}
	if strlen(r.arrivalDate) > 2000 {
		return localVarReturnValue, nil, reportError("arrivalDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockCodesFinOperationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockCodesFinOperationsLOVRequest) Authorization(authorization string) ApiGetBlockCodesFinOperationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockCodesFinOperationsLOVRequest) XAppKey(xAppKey string) ApiGetBlockCodesFinOperationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockCodesFinOperationsLOVRequest) XHotelid(xHotelid string) ApiGetBlockCodesFinOperationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockCodesFinOperationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockCodesFinOperationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockCodesFinOperationsLOVRequest) ParameterName(parameterName []string) ApiGetBlockCodesFinOperationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockCodesFinOperationsLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockCodesFinOperationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockCodesFinOperationsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockCodesFinOperationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockCodesFinOperationsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockCodesFinOperationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockCodesFinOperationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockCodesFinOperationsLOVExecute(r)
}

/*
GetBlockCodesFinOperationsLOV Fetch List Of Values for Block Codes Fin Operations

 <p><strong>OperationId:</strong>getBlockCodesFinOperationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockCodesFinOperations LOV
 @return ApiGetBlockCodesFinOperationsLOVRequest
*/
func (a *LOVApiService) GetBlockCodesFinOperationsLOV(ctx context.Context, hotelId string) ApiGetBlockCodesFinOperationsLOVRequest {
	return ApiGetBlockCodesFinOperationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockCodesFinOperationsLOVExecute(r ApiGetBlockCodesFinOperationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockCodesFinOperationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/blockCodesFinOperations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	endDate string
	beginDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockCodesLOVRequest) Authorization(authorization string) ApiGetBlockCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockCodesLOVRequest) XAppKey(xAppKey string) ApiGetBlockCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockCodesLOVRequest) XHotelid(xHotelid string) ApiGetBlockCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockCodesLOVRequest) ParameterName(parameterName []string) ApiGetBlockCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockCodesLOVExecute(r)
}

/*
GetBlockCodesLOV Fetch List Of Values for Block Codes

 <p><strong>OperationId:</strong>getBlockCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endDate Value of the parameter 'endDate' which is required to fetch BlockCodes LOV
 @param beginDate Value of the parameter 'beginDate' which is required to fetch BlockCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockCodes LOV
 @return ApiGetBlockCodesLOVRequest
*/
func (a *LOVApiService) GetBlockCodesLOV(ctx context.Context, endDate string, beginDate string, hotelId string) ApiGetBlockCodesLOVRequest {
	return ApiGetBlockCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		endDate: endDate,
		beginDate: beginDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockCodesLOVExecute(r ApiGetBlockCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/beginDate/{beginDate}/endDate/{endDate}/blockCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"endDate"+"}", url.PathEscape(parameterValueToString(r.endDate, "endDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"beginDate"+"}", url.PathEscape(parameterValueToString(r.beginDate, "beginDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.endDate) < 1 {
		return localVarReturnValue, nil, reportError("endDate must have at least 1 elements")
	}
	if strlen(r.endDate) > 2000 {
		return localVarReturnValue, nil, reportError("endDate must have less than 2000 elements")
	}
	if strlen(r.beginDate) < 1 {
		return localVarReturnValue, nil, reportError("beginDate must have at least 1 elements")
	}
	if strlen(r.beginDate) > 2000 {
		return localVarReturnValue, nil, reportError("beginDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockCurrentStatusesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockCurrentStatusesLOVRequest) Authorization(authorization string) ApiGetBlockCurrentStatusesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockCurrentStatusesLOVRequest) XAppKey(xAppKey string) ApiGetBlockCurrentStatusesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockCurrentStatusesLOVRequest) XHotelid(xHotelid string) ApiGetBlockCurrentStatusesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockCurrentStatusesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockCurrentStatusesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockCurrentStatusesLOVRequest) ParameterName(parameterName []string) ApiGetBlockCurrentStatusesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockCurrentStatusesLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockCurrentStatusesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockCurrentStatusesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockCurrentStatusesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockCurrentStatusesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockCurrentStatusesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockCurrentStatusesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockCurrentStatusesLOVExecute(r)
}

/*
GetBlockCurrentStatusesLOV Fetch List Of Values for Block Current Statuses

 <p><strong>OperationId:</strong>getBlockCurrentStatusesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Value of the parameter 'blockId' which is required to fetch BlockCurrentStatuses LOV
 @return ApiGetBlockCurrentStatusesLOVRequest
*/
func (a *LOVApiService) GetBlockCurrentStatusesLOV(ctx context.Context, blockId string) ApiGetBlockCurrentStatusesLOVRequest {
	return ApiGetBlockCurrentStatusesLOVRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockCurrentStatusesLOVExecute(r ApiGetBlockCurrentStatusesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockCurrentStatusesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/blockId/{blockId}/blockCurrentStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockEventIdsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockEventIdsLOVRequest) Authorization(authorization string) ApiGetBlockEventIdsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockEventIdsLOVRequest) XAppKey(xAppKey string) ApiGetBlockEventIdsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockEventIdsLOVRequest) XHotelid(xHotelid string) ApiGetBlockEventIdsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockEventIdsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockEventIdsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockEventIdsLOVRequest) ParameterName(parameterName []string) ApiGetBlockEventIdsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockEventIdsLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockEventIdsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockEventIdsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockEventIdsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockEventIdsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockEventIdsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockEventIdsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockEventIdsLOVExecute(r)
}

/*
GetBlockEventIdsLOV Fetch List Of Values for Block Event Ids

 <p><strong>OperationId:</strong>getBlockEventIdsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Value of the parameter 'blockId' which is required to fetch BlockEventIds LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockEventIds LOV
 @return ApiGetBlockEventIdsLOVRequest
*/
func (a *LOVApiService) GetBlockEventIdsLOV(ctx context.Context, blockId string, hotelId string) ApiGetBlockEventIdsLOVRequest {
	return ApiGetBlockEventIdsLOVRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockEventIdsLOVExecute(r ApiGetBlockEventIdsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockEventIdsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/blockId/{blockId}/blockEventIds"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockEventsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockEventsLOVRequest) Authorization(authorization string) ApiGetBlockEventsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockEventsLOVRequest) XAppKey(xAppKey string) ApiGetBlockEventsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockEventsLOVRequest) XHotelid(xHotelid string) ApiGetBlockEventsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockEventsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockEventsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockEventsLOVRequest) ParameterName(parameterName []string) ApiGetBlockEventsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockEventsLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockEventsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockEventsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockEventsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockEventsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockEventsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockEventsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockEventsLOVExecute(r)
}

/*
GetBlockEventsLOV Fetch List Of Values for Block Events

 <p><strong>OperationId:</strong>getBlockEventsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockEvents LOV
 @return ApiGetBlockEventsLOVRequest
*/
func (a *LOVApiService) GetBlockEventsLOV(ctx context.Context, hotelId string) ApiGetBlockEventsLOVRequest {
	return ApiGetBlockEventsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockEventsLOVExecute(r ApiGetBlockEventsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockEventsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/blockEvents"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockIdsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	endDate string
	beginDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockIdsLOVRequest) Authorization(authorization string) ApiGetBlockIdsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockIdsLOVRequest) XAppKey(xAppKey string) ApiGetBlockIdsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockIdsLOVRequest) XHotelid(xHotelid string) ApiGetBlockIdsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockIdsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockIdsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockIdsLOVRequest) ParameterName(parameterName []string) ApiGetBlockIdsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockIdsLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockIdsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockIdsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockIdsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockIdsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockIdsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockIdsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockIdsLOVExecute(r)
}

/*
GetBlockIdsLOV Fetch List Of Values for Block Ids

 <p><strong>OperationId:</strong>getBlockIdsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endDate Value of the parameter 'endDate' which is required to fetch BlockIds LOV
 @param beginDate Value of the parameter 'beginDate' which is required to fetch BlockIds LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockIds LOV
 @return ApiGetBlockIdsLOVRequest
*/
func (a *LOVApiService) GetBlockIdsLOV(ctx context.Context, endDate string, beginDate string, hotelId string) ApiGetBlockIdsLOVRequest {
	return ApiGetBlockIdsLOVRequest{
		ApiService: a,
		ctx: ctx,
		endDate: endDate,
		beginDate: beginDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockIdsLOVExecute(r ApiGetBlockIdsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockIdsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/beginDate/{beginDate}/endDate/{endDate}/blockIds"
	localVarPath = strings.Replace(localVarPath, "{"+"endDate"+"}", url.PathEscape(parameterValueToString(r.endDate, "endDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"beginDate"+"}", url.PathEscape(parameterValueToString(r.beginDate, "beginDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.endDate) < 1 {
		return localVarReturnValue, nil, reportError("endDate must have at least 1 elements")
	}
	if strlen(r.endDate) > 2000 {
		return localVarReturnValue, nil, reportError("endDate must have less than 2000 elements")
	}
	if strlen(r.beginDate) < 1 {
		return localVarReturnValue, nil, reportError("beginDate must have at least 1 elements")
	}
	if strlen(r.beginDate) > 2000 {
		return localVarReturnValue, nil, reportError("beginDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockModeLovLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockModeLovLOVRequest) Authorization(authorization string) ApiGetBlockModeLovLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockModeLovLOVRequest) XAppKey(xAppKey string) ApiGetBlockModeLovLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockModeLovLOVRequest) XHotelid(xHotelid string) ApiGetBlockModeLovLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockModeLovLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockModeLovLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockModeLovLOVRequest) ParameterName(parameterName []string) ApiGetBlockModeLovLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockModeLovLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockModeLovLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockModeLovLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockModeLovLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockModeLovLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockModeLovLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockModeLovLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockModeLovLOVExecute(r)
}

/*
GetBlockModeLovLOV Fetch List Of Values for Block Mode Lov

 <p><strong>OperationId:</strong>getBlockModeLovLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockModeLov LOV
 @return ApiGetBlockModeLovLOVRequest
*/
func (a *LOVApiService) GetBlockModeLovLOV(ctx context.Context, hotelId string) ApiGetBlockModeLovLOVRequest {
	return ApiGetBlockModeLovLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockModeLovLOVExecute(r ApiGetBlockModeLovLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockModeLovLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/blockModeLov"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockNextStatusesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingStatus string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockNextStatusesLOVRequest) Authorization(authorization string) ApiGetBlockNextStatusesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockNextStatusesLOVRequest) XAppKey(xAppKey string) ApiGetBlockNextStatusesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockNextStatusesLOVRequest) XHotelid(xHotelid string) ApiGetBlockNextStatusesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockNextStatusesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockNextStatusesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockNextStatusesLOVRequest) ParameterName(parameterName []string) ApiGetBlockNextStatusesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockNextStatusesLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockNextStatusesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockNextStatusesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockNextStatusesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockNextStatusesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockNextStatusesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockNextStatusesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockNextStatusesLOVExecute(r)
}

/*
GetBlockNextStatusesLOV Fetch List Of Values for Block Next Statuses

 <p><strong>OperationId:</strong>getBlockNextStatusesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingStatus Value of the parameter 'bookingStatus' which is required to fetch BlockNextStatuses LOV
 @return ApiGetBlockNextStatusesLOVRequest
*/
func (a *LOVApiService) GetBlockNextStatusesLOV(ctx context.Context, bookingStatus string) ApiGetBlockNextStatusesLOVRequest {
	return ApiGetBlockNextStatusesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingStatus: bookingStatus,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockNextStatusesLOVExecute(r ApiGetBlockNextStatusesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockNextStatusesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingStatus/{bookingStatus}/blockNextStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingStatus"+"}", url.PathEscape(parameterValueToString(r.bookingStatus, "bookingStatus")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingStatus) < 1 {
		return localVarReturnValue, nil, reportError("bookingStatus must have at least 1 elements")
	}
	if strlen(r.bookingStatus) > 2000 {
		return localVarReturnValue, nil, reportError("bookingStatus must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockPaymentMethodsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockPaymentMethodsLOVRequest) Authorization(authorization string) ApiGetBlockPaymentMethodsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockPaymentMethodsLOVRequest) XAppKey(xAppKey string) ApiGetBlockPaymentMethodsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockPaymentMethodsLOVRequest) XHotelid(xHotelid string) ApiGetBlockPaymentMethodsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockPaymentMethodsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockPaymentMethodsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockPaymentMethodsLOVRequest) ParameterName(parameterName []string) ApiGetBlockPaymentMethodsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockPaymentMethodsLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockPaymentMethodsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockPaymentMethodsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockPaymentMethodsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockPaymentMethodsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockPaymentMethodsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockPaymentMethodsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockPaymentMethodsLOVExecute(r)
}

/*
GetBlockPaymentMethodsLOV Fetch List Of Values for Block Payment Methods

 <p><strong>OperationId:</strong>getBlockPaymentMethodsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockPaymentMethods LOV
 @return ApiGetBlockPaymentMethodsLOVRequest
*/
func (a *LOVApiService) GetBlockPaymentMethodsLOV(ctx context.Context, hotelId string) ApiGetBlockPaymentMethodsLOVRequest {
	return ApiGetBlockPaymentMethodsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockPaymentMethodsLOVExecute(r ApiGetBlockPaymentMethodsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockPaymentMethodsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/blockPaymentMethods"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	negotiatedOnly string
	endDate string
	beginDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockRateCodesLOVRequest) Authorization(authorization string) ApiGetBlockRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockRateCodesLOVRequest) XAppKey(xAppKey string) ApiGetBlockRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockRateCodesLOVRequest) XHotelid(xHotelid string) ApiGetBlockRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockRateCodesLOVRequest) ParameterName(parameterName []string) ApiGetBlockRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockRateCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockRateCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockRateCodesLOVExecute(r)
}

/*
GetBlockRateCodesLOV Fetch List Of Values for Block Rate Codes

 <p><strong>OperationId:</strong>getBlockRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param negotiatedOnly Value of the parameter 'negotiatedOnly' which is required to fetch BlockRateCodes LOV
 @param endDate Value of the parameter 'endDate' which is required to fetch BlockRateCodes LOV
 @param beginDate Value of the parameter 'beginDate' which is required to fetch BlockRateCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockRateCodes LOV
 @return ApiGetBlockRateCodesLOVRequest
*/
func (a *LOVApiService) GetBlockRateCodesLOV(ctx context.Context, negotiatedOnly string, endDate string, beginDate string, hotelId string) ApiGetBlockRateCodesLOVRequest {
	return ApiGetBlockRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		negotiatedOnly: negotiatedOnly,
		endDate: endDate,
		beginDate: beginDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockRateCodesLOVExecute(r ApiGetBlockRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/beginDate/{beginDate}/endDate/{endDate}/negotiatedOnly/{negotiatedOnly}/blockRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"negotiatedOnly"+"}", url.PathEscape(parameterValueToString(r.negotiatedOnly, "negotiatedOnly")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endDate"+"}", url.PathEscape(parameterValueToString(r.endDate, "endDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"beginDate"+"}", url.PathEscape(parameterValueToString(r.beginDate, "beginDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.negotiatedOnly) < 1 {
		return localVarReturnValue, nil, reportError("negotiatedOnly must have at least 1 elements")
	}
	if strlen(r.negotiatedOnly) > 2000 {
		return localVarReturnValue, nil, reportError("negotiatedOnly must have less than 2000 elements")
	}
	if strlen(r.endDate) < 1 {
		return localVarReturnValue, nil, reportError("endDate must have at least 1 elements")
	}
	if strlen(r.endDate) > 2000 {
		return localVarReturnValue, nil, reportError("endDate must have less than 2000 elements")
	}
	if strlen(r.beginDate) < 1 {
		return localVarReturnValue, nil, reportError("beginDate must have at least 1 elements")
	}
	if strlen(r.beginDate) > 2000 {
		return localVarReturnValue, nil, reportError("beginDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockRatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	blockId string
	departure string
	arrival string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockRatesLOVRequest) Authorization(authorization string) ApiGetBlockRatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockRatesLOVRequest) XAppKey(xAppKey string) ApiGetBlockRatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockRatesLOVRequest) XHotelid(xHotelid string) ApiGetBlockRatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockRatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockRatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockRatesLOVRequest) ParameterName(parameterName []string) ApiGetBlockRatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockRatesLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockRatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockRatesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockRatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockRatesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockRatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockRatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockRatesLOVExecute(r)
}

/*
GetBlockRatesLOV Fetch List Of Values for Block Rates

 <p><strong>OperationId:</strong>getBlockRatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Value of the parameter 'blockId' which is required to fetch BlockRates LOV
 @param departure Value of the parameter 'departure' which is required to fetch BlockRates LOV
 @param arrival Value of the parameter 'arrival' which is required to fetch BlockRates LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockRates LOV
 @return ApiGetBlockRatesLOVRequest
*/
func (a *LOVApiService) GetBlockRatesLOV(ctx context.Context, blockId string, departure string, arrival string, hotelId string) ApiGetBlockRatesLOVRequest {
	return ApiGetBlockRatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		departure: departure,
		arrival: arrival,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockRatesLOVExecute(r ApiGetBlockRatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockRatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arrival/{arrival}/departure/{departure}/blockId/{blockId}/blockRates"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"departure"+"}", url.PathEscape(parameterValueToString(r.departure, "departure")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"arrival"+"}", url.PathEscape(parameterValueToString(r.arrival, "arrival")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.departure) < 1 {
		return localVarReturnValue, nil, reportError("departure must have at least 1 elements")
	}
	if strlen(r.departure) > 2000 {
		return localVarReturnValue, nil, reportError("departure must have less than 2000 elements")
	}
	if strlen(r.arrival) < 1 {
		return localVarReturnValue, nil, reportError("arrival must have at least 1 elements")
	}
	if strlen(r.arrival) > 2000 {
		return localVarReturnValue, nil, reportError("arrival must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockReservationTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingStatus string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBlockReservationTypesLOVRequest) Authorization(authorization string) ApiGetBlockReservationTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBlockReservationTypesLOVRequest) XAppKey(xAppKey string) ApiGetBlockReservationTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBlockReservationTypesLOVRequest) XHotelid(xHotelid string) ApiGetBlockReservationTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBlockReservationTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBlockReservationTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBlockReservationTypesLOVRequest) ParameterName(parameterName []string) ApiGetBlockReservationTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBlockReservationTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetBlockReservationTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBlockReservationTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBlockReservationTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBlockReservationTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBlockReservationTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBlockReservationTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockReservationTypesLOVExecute(r)
}

/*
GetBlockReservationTypesLOV Fetch List Of Values for Block Reservation Types

 <p><strong>OperationId:</strong>getBlockReservationTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingStatus Value of the parameter 'bookingStatus' which is required to fetch BlockReservationTypes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockReservationTypes LOV
 @return ApiGetBlockReservationTypesLOVRequest
*/
func (a *LOVApiService) GetBlockReservationTypesLOV(ctx context.Context, bookingStatus string, hotelId string) ApiGetBlockReservationTypesLOVRequest {
	return ApiGetBlockReservationTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingStatus: bookingStatus,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockReservationTypesLOVExecute(r ApiGetBlockReservationTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockReservationTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/bookingStatus/{bookingStatus}/blockReservationTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingStatus"+"}", url.PathEscape(parameterValueToString(r.bookingStatus, "bookingStatus")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingStatus) < 1 {
		return localVarReturnValue, nil, reportError("bookingStatus must have at least 1 elements")
	}
	if strlen(r.bookingStatus) > 2000 {
		return localVarReturnValue, nil, reportError("bookingStatus must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBookingChannelRatePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	channel string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBookingChannelRatePlansLOVRequest) Authorization(authorization string) ApiGetBookingChannelRatePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBookingChannelRatePlansLOVRequest) XAppKey(xAppKey string) ApiGetBookingChannelRatePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBookingChannelRatePlansLOVRequest) XHotelid(xHotelid string) ApiGetBookingChannelRatePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBookingChannelRatePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBookingChannelRatePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBookingChannelRatePlansLOVRequest) ParameterName(parameterName []string) ApiGetBookingChannelRatePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBookingChannelRatePlansLOVRequest) ParameterValue(parameterValue []string) ApiGetBookingChannelRatePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBookingChannelRatePlansLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBookingChannelRatePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBookingChannelRatePlansLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBookingChannelRatePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBookingChannelRatePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBookingChannelRatePlansLOVExecute(r)
}

/*
GetBookingChannelRatePlansLOV Fetch List Of Values for Booking Channel Rate Plans

 <p><strong>OperationId:</strong>getBookingChannelRatePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channel Value of the parameter 'channel' which is required to fetch BookingChannelRatePlans LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BookingChannelRatePlans LOV
 @return ApiGetBookingChannelRatePlansLOVRequest
*/
func (a *LOVApiService) GetBookingChannelRatePlansLOV(ctx context.Context, channel string, hotelId string) ApiGetBookingChannelRatePlansLOVRequest {
	return ApiGetBookingChannelRatePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		channel: channel,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBookingChannelRatePlansLOVExecute(r ApiGetBookingChannelRatePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBookingChannelRatePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/channel/{channel}/bookingChannelRatePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"channel"+"}", url.PathEscape(parameterValueToString(r.channel, "channel")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channel) < 1 {
		return localVarReturnValue, nil, reportError("channel must have at least 1 elements")
	}
	if strlen(r.channel) > 2000 {
		return localVarReturnValue, nil, reportError("channel must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBookingChannelRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	channel string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBookingChannelRoomTypesLOVRequest) Authorization(authorization string) ApiGetBookingChannelRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBookingChannelRoomTypesLOVRequest) XAppKey(xAppKey string) ApiGetBookingChannelRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBookingChannelRoomTypesLOVRequest) XHotelid(xHotelid string) ApiGetBookingChannelRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBookingChannelRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBookingChannelRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBookingChannelRoomTypesLOVRequest) ParameterName(parameterName []string) ApiGetBookingChannelRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBookingChannelRoomTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetBookingChannelRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBookingChannelRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBookingChannelRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBookingChannelRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBookingChannelRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBookingChannelRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBookingChannelRoomTypesLOVExecute(r)
}

/*
GetBookingChannelRoomTypesLOV Fetch List Of Values for Booking Channel Room Types

 <p><strong>OperationId:</strong>getBookingChannelRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channel Value of the parameter 'channel' which is required to fetch BookingChannelRoomTypes LOV
 @return ApiGetBookingChannelRoomTypesLOVRequest
*/
func (a *LOVApiService) GetBookingChannelRoomTypesLOV(ctx context.Context, channel string) ApiGetBookingChannelRoomTypesLOVRequest {
	return ApiGetBookingChannelRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		channel: channel,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBookingChannelRoomTypesLOVExecute(r ApiGetBookingChannelRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBookingChannelRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/channel/{channel}/bookingChannelRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"channel"+"}", url.PathEscape(parameterValueToString(r.channel, "channel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channel) < 1 {
		return localVarReturnValue, nil, reportError("channel must have at least 1 elements")
	}
	if strlen(r.channel) > 2000 {
		return localVarReturnValue, nil, reportError("channel must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBookingTypesIndividualsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBookingTypesIndividualsLOVRequest) Authorization(authorization string) ApiGetBookingTypesIndividualsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBookingTypesIndividualsLOVRequest) XAppKey(xAppKey string) ApiGetBookingTypesIndividualsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBookingTypesIndividualsLOVRequest) XHotelid(xHotelid string) ApiGetBookingTypesIndividualsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBookingTypesIndividualsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBookingTypesIndividualsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBookingTypesIndividualsLOVRequest) ParameterName(parameterName []string) ApiGetBookingTypesIndividualsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBookingTypesIndividualsLOVRequest) ParameterValue(parameterValue []string) ApiGetBookingTypesIndividualsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBookingTypesIndividualsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBookingTypesIndividualsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBookingTypesIndividualsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBookingTypesIndividualsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBookingTypesIndividualsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBookingTypesIndividualsLOVExecute(r)
}

/*
GetBookingTypesIndividualsLOV Fetch List Of Values for Booking Types Individuals

 <p><strong>OperationId:</strong>getBookingTypesIndividualsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BookingTypesIndividuals LOV
 @return ApiGetBookingTypesIndividualsLOVRequest
*/
func (a *LOVApiService) GetBookingTypesIndividualsLOV(ctx context.Context, hotelId string) ApiGetBookingTypesIndividualsLOVRequest {
	return ApiGetBookingTypesIndividualsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBookingTypesIndividualsLOVExecute(r ApiGetBookingTypesIndividualsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBookingTypesIndividualsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/bookingTypesIndividuals"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBudgetForecastCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBudgetForecastCodesLOVRequest) Authorization(authorization string) ApiGetBudgetForecastCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBudgetForecastCodesLOVRequest) XAppKey(xAppKey string) ApiGetBudgetForecastCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBudgetForecastCodesLOVRequest) XHotelid(xHotelid string) ApiGetBudgetForecastCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBudgetForecastCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBudgetForecastCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBudgetForecastCodesLOVRequest) ParameterName(parameterName []string) ApiGetBudgetForecastCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBudgetForecastCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetBudgetForecastCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBudgetForecastCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBudgetForecastCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBudgetForecastCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBudgetForecastCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBudgetForecastCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBudgetForecastCodesLOVExecute(r)
}

/*
GetBudgetForecastCodesLOV Fetch List Of Values for Budget Forecast Codes

 <p><strong>OperationId:</strong>getBudgetForecastCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BudgetForecastCodes LOV
 @return ApiGetBudgetForecastCodesLOVRequest
*/
func (a *LOVApiService) GetBudgetForecastCodesLOV(ctx context.Context, hotelId string) ApiGetBudgetForecastCodesLOVRequest {
	return ApiGetBudgetForecastCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBudgetForecastCodesLOVExecute(r ApiGetBudgetForecastCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBudgetForecastCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/budgetForecastCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBudgetRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBudgetRateCodesLOVRequest) Authorization(authorization string) ApiGetBudgetRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBudgetRateCodesLOVRequest) XAppKey(xAppKey string) ApiGetBudgetRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBudgetRateCodesLOVRequest) XHotelid(xHotelid string) ApiGetBudgetRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBudgetRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBudgetRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBudgetRateCodesLOVRequest) ParameterName(parameterName []string) ApiGetBudgetRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBudgetRateCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetBudgetRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBudgetRateCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBudgetRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBudgetRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBudgetRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBudgetRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBudgetRateCodesLOVExecute(r)
}

/*
GetBudgetRateCodesLOV Fetch List Of Values for Budget Rate Codes

 <p><strong>OperationId:</strong>getBudgetRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BudgetRateCodes LOV
 @return ApiGetBudgetRateCodesLOVRequest
*/
func (a *LOVApiService) GetBudgetRateCodesLOV(ctx context.Context, hotelId string) ApiGetBudgetRateCodesLOVRequest {
	return ApiGetBudgetRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBudgetRateCodesLOVExecute(r ApiGetBudgetRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBudgetRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/budgetRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessEventActionTypeExtDBLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	databaseId string
	extSystem string
	module string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBusinessEventActionTypeExtDBLOVRequest) Authorization(authorization string) ApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBusinessEventActionTypeExtDBLOVRequest) XAppKey(xAppKey string) ApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBusinessEventActionTypeExtDBLOVRequest) XHotelid(xHotelid string) ApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBusinessEventActionTypeExtDBLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBusinessEventActionTypeExtDBLOVRequest) ParameterName(parameterName []string) ApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBusinessEventActionTypeExtDBLOVRequest) ParameterValue(parameterValue []string) ApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBusinessEventActionTypeExtDBLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBusinessEventActionTypeExtDBLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBusinessEventActionTypeExtDBLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBusinessEventActionTypeExtDBLOVExecute(r)
}

/*
GetBusinessEventActionTypeExtDBLOV Fetch List Of Values for Business Event Action Type Ext DB

 <p><strong>OperationId:</strong>getBusinessEventActionTypeExtDBLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId Value of the parameter 'databaseId' which is required to fetch BusinessEventActionTypeExtDB LOV
 @param extSystem Value of the parameter 'extSystem' which is required to fetch BusinessEventActionTypeExtDB LOV
 @param module Value of the parameter 'module' which is required to fetch BusinessEventActionTypeExtDB LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BusinessEventActionTypeExtDB LOV
 @return ApiGetBusinessEventActionTypeExtDBLOVRequest
*/
func (a *LOVApiService) GetBusinessEventActionTypeExtDBLOV(ctx context.Context, databaseId string, extSystem string, module string, hotelId string) ApiGetBusinessEventActionTypeExtDBLOVRequest {
	return ApiGetBusinessEventActionTypeExtDBLOVRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
		extSystem: extSystem,
		module: module,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBusinessEventActionTypeExtDBLOVExecute(r ApiGetBusinessEventActionTypeExtDBLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBusinessEventActionTypeExtDBLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/module/{module}/extSystem/{extSystem}/databaseId/{databaseId}/businessEventActionTypeExtDB"
	localVarPath = strings.Replace(localVarPath, "{"+"databaseId"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystem"+"}", url.PathEscape(parameterValueToString(r.extSystem, "extSystem")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"module"+"}", url.PathEscape(parameterValueToString(r.module, "module")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.databaseId) < 1 {
		return localVarReturnValue, nil, reportError("databaseId must have at least 1 elements")
	}
	if strlen(r.databaseId) > 2000 {
		return localVarReturnValue, nil, reportError("databaseId must have less than 2000 elements")
	}
	if strlen(r.extSystem) < 1 {
		return localVarReturnValue, nil, reportError("extSystem must have at least 1 elements")
	}
	if strlen(r.extSystem) > 2000 {
		return localVarReturnValue, nil, reportError("extSystem must have less than 2000 elements")
	}
	if strlen(r.module) < 1 {
		return localVarReturnValue, nil, reportError("module must have at least 1 elements")
	}
	if strlen(r.module) > 2000 {
		return localVarReturnValue, nil, reportError("module must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessEventActionTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	module string
	extSystem string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetBusinessEventActionTypeLOVRequest) Authorization(authorization string) ApiGetBusinessEventActionTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetBusinessEventActionTypeLOVRequest) XAppKey(xAppKey string) ApiGetBusinessEventActionTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetBusinessEventActionTypeLOVRequest) XHotelid(xHotelid string) ApiGetBusinessEventActionTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetBusinessEventActionTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetBusinessEventActionTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetBusinessEventActionTypeLOVRequest) ParameterName(parameterName []string) ApiGetBusinessEventActionTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetBusinessEventActionTypeLOVRequest) ParameterValue(parameterValue []string) ApiGetBusinessEventActionTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetBusinessEventActionTypeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetBusinessEventActionTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetBusinessEventActionTypeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetBusinessEventActionTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetBusinessEventActionTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBusinessEventActionTypeLOVExecute(r)
}

/*
GetBusinessEventActionTypeLOV Fetch List Of Values for Business Event Action Type

 <p><strong>OperationId:</strong>getBusinessEventActionTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param module Value of the parameter 'module' which is required to fetch BusinessEventActionType LOV
 @param extSystem Value of the parameter 'extSystem' which is required to fetch BusinessEventActionType LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BusinessEventActionType LOV
 @return ApiGetBusinessEventActionTypeLOVRequest
*/
func (a *LOVApiService) GetBusinessEventActionTypeLOV(ctx context.Context, module string, extSystem string, hotelId string) ApiGetBusinessEventActionTypeLOVRequest {
	return ApiGetBusinessEventActionTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		module: module,
		extSystem: extSystem,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBusinessEventActionTypeLOVExecute(r ApiGetBusinessEventActionTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBusinessEventActionTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/extSystem/{extSystem}/module/{module}/businessEventActionType"
	localVarPath = strings.Replace(localVarPath, "{"+"module"+"}", url.PathEscape(parameterValueToString(r.module, "module")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystem"+"}", url.PathEscape(parameterValueToString(r.extSystem, "extSystem")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.module) < 1 {
		return localVarReturnValue, nil, reportError("module must have at least 1 elements")
	}
	if strlen(r.module) > 2000 {
		return localVarReturnValue, nil, reportError("module must have less than 2000 elements")
	}
	if strlen(r.extSystem) < 1 {
		return localVarReturnValue, nil, reportError("extSystem must have at least 1 elements")
	}
	if strlen(r.extSystem) > 2000 {
		return localVarReturnValue, nil, reportError("extSystem must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCampaignActivityTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCampaignActivityTypesLOVRequest) Authorization(authorization string) ApiGetCampaignActivityTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCampaignActivityTypesLOVRequest) XAppKey(xAppKey string) ApiGetCampaignActivityTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCampaignActivityTypesLOVRequest) XHotelid(xHotelid string) ApiGetCampaignActivityTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCampaignActivityTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCampaignActivityTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCampaignActivityTypesLOVRequest) ParameterName(parameterName []string) ApiGetCampaignActivityTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCampaignActivityTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetCampaignActivityTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCampaignActivityTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCampaignActivityTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCampaignActivityTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCampaignActivityTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCampaignActivityTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCampaignActivityTypesLOVExecute(r)
}

/*
GetCampaignActivityTypesLOV Fetch List Of Values for Campaign Activity Types

 <p><strong>OperationId:</strong>getCampaignActivityTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CampaignActivityTypes LOV
 @return ApiGetCampaignActivityTypesLOVRequest
*/
func (a *LOVApiService) GetCampaignActivityTypesLOV(ctx context.Context, hotelId string) ApiGetCampaignActivityTypesLOVRequest {
	return ApiGetCampaignActivityTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCampaignActivityTypesLOVExecute(r ApiGetCampaignActivityTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCampaignActivityTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/campaignActivityTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCashRegisterIDLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCashRegisterIDLOVRequest) Authorization(authorization string) ApiGetCashRegisterIDLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCashRegisterIDLOVRequest) XAppKey(xAppKey string) ApiGetCashRegisterIDLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCashRegisterIDLOVRequest) XHotelid(xHotelid string) ApiGetCashRegisterIDLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCashRegisterIDLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCashRegisterIDLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCashRegisterIDLOVRequest) ParameterName(parameterName []string) ApiGetCashRegisterIDLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCashRegisterIDLOVRequest) ParameterValue(parameterValue []string) ApiGetCashRegisterIDLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCashRegisterIDLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCashRegisterIDLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCashRegisterIDLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCashRegisterIDLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCashRegisterIDLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCashRegisterIDLOVExecute(r)
}

/*
GetCashRegisterIDLOV Fetch List Of Values for Cash Register ID

 <p><strong>OperationId:</strong>getCashRegisterIDLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CashRegisterID LOV
 @return ApiGetCashRegisterIDLOVRequest
*/
func (a *LOVApiService) GetCashRegisterIDLOV(ctx context.Context, hotelId string) ApiGetCashRegisterIDLOVRequest {
	return ApiGetCashRegisterIDLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCashRegisterIDLOVExecute(r ApiGetCashRegisterIDLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCashRegisterIDLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/cashRegisterId"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCashierHotelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	cashierId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCashierHotelsLOVRequest) Authorization(authorization string) ApiGetCashierHotelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCashierHotelsLOVRequest) XAppKey(xAppKey string) ApiGetCashierHotelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCashierHotelsLOVRequest) XHotelid(xHotelid string) ApiGetCashierHotelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCashierHotelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCashierHotelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCashierHotelsLOVRequest) ParameterName(parameterName []string) ApiGetCashierHotelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCashierHotelsLOVRequest) ParameterValue(parameterValue []string) ApiGetCashierHotelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCashierHotelsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCashierHotelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCashierHotelsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCashierHotelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCashierHotelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCashierHotelsLOVExecute(r)
}

/*
GetCashierHotelsLOV Fetch List Of Values for Cashier Hotels

 <p><strong>OperationId:</strong>getCashierHotelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Value of the parameter 'cashierId' which is required to fetch CashierHotels LOV
 @return ApiGetCashierHotelsLOVRequest
*/
func (a *LOVApiService) GetCashierHotelsLOV(ctx context.Context, cashierId string) ApiGetCashierHotelsLOVRequest {
	return ApiGetCashierHotelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCashierHotelsLOVExecute(r ApiGetCashierHotelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCashierHotelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/cashierId/{cashierId}/cashierHotels"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatBudgetTypeEventCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	catBudgetType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCatBudgetTypeEventCodesLOVRequest) Authorization(authorization string) ApiGetCatBudgetTypeEventCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCatBudgetTypeEventCodesLOVRequest) XAppKey(xAppKey string) ApiGetCatBudgetTypeEventCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCatBudgetTypeEventCodesLOVRequest) XHotelid(xHotelid string) ApiGetCatBudgetTypeEventCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCatBudgetTypeEventCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCatBudgetTypeEventCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCatBudgetTypeEventCodesLOVRequest) ParameterName(parameterName []string) ApiGetCatBudgetTypeEventCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCatBudgetTypeEventCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetCatBudgetTypeEventCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCatBudgetTypeEventCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCatBudgetTypeEventCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCatBudgetTypeEventCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCatBudgetTypeEventCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCatBudgetTypeEventCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCatBudgetTypeEventCodesLOVExecute(r)
}

/*
GetCatBudgetTypeEventCodesLOV Fetch List Of Values for Cat Budget Type Event Codes

 <p><strong>OperationId:</strong>getCatBudgetTypeEventCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catBudgetType Value of the parameter 'catBudgetType' which is required to fetch CatBudgetTypeEventCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CatBudgetTypeEventCodes LOV
 @return ApiGetCatBudgetTypeEventCodesLOVRequest
*/
func (a *LOVApiService) GetCatBudgetTypeEventCodesLOV(ctx context.Context, catBudgetType string, hotelId string) ApiGetCatBudgetTypeEventCodesLOVRequest {
	return ApiGetCatBudgetTypeEventCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		catBudgetType: catBudgetType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCatBudgetTypeEventCodesLOVExecute(r ApiGetCatBudgetTypeEventCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCatBudgetTypeEventCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/catBudgetType/{catBudgetType}/catBudgetTypeEventCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"catBudgetType"+"}", url.PathEscape(parameterValueToString(r.catBudgetType, "catBudgetType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catBudgetType) < 1 {
		return localVarReturnValue, nil, reportError("catBudgetType must have at least 1 elements")
	}
	if strlen(r.catBudgetType) > 2000 {
		return localVarReturnValue, nil, reportError("catBudgetType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatBudgetTypeMarketCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	catBudgetType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCatBudgetTypeMarketCodesLOVRequest) Authorization(authorization string) ApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCatBudgetTypeMarketCodesLOVRequest) XAppKey(xAppKey string) ApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCatBudgetTypeMarketCodesLOVRequest) XHotelid(xHotelid string) ApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCatBudgetTypeMarketCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCatBudgetTypeMarketCodesLOVRequest) ParameterName(parameterName []string) ApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCatBudgetTypeMarketCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCatBudgetTypeMarketCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCatBudgetTypeMarketCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCatBudgetTypeMarketCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCatBudgetTypeMarketCodesLOVExecute(r)
}

/*
GetCatBudgetTypeMarketCodesLOV Fetch List Of Values for Cat Budget Type Market Codes

 <p><strong>OperationId:</strong>getCatBudgetTypeMarketCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catBudgetType Value of the parameter 'catBudgetType' which is required to fetch CatBudgetTypeMarketCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CatBudgetTypeMarketCodes LOV
 @return ApiGetCatBudgetTypeMarketCodesLOVRequest
*/
func (a *LOVApiService) GetCatBudgetTypeMarketCodesLOV(ctx context.Context, catBudgetType string, hotelId string) ApiGetCatBudgetTypeMarketCodesLOVRequest {
	return ApiGetCatBudgetTypeMarketCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		catBudgetType: catBudgetType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCatBudgetTypeMarketCodesLOVExecute(r ApiGetCatBudgetTypeMarketCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCatBudgetTypeMarketCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/catBudgetType/{catBudgetType}/catBudgetTypeMarketCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"catBudgetType"+"}", url.PathEscape(parameterValueToString(r.catBudgetType, "catBudgetType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catBudgetType) < 1 {
		return localVarReturnValue, nil, reportError("catBudgetType must have at least 1 elements")
	}
	if strlen(r.catBudgetType) > 2000 {
		return localVarReturnValue, nil, reportError("catBudgetType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatBudgetTypeMealCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	catBudgetType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCatBudgetTypeMealCodesLOVRequest) Authorization(authorization string) ApiGetCatBudgetTypeMealCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCatBudgetTypeMealCodesLOVRequest) XAppKey(xAppKey string) ApiGetCatBudgetTypeMealCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCatBudgetTypeMealCodesLOVRequest) XHotelid(xHotelid string) ApiGetCatBudgetTypeMealCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCatBudgetTypeMealCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCatBudgetTypeMealCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCatBudgetTypeMealCodesLOVRequest) ParameterName(parameterName []string) ApiGetCatBudgetTypeMealCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCatBudgetTypeMealCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetCatBudgetTypeMealCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCatBudgetTypeMealCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCatBudgetTypeMealCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCatBudgetTypeMealCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCatBudgetTypeMealCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCatBudgetTypeMealCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCatBudgetTypeMealCodesLOVExecute(r)
}

/*
GetCatBudgetTypeMealCodesLOV Fetch List Of Values for Cat Budget Type Meal Codes

 <p><strong>OperationId:</strong>getCatBudgetTypeMealCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catBudgetType Value of the parameter 'catBudgetType' which is required to fetch CatBudgetTypeMealCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CatBudgetTypeMealCodes LOV
 @return ApiGetCatBudgetTypeMealCodesLOVRequest
*/
func (a *LOVApiService) GetCatBudgetTypeMealCodesLOV(ctx context.Context, catBudgetType string, hotelId string) ApiGetCatBudgetTypeMealCodesLOVRequest {
	return ApiGetCatBudgetTypeMealCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		catBudgetType: catBudgetType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCatBudgetTypeMealCodesLOVExecute(r ApiGetCatBudgetTypeMealCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCatBudgetTypeMealCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/catBudgetType/{catBudgetType}/catBudgetTypeMealCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"catBudgetType"+"}", url.PathEscape(parameterValueToString(r.catBudgetType, "catBudgetType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catBudgetType) < 1 {
		return localVarReturnValue, nil, reportError("catBudgetType must have at least 1 elements")
	}
	if strlen(r.catBudgetType) > 2000 {
		return localVarReturnValue, nil, reportError("catBudgetType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatBudgetTypeRevenueCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	catBudgetType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCatBudgetTypeRevenueCodesLOVRequest) Authorization(authorization string) ApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCatBudgetTypeRevenueCodesLOVRequest) XAppKey(xAppKey string) ApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCatBudgetTypeRevenueCodesLOVRequest) XHotelid(xHotelid string) ApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCatBudgetTypeRevenueCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCatBudgetTypeRevenueCodesLOVRequest) ParameterName(parameterName []string) ApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCatBudgetTypeRevenueCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCatBudgetTypeRevenueCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCatBudgetTypeRevenueCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCatBudgetTypeRevenueCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCatBudgetTypeRevenueCodesLOVExecute(r)
}

/*
GetCatBudgetTypeRevenueCodesLOV Fetch List Of Values for Cat Budget Type Revenue Codes

 <p><strong>OperationId:</strong>getCatBudgetTypeRevenueCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catBudgetType Value of the parameter 'catBudgetType' which is required to fetch CatBudgetTypeRevenueCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CatBudgetTypeRevenueCodes LOV
 @return ApiGetCatBudgetTypeRevenueCodesLOVRequest
*/
func (a *LOVApiService) GetCatBudgetTypeRevenueCodesLOV(ctx context.Context, catBudgetType string, hotelId string) ApiGetCatBudgetTypeRevenueCodesLOVRequest {
	return ApiGetCatBudgetTypeRevenueCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		catBudgetType: catBudgetType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCatBudgetTypeRevenueCodesLOVExecute(r ApiGetCatBudgetTypeRevenueCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCatBudgetTypeRevenueCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/catBudgetType/{catBudgetType}/catBudgetTypeRevenueCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"catBudgetType"+"}", url.PathEscape(parameterValueToString(r.catBudgetType, "catBudgetType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catBudgetType) < 1 {
		return localVarReturnValue, nil, reportError("catBudgetType must have at least 1 elements")
	}
	if strlen(r.catBudgetType) > 2000 {
		return localVarReturnValue, nil, reportError("catBudgetType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCateringBudgetTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	active string
	catering string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCateringBudgetTypesLOVRequest) Authorization(authorization string) ApiGetCateringBudgetTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCateringBudgetTypesLOVRequest) XAppKey(xAppKey string) ApiGetCateringBudgetTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCateringBudgetTypesLOVRequest) XHotelid(xHotelid string) ApiGetCateringBudgetTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCateringBudgetTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCateringBudgetTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCateringBudgetTypesLOVRequest) ParameterName(parameterName []string) ApiGetCateringBudgetTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCateringBudgetTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetCateringBudgetTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCateringBudgetTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCateringBudgetTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCateringBudgetTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCateringBudgetTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCateringBudgetTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringBudgetTypesLOVExecute(r)
}

/*
GetCateringBudgetTypesLOV Fetch List Of Values for Catering Budget Types

 <p><strong>OperationId:</strong>getCateringBudgetTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param active Value of the parameter 'active' which is required to fetch CateringBudgetTypes LOV
 @param catering Value of the parameter 'catering' which is required to fetch CateringBudgetTypes LOV
 @return ApiGetCateringBudgetTypesLOVRequest
*/
func (a *LOVApiService) GetCateringBudgetTypesLOV(ctx context.Context, active string, catering string) ApiGetCateringBudgetTypesLOVRequest {
	return ApiGetCateringBudgetTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		active: active,
		catering: catering,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringBudgetTypesLOVExecute(r ApiGetCateringBudgetTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringBudgetTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/catering/{catering}/active/{active}/cateringBudgetTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"active"+"}", url.PathEscape(parameterValueToString(r.active, "active")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catering"+"}", url.PathEscape(parameterValueToString(r.catering, "catering")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.active) < 1 {
		return localVarReturnValue, nil, reportError("active must have at least 1 elements")
	}
	if strlen(r.active) > 2000 {
		return localVarReturnValue, nil, reportError("active must have less than 2000 elements")
	}
	if strlen(r.catering) < 1 {
		return localVarReturnValue, nil, reportError("catering must have at least 1 elements")
	}
	if strlen(r.catering) > 2000 {
		return localVarReturnValue, nil, reportError("catering must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCateringCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	codeType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCateringCodesLOVRequest) Authorization(authorization string) ApiGetCateringCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCateringCodesLOVRequest) XAppKey(xAppKey string) ApiGetCateringCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCateringCodesLOVRequest) XHotelid(xHotelid string) ApiGetCateringCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCateringCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCateringCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCateringCodesLOVRequest) ParameterName(parameterName []string) ApiGetCateringCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCateringCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetCateringCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCateringCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCateringCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCateringCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCateringCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCateringCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringCodesLOVExecute(r)
}

/*
GetCateringCodesLOV Fetch List Of Values for Catering Codes

 <p><strong>OperationId:</strong>getCateringCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param codeType Value of the parameter 'codeType' which is required to fetch CateringCodes LOV
 @return ApiGetCateringCodesLOVRequest
*/
func (a *LOVApiService) GetCateringCodesLOV(ctx context.Context, codeType string) ApiGetCateringCodesLOVRequest {
	return ApiGetCateringCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		codeType: codeType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringCodesLOVExecute(r ApiGetCateringCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/codeType/{codeType}/cateringCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"codeType"+"}", url.PathEscape(parameterValueToString(r.codeType, "codeType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.codeType) < 1 {
		return localVarReturnValue, nil, reportError("codeType must have at least 1 elements")
	}
	if strlen(r.codeType) > 2000 {
		return localVarReturnValue, nil, reportError("codeType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCateringEventStatusLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	waitList string
	newEvent string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCateringEventStatusLOVRequest) Authorization(authorization string) ApiGetCateringEventStatusLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCateringEventStatusLOVRequest) XAppKey(xAppKey string) ApiGetCateringEventStatusLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCateringEventStatusLOVRequest) XHotelid(xHotelid string) ApiGetCateringEventStatusLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCateringEventStatusLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCateringEventStatusLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCateringEventStatusLOVRequest) ParameterName(parameterName []string) ApiGetCateringEventStatusLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCateringEventStatusLOVRequest) ParameterValue(parameterValue []string) ApiGetCateringEventStatusLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCateringEventStatusLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCateringEventStatusLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCateringEventStatusLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCateringEventStatusLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCateringEventStatusLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringEventStatusLOVExecute(r)
}

/*
GetCateringEventStatusLOV Fetch List Of Values for Catering Event Status

 <p><strong>OperationId:</strong>getCateringEventStatusLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param waitList Value of the parameter 'waitList' which is required to fetch CateringEventStatus LOV
 @param newEvent Value of the parameter 'newEvent' which is required to fetch CateringEventStatus LOV
 @return ApiGetCateringEventStatusLOVRequest
*/
func (a *LOVApiService) GetCateringEventStatusLOV(ctx context.Context, waitList string, newEvent string) ApiGetCateringEventStatusLOVRequest {
	return ApiGetCateringEventStatusLOVRequest{
		ApiService: a,
		ctx: ctx,
		waitList: waitList,
		newEvent: newEvent,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringEventStatusLOVExecute(r ApiGetCateringEventStatusLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringEventStatusLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/newEvent/{newEvent}/waitList/{waitList}/cateringEventStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"waitList"+"}", url.PathEscape(parameterValueToString(r.waitList, "waitList")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"newEvent"+"}", url.PathEscape(parameterValueToString(r.newEvent, "newEvent")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.waitList) < 1 {
		return localVarReturnValue, nil, reportError("waitList must have at least 1 elements")
	}
	if strlen(r.waitList) > 2000 {
		return localVarReturnValue, nil, reportError("waitList must have less than 2000 elements")
	}
	if strlen(r.newEvent) < 1 {
		return localVarReturnValue, nil, reportError("newEvent must have at least 1 elements")
	}
	if strlen(r.newEvent) > 2000 {
		return localVarReturnValue, nil, reportError("newEvent must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCateringPackageCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	radioType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCateringPackageCodesLOVRequest) Authorization(authorization string) ApiGetCateringPackageCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCateringPackageCodesLOVRequest) XAppKey(xAppKey string) ApiGetCateringPackageCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCateringPackageCodesLOVRequest) XHotelid(xHotelid string) ApiGetCateringPackageCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCateringPackageCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCateringPackageCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCateringPackageCodesLOVRequest) ParameterName(parameterName []string) ApiGetCateringPackageCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCateringPackageCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetCateringPackageCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCateringPackageCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCateringPackageCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCateringPackageCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCateringPackageCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCateringPackageCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringPackageCodesLOVExecute(r)
}

/*
GetCateringPackageCodesLOV Fetch List Of Values for Catering Package Codes

 <p><strong>OperationId:</strong>getCateringPackageCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CateringPackageCodes LOV
 @param radioType Value of the parameter 'radioType' which is required to fetch CateringPackageCodes LOV
 @return ApiGetCateringPackageCodesLOVRequest
*/
func (a *LOVApiService) GetCateringPackageCodesLOV(ctx context.Context, hotelId string, radioType string) ApiGetCateringPackageCodesLOVRequest {
	return ApiGetCateringPackageCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		radioType: radioType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringPackageCodesLOVExecute(r ApiGetCateringPackageCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringPackageCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/radioType/{radioType}/hotels/{hotelId}/cateringPackageCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"radioType"+"}", url.PathEscape(parameterValueToString(r.radioType, "radioType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.radioType) < 1 {
		return localVarReturnValue, nil, reportError("radioType must have at least 1 elements")
	}
	if strlen(r.radioType) > 2000 {
		return localVarReturnValue, nil, reportError("radioType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCateringPackagePriceCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCateringPackagePriceCodesLOVRequest) Authorization(authorization string) ApiGetCateringPackagePriceCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCateringPackagePriceCodesLOVRequest) XAppKey(xAppKey string) ApiGetCateringPackagePriceCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCateringPackagePriceCodesLOVRequest) XHotelid(xHotelid string) ApiGetCateringPackagePriceCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCateringPackagePriceCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCateringPackagePriceCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCateringPackagePriceCodesLOVRequest) ParameterName(parameterName []string) ApiGetCateringPackagePriceCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCateringPackagePriceCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetCateringPackagePriceCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCateringPackagePriceCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCateringPackagePriceCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCateringPackagePriceCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCateringPackagePriceCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCateringPackagePriceCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringPackagePriceCodesLOVExecute(r)
}

/*
GetCateringPackagePriceCodesLOV Fetch List Of Values for Catering Package Price Codes

 <p><strong>OperationId:</strong>getCateringPackagePriceCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CateringPackagePriceCodes LOV
 @return ApiGetCateringPackagePriceCodesLOVRequest
*/
func (a *LOVApiService) GetCateringPackagePriceCodesLOV(ctx context.Context, hotelId string) ApiGetCateringPackagePriceCodesLOVRequest {
	return ApiGetCateringPackagePriceCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringPackagePriceCodesLOVExecute(r ApiGetCateringPackagePriceCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringPackagePriceCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/cateringPackagePriceCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCateringPackageRevenueConfigEventTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	pkgLinkId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCateringPackageRevenueConfigEventTypeLOVRequest) Authorization(authorization string) ApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCateringPackageRevenueConfigEventTypeLOVRequest) XAppKey(xAppKey string) ApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCateringPackageRevenueConfigEventTypeLOVRequest) XHotelid(xHotelid string) ApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCateringPackageRevenueConfigEventTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCateringPackageRevenueConfigEventTypeLOVRequest) ParameterName(parameterName []string) ApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCateringPackageRevenueConfigEventTypeLOVRequest) ParameterValue(parameterValue []string) ApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCateringPackageRevenueConfigEventTypeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCateringPackageRevenueConfigEventTypeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCateringPackageRevenueConfigEventTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringPackageRevenueConfigEventTypeLOVExecute(r)
}

/*
GetCateringPackageRevenueConfigEventTypeLOV Fetch List Of Values for Catering Package Revenue Config Event Type

 <p><strong>OperationId:</strong>getCateringPackageRevenueConfigEventTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkgLinkId Value of the parameter 'pkgLinkId' which is required to fetch CateringPackageRevenueConfigEventType LOV
 @return ApiGetCateringPackageRevenueConfigEventTypeLOVRequest
*/
func (a *LOVApiService) GetCateringPackageRevenueConfigEventTypeLOV(ctx context.Context, pkgLinkId string) ApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	return ApiGetCateringPackageRevenueConfigEventTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		pkgLinkId: pkgLinkId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringPackageRevenueConfigEventTypeLOVExecute(r ApiGetCateringPackageRevenueConfigEventTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringPackageRevenueConfigEventTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/pkgLinkId/{pkgLinkId}/cateringPackageRevenueConfigEventType"
	localVarPath = strings.Replace(localVarPath, "{"+"pkgLinkId"+"}", url.PathEscape(parameterValueToString(r.pkgLinkId, "pkgLinkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.pkgLinkId) < 1 {
		return localVarReturnValue, nil, reportError("pkgLinkId must have at least 1 elements")
	}
	if strlen(r.pkgLinkId) > 2000 {
		return localVarReturnValue, nil, reportError("pkgLinkId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCateringPackageRevenueEventTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	pkgId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCateringPackageRevenueEventTypeLOVRequest) Authorization(authorization string) ApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCateringPackageRevenueEventTypeLOVRequest) XAppKey(xAppKey string) ApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCateringPackageRevenueEventTypeLOVRequest) XHotelid(xHotelid string) ApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCateringPackageRevenueEventTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCateringPackageRevenueEventTypeLOVRequest) ParameterName(parameterName []string) ApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCateringPackageRevenueEventTypeLOVRequest) ParameterValue(parameterValue []string) ApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCateringPackageRevenueEventTypeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCateringPackageRevenueEventTypeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCateringPackageRevenueEventTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringPackageRevenueEventTypeLOVExecute(r)
}

/*
GetCateringPackageRevenueEventTypeLOV Fetch List Of Values for Catering Package Revenue Event Type

 <p><strong>OperationId:</strong>getCateringPackageRevenueEventTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkgId Value of the parameter 'pkgId' which is required to fetch CateringPackageRevenueEventType LOV
 @return ApiGetCateringPackageRevenueEventTypeLOVRequest
*/
func (a *LOVApiService) GetCateringPackageRevenueEventTypeLOV(ctx context.Context, pkgId string) ApiGetCateringPackageRevenueEventTypeLOVRequest {
	return ApiGetCateringPackageRevenueEventTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		pkgId: pkgId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringPackageRevenueEventTypeLOVExecute(r ApiGetCateringPackageRevenueEventTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringPackageRevenueEventTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/pkgId/{pkgId}/cateringPackageRevenueEventType"
	localVarPath = strings.Replace(localVarPath, "{"+"pkgId"+"}", url.PathEscape(parameterValueToString(r.pkgId, "pkgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.pkgId) < 1 {
		return localVarReturnValue, nil, reportError("pkgId must have at least 1 elements")
	}
	if strlen(r.pkgId) > 2000 {
		return localVarReturnValue, nil, reportError("pkgId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCateringSetupStylesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	space string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCateringSetupStylesLOVRequest) Authorization(authorization string) ApiGetCateringSetupStylesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCateringSetupStylesLOVRequest) XAppKey(xAppKey string) ApiGetCateringSetupStylesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCateringSetupStylesLOVRequest) XHotelid(xHotelid string) ApiGetCateringSetupStylesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCateringSetupStylesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCateringSetupStylesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCateringSetupStylesLOVRequest) ParameterName(parameterName []string) ApiGetCateringSetupStylesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCateringSetupStylesLOVRequest) ParameterValue(parameterValue []string) ApiGetCateringSetupStylesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCateringSetupStylesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCateringSetupStylesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCateringSetupStylesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCateringSetupStylesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCateringSetupStylesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringSetupStylesLOVExecute(r)
}

/*
GetCateringSetupStylesLOV Fetch List Of Values for Catering Setup Styles

 <p><strong>OperationId:</strong>getCateringSetupStylesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Value of the parameter 'space' which is required to fetch CateringSetupStyles LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CateringSetupStyles LOV
 @return ApiGetCateringSetupStylesLOVRequest
*/
func (a *LOVApiService) GetCateringSetupStylesLOV(ctx context.Context, space string, hotelId string) ApiGetCateringSetupStylesLOVRequest {
	return ApiGetCateringSetupStylesLOVRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringSetupStylesLOVExecute(r ApiGetCateringSetupStylesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringSetupStylesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/space/{space}/cateringSetupStyles"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.space) < 1 {
		return localVarReturnValue, nil, reportError("space must have at least 1 elements")
	}
	if strlen(r.space) > 2000 {
		return localVarReturnValue, nil, reportError("space must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCateringStatusCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	exclusionList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCateringStatusCodesLOVRequest) Authorization(authorization string) ApiGetCateringStatusCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCateringStatusCodesLOVRequest) XAppKey(xAppKey string) ApiGetCateringStatusCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCateringStatusCodesLOVRequest) XHotelid(xHotelid string) ApiGetCateringStatusCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCateringStatusCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCateringStatusCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCateringStatusCodesLOVRequest) ParameterName(parameterName []string) ApiGetCateringStatusCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCateringStatusCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetCateringStatusCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCateringStatusCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCateringStatusCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCateringStatusCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCateringStatusCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCateringStatusCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringStatusCodesLOVExecute(r)
}

/*
GetCateringStatusCodesLOV Fetch List Of Values for Catering Status Codes

 <p><strong>OperationId:</strong>getCateringStatusCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exclusionList Value of the parameter 'exclusionList' which is required to fetch CateringStatusCodes LOV
 @return ApiGetCateringStatusCodesLOVRequest
*/
func (a *LOVApiService) GetCateringStatusCodesLOV(ctx context.Context, exclusionList string) ApiGetCateringStatusCodesLOVRequest {
	return ApiGetCateringStatusCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		exclusionList: exclusionList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringStatusCodesLOVExecute(r ApiGetCateringStatusCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringStatusCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/exclusionList/{exclusionList}/cateringStatusCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"exclusionList"+"}", url.PathEscape(parameterValueToString(r.exclusionList, "exclusionList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.exclusionList) < 1 {
		return localVarReturnValue, nil, reportError("exclusionList must have at least 1 elements")
	}
	if strlen(r.exclusionList) > 2000 {
		return localVarReturnValue, nil, reportError("exclusionList must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChainLanguagesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	chainCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChainLanguagesLOVRequest) Authorization(authorization string) ApiGetChainLanguagesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChainLanguagesLOVRequest) XAppKey(xAppKey string) ApiGetChainLanguagesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChainLanguagesLOVRequest) XHotelid(xHotelid string) ApiGetChainLanguagesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetChainLanguagesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetChainLanguagesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetChainLanguagesLOVRequest) ParameterName(parameterName []string) ApiGetChainLanguagesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetChainLanguagesLOVRequest) ParameterValue(parameterValue []string) ApiGetChainLanguagesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetChainLanguagesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetChainLanguagesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChainLanguagesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetChainLanguagesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChainLanguagesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetChainLanguagesLOVExecute(r)
}

/*
GetChainLanguagesLOV Fetch List Of Values for Chain Languages

 <p><strong>OperationId:</strong>getChainLanguagesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainCode Value of the parameter 'chainCode' which is required to fetch ChainLanguages LOV
 @return ApiGetChainLanguagesLOVRequest
*/
func (a *LOVApiService) GetChainLanguagesLOV(ctx context.Context, chainCode string) ApiGetChainLanguagesLOVRequest {
	return ApiGetChainLanguagesLOVRequest{
		ApiService: a,
		ctx: ctx,
		chainCode: chainCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetChainLanguagesLOVExecute(r ApiGetChainLanguagesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetChainLanguagesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/chainCode/{chainCode}/chainLanguages"
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelCardTypeMappingCardTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelCardTypeMappingCardTypeLOVRequest) Authorization(authorization string) ApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelCardTypeMappingCardTypeLOVRequest) XAppKey(xAppKey string) ApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelCardTypeMappingCardTypeLOVRequest) XHotelid(xHotelid string) ApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetChannelCardTypeMappingCardTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetChannelCardTypeMappingCardTypeLOVRequest) ParameterName(parameterName []string) ApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetChannelCardTypeMappingCardTypeLOVRequest) ParameterValue(parameterValue []string) ApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetChannelCardTypeMappingCardTypeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelCardTypeMappingCardTypeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelCardTypeMappingCardTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetChannelCardTypeMappingCardTypeLOVExecute(r)
}

/*
GetChannelCardTypeMappingCardTypeLOV Fetch List Of Values for Channel Card Type Mapping Card Type

 <p><strong>OperationId:</strong>getChannelCardTypeMappingCardTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ChannelCardTypeMappingCardType LOV
 @return ApiGetChannelCardTypeMappingCardTypeLOVRequest
*/
func (a *LOVApiService) GetChannelCardTypeMappingCardTypeLOV(ctx context.Context, hotelId string) ApiGetChannelCardTypeMappingCardTypeLOVRequest {
	return ApiGetChannelCardTypeMappingCardTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetChannelCardTypeMappingCardTypeLOVExecute(r ApiGetChannelCardTypeMappingCardTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetChannelCardTypeMappingCardTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/channelCardTypeMappingCardType"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	cardType string
	gdsHost string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) Authorization(authorization string) ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) XAppKey(xAppKey string) ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) XHotelid(xHotelid string) ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) ParameterName(parameterName []string) ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) ParameterValue(parameterValue []string) ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetChannelCardTypeMappingChannelCardTypeLOVExecute(r)
}

/*
GetChannelCardTypeMappingChannelCardTypeLOV Fetch List Of Values for Channel Card Type Mapping Channel Card Type

 <p><strong>OperationId:</strong>getChannelCardTypeMappingChannelCardTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardType Value of the parameter 'cardType' which is required to fetch ChannelCardTypeMappingChannelCardType LOV
 @param gdsHost Value of the parameter 'gdsHost' which is required to fetch ChannelCardTypeMappingChannelCardType LOV
 @return ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest
*/
func (a *LOVApiService) GetChannelCardTypeMappingChannelCardTypeLOV(ctx context.Context, cardType string, gdsHost string) ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	return ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		cardType: cardType,
		gdsHost: gdsHost,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetChannelCardTypeMappingChannelCardTypeLOVExecute(r ApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetChannelCardTypeMappingChannelCardTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/gdsHost/{gdsHost}/cardType/{cardType}/channelCardTypeMappingChannelCardType"
	localVarPath = strings.Replace(localVarPath, "{"+"cardType"+"}", url.PathEscape(parameterValueToString(r.cardType, "cardType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"gdsHost"+"}", url.PathEscape(parameterValueToString(r.gdsHost, "gdsHost")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cardType) < 1 {
		return localVarReturnValue, nil, reportError("cardType must have at least 1 elements")
	}
	if strlen(r.cardType) > 2000 {
		return localVarReturnValue, nil, reportError("cardType must have less than 2000 elements")
	}
	if strlen(r.gdsHost) < 1 {
		return localVarReturnValue, nil, reportError("gdsHost must have at least 1 elements")
	}
	if strlen(r.gdsHost) > 2000 {
		return localVarReturnValue, nil, reportError("gdsHost must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelCardTypeMappingGdsHostLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelCardTypeMappingGdsHostLOVRequest) Authorization(authorization string) ApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelCardTypeMappingGdsHostLOVRequest) XAppKey(xAppKey string) ApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelCardTypeMappingGdsHostLOVRequest) XHotelid(xHotelid string) ApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetChannelCardTypeMappingGdsHostLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetChannelCardTypeMappingGdsHostLOVRequest) ParameterName(parameterName []string) ApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetChannelCardTypeMappingGdsHostLOVRequest) ParameterValue(parameterValue []string) ApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetChannelCardTypeMappingGdsHostLOVRequest) XExternalsystem(xExternalsystem string) ApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelCardTypeMappingGdsHostLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelCardTypeMappingGdsHostLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetChannelCardTypeMappingGdsHostLOVExecute(r)
}

/*
GetChannelCardTypeMappingGdsHostLOV Fetch List Of Values for Channel Card Type Mapping Gds Host

 <p><strong>OperationId:</strong>getChannelCardTypeMappingGdsHostLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ChannelCardTypeMappingGdsHost LOV
 @return ApiGetChannelCardTypeMappingGdsHostLOVRequest
*/
func (a *LOVApiService) GetChannelCardTypeMappingGdsHostLOV(ctx context.Context, hotelId string) ApiGetChannelCardTypeMappingGdsHostLOVRequest {
	return ApiGetChannelCardTypeMappingGdsHostLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetChannelCardTypeMappingGdsHostLOVExecute(r ApiGetChannelCardTypeMappingGdsHostLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetChannelCardTypeMappingGdsHostLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/channelCardTypeMappingGdsHost"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelConfigRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomType string
	bookingChannelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelConfigRateCodesLOVRequest) Authorization(authorization string) ApiGetChannelConfigRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelConfigRateCodesLOVRequest) XAppKey(xAppKey string) ApiGetChannelConfigRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelConfigRateCodesLOVRequest) XHotelid(xHotelid string) ApiGetChannelConfigRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetChannelConfigRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetChannelConfigRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetChannelConfigRateCodesLOVRequest) ParameterName(parameterName []string) ApiGetChannelConfigRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetChannelConfigRateCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetChannelConfigRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetChannelConfigRateCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetChannelConfigRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelConfigRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelConfigRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelConfigRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetChannelConfigRateCodesLOVExecute(r)
}

/*
GetChannelConfigRateCodesLOV Fetch List Of Values for Channel Config Rate Codes

 <p><strong>OperationId:</strong>getChannelConfigRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomType Value of the parameter 'roomType' which is required to fetch ChannelConfigRateCodes LOV
 @param bookingChannelCode Value of the parameter 'bookingChannelCode' which is required to fetch ChannelConfigRateCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ChannelConfigRateCodes LOV
 @return ApiGetChannelConfigRateCodesLOVRequest
*/
func (a *LOVApiService) GetChannelConfigRateCodesLOV(ctx context.Context, roomType string, bookingChannelCode string, hotelId string) ApiGetChannelConfigRateCodesLOVRequest {
	return ApiGetChannelConfigRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomType: roomType,
		bookingChannelCode: bookingChannelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetChannelConfigRateCodesLOVExecute(r ApiGetChannelConfigRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetChannelConfigRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/bookingChannels/{bookingChannelCode}/roomType/{roomType}/channelConfigRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"roomType"+"}", url.PathEscape(parameterValueToString(r.roomType, "roomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCode"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCode, "bookingChannelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomType) < 1 {
		return localVarReturnValue, nil, reportError("roomType must have at least 1 elements")
	}
	if strlen(r.roomType) > 2000 {
		return localVarReturnValue, nil, reportError("roomType must have less than 2000 elements")
	}
	if strlen(r.bookingChannelCode) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have at least 1 elements")
	}
	if strlen(r.bookingChannelCode) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelParametersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	channelCode string
	settingName string
	levelType string
	levelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetChannelParametersLOVRequest) Authorization(authorization string) ApiGetChannelParametersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetChannelParametersLOVRequest) XAppKey(xAppKey string) ApiGetChannelParametersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetChannelParametersLOVRequest) XHotelid(xHotelid string) ApiGetChannelParametersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetChannelParametersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetChannelParametersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetChannelParametersLOVRequest) ParameterName(parameterName []string) ApiGetChannelParametersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetChannelParametersLOVRequest) ParameterValue(parameterValue []string) ApiGetChannelParametersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetChannelParametersLOVRequest) XExternalsystem(xExternalsystem string) ApiGetChannelParametersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetChannelParametersLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetChannelParametersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetChannelParametersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetChannelParametersLOVExecute(r)
}

/*
GetChannelParametersLOV Fetch List Of Values for Channel Parameters

 <p><strong>OperationId:</strong>getChannelParametersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Value of the parameter 'channelCode' which is required to fetch ChannelParameters LOV
 @param settingName Value of the parameter 'settingName' which is required to fetch ChannelParameters LOV
 @param levelType Value of the parameter 'levelType' which is required to fetch ChannelParameters LOV
 @param levelCode Value of the parameter 'levelCode' which is required to fetch ChannelParameters LOV
 @return ApiGetChannelParametersLOVRequest
*/
func (a *LOVApiService) GetChannelParametersLOV(ctx context.Context, channelCode string, settingName string, levelType string, levelCode string) ApiGetChannelParametersLOVRequest {
	return ApiGetChannelParametersLOVRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
		settingName: settingName,
		levelType: levelType,
		levelCode: levelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetChannelParametersLOVExecute(r ApiGetChannelParametersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetChannelParametersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/levelCode/{levelCode}/levelType/{levelType}/settingName/{settingName}/channelCode/{channelCode}/channelParameters"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"settingName"+"}", url.PathEscape(parameterValueToString(r.settingName, "settingName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelCode"+"}", url.PathEscape(parameterValueToString(r.levelCode, "levelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.settingName) < 1 {
		return localVarReturnValue, nil, reportError("settingName must have at least 1 elements")
	}
	if strlen(r.settingName) > 2000 {
		return localVarReturnValue, nil, reportError("settingName must have less than 2000 elements")
	}
	if strlen(r.levelType) < 1 {
		return localVarReturnValue, nil, reportError("levelType must have at least 1 elements")
	}
	if strlen(r.levelType) > 2000 {
		return localVarReturnValue, nil, reportError("levelType must have less than 2000 elements")
	}
	if strlen(r.levelCode) < 1 {
		return localVarReturnValue, nil, reportError("levelCode must have at least 1 elements")
	}
	if strlen(r.levelCode) > 2000 {
		return localVarReturnValue, nil, reportError("levelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClaimMembershipDetailsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetClaimMembershipDetailsLOVRequest) Authorization(authorization string) ApiGetClaimMembershipDetailsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetClaimMembershipDetailsLOVRequest) XAppKey(xAppKey string) ApiGetClaimMembershipDetailsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetClaimMembershipDetailsLOVRequest) XHotelid(xHotelid string) ApiGetClaimMembershipDetailsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetClaimMembershipDetailsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetClaimMembershipDetailsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetClaimMembershipDetailsLOVRequest) ParameterName(parameterName []string) ApiGetClaimMembershipDetailsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetClaimMembershipDetailsLOVRequest) ParameterValue(parameterValue []string) ApiGetClaimMembershipDetailsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetClaimMembershipDetailsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetClaimMembershipDetailsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetClaimMembershipDetailsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetClaimMembershipDetailsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetClaimMembershipDetailsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetClaimMembershipDetailsLOVExecute(r)
}

/*
GetClaimMembershipDetailsLOV Fetch List Of Values for Claim Membership Details

 <p><strong>OperationId:</strong>getClaimMembershipDetailsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch ClaimMembershipDetails LOV
 @return ApiGetClaimMembershipDetailsLOVRequest
*/
func (a *LOVApiService) GetClaimMembershipDetailsLOV(ctx context.Context, profileId string) ApiGetClaimMembershipDetailsLOVRequest {
	return ApiGetClaimMembershipDetailsLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetClaimMembershipDetailsLOVExecute(r ApiGetClaimMembershipDetailsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetClaimMembershipDetailsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/profiles/{profileId}/claimMembershipDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommissionCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCommissionCodeLOVRequest) Authorization(authorization string) ApiGetCommissionCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCommissionCodeLOVRequest) XAppKey(xAppKey string) ApiGetCommissionCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCommissionCodeLOVRequest) XHotelid(xHotelid string) ApiGetCommissionCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCommissionCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCommissionCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCommissionCodeLOVRequest) ParameterName(parameterName []string) ApiGetCommissionCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCommissionCodeLOVRequest) ParameterValue(parameterValue []string) ApiGetCommissionCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCommissionCodeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCommissionCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCommissionCodeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCommissionCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCommissionCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCommissionCodeLOVExecute(r)
}

/*
GetCommissionCodeLOV Fetch List Of Values for Commission Code

 <p><strong>OperationId:</strong>getCommissionCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CommissionCode LOV
 @return ApiGetCommissionCodeLOVRequest
*/
func (a *LOVApiService) GetCommissionCodeLOV(ctx context.Context, hotelId string) ApiGetCommissionCodeLOVRequest {
	return ApiGetCommissionCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCommissionCodeLOVExecute(r ApiGetCommissionCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCommissionCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/commissionCode"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommissionTxnCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCommissionTxnCodesLOVRequest) Authorization(authorization string) ApiGetCommissionTxnCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCommissionTxnCodesLOVRequest) XAppKey(xAppKey string) ApiGetCommissionTxnCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCommissionTxnCodesLOVRequest) XHotelid(xHotelid string) ApiGetCommissionTxnCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCommissionTxnCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCommissionTxnCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCommissionTxnCodesLOVRequest) ParameterName(parameterName []string) ApiGetCommissionTxnCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCommissionTxnCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetCommissionTxnCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCommissionTxnCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCommissionTxnCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCommissionTxnCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCommissionTxnCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCommissionTxnCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCommissionTxnCodesLOVExecute(r)
}

/*
GetCommissionTxnCodesLOV Fetch List Of Values for Commission Txn Codes

 <p><strong>OperationId:</strong>getCommissionTxnCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CommissionTxnCodes LOV
 @return ApiGetCommissionTxnCodesLOVRequest
*/
func (a *LOVApiService) GetCommissionTxnCodesLOV(ctx context.Context, hotelId string) ApiGetCommissionTxnCodesLOVRequest {
	return ApiGetCommissionTxnCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCommissionTxnCodesLOVExecute(r ApiGetCommissionTxnCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCommissionTxnCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/commissionTxnCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompAuthorizersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCompAuthorizersLOVRequest) Authorization(authorization string) ApiGetCompAuthorizersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCompAuthorizersLOVRequest) XAppKey(xAppKey string) ApiGetCompAuthorizersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCompAuthorizersLOVRequest) XHotelid(xHotelid string) ApiGetCompAuthorizersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCompAuthorizersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCompAuthorizersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCompAuthorizersLOVRequest) ParameterName(parameterName []string) ApiGetCompAuthorizersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCompAuthorizersLOVRequest) ParameterValue(parameterValue []string) ApiGetCompAuthorizersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCompAuthorizersLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCompAuthorizersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCompAuthorizersLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCompAuthorizersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCompAuthorizersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCompAuthorizersLOVExecute(r)
}

/*
GetCompAuthorizersLOV Fetch List Of Values for Comp Authorizers

 <p><strong>OperationId:</strong>getCompAuthorizersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CompAuthorizers LOV
 @return ApiGetCompAuthorizersLOVRequest
*/
func (a *LOVApiService) GetCompAuthorizersLOV(ctx context.Context, hotelId string) ApiGetCompAuthorizersLOVRequest {
	return ApiGetCompAuthorizersLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCompAuthorizersLOVExecute(r ApiGetCompAuthorizersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCompAuthorizersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/compAuthorizers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCompTypesLOVRequest) Authorization(authorization string) ApiGetCompTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCompTypesLOVRequest) XAppKey(xAppKey string) ApiGetCompTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCompTypesLOVRequest) XHotelid(xHotelid string) ApiGetCompTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCompTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCompTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCompTypesLOVRequest) ParameterName(parameterName []string) ApiGetCompTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCompTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetCompTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCompTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCompTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCompTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCompTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCompTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCompTypesLOVExecute(r)
}

/*
GetCompTypesLOV Fetch List Of Values for Comp Types

 <p><strong>OperationId:</strong>getCompTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CompTypes LOV
 @return ApiGetCompTypesLOVRequest
*/
func (a *LOVApiService) GetCompTypesLOV(ctx context.Context, hotelId string) ApiGetCompTypesLOVRequest {
	return ApiGetCompTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCompTypesLOVExecute(r ApiGetCompTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCompTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/compTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompaniesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCompaniesLOVRequest) Authorization(authorization string) ApiGetCompaniesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCompaniesLOVRequest) XAppKey(xAppKey string) ApiGetCompaniesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCompaniesLOVRequest) XHotelid(xHotelid string) ApiGetCompaniesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCompaniesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCompaniesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCompaniesLOVRequest) ParameterName(parameterName []string) ApiGetCompaniesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCompaniesLOVRequest) ParameterValue(parameterValue []string) ApiGetCompaniesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCompaniesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCompaniesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCompaniesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCompaniesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCompaniesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCompaniesLOVExecute(r)
}

/*
GetCompaniesLOV Fetch List Of Values for Companies

 <p><strong>OperationId:</strong>getCompaniesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Companies LOV
 @return ApiGetCompaniesLOVRequest
*/
func (a *LOVApiService) GetCompaniesLOV(ctx context.Context, hotelId string) ApiGetCompaniesLOVRequest {
	return ApiGetCompaniesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCompaniesLOVExecute(r ApiGetCompaniesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCompaniesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/companies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfLetterReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetConfLetterReportsLOVRequest) Authorization(authorization string) ApiGetConfLetterReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetConfLetterReportsLOVRequest) XAppKey(xAppKey string) ApiGetConfLetterReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetConfLetterReportsLOVRequest) XHotelid(xHotelid string) ApiGetConfLetterReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetConfLetterReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetConfLetterReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetConfLetterReportsLOVRequest) ParameterName(parameterName []string) ApiGetConfLetterReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetConfLetterReportsLOVRequest) ParameterValue(parameterValue []string) ApiGetConfLetterReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetConfLetterReportsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetConfLetterReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetConfLetterReportsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetConfLetterReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetConfLetterReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetConfLetterReportsLOVExecute(r)
}

/*
GetConfLetterReportsLOV Fetch List Of Values for Conf Letter Reports

 <p><strong>OperationId:</strong>getConfLetterReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ConfLetterReports LOV
 @return ApiGetConfLetterReportsLOVRequest
*/
func (a *LOVApiService) GetConfLetterReportsLOV(ctx context.Context, hotelId string) ApiGetConfLetterReportsLOVRequest {
	return ApiGetConfLetterReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetConfLetterReportsLOVExecute(r ApiGetConfLetterReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetConfLetterReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/confLetterReports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfigAdvDynamicBaseRatePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	daily string
	tiered string
	currentRateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetConfigAdvDynamicBaseRatePlansLOVRequest) Authorization(authorization string) ApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetConfigAdvDynamicBaseRatePlansLOVRequest) XAppKey(xAppKey string) ApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetConfigAdvDynamicBaseRatePlansLOVRequest) XHotelid(xHotelid string) ApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetConfigAdvDynamicBaseRatePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetConfigAdvDynamicBaseRatePlansLOVRequest) ParameterName(parameterName []string) ApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetConfigAdvDynamicBaseRatePlansLOVRequest) ParameterValue(parameterValue []string) ApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetConfigAdvDynamicBaseRatePlansLOVRequest) XExternalsystem(xExternalsystem string) ApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetConfigAdvDynamicBaseRatePlansLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetConfigAdvDynamicBaseRatePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetConfigAdvDynamicBaseRatePlansLOVExecute(r)
}

/*
GetConfigAdvDynamicBaseRatePlansLOV Fetch List Of Values for Config Adv Dynamic Base Rate Plans

 <p><strong>OperationId:</strong>getConfigAdvDynamicBaseRatePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param daily Value of the parameter 'daily' which is required to fetch ConfigAdvDynamicBaseRatePlans LOV
 @param tiered Value of the parameter 'tiered' which is required to fetch ConfigAdvDynamicBaseRatePlans LOV
 @param currentRateCode Value of the parameter 'currentRateCode' which is required to fetch ConfigAdvDynamicBaseRatePlans LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ConfigAdvDynamicBaseRatePlans LOV
 @return ApiGetConfigAdvDynamicBaseRatePlansLOVRequest
*/
func (a *LOVApiService) GetConfigAdvDynamicBaseRatePlansLOV(ctx context.Context, daily string, tiered string, currentRateCode string, hotelId string) ApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	return ApiGetConfigAdvDynamicBaseRatePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		daily: daily,
		tiered: tiered,
		currentRateCode: currentRateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetConfigAdvDynamicBaseRatePlansLOVExecute(r ApiGetConfigAdvDynamicBaseRatePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetConfigAdvDynamicBaseRatePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/currentRateCode/{currentRateCode}/tiered/{tiered}/daily/{daily}/configAdvDynamicBaseRatePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"daily"+"}", url.PathEscape(parameterValueToString(r.daily, "daily")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tiered"+"}", url.PathEscape(parameterValueToString(r.tiered, "tiered")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"currentRateCode"+"}", url.PathEscape(parameterValueToString(r.currentRateCode, "currentRateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.daily) < 1 {
		return localVarReturnValue, nil, reportError("daily must have at least 1 elements")
	}
	if strlen(r.daily) > 2000 {
		return localVarReturnValue, nil, reportError("daily must have less than 2000 elements")
	}
	if strlen(r.tiered) < 1 {
		return localVarReturnValue, nil, reportError("tiered must have at least 1 elements")
	}
	if strlen(r.tiered) > 2000 {
		return localVarReturnValue, nil, reportError("tiered must have less than 2000 elements")
	}
	if strlen(r.currentRateCode) < 1 {
		return localVarReturnValue, nil, reportError("currentRateCode must have at least 1 elements")
	}
	if strlen(r.currentRateCode) > 2000 {
		return localVarReturnValue, nil, reportError("currentRateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfigBaseRatePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	tiered string
	daily string
	currencyCode string
	currentRateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetConfigBaseRatePlansLOVRequest) Authorization(authorization string) ApiGetConfigBaseRatePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetConfigBaseRatePlansLOVRequest) XAppKey(xAppKey string) ApiGetConfigBaseRatePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetConfigBaseRatePlansLOVRequest) XHotelid(xHotelid string) ApiGetConfigBaseRatePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetConfigBaseRatePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetConfigBaseRatePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetConfigBaseRatePlansLOVRequest) ParameterName(parameterName []string) ApiGetConfigBaseRatePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetConfigBaseRatePlansLOVRequest) ParameterValue(parameterValue []string) ApiGetConfigBaseRatePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetConfigBaseRatePlansLOVRequest) XExternalsystem(xExternalsystem string) ApiGetConfigBaseRatePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetConfigBaseRatePlansLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetConfigBaseRatePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetConfigBaseRatePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetConfigBaseRatePlansLOVExecute(r)
}

/*
GetConfigBaseRatePlansLOV Fetch List Of Values for Config Base Rate Plans

 <p><strong>OperationId:</strong>getConfigBaseRatePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tiered Value of the parameter 'tiered' which is required to fetch ConfigBaseRatePlans LOV
 @param daily Value of the parameter 'daily' which is required to fetch ConfigBaseRatePlans LOV
 @param currencyCode Value of the parameter 'currencyCode' which is required to fetch ConfigBaseRatePlans LOV
 @param currentRateCode Value of the parameter 'currentRateCode' which is required to fetch ConfigBaseRatePlans LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ConfigBaseRatePlans LOV
 @return ApiGetConfigBaseRatePlansLOVRequest
*/
func (a *LOVApiService) GetConfigBaseRatePlansLOV(ctx context.Context, tiered string, daily string, currencyCode string, currentRateCode string, hotelId string) ApiGetConfigBaseRatePlansLOVRequest {
	return ApiGetConfigBaseRatePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		tiered: tiered,
		daily: daily,
		currencyCode: currencyCode,
		currentRateCode: currentRateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetConfigBaseRatePlansLOVExecute(r ApiGetConfigBaseRatePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetConfigBaseRatePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/currentRateCode/{currentRateCode}/currencyCode/{currencyCode}/daily/{daily}/tiered/{tiered}/configBaseRatePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"tiered"+"}", url.PathEscape(parameterValueToString(r.tiered, "tiered")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"daily"+"}", url.PathEscape(parameterValueToString(r.daily, "daily")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"currencyCode"+"}", url.PathEscape(parameterValueToString(r.currencyCode, "currencyCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"currentRateCode"+"}", url.PathEscape(parameterValueToString(r.currentRateCode, "currentRateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.tiered) < 1 {
		return localVarReturnValue, nil, reportError("tiered must have at least 1 elements")
	}
	if strlen(r.tiered) > 2000 {
		return localVarReturnValue, nil, reportError("tiered must have less than 2000 elements")
	}
	if strlen(r.daily) < 1 {
		return localVarReturnValue, nil, reportError("daily must have at least 1 elements")
	}
	if strlen(r.daily) > 2000 {
		return localVarReturnValue, nil, reportError("daily must have less than 2000 elements")
	}
	if strlen(r.currencyCode) < 1 {
		return localVarReturnValue, nil, reportError("currencyCode must have at least 1 elements")
	}
	if strlen(r.currencyCode) > 2000 {
		return localVarReturnValue, nil, reportError("currencyCode must have less than 2000 elements")
	}
	if strlen(r.currentRateCode) < 1 {
		return localVarReturnValue, nil, reportError("currentRateCode must have at least 1 elements")
	}
	if strlen(r.currentRateCode) > 2000 {
		return localVarReturnValue, nil, reportError("currentRateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfigDynamicBaseRatePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	currentRateCode string
	tiered string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetConfigDynamicBaseRatePlansLOVRequest) Authorization(authorization string) ApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetConfigDynamicBaseRatePlansLOVRequest) XAppKey(xAppKey string) ApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetConfigDynamicBaseRatePlansLOVRequest) XHotelid(xHotelid string) ApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetConfigDynamicBaseRatePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetConfigDynamicBaseRatePlansLOVRequest) ParameterName(parameterName []string) ApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetConfigDynamicBaseRatePlansLOVRequest) ParameterValue(parameterValue []string) ApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetConfigDynamicBaseRatePlansLOVRequest) XExternalsystem(xExternalsystem string) ApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetConfigDynamicBaseRatePlansLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetConfigDynamicBaseRatePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetConfigDynamicBaseRatePlansLOVExecute(r)
}

/*
GetConfigDynamicBaseRatePlansLOV Fetch List Of Values for Config Dynamic Base Rate Plans

 <p><strong>OperationId:</strong>getConfigDynamicBaseRatePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currentRateCode Value of the parameter 'currentRateCode' which is required to fetch ConfigDynamicBaseRatePlans LOV
 @param tiered Value of the parameter 'tiered' which is required to fetch ConfigDynamicBaseRatePlans LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ConfigDynamicBaseRatePlans LOV
 @return ApiGetConfigDynamicBaseRatePlansLOVRequest
*/
func (a *LOVApiService) GetConfigDynamicBaseRatePlansLOV(ctx context.Context, currentRateCode string, tiered string, hotelId string) ApiGetConfigDynamicBaseRatePlansLOVRequest {
	return ApiGetConfigDynamicBaseRatePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		currentRateCode: currentRateCode,
		tiered: tiered,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetConfigDynamicBaseRatePlansLOVExecute(r ApiGetConfigDynamicBaseRatePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetConfigDynamicBaseRatePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/tiered/{tiered}/currentRateCode/{currentRateCode}/configDynamicBaseRatePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"currentRateCode"+"}", url.PathEscape(parameterValueToString(r.currentRateCode, "currentRateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tiered"+"}", url.PathEscape(parameterValueToString(r.tiered, "tiered")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.currentRateCode) < 1 {
		return localVarReturnValue, nil, reportError("currentRateCode must have at least 1 elements")
	}
	if strlen(r.currentRateCode) > 2000 {
		return localVarReturnValue, nil, reportError("currentRateCode must have less than 2000 elements")
	}
	if strlen(r.tiered) < 1 {
		return localVarReturnValue, nil, reportError("tiered must have at least 1 elements")
	}
	if strlen(r.tiered) > 2000 {
		return localVarReturnValue, nil, reportError("tiered must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfigReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	moduleName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetConfigReportsLOVRequest) Authorization(authorization string) ApiGetConfigReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetConfigReportsLOVRequest) XAppKey(xAppKey string) ApiGetConfigReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetConfigReportsLOVRequest) XHotelid(xHotelid string) ApiGetConfigReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetConfigReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetConfigReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetConfigReportsLOVRequest) ParameterName(parameterName []string) ApiGetConfigReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetConfigReportsLOVRequest) ParameterValue(parameterValue []string) ApiGetConfigReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetConfigReportsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetConfigReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetConfigReportsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetConfigReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetConfigReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetConfigReportsLOVExecute(r)
}

/*
GetConfigReportsLOV Fetch List Of Values for Config Reports

 <p><strong>OperationId:</strong>getConfigReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param moduleName Value of the parameter 'moduleName' which is required to fetch ConfigReports LOV
 @return ApiGetConfigReportsLOVRequest
*/
func (a *LOVApiService) GetConfigReportsLOV(ctx context.Context, moduleName string) ApiGetConfigReportsLOVRequest {
	return ApiGetConfigReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		moduleName: moduleName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetConfigReportsLOVExecute(r ApiGetConfigReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetConfigReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/moduleName/{moduleName}/configReports"
	localVarPath = strings.Replace(localVarPath, "{"+"moduleName"+"}", url.PathEscape(parameterValueToString(r.moduleName, "moduleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.moduleName) < 1 {
		return localVarReturnValue, nil, reportError("moduleName must have at least 1 elements")
	}
	if strlen(r.moduleName) > 2000 {
		return localVarReturnValue, nil, reportError("moduleName must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConnectingSuitesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetConnectingSuitesLOVRequest) Authorization(authorization string) ApiGetConnectingSuitesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetConnectingSuitesLOVRequest) XAppKey(xAppKey string) ApiGetConnectingSuitesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetConnectingSuitesLOVRequest) XHotelid(xHotelid string) ApiGetConnectingSuitesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetConnectingSuitesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetConnectingSuitesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetConnectingSuitesLOVRequest) ParameterName(parameterName []string) ApiGetConnectingSuitesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetConnectingSuitesLOVRequest) ParameterValue(parameterValue []string) ApiGetConnectingSuitesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetConnectingSuitesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetConnectingSuitesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetConnectingSuitesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetConnectingSuitesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetConnectingSuitesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetConnectingSuitesLOVExecute(r)
}

/*
GetConnectingSuitesLOV Fetch List Of Values for Connecting Suites

 <p><strong>OperationId:</strong>getConnectingSuitesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomNumber Value of the parameter 'roomNumber' which is required to fetch ConnectingSuites LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ConnectingSuites LOV
 @return ApiGetConnectingSuitesLOVRequest
*/
func (a *LOVApiService) GetConnectingSuitesLOV(ctx context.Context, roomNumber string, hotelId string) ApiGetConnectingSuitesLOVRequest {
	return ApiGetConnectingSuitesLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomNumber: roomNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetConnectingSuitesLOVExecute(r ApiGetConnectingSuitesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetConnectingSuitesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomNumber/{roomNumber}/connectingSuites"
	localVarPath = strings.Replace(localVarPath, "{"+"roomNumber"+"}", url.PathEscape(parameterValueToString(r.roomNumber, "roomNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomNumber) < 1 {
		return localVarReturnValue, nil, reportError("roomNumber must have at least 1 elements")
	}
	if strlen(r.roomNumber) > 2000 {
		return localVarReturnValue, nil, reportError("roomNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreditCardTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCreditCardTypesLOVRequest) Authorization(authorization string) ApiGetCreditCardTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCreditCardTypesLOVRequest) XAppKey(xAppKey string) ApiGetCreditCardTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCreditCardTypesLOVRequest) XHotelid(xHotelid string) ApiGetCreditCardTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCreditCardTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCreditCardTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCreditCardTypesLOVRequest) ParameterName(parameterName []string) ApiGetCreditCardTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCreditCardTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetCreditCardTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCreditCardTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCreditCardTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCreditCardTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCreditCardTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCreditCardTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCreditCardTypesLOVExecute(r)
}

/*
GetCreditCardTypesLOV Fetch List Of Values for Credit Card Types

 <p><strong>OperationId:</strong>getCreditCardTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CreditCardTypes LOV
 @return ApiGetCreditCardTypesLOVRequest
*/
func (a *LOVApiService) GetCreditCardTypesLOV(ctx context.Context, hotelId string) ApiGetCreditCardTypesLOVRequest {
	return ApiGetCreditCardTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCreditCardTypesLOVExecute(r ApiGetCreditCardTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCreditCardTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/creditCardTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCroUsersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	userId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCroUsersLOVRequest) Authorization(authorization string) ApiGetCroUsersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCroUsersLOVRequest) XAppKey(xAppKey string) ApiGetCroUsersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCroUsersLOVRequest) XHotelid(xHotelid string) ApiGetCroUsersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCroUsersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCroUsersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCroUsersLOVRequest) ParameterName(parameterName []string) ApiGetCroUsersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCroUsersLOVRequest) ParameterValue(parameterValue []string) ApiGetCroUsersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCroUsersLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCroUsersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCroUsersLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCroUsersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCroUsersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCroUsersLOVExecute(r)
}

/*
GetCroUsersLOV Fetch List Of Values for Cro Users

 <p><strong>OperationId:</strong>getCroUsersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Value of the parameter 'userId' which is required to fetch CroUsers LOV
 @return ApiGetCroUsersLOVRequest
*/
func (a *LOVApiService) GetCroUsersLOV(ctx context.Context, userId string) ApiGetCroUsersLOVRequest {
	return ApiGetCroUsersLOVRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCroUsersLOVExecute(r ApiGetCroUsersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCroUsersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/userId/{userId}/croUsers"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.userId) < 1 {
		return localVarReturnValue, nil, reportError("userId must have at least 1 elements")
	}
	if strlen(r.userId) > 2000 {
		return localVarReturnValue, nil, reportError("userId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrencyExchangeRatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	exchangeType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCurrencyExchangeRatesLOVRequest) Authorization(authorization string) ApiGetCurrencyExchangeRatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCurrencyExchangeRatesLOVRequest) XAppKey(xAppKey string) ApiGetCurrencyExchangeRatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCurrencyExchangeRatesLOVRequest) XHotelid(xHotelid string) ApiGetCurrencyExchangeRatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCurrencyExchangeRatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCurrencyExchangeRatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCurrencyExchangeRatesLOVRequest) ParameterName(parameterName []string) ApiGetCurrencyExchangeRatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCurrencyExchangeRatesLOVRequest) ParameterValue(parameterValue []string) ApiGetCurrencyExchangeRatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCurrencyExchangeRatesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCurrencyExchangeRatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCurrencyExchangeRatesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCurrencyExchangeRatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCurrencyExchangeRatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCurrencyExchangeRatesLOVExecute(r)
}

/*
GetCurrencyExchangeRatesLOV Fetch List Of Values for Currency Exchange Rates

 <p><strong>OperationId:</strong>getCurrencyExchangeRatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exchangeType Value of the parameter 'exchangeType' which is required to fetch CurrencyExchangeRates LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CurrencyExchangeRates LOV
 @return ApiGetCurrencyExchangeRatesLOVRequest
*/
func (a *LOVApiService) GetCurrencyExchangeRatesLOV(ctx context.Context, exchangeType string, hotelId string) ApiGetCurrencyExchangeRatesLOVRequest {
	return ApiGetCurrencyExchangeRatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		exchangeType: exchangeType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCurrencyExchangeRatesLOVExecute(r ApiGetCurrencyExchangeRatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCurrencyExchangeRatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/exchangeType/{exchangeType}/currencyExchangeRates"
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeType"+"}", url.PathEscape(parameterValueToString(r.exchangeType, "exchangeType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.exchangeType) < 1 {
		return localVarReturnValue, nil, reportError("exchangeType must have at least 1 elements")
	}
	if strlen(r.exchangeType) > 2000 {
		return localVarReturnValue, nil, reportError("exchangeType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrencyFormatsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	decimal string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCurrencyFormatsLOVRequest) Authorization(authorization string) ApiGetCurrencyFormatsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCurrencyFormatsLOVRequest) XAppKey(xAppKey string) ApiGetCurrencyFormatsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCurrencyFormatsLOVRequest) XHotelid(xHotelid string) ApiGetCurrencyFormatsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCurrencyFormatsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCurrencyFormatsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCurrencyFormatsLOVRequest) ParameterName(parameterName []string) ApiGetCurrencyFormatsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCurrencyFormatsLOVRequest) ParameterValue(parameterValue []string) ApiGetCurrencyFormatsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCurrencyFormatsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCurrencyFormatsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCurrencyFormatsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCurrencyFormatsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCurrencyFormatsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCurrencyFormatsLOVExecute(r)
}

/*
GetCurrencyFormatsLOV Fetch List Of Values for Currency Formats

 <p><strong>OperationId:</strong>getCurrencyFormatsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param decimal Value of the parameter 'decimal' which is required to fetch CurrencyFormats LOV
 @return ApiGetCurrencyFormatsLOVRequest
*/
func (a *LOVApiService) GetCurrencyFormatsLOV(ctx context.Context, decimal string) ApiGetCurrencyFormatsLOVRequest {
	return ApiGetCurrencyFormatsLOVRequest{
		ApiService: a,
		ctx: ctx,
		decimal: decimal,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCurrencyFormatsLOVExecute(r ApiGetCurrencyFormatsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCurrencyFormatsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/decimal/{decimal}/currencyFormats"
	localVarPath = strings.Replace(localVarPath, "{"+"decimal"+"}", url.PathEscape(parameterValueToString(r.decimal, "decimal")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.decimal) < 1 {
		return localVarReturnValue, nil, reportError("decimal must have at least 1 elements")
	}
	if strlen(r.decimal) > 2000 {
		return localVarReturnValue, nil, reportError("decimal must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomNumberConfigCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCustomNumberConfigCodesLOVRequest) Authorization(authorization string) ApiGetCustomNumberConfigCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCustomNumberConfigCodesLOVRequest) XAppKey(xAppKey string) ApiGetCustomNumberConfigCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCustomNumberConfigCodesLOVRequest) XHotelid(xHotelid string) ApiGetCustomNumberConfigCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCustomNumberConfigCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCustomNumberConfigCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCustomNumberConfigCodesLOVRequest) ParameterName(parameterName []string) ApiGetCustomNumberConfigCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCustomNumberConfigCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetCustomNumberConfigCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCustomNumberConfigCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCustomNumberConfigCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCustomNumberConfigCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCustomNumberConfigCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCustomNumberConfigCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCustomNumberConfigCodesLOVExecute(r)
}

/*
GetCustomNumberConfigCodesLOV Fetch List Of Values for Custom Number Config Codes

 <p><strong>OperationId:</strong>getCustomNumberConfigCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CustomNumberConfigCodes LOV
 @return ApiGetCustomNumberConfigCodesLOVRequest
*/
func (a *LOVApiService) GetCustomNumberConfigCodesLOV(ctx context.Context, hotelId string) ApiGetCustomNumberConfigCodesLOVRequest {
	return ApiGetCustomNumberConfigCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCustomNumberConfigCodesLOVExecute(r ApiGetCustomNumberConfigCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCustomNumberConfigCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/customNumberConfigCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomRoomTranslationLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	dbfLogo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetCustomRoomTranslationLOVRequest) Authorization(authorization string) ApiGetCustomRoomTranslationLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetCustomRoomTranslationLOVRequest) XAppKey(xAppKey string) ApiGetCustomRoomTranslationLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetCustomRoomTranslationLOVRequest) XHotelid(xHotelid string) ApiGetCustomRoomTranslationLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetCustomRoomTranslationLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetCustomRoomTranslationLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetCustomRoomTranslationLOVRequest) ParameterName(parameterName []string) ApiGetCustomRoomTranslationLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetCustomRoomTranslationLOVRequest) ParameterValue(parameterValue []string) ApiGetCustomRoomTranslationLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetCustomRoomTranslationLOVRequest) XExternalsystem(xExternalsystem string) ApiGetCustomRoomTranslationLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetCustomRoomTranslationLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetCustomRoomTranslationLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetCustomRoomTranslationLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCustomRoomTranslationLOVExecute(r)
}

/*
GetCustomRoomTranslationLOV Fetch List Of Values for Custom Room Translation

 <p><strong>OperationId:</strong>getCustomRoomTranslationLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dbfLogo Value of the parameter 'dbfLogo' which is required to fetch CustomRoomTranslation LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CustomRoomTranslation LOV
 @return ApiGetCustomRoomTranslationLOVRequest
*/
func (a *LOVApiService) GetCustomRoomTranslationLOV(ctx context.Context, dbfLogo string, hotelId string) ApiGetCustomRoomTranslationLOVRequest {
	return ApiGetCustomRoomTranslationLOVRequest{
		ApiService: a,
		ctx: ctx,
		dbfLogo: dbfLogo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCustomRoomTranslationLOVExecute(r ApiGetCustomRoomTranslationLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCustomRoomTranslationLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/dbfLogo/{dbfLogo}/customRoomTranslation"
	localVarPath = strings.Replace(localVarPath, "{"+"dbfLogo"+"}", url.PathEscape(parameterValueToString(r.dbfLogo, "dbfLogo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.dbfLogo) < 1 {
		return localVarReturnValue, nil, reportError("dbfLogo must have at least 1 elements")
	}
	if strlen(r.dbfLogo) > 2000 {
		return localVarReturnValue, nil, reportError("dbfLogo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDepositCancelRulesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	policyType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetDepositCancelRulesLOVRequest) Authorization(authorization string) ApiGetDepositCancelRulesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetDepositCancelRulesLOVRequest) XAppKey(xAppKey string) ApiGetDepositCancelRulesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetDepositCancelRulesLOVRequest) XHotelid(xHotelid string) ApiGetDepositCancelRulesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetDepositCancelRulesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetDepositCancelRulesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetDepositCancelRulesLOVRequest) ParameterName(parameterName []string) ApiGetDepositCancelRulesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetDepositCancelRulesLOVRequest) ParameterValue(parameterValue []string) ApiGetDepositCancelRulesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetDepositCancelRulesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetDepositCancelRulesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetDepositCancelRulesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetDepositCancelRulesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetDepositCancelRulesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetDepositCancelRulesLOVExecute(r)
}

/*
GetDepositCancelRulesLOV Fetch List Of Values for Deposit Cancel Rules

 <p><strong>OperationId:</strong>getDepositCancelRulesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyType Value of the parameter 'policyType' which is required to fetch DepositCancelRules LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch DepositCancelRules LOV
 @return ApiGetDepositCancelRulesLOVRequest
*/
func (a *LOVApiService) GetDepositCancelRulesLOV(ctx context.Context, policyType string, hotelId string) ApiGetDepositCancelRulesLOVRequest {
	return ApiGetDepositCancelRulesLOVRequest{
		ApiService: a,
		ctx: ctx,
		policyType: policyType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetDepositCancelRulesLOVExecute(r ApiGetDepositCancelRulesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetDepositCancelRulesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/policyType/{policyType}/depositCancelRules"
	localVarPath = strings.Replace(localVarPath, "{"+"policyType"+"}", url.PathEscape(parameterValueToString(r.policyType, "policyType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.policyType) < 1 {
		return localVarReturnValue, nil, reportError("policyType must have at least 1 elements")
	}
	if strlen(r.policyType) > 2000 {
		return localVarReturnValue, nil, reportError("policyType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDepositCancelRulesMultiHotelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	policyType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetDepositCancelRulesMultiHotelLOVRequest) Authorization(authorization string) ApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetDepositCancelRulesMultiHotelLOVRequest) XAppKey(xAppKey string) ApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetDepositCancelRulesMultiHotelLOVRequest) XHotelid(xHotelid string) ApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetDepositCancelRulesMultiHotelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetDepositCancelRulesMultiHotelLOVRequest) ParameterName(parameterName []string) ApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetDepositCancelRulesMultiHotelLOVRequest) ParameterValue(parameterValue []string) ApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetDepositCancelRulesMultiHotelLOVRequest) XExternalsystem(xExternalsystem string) ApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetDepositCancelRulesMultiHotelLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetDepositCancelRulesMultiHotelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetDepositCancelRulesMultiHotelLOVExecute(r)
}

/*
GetDepositCancelRulesMultiHotelLOV Fetch List Of Values for Deposit Cancel Rules Multi Hotel

 <p><strong>OperationId:</strong>getDepositCancelRulesMultiHotelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyType Value of the parameter 'policyType' which is required to fetch DepositCancelRulesMultiHotel LOV
 @return ApiGetDepositCancelRulesMultiHotelLOVRequest
*/
func (a *LOVApiService) GetDepositCancelRulesMultiHotelLOV(ctx context.Context, policyType string) ApiGetDepositCancelRulesMultiHotelLOVRequest {
	return ApiGetDepositCancelRulesMultiHotelLOVRequest{
		ApiService: a,
		ctx: ctx,
		policyType: policyType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetDepositCancelRulesMultiHotelLOVExecute(r ApiGetDepositCancelRulesMultiHotelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetDepositCancelRulesMultiHotelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/policyType/{policyType}/depositCancelRulesMultiHotel"
	localVarPath = strings.Replace(localVarPath, "{"+"policyType"+"}", url.PathEscape(parameterValueToString(r.policyType, "policyType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.policyType) < 1 {
		return localVarReturnValue, nil, reportError("policyType must have at least 1 elements")
	}
	if strlen(r.policyType) > 2000 {
		return localVarReturnValue, nil, reportError("policyType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceCodeMappingValuesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	externalCode string
	codeType string
	deviceCode string
	deviceType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetDeviceCodeMappingValuesLOVRequest) Authorization(authorization string) ApiGetDeviceCodeMappingValuesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetDeviceCodeMappingValuesLOVRequest) XAppKey(xAppKey string) ApiGetDeviceCodeMappingValuesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetDeviceCodeMappingValuesLOVRequest) XHotelid(xHotelid string) ApiGetDeviceCodeMappingValuesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetDeviceCodeMappingValuesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetDeviceCodeMappingValuesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetDeviceCodeMappingValuesLOVRequest) ParameterName(parameterName []string) ApiGetDeviceCodeMappingValuesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetDeviceCodeMappingValuesLOVRequest) ParameterValue(parameterValue []string) ApiGetDeviceCodeMappingValuesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetDeviceCodeMappingValuesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetDeviceCodeMappingValuesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetDeviceCodeMappingValuesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetDeviceCodeMappingValuesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetDeviceCodeMappingValuesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetDeviceCodeMappingValuesLOVExecute(r)
}

/*
GetDeviceCodeMappingValuesLOV Fetch List Of Values for Device Code Mapping Values

 <p><strong>OperationId:</strong>getDeviceCodeMappingValuesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalCode Value of the parameter 'externalCode' which is required to fetch DeviceCodeMappingValues LOV
 @param codeType Value of the parameter 'codeType' which is required to fetch DeviceCodeMappingValues LOV
 @param deviceCode Value of the parameter 'deviceCode' which is required to fetch DeviceCodeMappingValues LOV
 @param deviceType Value of the parameter 'deviceType' which is required to fetch DeviceCodeMappingValues LOV
 @return ApiGetDeviceCodeMappingValuesLOVRequest
*/
func (a *LOVApiService) GetDeviceCodeMappingValuesLOV(ctx context.Context, externalCode string, codeType string, deviceCode string, deviceType string) ApiGetDeviceCodeMappingValuesLOVRequest {
	return ApiGetDeviceCodeMappingValuesLOVRequest{
		ApiService: a,
		ctx: ctx,
		externalCode: externalCode,
		codeType: codeType,
		deviceCode: deviceCode,
		deviceType: deviceType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetDeviceCodeMappingValuesLOVExecute(r ApiGetDeviceCodeMappingValuesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetDeviceCodeMappingValuesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/deviceType/{deviceType}/deviceCode/{deviceCode}/codeType/{codeType}/externalCode/{externalCode}/deviceCodeMappingValues"
	localVarPath = strings.Replace(localVarPath, "{"+"externalCode"+"}", url.PathEscape(parameterValueToString(r.externalCode, "externalCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"codeType"+"}", url.PathEscape(parameterValueToString(r.codeType, "codeType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceCode"+"}", url.PathEscape(parameterValueToString(r.deviceCode, "deviceCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceType"+"}", url.PathEscape(parameterValueToString(r.deviceType, "deviceType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.externalCode) < 1 {
		return localVarReturnValue, nil, reportError("externalCode must have at least 1 elements")
	}
	if strlen(r.externalCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalCode must have less than 2000 elements")
	}
	if strlen(r.codeType) < 1 {
		return localVarReturnValue, nil, reportError("codeType must have at least 1 elements")
	}
	if strlen(r.codeType) > 2000 {
		return localVarReturnValue, nil, reportError("codeType must have less than 2000 elements")
	}
	if strlen(r.deviceCode) < 1 {
		return localVarReturnValue, nil, reportError("deviceCode must have at least 1 elements")
	}
	if strlen(r.deviceCode) > 2000 {
		return localVarReturnValue, nil, reportError("deviceCode must have less than 2000 elements")
	}
	if strlen(r.deviceType) < 1 {
		return localVarReturnValue, nil, reportError("deviceType must have at least 1 elements")
	}
	if strlen(r.deviceType) > 2000 {
		return localVarReturnValue, nil, reportError("deviceType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceLocationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetDeviceLocationsLOVRequest) Authorization(authorization string) ApiGetDeviceLocationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetDeviceLocationsLOVRequest) XAppKey(xAppKey string) ApiGetDeviceLocationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetDeviceLocationsLOVRequest) XHotelid(xHotelid string) ApiGetDeviceLocationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetDeviceLocationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetDeviceLocationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetDeviceLocationsLOVRequest) ParameterName(parameterName []string) ApiGetDeviceLocationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetDeviceLocationsLOVRequest) ParameterValue(parameterValue []string) ApiGetDeviceLocationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetDeviceLocationsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetDeviceLocationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetDeviceLocationsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetDeviceLocationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetDeviceLocationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetDeviceLocationsLOVExecute(r)
}

/*
GetDeviceLocationsLOV Fetch List Of Values for Device Locations

 <p><strong>OperationId:</strong>getDeviceLocationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch DeviceLocations LOV
 @return ApiGetDeviceLocationsLOVRequest
*/
func (a *LOVApiService) GetDeviceLocationsLOV(ctx context.Context, hotelId string) ApiGetDeviceLocationsLOVRequest {
	return ApiGetDeviceLocationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetDeviceLocationsLOVExecute(r ApiGetDeviceLocationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetDeviceLocationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/deviceLocations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDietaryPreferencesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetDietaryPreferencesLOVRequest) Authorization(authorization string) ApiGetDietaryPreferencesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetDietaryPreferencesLOVRequest) XAppKey(xAppKey string) ApiGetDietaryPreferencesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetDietaryPreferencesLOVRequest) XHotelid(xHotelid string) ApiGetDietaryPreferencesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetDietaryPreferencesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetDietaryPreferencesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetDietaryPreferencesLOVRequest) ParameterName(parameterName []string) ApiGetDietaryPreferencesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetDietaryPreferencesLOVRequest) ParameterValue(parameterValue []string) ApiGetDietaryPreferencesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetDietaryPreferencesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetDietaryPreferencesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetDietaryPreferencesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetDietaryPreferencesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetDietaryPreferencesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetDietaryPreferencesLOVExecute(r)
}

/*
GetDietaryPreferencesLOV Fetch List Of Values for Dietary Preferences

 <p><strong>OperationId:</strong>getDietaryPreferencesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch DietaryPreferences LOV
 @return ApiGetDietaryPreferencesLOVRequest
*/
func (a *LOVApiService) GetDietaryPreferencesLOV(ctx context.Context, hotelId string) ApiGetDietaryPreferencesLOVRequest {
	return ApiGetDietaryPreferencesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetDietaryPreferencesLOVExecute(r ApiGetDietaryPreferencesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetDietaryPreferencesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/dietaryPreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDistributionTemplatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	location string
	locationType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetDistributionTemplatesLOVRequest) Authorization(authorization string) ApiGetDistributionTemplatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetDistributionTemplatesLOVRequest) XAppKey(xAppKey string) ApiGetDistributionTemplatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetDistributionTemplatesLOVRequest) XHotelid(xHotelid string) ApiGetDistributionTemplatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetDistributionTemplatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetDistributionTemplatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetDistributionTemplatesLOVRequest) ParameterName(parameterName []string) ApiGetDistributionTemplatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetDistributionTemplatesLOVRequest) ParameterValue(parameterValue []string) ApiGetDistributionTemplatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetDistributionTemplatesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetDistributionTemplatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetDistributionTemplatesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetDistributionTemplatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetDistributionTemplatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetDistributionTemplatesLOVExecute(r)
}

/*
GetDistributionTemplatesLOV Fetch List Of Values for Distribution Templates

 <p><strong>OperationId:</strong>getDistributionTemplatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param location Value of the parameter 'location' which is required to fetch DistributionTemplates LOV
 @param locationType Value of the parameter 'locationType' which is required to fetch DistributionTemplates LOV
 @return ApiGetDistributionTemplatesLOVRequest
*/
func (a *LOVApiService) GetDistributionTemplatesLOV(ctx context.Context, location string, locationType string) ApiGetDistributionTemplatesLOVRequest {
	return ApiGetDistributionTemplatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		location: location,
		locationType: locationType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetDistributionTemplatesLOVExecute(r ApiGetDistributionTemplatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetDistributionTemplatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/locationType/{locationType}/location/{location}/distributionTemplates"
	localVarPath = strings.Replace(localVarPath, "{"+"location"+"}", url.PathEscape(parameterValueToString(r.location, "location")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationType"+"}", url.PathEscape(parameterValueToString(r.locationType, "locationType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.location) < 1 {
		return localVarReturnValue, nil, reportError("location must have at least 1 elements")
	}
	if strlen(r.location) > 2000 {
		return localVarReturnValue, nil, reportError("location must have less than 2000 elements")
	}
	if strlen(r.locationType) < 1 {
		return localVarReturnValue, nil, reportError("locationType must have at least 1 elements")
	}
	if strlen(r.locationType) > 2000 {
		return localVarReturnValue, nil, reportError("locationType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetECertificateGroupEntityLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	entityName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetECertificateGroupEntityLOVRequest) Authorization(authorization string) ApiGetECertificateGroupEntityLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetECertificateGroupEntityLOVRequest) XAppKey(xAppKey string) ApiGetECertificateGroupEntityLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetECertificateGroupEntityLOVRequest) XHotelid(xHotelid string) ApiGetECertificateGroupEntityLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetECertificateGroupEntityLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetECertificateGroupEntityLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetECertificateGroupEntityLOVRequest) ParameterName(parameterName []string) ApiGetECertificateGroupEntityLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetECertificateGroupEntityLOVRequest) ParameterValue(parameterValue []string) ApiGetECertificateGroupEntityLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetECertificateGroupEntityLOVRequest) XExternalsystem(xExternalsystem string) ApiGetECertificateGroupEntityLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetECertificateGroupEntityLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetECertificateGroupEntityLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetECertificateGroupEntityLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetECertificateGroupEntityLOVExecute(r)
}

/*
GetECertificateGroupEntityLOV Fetch List Of Values for ECertificate Group Entity

 <p><strong>OperationId:</strong>getECertificateGroupEntityLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entityName Value of the parameter 'entityName' which is required to fetch ECertificateGroupEntity LOV
 @return ApiGetECertificateGroupEntityLOVRequest
*/
func (a *LOVApiService) GetECertificateGroupEntityLOV(ctx context.Context, entityName string) ApiGetECertificateGroupEntityLOVRequest {
	return ApiGetECertificateGroupEntityLOVRequest{
		ApiService: a,
		ctx: ctx,
		entityName: entityName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetECertificateGroupEntityLOVExecute(r ApiGetECertificateGroupEntityLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetECertificateGroupEntityLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/entityName/{entityName}/eCertificateGroupEntity"
	localVarPath = strings.Replace(localVarPath, "{"+"entityName"+"}", url.PathEscape(parameterValueToString(r.entityName, "entityName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.entityName) < 1 {
		return localVarReturnValue, nil, reportError("entityName must have at least 1 elements")
	}
	if strlen(r.entityName) > 2000 {
		return localVarReturnValue, nil, reportError("entityName must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetECouponLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetECouponLOVRequest) Authorization(authorization string) ApiGetECouponLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetECouponLOVRequest) XAppKey(xAppKey string) ApiGetECouponLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetECouponLOVRequest) XHotelid(xHotelid string) ApiGetECouponLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetECouponLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetECouponLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetECouponLOVRequest) ParameterName(parameterName []string) ApiGetECouponLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetECouponLOVRequest) ParameterValue(parameterValue []string) ApiGetECouponLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetECouponLOVRequest) XExternalsystem(xExternalsystem string) ApiGetECouponLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetECouponLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetECouponLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetECouponLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetECouponLOVExecute(r)
}

/*
GetECouponLOV Fetch List Of Values for ECoupon

 <p><strong>OperationId:</strong>getECouponLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ECoupon LOV
 @return ApiGetECouponLOVRequest
*/
func (a *LOVApiService) GetECouponLOV(ctx context.Context, hotelId string) ApiGetECouponLOVRequest {
	return ApiGetECouponLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetECouponLOVExecute(r ApiGetECouponLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetECouponLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/eCoupon"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetECouponRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetECouponRateCodesLOVRequest) Authorization(authorization string) ApiGetECouponRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetECouponRateCodesLOVRequest) XAppKey(xAppKey string) ApiGetECouponRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetECouponRateCodesLOVRequest) XHotelid(xHotelid string) ApiGetECouponRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetECouponRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetECouponRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetECouponRateCodesLOVRequest) ParameterName(parameterName []string) ApiGetECouponRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetECouponRateCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetECouponRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetECouponRateCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetECouponRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetECouponRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetECouponRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetECouponRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetECouponRateCodesLOVExecute(r)
}

/*
GetECouponRateCodesLOV Fetch List Of Values for ECoupon Rate Codes

 <p><strong>OperationId:</strong>getECouponRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ECouponRateCodes LOV
 @return ApiGetECouponRateCodesLOVRequest
*/
func (a *LOVApiService) GetECouponRateCodesLOV(ctx context.Context, hotelId string) ApiGetECouponRateCodesLOVRequest {
	return ApiGetECouponRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetECouponRateCodesLOVExecute(r ApiGetECouponRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetECouponRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/eCouponRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcouponResvRoomLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetEcouponResvRoomLOVRequest) Authorization(authorization string) ApiGetEcouponResvRoomLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetEcouponResvRoomLOVRequest) XAppKey(xAppKey string) ApiGetEcouponResvRoomLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetEcouponResvRoomLOVRequest) XHotelid(xHotelid string) ApiGetEcouponResvRoomLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetEcouponResvRoomLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetEcouponResvRoomLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetEcouponResvRoomLOVRequest) ParameterName(parameterName []string) ApiGetEcouponResvRoomLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetEcouponResvRoomLOVRequest) ParameterValue(parameterValue []string) ApiGetEcouponResvRoomLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetEcouponResvRoomLOVRequest) XExternalsystem(xExternalsystem string) ApiGetEcouponResvRoomLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetEcouponResvRoomLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetEcouponResvRoomLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEcouponResvRoomLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEcouponResvRoomLOVExecute(r)
}

/*
GetEcouponResvRoomLOV Fetch List Of Values for Ecoupon Resv Room

 <p><strong>OperationId:</strong>getEcouponResvRoomLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch EcouponResvRoom LOV
 @return ApiGetEcouponResvRoomLOVRequest
*/
func (a *LOVApiService) GetEcouponResvRoomLOV(ctx context.Context, hotelId string) ApiGetEcouponResvRoomLOVRequest {
	return ApiGetEcouponResvRoomLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEcouponResvRoomLOVExecute(r ApiGetEcouponResvRoomLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEcouponResvRoomLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/ecouponResvRoom"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEndOfDayReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	beforeIncomeAudit string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetEndOfDayReportsLOVRequest) Authorization(authorization string) ApiGetEndOfDayReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetEndOfDayReportsLOVRequest) XAppKey(xAppKey string) ApiGetEndOfDayReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetEndOfDayReportsLOVRequest) XHotelid(xHotelid string) ApiGetEndOfDayReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetEndOfDayReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetEndOfDayReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetEndOfDayReportsLOVRequest) ParameterName(parameterName []string) ApiGetEndOfDayReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetEndOfDayReportsLOVRequest) ParameterValue(parameterValue []string) ApiGetEndOfDayReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetEndOfDayReportsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetEndOfDayReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetEndOfDayReportsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetEndOfDayReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEndOfDayReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEndOfDayReportsLOVExecute(r)
}

/*
GetEndOfDayReportsLOV Fetch List Of Values for End Of Day Reports

 <p><strong>OperationId:</strong>getEndOfDayReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param beforeIncomeAudit Value of the parameter 'beforeIncomeAudit' which is required to fetch EndOfDayReports LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch EndOfDayReports LOV
 @return ApiGetEndOfDayReportsLOVRequest
*/
func (a *LOVApiService) GetEndOfDayReportsLOV(ctx context.Context, beforeIncomeAudit string, hotelId string) ApiGetEndOfDayReportsLOVRequest {
	return ApiGetEndOfDayReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		beforeIncomeAudit: beforeIncomeAudit,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEndOfDayReportsLOVExecute(r ApiGetEndOfDayReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEndOfDayReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/beforeIncomeAudit/{beforeIncomeAudit}/endOfDayReports"
	localVarPath = strings.Replace(localVarPath, "{"+"beforeIncomeAudit"+"}", url.PathEscape(parameterValueToString(r.beforeIncomeAudit, "beforeIncomeAudit")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.beforeIncomeAudit) < 1 {
		return localVarReturnValue, nil, reportError("beforeIncomeAudit must have at least 1 elements")
	}
	if strlen(r.beforeIncomeAudit) > 2000 {
		return localVarReturnValue, nil, reportError("beforeIncomeAudit must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEnrollmentMatchCommunicationTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	type_ string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetEnrollmentMatchCommunicationTypeLOVRequest) Authorization(authorization string) ApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetEnrollmentMatchCommunicationTypeLOVRequest) XAppKey(xAppKey string) ApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetEnrollmentMatchCommunicationTypeLOVRequest) XHotelid(xHotelid string) ApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetEnrollmentMatchCommunicationTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetEnrollmentMatchCommunicationTypeLOVRequest) ParameterName(parameterName []string) ApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetEnrollmentMatchCommunicationTypeLOVRequest) ParameterValue(parameterValue []string) ApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetEnrollmentMatchCommunicationTypeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetEnrollmentMatchCommunicationTypeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEnrollmentMatchCommunicationTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEnrollmentMatchCommunicationTypeLOVExecute(r)
}

/*
GetEnrollmentMatchCommunicationTypeLOV Fetch List Of Values for Enrollment Match Communication Type

 <p><strong>OperationId:</strong>getEnrollmentMatchCommunicationTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Value of the parameter 'type' which is required to fetch EnrollmentMatchCommunicationType LOV
 @return ApiGetEnrollmentMatchCommunicationTypeLOVRequest
*/
func (a *LOVApiService) GetEnrollmentMatchCommunicationTypeLOV(ctx context.Context, type_ string) ApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	return ApiGetEnrollmentMatchCommunicationTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEnrollmentMatchCommunicationTypeLOVExecute(r ApiGetEnrollmentMatchCommunicationTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEnrollmentMatchCommunicationTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/type/{type}/enrollmentMatchCommunicationType"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.type_) < 1 {
		return localVarReturnValue, nil, reportError("type_ must have at least 1 elements")
	}
	if strlen(r.type_) > 2000 {
		return localVarReturnValue, nil, reportError("type_ must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetEventGroupsLOVRequest) Authorization(authorization string) ApiGetEventGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetEventGroupsLOVRequest) XAppKey(xAppKey string) ApiGetEventGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetEventGroupsLOVRequest) XHotelid(xHotelid string) ApiGetEventGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetEventGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetEventGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetEventGroupsLOVRequest) ParameterName(parameterName []string) ApiGetEventGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetEventGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetEventGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetEventGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetEventGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetEventGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetEventGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEventGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEventGroupsLOVExecute(r)
}

/*
GetEventGroupsLOV Fetch List Of Values for Event Groups

 <p><strong>OperationId:</strong>getEventGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch EventGroups LOV
 @return ApiGetEventGroupsLOVRequest
*/
func (a *LOVApiService) GetEventGroupsLOV(ctx context.Context, hotelId string) ApiGetEventGroupsLOVRequest {
	return ApiGetEventGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEventGroupsLOVExecute(r ApiGetEventGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEventGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/eventGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventLocationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetEventLocationsLOVRequest) Authorization(authorization string) ApiGetEventLocationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetEventLocationsLOVRequest) XAppKey(xAppKey string) ApiGetEventLocationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetEventLocationsLOVRequest) XHotelid(xHotelid string) ApiGetEventLocationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetEventLocationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetEventLocationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetEventLocationsLOVRequest) ParameterName(parameterName []string) ApiGetEventLocationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetEventLocationsLOVRequest) ParameterValue(parameterValue []string) ApiGetEventLocationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetEventLocationsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetEventLocationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetEventLocationsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetEventLocationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEventLocationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEventLocationsLOVExecute(r)
}

/*
GetEventLocationsLOV Fetch List Of Values for Event Locations

 <p><strong>OperationId:</strong>getEventLocationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch EventLocations LOV
 @return ApiGetEventLocationsLOVRequest
*/
func (a *LOVApiService) GetEventLocationsLOV(ctx context.Context, hotelId string) ApiGetEventLocationsLOVRequest {
	return ApiGetEventLocationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEventLocationsLOVExecute(r ApiGetEventLocationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEventLocationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/eventLocations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventRateCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	space string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetEventRateCodeLOVRequest) Authorization(authorization string) ApiGetEventRateCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetEventRateCodeLOVRequest) XAppKey(xAppKey string) ApiGetEventRateCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetEventRateCodeLOVRequest) XHotelid(xHotelid string) ApiGetEventRateCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetEventRateCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetEventRateCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetEventRateCodeLOVRequest) ParameterName(parameterName []string) ApiGetEventRateCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetEventRateCodeLOVRequest) ParameterValue(parameterValue []string) ApiGetEventRateCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetEventRateCodeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetEventRateCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetEventRateCodeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetEventRateCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEventRateCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEventRateCodeLOVExecute(r)
}

/*
GetEventRateCodeLOV Fetch List Of Values for Event Rate Code

 <p><strong>OperationId:</strong>getEventRateCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Value of the parameter 'space' which is required to fetch EventRateCode LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch EventRateCode LOV
 @return ApiGetEventRateCodeLOVRequest
*/
func (a *LOVApiService) GetEventRateCodeLOV(ctx context.Context, space string, hotelId string) ApiGetEventRateCodeLOVRequest {
	return ApiGetEventRateCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEventRateCodeLOVExecute(r ApiGetEventRateCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEventRateCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/space/{space}/eventRateCode"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.space) < 1 {
		return localVarReturnValue, nil, reportError("space must have at least 1 elements")
	}
	if strlen(r.space) > 2000 {
		return localVarReturnValue, nil, reportError("space must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventSetupStylesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	room string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetEventSetupStylesLOVRequest) Authorization(authorization string) ApiGetEventSetupStylesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetEventSetupStylesLOVRequest) XAppKey(xAppKey string) ApiGetEventSetupStylesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetEventSetupStylesLOVRequest) XHotelid(xHotelid string) ApiGetEventSetupStylesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetEventSetupStylesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetEventSetupStylesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetEventSetupStylesLOVRequest) ParameterName(parameterName []string) ApiGetEventSetupStylesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetEventSetupStylesLOVRequest) ParameterValue(parameterValue []string) ApiGetEventSetupStylesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetEventSetupStylesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetEventSetupStylesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetEventSetupStylesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetEventSetupStylesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEventSetupStylesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEventSetupStylesLOVExecute(r)
}

/*
GetEventSetupStylesLOV Fetch List Of Values for Event Setup Styles

 <p><strong>OperationId:</strong>getEventSetupStylesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param room Value of the parameter 'room' which is required to fetch EventSetupStyles LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch EventSetupStyles LOV
 @return ApiGetEventSetupStylesLOVRequest
*/
func (a *LOVApiService) GetEventSetupStylesLOV(ctx context.Context, room string, hotelId string) ApiGetEventSetupStylesLOVRequest {
	return ApiGetEventSetupStylesLOVRequest{
		ApiService: a,
		ctx: ctx,
		room: room,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEventSetupStylesLOVExecute(r ApiGetEventSetupStylesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEventSetupStylesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/room/{room}/eventSetupStyles"
	localVarPath = strings.Replace(localVarPath, "{"+"room"+"}", url.PathEscape(parameterValueToString(r.room, "room")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.room) < 1 {
		return localVarReturnValue, nil, reportError("room must have at least 1 elements")
	}
	if strlen(r.room) > 2000 {
		return localVarReturnValue, nil, reportError("room must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventStatusCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	exclusionList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetEventStatusCodesLOVRequest) Authorization(authorization string) ApiGetEventStatusCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetEventStatusCodesLOVRequest) XAppKey(xAppKey string) ApiGetEventStatusCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetEventStatusCodesLOVRequest) XHotelid(xHotelid string) ApiGetEventStatusCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetEventStatusCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetEventStatusCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetEventStatusCodesLOVRequest) ParameterName(parameterName []string) ApiGetEventStatusCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetEventStatusCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetEventStatusCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetEventStatusCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetEventStatusCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetEventStatusCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetEventStatusCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEventStatusCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEventStatusCodesLOVExecute(r)
}

/*
GetEventStatusCodesLOV Fetch List Of Values for Event Status Codes

 <p><strong>OperationId:</strong>getEventStatusCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exclusionList Value of the parameter 'exclusionList' which is required to fetch EventStatusCodes LOV
 @return ApiGetEventStatusCodesLOVRequest
*/
func (a *LOVApiService) GetEventStatusCodesLOV(ctx context.Context, exclusionList string) ApiGetEventStatusCodesLOVRequest {
	return ApiGetEventStatusCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		exclusionList: exclusionList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEventStatusCodesLOVExecute(r ApiGetEventStatusCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEventStatusCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/exclusionList/{exclusionList}/eventStatusCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"exclusionList"+"}", url.PathEscape(parameterValueToString(r.exclusionList, "exclusionList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.exclusionList) < 1 {
		return localVarReturnValue, nil, reportError("exclusionList must have at least 1 elements")
	}
	if strlen(r.exclusionList) > 2000 {
		return localVarReturnValue, nil, reportError("exclusionList must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExchangeTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	currencyCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetExchangeTypesLOVRequest) Authorization(authorization string) ApiGetExchangeTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetExchangeTypesLOVRequest) XAppKey(xAppKey string) ApiGetExchangeTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetExchangeTypesLOVRequest) XHotelid(xHotelid string) ApiGetExchangeTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetExchangeTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetExchangeTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetExchangeTypesLOVRequest) ParameterName(parameterName []string) ApiGetExchangeTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetExchangeTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetExchangeTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetExchangeTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetExchangeTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetExchangeTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetExchangeTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetExchangeTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetExchangeTypesLOVExecute(r)
}

/*
GetExchangeTypesLOV Fetch List Of Values for Exchange Types

 <p><strong>OperationId:</strong>getExchangeTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyCode Value of the parameter 'currencyCode' which is required to fetch ExchangeTypes LOV
 @return ApiGetExchangeTypesLOVRequest
*/
func (a *LOVApiService) GetExchangeTypesLOV(ctx context.Context, currencyCode string) ApiGetExchangeTypesLOVRequest {
	return ApiGetExchangeTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		currencyCode: currencyCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetExchangeTypesLOVExecute(r ApiGetExchangeTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetExchangeTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/currencyCode/{currencyCode}/exchangeTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyCode"+"}", url.PathEscape(parameterValueToString(r.currencyCode, "currencyCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.currencyCode) < 1 {
		return localVarReturnValue, nil, reportError("currencyCode must have at least 1 elements")
	}
	if strlen(r.currencyCode) > 2000 {
		return localVarReturnValue, nil, reportError("currencyCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExportMappingCodesToLinkLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	configType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetExportMappingCodesToLinkLOVRequest) Authorization(authorization string) ApiGetExportMappingCodesToLinkLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetExportMappingCodesToLinkLOVRequest) XAppKey(xAppKey string) ApiGetExportMappingCodesToLinkLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetExportMappingCodesToLinkLOVRequest) XHotelid(xHotelid string) ApiGetExportMappingCodesToLinkLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetExportMappingCodesToLinkLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetExportMappingCodesToLinkLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetExportMappingCodesToLinkLOVRequest) ParameterName(parameterName []string) ApiGetExportMappingCodesToLinkLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetExportMappingCodesToLinkLOVRequest) ParameterValue(parameterValue []string) ApiGetExportMappingCodesToLinkLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetExportMappingCodesToLinkLOVRequest) XExternalsystem(xExternalsystem string) ApiGetExportMappingCodesToLinkLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetExportMappingCodesToLinkLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetExportMappingCodesToLinkLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetExportMappingCodesToLinkLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetExportMappingCodesToLinkLOVExecute(r)
}

/*
GetExportMappingCodesToLinkLOV Fetch List Of Values for Export Mapping Codes To Link

 <p><strong>OperationId:</strong>getExportMappingCodesToLinkLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configType Value of the parameter 'configType' which is required to fetch ExportMappingCodesToLink LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ExportMappingCodesToLink LOV
 @return ApiGetExportMappingCodesToLinkLOVRequest
*/
func (a *LOVApiService) GetExportMappingCodesToLinkLOV(ctx context.Context, configType string, hotelId string) ApiGetExportMappingCodesToLinkLOVRequest {
	return ApiGetExportMappingCodesToLinkLOVRequest{
		ApiService: a,
		ctx: ctx,
		configType: configType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetExportMappingCodesToLinkLOVExecute(r ApiGetExportMappingCodesToLinkLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetExportMappingCodesToLinkLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/configType/{configType}/exportMappingCodesToLink"
	localVarPath = strings.Replace(localVarPath, "{"+"configType"+"}", url.PathEscape(parameterValueToString(r.configType, "configType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configType) < 1 {
		return localVarReturnValue, nil, reportError("configType must have at least 1 elements")
	}
	if strlen(r.configType) > 2000 {
		return localVarReturnValue, nil, reportError("configType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExportMappingTypeCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetExportMappingTypeCodesLOVRequest) Authorization(authorization string) ApiGetExportMappingTypeCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetExportMappingTypeCodesLOVRequest) XAppKey(xAppKey string) ApiGetExportMappingTypeCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetExportMappingTypeCodesLOVRequest) XHotelid(xHotelid string) ApiGetExportMappingTypeCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetExportMappingTypeCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetExportMappingTypeCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetExportMappingTypeCodesLOVRequest) ParameterName(parameterName []string) ApiGetExportMappingTypeCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetExportMappingTypeCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetExportMappingTypeCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetExportMappingTypeCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetExportMappingTypeCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetExportMappingTypeCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetExportMappingTypeCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetExportMappingTypeCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetExportMappingTypeCodesLOVExecute(r)
}

/*
GetExportMappingTypeCodesLOV Fetch List Of Values for Export Mapping Type Codes

 <p><strong>OperationId:</strong>getExportMappingTypeCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ExportMappingTypeCodes LOV
 @return ApiGetExportMappingTypeCodesLOVRequest
*/
func (a *LOVApiService) GetExportMappingTypeCodesLOV(ctx context.Context, hotelId string) ApiGetExportMappingTypeCodesLOVRequest {
	return ApiGetExportMappingTypeCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetExportMappingTypeCodesLOVExecute(r ApiGetExportMappingTypeCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetExportMappingTypeCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/exportMappingTypeCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalDatabaseAvailableResortsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	databaseId string
	interfaceType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetExternalDatabaseAvailableResortsLOVRequest) Authorization(authorization string) ApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetExternalDatabaseAvailableResortsLOVRequest) XAppKey(xAppKey string) ApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetExternalDatabaseAvailableResortsLOVRequest) XHotelid(xHotelid string) ApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetExternalDatabaseAvailableResortsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetExternalDatabaseAvailableResortsLOVRequest) ParameterName(parameterName []string) ApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetExternalDatabaseAvailableResortsLOVRequest) ParameterValue(parameterValue []string) ApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetExternalDatabaseAvailableResortsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetExternalDatabaseAvailableResortsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetExternalDatabaseAvailableResortsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetExternalDatabaseAvailableResortsLOVExecute(r)
}

/*
GetExternalDatabaseAvailableResortsLOV Fetch List Of Values for External Database Available Resorts

 <p><strong>OperationId:</strong>getExternalDatabaseAvailableResortsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId Value of the parameter 'databaseId' which is required to fetch ExternalDatabaseAvailableResorts LOV
 @param interfaceType Value of the parameter 'interfaceType' which is required to fetch ExternalDatabaseAvailableResorts LOV
 @return ApiGetExternalDatabaseAvailableResortsLOVRequest
*/
func (a *LOVApiService) GetExternalDatabaseAvailableResortsLOV(ctx context.Context, databaseId string, interfaceType string) ApiGetExternalDatabaseAvailableResortsLOVRequest {
	return ApiGetExternalDatabaseAvailableResortsLOVRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
		interfaceType: interfaceType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetExternalDatabaseAvailableResortsLOVExecute(r ApiGetExternalDatabaseAvailableResortsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetExternalDatabaseAvailableResortsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/interfaceType/{interfaceType}/databaseId/{databaseId}/externalDatabaseAvailableResorts"
	localVarPath = strings.Replace(localVarPath, "{"+"databaseId"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceType"+"}", url.PathEscape(parameterValueToString(r.interfaceType, "interfaceType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.databaseId) < 1 {
		return localVarReturnValue, nil, reportError("databaseId must have at least 1 elements")
	}
	if strlen(r.databaseId) > 2000 {
		return localVarReturnValue, nil, reportError("databaseId must have less than 2000 elements")
	}
	if strlen(r.interfaceType) < 1 {
		return localVarReturnValue, nil, reportError("interfaceType must have at least 1 elements")
	}
	if strlen(r.interfaceType) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalReferenceTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetExternalReferenceTypesLOVRequest) Authorization(authorization string) ApiGetExternalReferenceTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetExternalReferenceTypesLOVRequest) XAppKey(xAppKey string) ApiGetExternalReferenceTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetExternalReferenceTypesLOVRequest) XHotelid(xHotelid string) ApiGetExternalReferenceTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetExternalReferenceTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetExternalReferenceTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetExternalReferenceTypesLOVRequest) ParameterName(parameterName []string) ApiGetExternalReferenceTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetExternalReferenceTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetExternalReferenceTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetExternalReferenceTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetExternalReferenceTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetExternalReferenceTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetExternalReferenceTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetExternalReferenceTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetExternalReferenceTypesLOVExecute(r)
}

/*
GetExternalReferenceTypesLOV Fetch List Of Values for External Reference Types

 <p><strong>OperationId:</strong>getExternalReferenceTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ExternalReferenceTypes LOV
 @return ApiGetExternalReferenceTypesLOVRequest
*/
func (a *LOVApiService) GetExternalReferenceTypesLOV(ctx context.Context, hotelId string) ApiGetExternalReferenceTypesLOVRequest {
	return ApiGetExternalReferenceTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetExternalReferenceTypesLOVExecute(r ApiGetExternalReferenceTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetExternalReferenceTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/externalReferenceTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFacilityCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFacilityCodesLOVRequest) Authorization(authorization string) ApiGetFacilityCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFacilityCodesLOVRequest) XAppKey(xAppKey string) ApiGetFacilityCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFacilityCodesLOVRequest) XHotelid(xHotelid string) ApiGetFacilityCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFacilityCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFacilityCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFacilityCodesLOVRequest) ParameterName(parameterName []string) ApiGetFacilityCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFacilityCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetFacilityCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFacilityCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFacilityCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFacilityCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFacilityCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFacilityCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFacilityCodesLOVExecute(r)
}

/*
GetFacilityCodesLOV Fetch List Of Values for Facility Codes

 <p><strong>OperationId:</strong>getFacilityCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FacilityCodes LOV
 @return ApiGetFacilityCodesLOVRequest
*/
func (a *LOVApiService) GetFacilityCodesLOV(ctx context.Context, hotelId string) ApiGetFacilityCodesLOVRequest {
	return ApiGetFacilityCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFacilityCodesLOVExecute(r ApiGetFacilityCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFacilityCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/facilityCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFacilityCodesReservationLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	facilityTask string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFacilityCodesReservationLOVRequest) Authorization(authorization string) ApiGetFacilityCodesReservationLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFacilityCodesReservationLOVRequest) XAppKey(xAppKey string) ApiGetFacilityCodesReservationLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFacilityCodesReservationLOVRequest) XHotelid(xHotelid string) ApiGetFacilityCodesReservationLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFacilityCodesReservationLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFacilityCodesReservationLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFacilityCodesReservationLOVRequest) ParameterName(parameterName []string) ApiGetFacilityCodesReservationLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFacilityCodesReservationLOVRequest) ParameterValue(parameterValue []string) ApiGetFacilityCodesReservationLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFacilityCodesReservationLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFacilityCodesReservationLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFacilityCodesReservationLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFacilityCodesReservationLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFacilityCodesReservationLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFacilityCodesReservationLOVExecute(r)
}

/*
GetFacilityCodesReservationLOV Fetch List Of Values for Facility Codes Reservation

 <p><strong>OperationId:</strong>getFacilityCodesReservationLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param facilityTask Value of the parameter 'facilityTask' which is required to fetch FacilityCodesReservation LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FacilityCodesReservation LOV
 @return ApiGetFacilityCodesReservationLOVRequest
*/
func (a *LOVApiService) GetFacilityCodesReservationLOV(ctx context.Context, facilityTask string, hotelId string) ApiGetFacilityCodesReservationLOVRequest {
	return ApiGetFacilityCodesReservationLOVRequest{
		ApiService: a,
		ctx: ctx,
		facilityTask: facilityTask,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFacilityCodesReservationLOVExecute(r ApiGetFacilityCodesReservationLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFacilityCodesReservationLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/facilityTask/{facilityTask}/facilityCodesReservation"
	localVarPath = strings.Replace(localVarPath, "{"+"facilityTask"+"}", url.PathEscape(parameterValueToString(r.facilityTask, "facilityTask")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.facilityTask) < 1 {
		return localVarReturnValue, nil, reportError("facilityTask must have at least 1 elements")
	}
	if strlen(r.facilityTask) > 2000 {
		return localVarReturnValue, nil, reportError("facilityTask must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFacilityTasksLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFacilityTasksLOVRequest) Authorization(authorization string) ApiGetFacilityTasksLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFacilityTasksLOVRequest) XAppKey(xAppKey string) ApiGetFacilityTasksLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFacilityTasksLOVRequest) XHotelid(xHotelid string) ApiGetFacilityTasksLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFacilityTasksLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFacilityTasksLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFacilityTasksLOVRequest) ParameterName(parameterName []string) ApiGetFacilityTasksLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFacilityTasksLOVRequest) ParameterValue(parameterValue []string) ApiGetFacilityTasksLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFacilityTasksLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFacilityTasksLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFacilityTasksLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFacilityTasksLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFacilityTasksLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFacilityTasksLOVExecute(r)
}

/*
GetFacilityTasksLOV Fetch List Of Values for Facility Tasks

 <p><strong>OperationId:</strong>getFacilityTasksLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FacilityTasks LOV
 @return ApiGetFacilityTasksLOVRequest
*/
func (a *LOVApiService) GetFacilityTasksLOV(ctx context.Context, hotelId string) ApiGetFacilityTasksLOVRequest {
	return ApiGetFacilityTasksLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFacilityTasksLOVExecute(r ApiGetFacilityTasksLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFacilityTasksLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/facilityTasks"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFacilityTasksRoomTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomTypeLabel string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFacilityTasksRoomTypeLOVRequest) Authorization(authorization string) ApiGetFacilityTasksRoomTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFacilityTasksRoomTypeLOVRequest) XAppKey(xAppKey string) ApiGetFacilityTasksRoomTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFacilityTasksRoomTypeLOVRequest) XHotelid(xHotelid string) ApiGetFacilityTasksRoomTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFacilityTasksRoomTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFacilityTasksRoomTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFacilityTasksRoomTypeLOVRequest) ParameterName(parameterName []string) ApiGetFacilityTasksRoomTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFacilityTasksRoomTypeLOVRequest) ParameterValue(parameterValue []string) ApiGetFacilityTasksRoomTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFacilityTasksRoomTypeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFacilityTasksRoomTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFacilityTasksRoomTypeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFacilityTasksRoomTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFacilityTasksRoomTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFacilityTasksRoomTypeLOVExecute(r)
}

/*
GetFacilityTasksRoomTypeLOV Fetch List Of Values for Facility Tasks Room Type

 <p><strong>OperationId:</strong>getFacilityTasksRoomTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeLabel Value of the parameter 'roomTypeLabel' which is required to fetch FacilityTasksRoomType LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FacilityTasksRoomType LOV
 @return ApiGetFacilityTasksRoomTypeLOVRequest
*/
func (a *LOVApiService) GetFacilityTasksRoomTypeLOV(ctx context.Context, roomTypeLabel string, hotelId string) ApiGetFacilityTasksRoomTypeLOVRequest {
	return ApiGetFacilityTasksRoomTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeLabel: roomTypeLabel,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFacilityTasksRoomTypeLOVExecute(r ApiGetFacilityTasksRoomTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFacilityTasksRoomTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomTypeLabel/{roomTypeLabel}/facilityTasksRoomType"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeLabel"+"}", url.PathEscape(parameterValueToString(r.roomTypeLabel, "roomTypeLabel")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeLabel) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeLabel must have at least 1 elements")
	}
	if strlen(r.roomTypeLabel) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeLabel must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFieldNameLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	changeSource string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFieldNameLOVRequest) Authorization(authorization string) ApiGetFieldNameLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFieldNameLOVRequest) XAppKey(xAppKey string) ApiGetFieldNameLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFieldNameLOVRequest) XHotelid(xHotelid string) ApiGetFieldNameLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFieldNameLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFieldNameLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFieldNameLOVRequest) ParameterName(parameterName []string) ApiGetFieldNameLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFieldNameLOVRequest) ParameterValue(parameterValue []string) ApiGetFieldNameLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFieldNameLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFieldNameLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFieldNameLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFieldNameLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFieldNameLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFieldNameLOVExecute(r)
}

/*
GetFieldNameLOV Fetch List Of Values for Field Name

 <p><strong>OperationId:</strong>getFieldNameLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param changeSource Value of the parameter 'changeSource' which is required to fetch FieldName LOV
 @return ApiGetFieldNameLOVRequest
*/
func (a *LOVApiService) GetFieldNameLOV(ctx context.Context, changeSource string) ApiGetFieldNameLOVRequest {
	return ApiGetFieldNameLOVRequest{
		ApiService: a,
		ctx: ctx,
		changeSource: changeSource,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFieldNameLOVExecute(r ApiGetFieldNameLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFieldNameLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/changeSource/{changeSource}/fieldName"
	localVarPath = strings.Replace(localVarPath, "{"+"changeSource"+"}", url.PathEscape(parameterValueToString(r.changeSource, "changeSource")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.changeSource) < 1 {
		return localVarReturnValue, nil, reportError("changeSource must have at least 1 elements")
	}
	if strlen(r.changeSource) > 2000 {
		return localVarReturnValue, nil, reportError("changeSource must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFiscalPaymentMethodsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFiscalPaymentMethodsLOVRequest) Authorization(authorization string) ApiGetFiscalPaymentMethodsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFiscalPaymentMethodsLOVRequest) XAppKey(xAppKey string) ApiGetFiscalPaymentMethodsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFiscalPaymentMethodsLOVRequest) XHotelid(xHotelid string) ApiGetFiscalPaymentMethodsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFiscalPaymentMethodsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFiscalPaymentMethodsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFiscalPaymentMethodsLOVRequest) ParameterName(parameterName []string) ApiGetFiscalPaymentMethodsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFiscalPaymentMethodsLOVRequest) ParameterValue(parameterValue []string) ApiGetFiscalPaymentMethodsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFiscalPaymentMethodsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFiscalPaymentMethodsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFiscalPaymentMethodsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFiscalPaymentMethodsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFiscalPaymentMethodsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFiscalPaymentMethodsLOVExecute(r)
}

/*
GetFiscalPaymentMethodsLOV Fetch List Of Values for Fiscal Payment Methods

 <p><strong>OperationId:</strong>getFiscalPaymentMethodsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FiscalPaymentMethods LOV
 @return ApiGetFiscalPaymentMethodsLOVRequest
*/
func (a *LOVApiService) GetFiscalPaymentMethodsLOV(ctx context.Context, hotelId string) ApiGetFiscalPaymentMethodsLOVRequest {
	return ApiGetFiscalPaymentMethodsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFiscalPaymentMethodsLOVExecute(r ApiGetFiscalPaymentMethodsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFiscalPaymentMethodsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fiscalPaymentMethods"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFixedChargesTransactionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFixedChargesTransactionCodesLOVRequest) Authorization(authorization string) ApiGetFixedChargesTransactionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFixedChargesTransactionCodesLOVRequest) XAppKey(xAppKey string) ApiGetFixedChargesTransactionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFixedChargesTransactionCodesLOVRequest) XHotelid(xHotelid string) ApiGetFixedChargesTransactionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFixedChargesTransactionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFixedChargesTransactionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFixedChargesTransactionCodesLOVRequest) ParameterName(parameterName []string) ApiGetFixedChargesTransactionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFixedChargesTransactionCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetFixedChargesTransactionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFixedChargesTransactionCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFixedChargesTransactionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFixedChargesTransactionCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFixedChargesTransactionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFixedChargesTransactionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFixedChargesTransactionCodesLOVExecute(r)
}

/*
GetFixedChargesTransactionCodesLOV Fetch List Of Values for Fixed Charges Transaction Codes

 <p><strong>OperationId:</strong>getFixedChargesTransactionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FixedChargesTransactionCodes LOV
 @return ApiGetFixedChargesTransactionCodesLOVRequest
*/
func (a *LOVApiService) GetFixedChargesTransactionCodesLOV(ctx context.Context, hotelId string) ApiGetFixedChargesTransactionCodesLOVRequest {
	return ApiGetFixedChargesTransactionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFixedChargesTransactionCodesLOVExecute(r ApiGetFixedChargesTransactionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFixedChargesTransactionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fixedChargesTransactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFloorsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFloorsLOVRequest) Authorization(authorization string) ApiGetFloorsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFloorsLOVRequest) XAppKey(xAppKey string) ApiGetFloorsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFloorsLOVRequest) XHotelid(xHotelid string) ApiGetFloorsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFloorsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFloorsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFloorsLOVRequest) ParameterName(parameterName []string) ApiGetFloorsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFloorsLOVRequest) ParameterValue(parameterValue []string) ApiGetFloorsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFloorsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFloorsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFloorsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFloorsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFloorsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFloorsLOVExecute(r)
}

/*
GetFloorsLOV Fetch List Of Values for Floors

 <p><strong>OperationId:</strong>getFloorsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Floors LOV
 @return ApiGetFloorsLOVRequest
*/
func (a *LOVApiService) GetFloorsLOV(ctx context.Context, hotelId string) ApiGetFloorsLOVRequest {
	return ApiGetFloorsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFloorsLOVExecute(r ApiGetFloorsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFloorsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/floors"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioGroupingCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	type_ string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioGroupingCodesLOVRequest) Authorization(authorization string) ApiGetFolioGroupingCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioGroupingCodesLOVRequest) XAppKey(xAppKey string) ApiGetFolioGroupingCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioGroupingCodesLOVRequest) XHotelid(xHotelid string) ApiGetFolioGroupingCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFolioGroupingCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFolioGroupingCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFolioGroupingCodesLOVRequest) ParameterName(parameterName []string) ApiGetFolioGroupingCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFolioGroupingCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetFolioGroupingCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFolioGroupingCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFolioGroupingCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioGroupingCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioGroupingCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioGroupingCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFolioGroupingCodesLOVExecute(r)
}

/*
GetFolioGroupingCodesLOV Fetch List Of Values for Folio Grouping Codes

 <p><strong>OperationId:</strong>getFolioGroupingCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Value of the parameter 'type' which is required to fetch FolioGroupingCodes LOV
 @return ApiGetFolioGroupingCodesLOVRequest
*/
func (a *LOVApiService) GetFolioGroupingCodesLOV(ctx context.Context, type_ string) ApiGetFolioGroupingCodesLOVRequest {
	return ApiGetFolioGroupingCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFolioGroupingCodesLOVExecute(r ApiGetFolioGroupingCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFolioGroupingCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/type/{type}/folioGroupingCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.type_) < 1 {
		return localVarReturnValue, nil, reportError("type_ must have at least 1 elements")
	}
	if strlen(r.type_) > 2000 {
		return localVarReturnValue, nil, reportError("type_ must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioGroupingTransactionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	mode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioGroupingTransactionCodesLOVRequest) Authorization(authorization string) ApiGetFolioGroupingTransactionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioGroupingTransactionCodesLOVRequest) XAppKey(xAppKey string) ApiGetFolioGroupingTransactionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioGroupingTransactionCodesLOVRequest) XHotelid(xHotelid string) ApiGetFolioGroupingTransactionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFolioGroupingTransactionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFolioGroupingTransactionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFolioGroupingTransactionCodesLOVRequest) ParameterName(parameterName []string) ApiGetFolioGroupingTransactionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFolioGroupingTransactionCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetFolioGroupingTransactionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFolioGroupingTransactionCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFolioGroupingTransactionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioGroupingTransactionCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioGroupingTransactionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioGroupingTransactionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFolioGroupingTransactionCodesLOVExecute(r)
}

/*
GetFolioGroupingTransactionCodesLOV Fetch List Of Values for Folio Grouping Transaction Codes

 <p><strong>OperationId:</strong>getFolioGroupingTransactionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mode Value of the parameter 'mode' which is required to fetch FolioGroupingTransactionCodes LOV
 @return ApiGetFolioGroupingTransactionCodesLOVRequest
*/
func (a *LOVApiService) GetFolioGroupingTransactionCodesLOV(ctx context.Context, mode string) ApiGetFolioGroupingTransactionCodesLOVRequest {
	return ApiGetFolioGroupingTransactionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		mode: mode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFolioGroupingTransactionCodesLOVExecute(r ApiGetFolioGroupingTransactionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFolioGroupingTransactionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/mode/{mode}/folioGroupingTransactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"mode"+"}", url.PathEscape(parameterValueToString(r.mode, "mode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.mode) < 1 {
		return localVarReturnValue, nil, reportError("mode must have at least 1 elements")
	}
	if strlen(r.mode) > 2000 {
		return localVarReturnValue, nil, reportError("mode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioStylesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioStylesLOVRequest) Authorization(authorization string) ApiGetFolioStylesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioStylesLOVRequest) XAppKey(xAppKey string) ApiGetFolioStylesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioStylesLOVRequest) XHotelid(xHotelid string) ApiGetFolioStylesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFolioStylesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFolioStylesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFolioStylesLOVRequest) ParameterName(parameterName []string) ApiGetFolioStylesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFolioStylesLOVRequest) ParameterValue(parameterValue []string) ApiGetFolioStylesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFolioStylesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFolioStylesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioStylesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioStylesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioStylesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFolioStylesLOVExecute(r)
}

/*
GetFolioStylesLOV Fetch List Of Values for Folio Styles

 <p><strong>OperationId:</strong>getFolioStylesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FolioStyles LOV
 @return ApiGetFolioStylesLOVRequest
*/
func (a *LOVApiService) GetFolioStylesLOV(ctx context.Context, hotelId string) ApiGetFolioStylesLOVRequest {
	return ApiGetFolioStylesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFolioStylesLOVExecute(r ApiGetFolioStylesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFolioStylesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/folioStyles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFolioTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFolioTypesLOVRequest) Authorization(authorization string) ApiGetFolioTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFolioTypesLOVRequest) XAppKey(xAppKey string) ApiGetFolioTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFolioTypesLOVRequest) XHotelid(xHotelid string) ApiGetFolioTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFolioTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFolioTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFolioTypesLOVRequest) ParameterName(parameterName []string) ApiGetFolioTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFolioTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetFolioTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFolioTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFolioTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFolioTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFolioTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFolioTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFolioTypesLOVExecute(r)
}

/*
GetFolioTypesLOV Fetch List Of Values for Folio Types

 <p><strong>OperationId:</strong>getFolioTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FolioTypes LOV
 @return ApiGetFolioTypesLOVRequest
*/
func (a *LOVApiService) GetFolioTypesLOV(ctx context.Context, hotelId string) ApiGetFolioTypesLOVRequest {
	return ApiGetFolioTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFolioTypesLOVExecute(r ApiGetFolioTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFolioTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/folioTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetForecastGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetForecastGroupsLOVRequest) Authorization(authorization string) ApiGetForecastGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetForecastGroupsLOVRequest) XAppKey(xAppKey string) ApiGetForecastGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetForecastGroupsLOVRequest) XHotelid(xHotelid string) ApiGetForecastGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetForecastGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetForecastGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetForecastGroupsLOVRequest) ParameterName(parameterName []string) ApiGetForecastGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetForecastGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetForecastGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetForecastGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetForecastGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetForecastGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetForecastGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetForecastGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetForecastGroupsLOVExecute(r)
}

/*
GetForecastGroupsLOV Fetch List Of Values for Forecast Groups

 <p><strong>OperationId:</strong>getForecastGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ForecastGroups LOV
 @return ApiGetForecastGroupsLOVRequest
*/
func (a *LOVApiService) GetForecastGroupsLOV(ctx context.Context, hotelId string) ApiGetForecastGroupsLOVRequest {
	return ApiGetForecastGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetForecastGroupsLOVExecute(r ApiGetForecastGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetForecastGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/forecastGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetForeignCurrenciesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	exchangeType string
	sell string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetForeignCurrenciesLOVRequest) Authorization(authorization string) ApiGetForeignCurrenciesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetForeignCurrenciesLOVRequest) XAppKey(xAppKey string) ApiGetForeignCurrenciesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetForeignCurrenciesLOVRequest) XHotelid(xHotelid string) ApiGetForeignCurrenciesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetForeignCurrenciesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetForeignCurrenciesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetForeignCurrenciesLOVRequest) ParameterName(parameterName []string) ApiGetForeignCurrenciesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetForeignCurrenciesLOVRequest) ParameterValue(parameterValue []string) ApiGetForeignCurrenciesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetForeignCurrenciesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetForeignCurrenciesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetForeignCurrenciesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetForeignCurrenciesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetForeignCurrenciesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetForeignCurrenciesLOVExecute(r)
}

/*
GetForeignCurrenciesLOV Fetch List Of Values for Foreign Currencies

 <p><strong>OperationId:</strong>getForeignCurrenciesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exchangeType Value of the parameter 'exchangeType' which is required to fetch ForeignCurrencies LOV
 @param sell Value of the parameter 'sell' which is required to fetch ForeignCurrencies LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ForeignCurrencies LOV
 @return ApiGetForeignCurrenciesLOVRequest
*/
func (a *LOVApiService) GetForeignCurrenciesLOV(ctx context.Context, exchangeType string, sell string, hotelId string) ApiGetForeignCurrenciesLOVRequest {
	return ApiGetForeignCurrenciesLOVRequest{
		ApiService: a,
		ctx: ctx,
		exchangeType: exchangeType,
		sell: sell,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetForeignCurrenciesLOVExecute(r ApiGetForeignCurrenciesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetForeignCurrenciesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/sell/{sell}/exchangeType/{exchangeType}/foreignCurrencies"
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeType"+"}", url.PathEscape(parameterValueToString(r.exchangeType, "exchangeType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sell"+"}", url.PathEscape(parameterValueToString(r.sell, "sell")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.exchangeType) < 1 {
		return localVarReturnValue, nil, reportError("exchangeType must have at least 1 elements")
	}
	if strlen(r.exchangeType) > 2000 {
		return localVarReturnValue, nil, reportError("exchangeType must have less than 2000 elements")
	}
	if strlen(r.sell) < 1 {
		return localVarReturnValue, nil, reportError("sell must have at least 1 elements")
	}
	if strlen(r.sell) > 2000 {
		return localVarReturnValue, nil, reportError("sell must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFormatLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	method string
	moduleName string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFormatLOVRequest) Authorization(authorization string) ApiGetFormatLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFormatLOVRequest) XAppKey(xAppKey string) ApiGetFormatLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFormatLOVRequest) XHotelid(xHotelid string) ApiGetFormatLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFormatLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFormatLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFormatLOVRequest) ParameterName(parameterName []string) ApiGetFormatLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFormatLOVRequest) ParameterValue(parameterValue []string) ApiGetFormatLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFormatLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFormatLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFormatLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFormatLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFormatLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFormatLOVExecute(r)
}

/*
GetFormatLOV Fetch List Of Values for Format

 <p><strong>OperationId:</strong>getFormatLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param method Value of the parameter 'method' which is required to fetch Format LOV
 @param moduleName Value of the parameter 'moduleName' which is required to fetch Format LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Format LOV
 @return ApiGetFormatLOVRequest
*/
func (a *LOVApiService) GetFormatLOV(ctx context.Context, method string, moduleName string, hotelId string) ApiGetFormatLOVRequest {
	return ApiGetFormatLOVRequest{
		ApiService: a,
		ctx: ctx,
		method: method,
		moduleName: moduleName,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFormatLOVExecute(r ApiGetFormatLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFormatLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/moduleName/{moduleName}/method/{method}/format"
	localVarPath = strings.Replace(localVarPath, "{"+"method"+"}", url.PathEscape(parameterValueToString(r.method, "method")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"moduleName"+"}", url.PathEscape(parameterValueToString(r.moduleName, "moduleName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.method) < 1 {
		return localVarReturnValue, nil, reportError("method must have at least 1 elements")
	}
	if strlen(r.method) > 2000 {
		return localVarReturnValue, nil, reportError("method must have less than 2000 elements")
	}
	if strlen(r.moduleName) < 1 {
		return localVarReturnValue, nil, reportError("moduleName must have at least 1 elements")
	}
	if strlen(r.moduleName) > 2000 {
		return localVarReturnValue, nil, reportError("moduleName must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFrequencyLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	defaultDepartureTask string
	guestRequested string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFrequencyLOVRequest) Authorization(authorization string) ApiGetFrequencyLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFrequencyLOVRequest) XAppKey(xAppKey string) ApiGetFrequencyLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFrequencyLOVRequest) XHotelid(xHotelid string) ApiGetFrequencyLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFrequencyLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFrequencyLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFrequencyLOVRequest) ParameterName(parameterName []string) ApiGetFrequencyLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFrequencyLOVRequest) ParameterValue(parameterValue []string) ApiGetFrequencyLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFrequencyLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFrequencyLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFrequencyLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFrequencyLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFrequencyLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFrequencyLOVExecute(r)
}

/*
GetFrequencyLOV Fetch List Of Values for Frequency

 <p><strong>OperationId:</strong>getFrequencyLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param defaultDepartureTask Value of the parameter 'defaultDepartureTask' which is required to fetch Frequency LOV
 @param guestRequested Value of the parameter 'guestRequested' which is required to fetch Frequency LOV
 @return ApiGetFrequencyLOVRequest
*/
func (a *LOVApiService) GetFrequencyLOV(ctx context.Context, defaultDepartureTask string, guestRequested string) ApiGetFrequencyLOVRequest {
	return ApiGetFrequencyLOVRequest{
		ApiService: a,
		ctx: ctx,
		defaultDepartureTask: defaultDepartureTask,
		guestRequested: guestRequested,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFrequencyLOVExecute(r ApiGetFrequencyLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFrequencyLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/guestRequested/{guestRequested}/defaultDepartureTask/{defaultDepartureTask}/frequency"
	localVarPath = strings.Replace(localVarPath, "{"+"defaultDepartureTask"+"}", url.PathEscape(parameterValueToString(r.defaultDepartureTask, "defaultDepartureTask")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"guestRequested"+"}", url.PathEscape(parameterValueToString(r.guestRequested, "guestRequested")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.defaultDepartureTask) < 1 {
		return localVarReturnValue, nil, reportError("defaultDepartureTask must have at least 1 elements")
	}
	if strlen(r.defaultDepartureTask) > 2000 {
		return localVarReturnValue, nil, reportError("defaultDepartureTask must have less than 2000 elements")
	}
	if strlen(r.guestRequested) < 1 {
		return localVarReturnValue, nil, reportError("guestRequested must have at least 1 elements")
	}
	if strlen(r.guestRequested) > 2000 {
		return localVarReturnValue, nil, reportError("guestRequested must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFrequencyTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	defaultDepartureTask string
	guestRequested string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFrequencyTypeLOVRequest) Authorization(authorization string) ApiGetFrequencyTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFrequencyTypeLOVRequest) XAppKey(xAppKey string) ApiGetFrequencyTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFrequencyTypeLOVRequest) XHotelid(xHotelid string) ApiGetFrequencyTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFrequencyTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFrequencyTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFrequencyTypeLOVRequest) ParameterName(parameterName []string) ApiGetFrequencyTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFrequencyTypeLOVRequest) ParameterValue(parameterValue []string) ApiGetFrequencyTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFrequencyTypeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFrequencyTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFrequencyTypeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFrequencyTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFrequencyTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFrequencyTypeLOVExecute(r)
}

/*
GetFrequencyTypeLOV Fetch List Of Values for Frequency Type

 <p><strong>OperationId:</strong>getFrequencyTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param defaultDepartureTask Value of the parameter 'defaultDepartureTask' which is required to fetch FrequencyType LOV
 @param guestRequested Value of the parameter 'guestRequested' which is required to fetch FrequencyType LOV
 @return ApiGetFrequencyTypeLOVRequest
*/
func (a *LOVApiService) GetFrequencyTypeLOV(ctx context.Context, defaultDepartureTask string, guestRequested string) ApiGetFrequencyTypeLOVRequest {
	return ApiGetFrequencyTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		defaultDepartureTask: defaultDepartureTask,
		guestRequested: guestRequested,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFrequencyTypeLOVExecute(r ApiGetFrequencyTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFrequencyTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/guestRequested/{guestRequested}/defaultDepartureTask/{defaultDepartureTask}/frequencyType"
	localVarPath = strings.Replace(localVarPath, "{"+"defaultDepartureTask"+"}", url.PathEscape(parameterValueToString(r.defaultDepartureTask, "defaultDepartureTask")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"guestRequested"+"}", url.PathEscape(parameterValueToString(r.guestRequested, "guestRequested")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.defaultDepartureTask) < 1 {
		return localVarReturnValue, nil, reportError("defaultDepartureTask must have at least 1 elements")
	}
	if strlen(r.defaultDepartureTask) > 2000 {
		return localVarReturnValue, nil, reportError("defaultDepartureTask must have less than 2000 elements")
	}
	if strlen(r.guestRequested) < 1 {
		return localVarReturnValue, nil, reportError("guestRequested must have at least 1 elements")
	}
	if strlen(r.guestRequested) > 2000 {
		return localVarReturnValue, nil, reportError("guestRequested must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFromRoomNumberLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetFromRoomNumberLOVRequest) Authorization(authorization string) ApiGetFromRoomNumberLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetFromRoomNumberLOVRequest) XAppKey(xAppKey string) ApiGetFromRoomNumberLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetFromRoomNumberLOVRequest) XHotelid(xHotelid string) ApiGetFromRoomNumberLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetFromRoomNumberLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetFromRoomNumberLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetFromRoomNumberLOVRequest) ParameterName(parameterName []string) ApiGetFromRoomNumberLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetFromRoomNumberLOVRequest) ParameterValue(parameterValue []string) ApiGetFromRoomNumberLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetFromRoomNumberLOVRequest) XExternalsystem(xExternalsystem string) ApiGetFromRoomNumberLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetFromRoomNumberLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetFromRoomNumberLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetFromRoomNumberLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFromRoomNumberLOVExecute(r)
}

/*
GetFromRoomNumberLOV Fetch List Of Values for From Room Number

 <p><strong>OperationId:</strong>getFromRoomNumberLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FromRoomNumber LOV
 @return ApiGetFromRoomNumberLOVRequest
*/
func (a *LOVApiService) GetFromRoomNumberLOV(ctx context.Context, hotelId string) ApiGetFromRoomNumberLOVRequest {
	return ApiGetFromRoomNumberLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFromRoomNumberLOVExecute(r ApiGetFromRoomNumberLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFromRoomNumberLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fromRoomNumber"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGdsConvAmenityCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingChannelCodes string
	featureType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGdsConvAmenityCodesLOVRequest) Authorization(authorization string) ApiGetGdsConvAmenityCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGdsConvAmenityCodesLOVRequest) XAppKey(xAppKey string) ApiGetGdsConvAmenityCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGdsConvAmenityCodesLOVRequest) XHotelid(xHotelid string) ApiGetGdsConvAmenityCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGdsConvAmenityCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGdsConvAmenityCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGdsConvAmenityCodesLOVRequest) ParameterName(parameterName []string) ApiGetGdsConvAmenityCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGdsConvAmenityCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetGdsConvAmenityCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGdsConvAmenityCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGdsConvAmenityCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGdsConvAmenityCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGdsConvAmenityCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGdsConvAmenityCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGdsConvAmenityCodesLOVExecute(r)
}

/*
GetGdsConvAmenityCodesLOV Fetch List Of Values for Gds Conv Amenity Codes

 <p><strong>OperationId:</strong>getGdsConvAmenityCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingChannelCodes Value of the parameter 'bookingChannelCodes' which is required to fetch GdsConvAmenityCodes LOV
 @param featureType Value of the parameter 'featureType' which is required to fetch GdsConvAmenityCodes LOV
 @return ApiGetGdsConvAmenityCodesLOVRequest
*/
func (a *LOVApiService) GetGdsConvAmenityCodesLOV(ctx context.Context, bookingChannelCodes string, featureType string) ApiGetGdsConvAmenityCodesLOVRequest {
	return ApiGetGdsConvAmenityCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingChannelCodes: bookingChannelCodes,
		featureType: featureType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGdsConvAmenityCodesLOVExecute(r ApiGetGdsConvAmenityCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGdsConvAmenityCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/featureType/{featureType}/bookingChannels/{bookingChannelCodes}/gdsConvAmenityCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCodes"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCodes, "bookingChannelCodes")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"featureType"+"}", url.PathEscape(parameterValueToString(r.featureType, "featureType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingChannelCodes) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCodes must have at least 1 elements")
	}
	if strlen(r.bookingChannelCodes) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCodes must have less than 2000 elements")
	}
	if strlen(r.featureType) < 1 {
		return localVarReturnValue, nil, reportError("featureType must have at least 1 elements")
	}
	if strlen(r.featureType) > 2000 {
		return localVarReturnValue, nil, reportError("featureType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGdsGuaranteeCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingChannelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGdsGuaranteeCodesLOVRequest) Authorization(authorization string) ApiGetGdsGuaranteeCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGdsGuaranteeCodesLOVRequest) XAppKey(xAppKey string) ApiGetGdsGuaranteeCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGdsGuaranteeCodesLOVRequest) XHotelid(xHotelid string) ApiGetGdsGuaranteeCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGdsGuaranteeCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGdsGuaranteeCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGdsGuaranteeCodesLOVRequest) ParameterName(parameterName []string) ApiGetGdsGuaranteeCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGdsGuaranteeCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetGdsGuaranteeCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGdsGuaranteeCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGdsGuaranteeCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGdsGuaranteeCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGdsGuaranteeCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGdsGuaranteeCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGdsGuaranteeCodesLOVExecute(r)
}

/*
GetGdsGuaranteeCodesLOV Fetch List Of Values for Gds Guarantee Codes

 <p><strong>OperationId:</strong>getGdsGuaranteeCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingChannelCode Value of the parameter 'bookingChannelCode' which is required to fetch GdsGuaranteeCodes LOV
 @return ApiGetGdsGuaranteeCodesLOVRequest
*/
func (a *LOVApiService) GetGdsGuaranteeCodesLOV(ctx context.Context, bookingChannelCode string) ApiGetGdsGuaranteeCodesLOVRequest {
	return ApiGetGdsGuaranteeCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingChannelCode: bookingChannelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGdsGuaranteeCodesLOVExecute(r ApiGetGdsGuaranteeCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGdsGuaranteeCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingChannels/{bookingChannelCode}/gdsGuaranteeCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCode"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCode, "bookingChannelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingChannelCode) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have at least 1 elements")
	}
	if strlen(r.bookingChannelCode) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGdsHotelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	channelType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGdsHotelsLOVRequest) Authorization(authorization string) ApiGetGdsHotelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGdsHotelsLOVRequest) XAppKey(xAppKey string) ApiGetGdsHotelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGdsHotelsLOVRequest) XHotelid(xHotelid string) ApiGetGdsHotelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGdsHotelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGdsHotelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGdsHotelsLOVRequest) ParameterName(parameterName []string) ApiGetGdsHotelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGdsHotelsLOVRequest) ParameterValue(parameterValue []string) ApiGetGdsHotelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGdsHotelsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGdsHotelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGdsHotelsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGdsHotelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGdsHotelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGdsHotelsLOVExecute(r)
}

/*
GetGdsHotelsLOV Fetch List Of Values for Gds Hotels

 <p><strong>OperationId:</strong>getGdsHotelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelType Value of the parameter 'channelType' which is required to fetch GdsHotels LOV
 @return ApiGetGdsHotelsLOVRequest
*/
func (a *LOVApiService) GetGdsHotelsLOV(ctx context.Context, channelType string) ApiGetGdsHotelsLOVRequest {
	return ApiGetGdsHotelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		channelType: channelType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGdsHotelsLOVExecute(r ApiGetGdsHotelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGdsHotelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/channelType/{channelType}/gdsHotels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelType"+"}", url.PathEscape(parameterValueToString(r.channelType, "channelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelType) < 1 {
		return localVarReturnValue, nil, reportError("channelType must have at least 1 elements")
	}
	if strlen(r.channelType) > 2000 {
		return localVarReturnValue, nil, reportError("channelType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGdsRateCategoriesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingChannelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGdsRateCategoriesLOVRequest) Authorization(authorization string) ApiGetGdsRateCategoriesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGdsRateCategoriesLOVRequest) XAppKey(xAppKey string) ApiGetGdsRateCategoriesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGdsRateCategoriesLOVRequest) XHotelid(xHotelid string) ApiGetGdsRateCategoriesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGdsRateCategoriesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGdsRateCategoriesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGdsRateCategoriesLOVRequest) ParameterName(parameterName []string) ApiGetGdsRateCategoriesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGdsRateCategoriesLOVRequest) ParameterValue(parameterValue []string) ApiGetGdsRateCategoriesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGdsRateCategoriesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGdsRateCategoriesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGdsRateCategoriesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGdsRateCategoriesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGdsRateCategoriesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGdsRateCategoriesLOVExecute(r)
}

/*
GetGdsRateCategoriesLOV Fetch List Of Values for Gds Rate Categories

 <p><strong>OperationId:</strong>getGdsRateCategoriesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingChannelCode Value of the parameter 'bookingChannelCode' which is required to fetch GdsRateCategories LOV
 @return ApiGetGdsRateCategoriesLOVRequest
*/
func (a *LOVApiService) GetGdsRateCategoriesLOV(ctx context.Context, bookingChannelCode string) ApiGetGdsRateCategoriesLOVRequest {
	return ApiGetGdsRateCategoriesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingChannelCode: bookingChannelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGdsRateCategoriesLOVExecute(r ApiGetGdsRateCategoriesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGdsRateCategoriesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingChannels/{bookingChannelCode}/gdsRateCategories"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCode"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCode, "bookingChannelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingChannelCode) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have at least 1 elements")
	}
	if strlen(r.bookingChannelCode) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGdsRateLevelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingChannelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGdsRateLevelsLOVRequest) Authorization(authorization string) ApiGetGdsRateLevelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGdsRateLevelsLOVRequest) XAppKey(xAppKey string) ApiGetGdsRateLevelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGdsRateLevelsLOVRequest) XHotelid(xHotelid string) ApiGetGdsRateLevelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGdsRateLevelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGdsRateLevelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGdsRateLevelsLOVRequest) ParameterName(parameterName []string) ApiGetGdsRateLevelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGdsRateLevelsLOVRequest) ParameterValue(parameterValue []string) ApiGetGdsRateLevelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGdsRateLevelsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGdsRateLevelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGdsRateLevelsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGdsRateLevelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGdsRateLevelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGdsRateLevelsLOVExecute(r)
}

/*
GetGdsRateLevelsLOV Fetch List Of Values for Gds Rate Levels

 <p><strong>OperationId:</strong>getGdsRateLevelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingChannelCode Value of the parameter 'bookingChannelCode' which is required to fetch GdsRateLevels LOV
 @return ApiGetGdsRateLevelsLOVRequest
*/
func (a *LOVApiService) GetGdsRateLevelsLOV(ctx context.Context, bookingChannelCode string) ApiGetGdsRateLevelsLOVRequest {
	return ApiGetGdsRateLevelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingChannelCode: bookingChannelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGdsRateLevelsLOVExecute(r ApiGetGdsRateLevelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGdsRateLevelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingChannels/{bookingChannelCode}/gdsRateLevels"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCode"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCode, "bookingChannelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingChannelCode) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have at least 1 elements")
	}
	if strlen(r.bookingChannelCode) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGdsRoomCategoryTemplatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingChannelCodes string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGdsRoomCategoryTemplatesLOVRequest) Authorization(authorization string) ApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGdsRoomCategoryTemplatesLOVRequest) XAppKey(xAppKey string) ApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGdsRoomCategoryTemplatesLOVRequest) XHotelid(xHotelid string) ApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGdsRoomCategoryTemplatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGdsRoomCategoryTemplatesLOVRequest) ParameterName(parameterName []string) ApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGdsRoomCategoryTemplatesLOVRequest) ParameterValue(parameterValue []string) ApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGdsRoomCategoryTemplatesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGdsRoomCategoryTemplatesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGdsRoomCategoryTemplatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGdsRoomCategoryTemplatesLOVExecute(r)
}

/*
GetGdsRoomCategoryTemplatesLOV Fetch List Of Values for Gds Room Category Templates

 <p><strong>OperationId:</strong>getGdsRoomCategoryTemplatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingChannelCodes Value of the parameter 'bookingChannelCodes' which is required to fetch GdsRoomCategoryTemplates LOV
 @return ApiGetGdsRoomCategoryTemplatesLOVRequest
*/
func (a *LOVApiService) GetGdsRoomCategoryTemplatesLOV(ctx context.Context, bookingChannelCodes string) ApiGetGdsRoomCategoryTemplatesLOVRequest {
	return ApiGetGdsRoomCategoryTemplatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingChannelCodes: bookingChannelCodes,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGdsRoomCategoryTemplatesLOVExecute(r ApiGetGdsRoomCategoryTemplatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGdsRoomCategoryTemplatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingChannels/{bookingChannelCodes}/gdsRoomCategoryTemplates"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCodes"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCodes, "bookingChannelCodes")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingChannelCodes) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCodes must have at least 1 elements")
	}
	if strlen(r.bookingChannelCodes) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCodes must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGemMenuItemsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGemMenuItemsLOVRequest) Authorization(authorization string) ApiGetGemMenuItemsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGemMenuItemsLOVRequest) XAppKey(xAppKey string) ApiGetGemMenuItemsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGemMenuItemsLOVRequest) XHotelid(xHotelid string) ApiGetGemMenuItemsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGemMenuItemsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGemMenuItemsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGemMenuItemsLOVRequest) ParameterName(parameterName []string) ApiGetGemMenuItemsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGemMenuItemsLOVRequest) ParameterValue(parameterValue []string) ApiGetGemMenuItemsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGemMenuItemsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGemMenuItemsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGemMenuItemsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGemMenuItemsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGemMenuItemsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGemMenuItemsLOVExecute(r)
}

/*
GetGemMenuItemsLOV Fetch List Of Values for Gem Menu Items

 <p><strong>OperationId:</strong>getGemMenuItemsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch GemMenuItems LOV
 @return ApiGetGemMenuItemsLOVRequest
*/
func (a *LOVApiService) GetGemMenuItemsLOV(ctx context.Context, hotelId string) ApiGetGemMenuItemsLOVRequest {
	return ApiGetGemMenuItemsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGemMenuItemsLOVExecute(r ApiGetGemMenuItemsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGemMenuItemsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/gemMenuItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGenericReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGenericReportsLOVRequest) Authorization(authorization string) ApiGetGenericReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGenericReportsLOVRequest) XAppKey(xAppKey string) ApiGetGenericReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGenericReportsLOVRequest) XHotelid(xHotelid string) ApiGetGenericReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGenericReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGenericReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGenericReportsLOVRequest) ParameterName(parameterName []string) ApiGetGenericReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGenericReportsLOVRequest) ParameterValue(parameterValue []string) ApiGetGenericReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGenericReportsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGenericReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGenericReportsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGenericReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGenericReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGenericReportsLOVExecute(r)
}

/*
GetGenericReportsLOV Fetch List Of Values for Generic Reports

 <p><strong>OperationId:</strong>getGenericReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch GenericReports LOV
 @return ApiGetGenericReportsLOVRequest
*/
func (a *LOVApiService) GetGenericReportsLOV(ctx context.Context, hotelId string) ApiGetGenericReportsLOVRequest {
	return ApiGetGenericReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGenericReportsLOVExecute(r ApiGetGenericReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGenericReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/genericReports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalAlertFieldQueryLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	sourceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGlobalAlertFieldQueryLOVRequest) Authorization(authorization string) ApiGetGlobalAlertFieldQueryLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGlobalAlertFieldQueryLOVRequest) XAppKey(xAppKey string) ApiGetGlobalAlertFieldQueryLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGlobalAlertFieldQueryLOVRequest) XHotelid(xHotelid string) ApiGetGlobalAlertFieldQueryLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGlobalAlertFieldQueryLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGlobalAlertFieldQueryLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGlobalAlertFieldQueryLOVRequest) ParameterName(parameterName []string) ApiGetGlobalAlertFieldQueryLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGlobalAlertFieldQueryLOVRequest) ParameterValue(parameterValue []string) ApiGetGlobalAlertFieldQueryLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGlobalAlertFieldQueryLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGlobalAlertFieldQueryLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGlobalAlertFieldQueryLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGlobalAlertFieldQueryLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGlobalAlertFieldQueryLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGlobalAlertFieldQueryLOVExecute(r)
}

/*
GetGlobalAlertFieldQueryLOV Fetch List Of Values for Global Alert Field Query

 <p><strong>OperationId:</strong>getGlobalAlertFieldQueryLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceId Value of the parameter 'sourceId' which is required to fetch GlobalAlertFieldQuery LOV
 @return ApiGetGlobalAlertFieldQueryLOVRequest
*/
func (a *LOVApiService) GetGlobalAlertFieldQueryLOV(ctx context.Context, sourceId string) ApiGetGlobalAlertFieldQueryLOVRequest {
	return ApiGetGlobalAlertFieldQueryLOVRequest{
		ApiService: a,
		ctx: ctx,
		sourceId: sourceId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGlobalAlertFieldQueryLOVExecute(r ApiGetGlobalAlertFieldQueryLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGlobalAlertFieldQueryLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/sourceId/{sourceId}/globalAlertFieldQuery"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceId"+"}", url.PathEscape(parameterValueToString(r.sourceId, "sourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceId) < 1 {
		return localVarReturnValue, nil, reportError("sourceId must have at least 1 elements")
	}
	if strlen(r.sourceId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalAlertFunctionLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fieldType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGlobalAlertFunctionLOVRequest) Authorization(authorization string) ApiGetGlobalAlertFunctionLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGlobalAlertFunctionLOVRequest) XAppKey(xAppKey string) ApiGetGlobalAlertFunctionLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGlobalAlertFunctionLOVRequest) XHotelid(xHotelid string) ApiGetGlobalAlertFunctionLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGlobalAlertFunctionLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGlobalAlertFunctionLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGlobalAlertFunctionLOVRequest) ParameterName(parameterName []string) ApiGetGlobalAlertFunctionLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGlobalAlertFunctionLOVRequest) ParameterValue(parameterValue []string) ApiGetGlobalAlertFunctionLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGlobalAlertFunctionLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGlobalAlertFunctionLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGlobalAlertFunctionLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGlobalAlertFunctionLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGlobalAlertFunctionLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGlobalAlertFunctionLOVExecute(r)
}

/*
GetGlobalAlertFunctionLOV Fetch List Of Values for Global Alert Function

 <p><strong>OperationId:</strong>getGlobalAlertFunctionLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldType Value of the parameter 'fieldType' which is required to fetch GlobalAlertFunction LOV
 @return ApiGetGlobalAlertFunctionLOVRequest
*/
func (a *LOVApiService) GetGlobalAlertFunctionLOV(ctx context.Context, fieldType string) ApiGetGlobalAlertFunctionLOVRequest {
	return ApiGetGlobalAlertFunctionLOVRequest{
		ApiService: a,
		ctx: ctx,
		fieldType: fieldType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGlobalAlertFunctionLOVExecute(r ApiGetGlobalAlertFunctionLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGlobalAlertFunctionLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/fieldType/{fieldType}/globalAlertFunction"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldType"+"}", url.PathEscape(parameterValueToString(r.fieldType, "fieldType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fieldType) < 1 {
		return localVarReturnValue, nil, reportError("fieldType must have at least 1 elements")
	}
	if strlen(r.fieldType) > 2000 {
		return localVarReturnValue, nil, reportError("fieldType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalAlertOperatorLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	tableName string
	fieldName string
	fieldType string
	sourceIdIn string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGlobalAlertOperatorLOVRequest) Authorization(authorization string) ApiGetGlobalAlertOperatorLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGlobalAlertOperatorLOVRequest) XAppKey(xAppKey string) ApiGetGlobalAlertOperatorLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGlobalAlertOperatorLOVRequest) XHotelid(xHotelid string) ApiGetGlobalAlertOperatorLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGlobalAlertOperatorLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGlobalAlertOperatorLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGlobalAlertOperatorLOVRequest) ParameterName(parameterName []string) ApiGetGlobalAlertOperatorLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGlobalAlertOperatorLOVRequest) ParameterValue(parameterValue []string) ApiGetGlobalAlertOperatorLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGlobalAlertOperatorLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGlobalAlertOperatorLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGlobalAlertOperatorLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGlobalAlertOperatorLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGlobalAlertOperatorLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGlobalAlertOperatorLOVExecute(r)
}

/*
GetGlobalAlertOperatorLOV Fetch List Of Values for Global Alert Operator

 <p><strong>OperationId:</strong>getGlobalAlertOperatorLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Value of the parameter 'tableName' which is required to fetch GlobalAlertOperator LOV
 @param fieldName Value of the parameter 'fieldName' which is required to fetch GlobalAlertOperator LOV
 @param fieldType Value of the parameter 'fieldType' which is required to fetch GlobalAlertOperator LOV
 @param sourceIdIn Value of the parameter 'sourceIdIn' which is required to fetch GlobalAlertOperator LOV
 @return ApiGetGlobalAlertOperatorLOVRequest
*/
func (a *LOVApiService) GetGlobalAlertOperatorLOV(ctx context.Context, tableName string, fieldName string, fieldType string, sourceIdIn string) ApiGetGlobalAlertOperatorLOVRequest {
	return ApiGetGlobalAlertOperatorLOVRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
		fieldName: fieldName,
		fieldType: fieldType,
		sourceIdIn: sourceIdIn,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGlobalAlertOperatorLOVExecute(r ApiGetGlobalAlertOperatorLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGlobalAlertOperatorLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/sourceIdIn/{sourceIdIn}/fieldType/{fieldType}/fieldName/{fieldName}/tableName/{tableName}/globalAlertOperator"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", url.PathEscape(parameterValueToString(r.fieldName, "fieldName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldType"+"}", url.PathEscape(parameterValueToString(r.fieldType, "fieldType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceIdIn"+"}", url.PathEscape(parameterValueToString(r.sourceIdIn, "sourceIdIn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.tableName) < 1 {
		return localVarReturnValue, nil, reportError("tableName must have at least 1 elements")
	}
	if strlen(r.tableName) > 2000 {
		return localVarReturnValue, nil, reportError("tableName must have less than 2000 elements")
	}
	if strlen(r.fieldName) < 1 {
		return localVarReturnValue, nil, reportError("fieldName must have at least 1 elements")
	}
	if strlen(r.fieldName) > 2000 {
		return localVarReturnValue, nil, reportError("fieldName must have less than 2000 elements")
	}
	if strlen(r.fieldType) < 1 {
		return localVarReturnValue, nil, reportError("fieldType must have at least 1 elements")
	}
	if strlen(r.fieldType) > 2000 {
		return localVarReturnValue, nil, reportError("fieldType must have less than 2000 elements")
	}
	if strlen(r.sourceIdIn) < 1 {
		return localVarReturnValue, nil, reportError("sourceIdIn must have at least 1 elements")
	}
	if strlen(r.sourceIdIn) > 2000 {
		return localVarReturnValue, nil, reportError("sourceIdIn must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGridTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingStatus string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGridTypesLOVRequest) Authorization(authorization string) ApiGetGridTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGridTypesLOVRequest) XAppKey(xAppKey string) ApiGetGridTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGridTypesLOVRequest) XHotelid(xHotelid string) ApiGetGridTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGridTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGridTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGridTypesLOVRequest) ParameterName(parameterName []string) ApiGetGridTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGridTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetGridTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGridTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGridTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGridTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGridTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGridTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGridTypesLOVExecute(r)
}

/*
GetGridTypesLOV Fetch List Of Values for Grid Types

 <p><strong>OperationId:</strong>getGridTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingStatus Value of the parameter 'bookingStatus' which is required to fetch GridTypes LOV
 @return ApiGetGridTypesLOVRequest
*/
func (a *LOVApiService) GetGridTypesLOV(ctx context.Context, bookingStatus string) ApiGetGridTypesLOVRequest {
	return ApiGetGridTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingStatus: bookingStatus,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGridTypesLOVExecute(r ApiGetGridTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGridTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingStatus/{bookingStatus}/gridTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingStatus"+"}", url.PathEscape(parameterValueToString(r.bookingStatus, "bookingStatus")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingStatus) < 1 {
		return localVarReturnValue, nil, reportError("bookingStatus must have at least 1 elements")
	}
	if strlen(r.bookingStatus) > 2000 {
		return localVarReturnValue, nil, reportError("bookingStatus must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupArrivalsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGroupArrivalsLOVRequest) Authorization(authorization string) ApiGetGroupArrivalsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGroupArrivalsLOVRequest) XAppKey(xAppKey string) ApiGetGroupArrivalsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGroupArrivalsLOVRequest) XHotelid(xHotelid string) ApiGetGroupArrivalsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGroupArrivalsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGroupArrivalsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGroupArrivalsLOVRequest) ParameterName(parameterName []string) ApiGetGroupArrivalsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGroupArrivalsLOVRequest) ParameterValue(parameterValue []string) ApiGetGroupArrivalsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGroupArrivalsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGroupArrivalsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGroupArrivalsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGroupArrivalsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGroupArrivalsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGroupArrivalsLOVExecute(r)
}

/*
GetGroupArrivalsLOV Fetch List Of Values for Group Arrivals

 <p><strong>OperationId:</strong>getGroupArrivalsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch GroupArrivals LOV
 @return ApiGetGroupArrivalsLOVRequest
*/
func (a *LOVApiService) GetGroupArrivalsLOV(ctx context.Context, hotelId string) ApiGetGroupArrivalsLOVRequest {
	return ApiGetGroupArrivalsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGroupArrivalsLOVExecute(r ApiGetGroupArrivalsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGroupArrivalsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/groupArrivals"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGroupsLOVRequest) Authorization(authorization string) ApiGetGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGroupsLOVRequest) XAppKey(xAppKey string) ApiGetGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGroupsLOVRequest) XHotelid(xHotelid string) ApiGetGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGroupsLOVRequest) ParameterName(parameterName []string) ApiGetGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGroupsLOVExecute(r)
}

/*
GetGroupsLOV Fetch List Of Values for Groups

 <p><strong>OperationId:</strong>getGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Groups LOV
 @return ApiGetGroupsLOVRequest
*/
func (a *LOVApiService) GetGroupsLOV(ctx context.Context, hotelId string) ApiGetGroupsLOVRequest {
	return ApiGetGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGroupsLOVExecute(r ApiGetGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGuestMessagesMultiHotelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGuestMessagesMultiHotelLOVRequest) Authorization(authorization string) ApiGetGuestMessagesMultiHotelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGuestMessagesMultiHotelLOVRequest) XAppKey(xAppKey string) ApiGetGuestMessagesMultiHotelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGuestMessagesMultiHotelLOVRequest) XHotelid(xHotelid string) ApiGetGuestMessagesMultiHotelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGuestMessagesMultiHotelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGuestMessagesMultiHotelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGuestMessagesMultiHotelLOVRequest) ParameterName(parameterName []string) ApiGetGuestMessagesMultiHotelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGuestMessagesMultiHotelLOVRequest) ParameterValue(parameterValue []string) ApiGetGuestMessagesMultiHotelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGuestMessagesMultiHotelLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGuestMessagesMultiHotelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGuestMessagesMultiHotelLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGuestMessagesMultiHotelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGuestMessagesMultiHotelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGuestMessagesMultiHotelLOVExecute(r)
}

/*
GetGuestMessagesMultiHotelLOV Fetch List Of Values for Guest Messages Multi Hotel

 <p><strong>OperationId:</strong>getGuestMessagesMultiHotelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch GuestMessagesMultiHotel LOV
 @return ApiGetGuestMessagesMultiHotelLOVRequest
*/
func (a *LOVApiService) GetGuestMessagesMultiHotelLOV(ctx context.Context, hotelId string) ApiGetGuestMessagesMultiHotelLOVRequest {
	return ApiGetGuestMessagesMultiHotelLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGuestMessagesMultiHotelLOVExecute(r ApiGetGuestMessagesMultiHotelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGuestMessagesMultiHotelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/guestMessagesMultiHotel"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGuestMessagesQuickTextsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetGuestMessagesQuickTextsLOVRequest) Authorization(authorization string) ApiGetGuestMessagesQuickTextsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetGuestMessagesQuickTextsLOVRequest) XAppKey(xAppKey string) ApiGetGuestMessagesQuickTextsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetGuestMessagesQuickTextsLOVRequest) XHotelid(xHotelid string) ApiGetGuestMessagesQuickTextsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetGuestMessagesQuickTextsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetGuestMessagesQuickTextsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetGuestMessagesQuickTextsLOVRequest) ParameterName(parameterName []string) ApiGetGuestMessagesQuickTextsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetGuestMessagesQuickTextsLOVRequest) ParameterValue(parameterValue []string) ApiGetGuestMessagesQuickTextsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetGuestMessagesQuickTextsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetGuestMessagesQuickTextsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetGuestMessagesQuickTextsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetGuestMessagesQuickTextsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetGuestMessagesQuickTextsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGuestMessagesQuickTextsLOVExecute(r)
}

/*
GetGuestMessagesQuickTextsLOV Fetch List Of Values for Guest Messages Quick Texts

 <p><strong>OperationId:</strong>getGuestMessagesQuickTextsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch GuestMessagesQuickTexts LOV
 @return ApiGetGuestMessagesQuickTextsLOVRequest
*/
func (a *LOVApiService) GetGuestMessagesQuickTextsLOV(ctx context.Context, hotelId string) ApiGetGuestMessagesQuickTextsLOVRequest {
	return ApiGetGuestMessagesQuickTextsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGuestMessagesQuickTextsLOVExecute(r ApiGetGuestMessagesQuickTextsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGuestMessagesQuickTextsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/guestMessagesQuickTexts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHKAttendantsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHKAttendantsLOVRequest) Authorization(authorization string) ApiGetHKAttendantsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHKAttendantsLOVRequest) XAppKey(xAppKey string) ApiGetHKAttendantsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHKAttendantsLOVRequest) XHotelid(xHotelid string) ApiGetHKAttendantsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHKAttendantsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHKAttendantsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHKAttendantsLOVRequest) ParameterName(parameterName []string) ApiGetHKAttendantsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHKAttendantsLOVRequest) ParameterValue(parameterValue []string) ApiGetHKAttendantsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHKAttendantsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHKAttendantsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHKAttendantsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHKAttendantsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHKAttendantsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKAttendantsLOVExecute(r)
}

/*
GetHKAttendantsLOV Fetch List Of Values for HKAttendants

 <p><strong>OperationId:</strong>getHKAttendantsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKAttendants LOV
 @return ApiGetHKAttendantsLOVRequest
*/
func (a *LOVApiService) GetHKAttendantsLOV(ctx context.Context, hotelId string) ApiGetHKAttendantsLOVRequest {
	return ApiGetHKAttendantsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKAttendantsLOVExecute(r ApiGetHKAttendantsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKAttendantsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkAttendants"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHKAttendantsMobileLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHKAttendantsMobileLOVRequest) Authorization(authorization string) ApiGetHKAttendantsMobileLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHKAttendantsMobileLOVRequest) XAppKey(xAppKey string) ApiGetHKAttendantsMobileLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHKAttendantsMobileLOVRequest) XHotelid(xHotelid string) ApiGetHKAttendantsMobileLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHKAttendantsMobileLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHKAttendantsMobileLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHKAttendantsMobileLOVRequest) ParameterName(parameterName []string) ApiGetHKAttendantsMobileLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHKAttendantsMobileLOVRequest) ParameterValue(parameterValue []string) ApiGetHKAttendantsMobileLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHKAttendantsMobileLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHKAttendantsMobileLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHKAttendantsMobileLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHKAttendantsMobileLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHKAttendantsMobileLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKAttendantsMobileLOVExecute(r)
}

/*
GetHKAttendantsMobileLOV Fetch List Of Values for HKAttendants Mobile

 <p><strong>OperationId:</strong>getHKAttendantsMobileLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKAttendantsMobile LOV
 @return ApiGetHKAttendantsMobileLOVRequest
*/
func (a *LOVApiService) GetHKAttendantsMobileLOV(ctx context.Context, hotelId string) ApiGetHKAttendantsMobileLOVRequest {
	return ApiGetHKAttendantsMobileLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKAttendantsMobileLOVExecute(r ApiGetHKAttendantsMobileLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKAttendantsMobileLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkAttendantsMobile"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHKScheduledAttendantsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	businessDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHKScheduledAttendantsLOVRequest) Authorization(authorization string) ApiGetHKScheduledAttendantsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHKScheduledAttendantsLOVRequest) XAppKey(xAppKey string) ApiGetHKScheduledAttendantsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHKScheduledAttendantsLOVRequest) XHotelid(xHotelid string) ApiGetHKScheduledAttendantsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHKScheduledAttendantsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHKScheduledAttendantsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHKScheduledAttendantsLOVRequest) ParameterName(parameterName []string) ApiGetHKScheduledAttendantsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHKScheduledAttendantsLOVRequest) ParameterValue(parameterValue []string) ApiGetHKScheduledAttendantsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHKScheduledAttendantsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHKScheduledAttendantsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHKScheduledAttendantsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHKScheduledAttendantsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHKScheduledAttendantsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKScheduledAttendantsLOVExecute(r)
}

/*
GetHKScheduledAttendantsLOV Fetch List Of Values for HKScheduled Attendants

 <p><strong>OperationId:</strong>getHKScheduledAttendantsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessDate Value of the parameter 'businessDate' which is required to fetch HKScheduledAttendants LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKScheduledAttendants LOV
 @return ApiGetHKScheduledAttendantsLOVRequest
*/
func (a *LOVApiService) GetHKScheduledAttendantsLOV(ctx context.Context, businessDate string, hotelId string) ApiGetHKScheduledAttendantsLOVRequest {
	return ApiGetHKScheduledAttendantsLOVRequest{
		ApiService: a,
		ctx: ctx,
		businessDate: businessDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKScheduledAttendantsLOVExecute(r ApiGetHKScheduledAttendantsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKScheduledAttendantsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/businessDate/{businessDate}/hkScheduledAttendants"
	localVarPath = strings.Replace(localVarPath, "{"+"businessDate"+"}", url.PathEscape(parameterValueToString(r.businessDate, "businessDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessDate) < 1 {
		return localVarReturnValue, nil, reportError("businessDate must have at least 1 elements")
	}
	if strlen(r.businessDate) > 2000 {
		return localVarReturnValue, nil, reportError("businessDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHKTaskBreakOutLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHKTaskBreakOutLOVRequest) Authorization(authorization string) ApiGetHKTaskBreakOutLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHKTaskBreakOutLOVRequest) XAppKey(xAppKey string) ApiGetHKTaskBreakOutLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHKTaskBreakOutLOVRequest) XHotelid(xHotelid string) ApiGetHKTaskBreakOutLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHKTaskBreakOutLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHKTaskBreakOutLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHKTaskBreakOutLOVRequest) ParameterName(parameterName []string) ApiGetHKTaskBreakOutLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHKTaskBreakOutLOVRequest) ParameterValue(parameterValue []string) ApiGetHKTaskBreakOutLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHKTaskBreakOutLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHKTaskBreakOutLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHKTaskBreakOutLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHKTaskBreakOutLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHKTaskBreakOutLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKTaskBreakOutLOVExecute(r)
}

/*
GetHKTaskBreakOutLOV Fetch List Of Values for HKTask Break Out

 <p><strong>OperationId:</strong>getHKTaskBreakOutLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKTaskBreakOut LOV
 @return ApiGetHKTaskBreakOutLOVRequest
*/
func (a *LOVApiService) GetHKTaskBreakOutLOV(ctx context.Context, hotelId string) ApiGetHKTaskBreakOutLOVRequest {
	return ApiGetHKTaskBreakOutLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKTaskBreakOutLOVExecute(r ApiGetHKTaskBreakOutLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKTaskBreakOutLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkTaskBreakOut"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHKTaskCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHKTaskCodesLOVRequest) Authorization(authorization string) ApiGetHKTaskCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHKTaskCodesLOVRequest) XAppKey(xAppKey string) ApiGetHKTaskCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHKTaskCodesLOVRequest) XHotelid(xHotelid string) ApiGetHKTaskCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHKTaskCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHKTaskCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHKTaskCodesLOVRequest) ParameterName(parameterName []string) ApiGetHKTaskCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHKTaskCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetHKTaskCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHKTaskCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHKTaskCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHKTaskCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHKTaskCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHKTaskCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKTaskCodesLOVExecute(r)
}

/*
GetHKTaskCodesLOV Fetch List Of Values for HKTask Codes

 <p><strong>OperationId:</strong>getHKTaskCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKTaskCodes LOV
 @return ApiGetHKTaskCodesLOVRequest
*/
func (a *LOVApiService) GetHKTaskCodesLOV(ctx context.Context, hotelId string) ApiGetHKTaskCodesLOVRequest {
	return ApiGetHKTaskCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKTaskCodesLOVExecute(r ApiGetHKTaskCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKTaskCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkTaskCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHKTaskSheetsNoLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	breakOutId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHKTaskSheetsNoLOVRequest) Authorization(authorization string) ApiGetHKTaskSheetsNoLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHKTaskSheetsNoLOVRequest) XAppKey(xAppKey string) ApiGetHKTaskSheetsNoLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHKTaskSheetsNoLOVRequest) XHotelid(xHotelid string) ApiGetHKTaskSheetsNoLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHKTaskSheetsNoLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHKTaskSheetsNoLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHKTaskSheetsNoLOVRequest) ParameterName(parameterName []string) ApiGetHKTaskSheetsNoLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHKTaskSheetsNoLOVRequest) ParameterValue(parameterValue []string) ApiGetHKTaskSheetsNoLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHKTaskSheetsNoLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHKTaskSheetsNoLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHKTaskSheetsNoLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHKTaskSheetsNoLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHKTaskSheetsNoLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKTaskSheetsNoLOVExecute(r)
}

/*
GetHKTaskSheetsNoLOV Fetch List Of Values for HKTask Sheets No

 <p><strong>OperationId:</strong>getHKTaskSheetsNoLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param breakOutId Value of the parameter 'breakOutId' which is required to fetch HKTaskSheetsNo LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKTaskSheetsNo LOV
 @return ApiGetHKTaskSheetsNoLOVRequest
*/
func (a *LOVApiService) GetHKTaskSheetsNoLOV(ctx context.Context, breakOutId string, hotelId string) ApiGetHKTaskSheetsNoLOVRequest {
	return ApiGetHKTaskSheetsNoLOVRequest{
		ApiService: a,
		ctx: ctx,
		breakOutId: breakOutId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKTaskSheetsNoLOVExecute(r ApiGetHKTaskSheetsNoLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKTaskSheetsNoLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/breakOutId/{breakOutId}/hkTaskSheetsNo"
	localVarPath = strings.Replace(localVarPath, "{"+"breakOutId"+"}", url.PathEscape(parameterValueToString(r.breakOutId, "breakOutId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.breakOutId) < 1 {
		return localVarReturnValue, nil, reportError("breakOutId must have at least 1 elements")
	}
	if strlen(r.breakOutId) > 2000 {
		return localVarReturnValue, nil, reportError("breakOutId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHKTaskTemplatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHKTaskTemplatesLOVRequest) Authorization(authorization string) ApiGetHKTaskTemplatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHKTaskTemplatesLOVRequest) XAppKey(xAppKey string) ApiGetHKTaskTemplatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHKTaskTemplatesLOVRequest) XHotelid(xHotelid string) ApiGetHKTaskTemplatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHKTaskTemplatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHKTaskTemplatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHKTaskTemplatesLOVRequest) ParameterName(parameterName []string) ApiGetHKTaskTemplatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHKTaskTemplatesLOVRequest) ParameterValue(parameterValue []string) ApiGetHKTaskTemplatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHKTaskTemplatesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHKTaskTemplatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHKTaskTemplatesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHKTaskTemplatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHKTaskTemplatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKTaskTemplatesLOVExecute(r)
}

/*
GetHKTaskTemplatesLOV Fetch List Of Values for HKTask Templates

 <p><strong>OperationId:</strong>getHKTaskTemplatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKTaskTemplates LOV
 @return ApiGetHKTaskTemplatesLOVRequest
*/
func (a *LOVApiService) GetHKTaskTemplatesLOV(ctx context.Context, hotelId string) ApiGetHKTaskTemplatesLOVRequest {
	return ApiGetHKTaskTemplatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKTaskTemplatesLOVExecute(r ApiGetHKTaskTemplatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKTaskTemplatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkTaskTemplates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHkFloorsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHkFloorsLOVRequest) Authorization(authorization string) ApiGetHkFloorsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHkFloorsLOVRequest) XAppKey(xAppKey string) ApiGetHkFloorsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHkFloorsLOVRequest) XHotelid(xHotelid string) ApiGetHkFloorsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHkFloorsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHkFloorsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHkFloorsLOVRequest) ParameterName(parameterName []string) ApiGetHkFloorsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHkFloorsLOVRequest) ParameterValue(parameterValue []string) ApiGetHkFloorsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHkFloorsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHkFloorsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHkFloorsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHkFloorsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHkFloorsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHkFloorsLOVExecute(r)
}

/*
GetHkFloorsLOV Fetch List Of Values for Hk Floors

 <p><strong>OperationId:</strong>getHkFloorsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HkFloors LOV
 @return ApiGetHkFloorsLOVRequest
*/
func (a *LOVApiService) GetHkFloorsLOV(ctx context.Context, hotelId string) ApiGetHkFloorsLOVRequest {
	return ApiGetHkFloorsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHkFloorsLOVExecute(r ApiGetHkFloorsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHkFloorsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkFloors"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHkRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHkRoomTypesLOVRequest) Authorization(authorization string) ApiGetHkRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHkRoomTypesLOVRequest) XAppKey(xAppKey string) ApiGetHkRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHkRoomTypesLOVRequest) XHotelid(xHotelid string) ApiGetHkRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHkRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHkRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHkRoomTypesLOVRequest) ParameterName(parameterName []string) ApiGetHkRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHkRoomTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetHkRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHkRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHkRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHkRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHkRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHkRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHkRoomTypesLOVExecute(r)
}

/*
GetHkRoomTypesLOV Fetch List Of Values for Hk Room Types

 <p><strong>OperationId:</strong>getHkRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HkRoomTypes LOV
 @return ApiGetHkRoomTypesLOVRequest
*/
func (a *LOVApiService) GetHkRoomTypesLOV(ctx context.Context, hotelId string) ApiGetHkRoomTypesLOVRequest {
	return ApiGetHkRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHkRoomTypesLOVExecute(r ApiGetHkRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHkRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHkRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHkRoomsLOVRequest) Authorization(authorization string) ApiGetHkRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHkRoomsLOVRequest) XAppKey(xAppKey string) ApiGetHkRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHkRoomsLOVRequest) XHotelid(xHotelid string) ApiGetHkRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHkRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHkRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHkRoomsLOVRequest) ParameterName(parameterName []string) ApiGetHkRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHkRoomsLOVRequest) ParameterValue(parameterValue []string) ApiGetHkRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHkRoomsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHkRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHkRoomsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHkRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHkRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHkRoomsLOVExecute(r)
}

/*
GetHkRoomsLOV Fetch List Of Values for Hk Rooms

 <p><strong>OperationId:</strong>getHkRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HkRooms LOV
 @return ApiGetHkRoomsLOVRequest
*/
func (a *LOVApiService) GetHkRoomsLOV(ctx context.Context, hotelId string) ApiGetHkRoomsLOVRequest {
	return ApiGetHkRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHkRoomsLOVExecute(r ApiGetHkRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHkRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelContactCommMethodLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	contactType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelContactCommMethodLOVRequest) Authorization(authorization string) ApiGetHotelContactCommMethodLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelContactCommMethodLOVRequest) XAppKey(xAppKey string) ApiGetHotelContactCommMethodLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelContactCommMethodLOVRequest) XHotelid(xHotelid string) ApiGetHotelContactCommMethodLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHotelContactCommMethodLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHotelContactCommMethodLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHotelContactCommMethodLOVRequest) ParameterName(parameterName []string) ApiGetHotelContactCommMethodLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHotelContactCommMethodLOVRequest) ParameterValue(parameterValue []string) ApiGetHotelContactCommMethodLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHotelContactCommMethodLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHotelContactCommMethodLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelContactCommMethodLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelContactCommMethodLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelContactCommMethodLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelContactCommMethodLOVExecute(r)
}

/*
GetHotelContactCommMethodLOV Fetch List Of Values for Hotel Contact Comm Method

 <p><strong>OperationId:</strong>getHotelContactCommMethodLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactType Value of the parameter 'contactType' which is required to fetch HotelContactCommMethod LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HotelContactCommMethod LOV
 @return ApiGetHotelContactCommMethodLOVRequest
*/
func (a *LOVApiService) GetHotelContactCommMethodLOV(ctx context.Context, contactType string, hotelId string) ApiGetHotelContactCommMethodLOVRequest {
	return ApiGetHotelContactCommMethodLOVRequest{
		ApiService: a,
		ctx: ctx,
		contactType: contactType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelContactCommMethodLOVExecute(r ApiGetHotelContactCommMethodLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelContactCommMethodLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/contactType/{contactType}/hotelContactCommMethod"
	localVarPath = strings.Replace(localVarPath, "{"+"contactType"+"}", url.PathEscape(parameterValueToString(r.contactType, "contactType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.contactType) < 1 {
		return localVarReturnValue, nil, reportError("contactType must have at least 1 elements")
	}
	if strlen(r.contactType) > 2000 {
		return localVarReturnValue, nil, reportError("contactType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelEventTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelEventTypesLOVRequest) Authorization(authorization string) ApiGetHotelEventTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelEventTypesLOVRequest) XAppKey(xAppKey string) ApiGetHotelEventTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelEventTypesLOVRequest) XHotelid(xHotelid string) ApiGetHotelEventTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHotelEventTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHotelEventTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHotelEventTypesLOVRequest) ParameterName(parameterName []string) ApiGetHotelEventTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHotelEventTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetHotelEventTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHotelEventTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHotelEventTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelEventTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelEventTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelEventTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelEventTypesLOVExecute(r)
}

/*
GetHotelEventTypesLOV Fetch List Of Values for Hotel Event Types

 <p><strong>OperationId:</strong>getHotelEventTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HotelEventTypes LOV
 @return ApiGetHotelEventTypesLOVRequest
*/
func (a *LOVApiService) GetHotelEventTypesLOV(ctx context.Context, hotelId string) ApiGetHotelEventTypesLOVRequest {
	return ApiGetHotelEventTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelEventTypesLOVExecute(r ApiGetHotelEventTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelEventTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hotelEventTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelInterfaceDataLineTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	logo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelInterfaceDataLineTypesLOVRequest) Authorization(authorization string) ApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelInterfaceDataLineTypesLOVRequest) XAppKey(xAppKey string) ApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelInterfaceDataLineTypesLOVRequest) XHotelid(xHotelid string) ApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHotelInterfaceDataLineTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHotelInterfaceDataLineTypesLOVRequest) ParameterName(parameterName []string) ApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHotelInterfaceDataLineTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHotelInterfaceDataLineTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelInterfaceDataLineTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelInterfaceDataLineTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelInterfaceDataLineTypesLOVExecute(r)
}

/*
GetHotelInterfaceDataLineTypesLOV Fetch List Of Values for Hotel Interface Data Line Types

 <p><strong>OperationId:</strong>getHotelInterfaceDataLineTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param logo Value of the parameter 'logo' which is required to fetch HotelInterfaceDataLineTypes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HotelInterfaceDataLineTypes LOV
 @return ApiGetHotelInterfaceDataLineTypesLOVRequest
*/
func (a *LOVApiService) GetHotelInterfaceDataLineTypesLOV(ctx context.Context, logo string, hotelId string) ApiGetHotelInterfaceDataLineTypesLOVRequest {
	return ApiGetHotelInterfaceDataLineTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		logo: logo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelInterfaceDataLineTypesLOVExecute(r ApiGetHotelInterfaceDataLineTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelInterfaceDataLineTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/logo/{logo}/hotelInterfaceDataLineTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"logo"+"}", url.PathEscape(parameterValueToString(r.logo, "logo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.logo) < 1 {
		return localVarReturnValue, nil, reportError("logo must have at least 1 elements")
	}
	if strlen(r.logo) > 2000 {
		return localVarReturnValue, nil, reportError("logo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelInterfaceImportRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelInterfaceImportRoomsLOVRequest) Authorization(authorization string) ApiGetHotelInterfaceImportRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelInterfaceImportRoomsLOVRequest) XAppKey(xAppKey string) ApiGetHotelInterfaceImportRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelInterfaceImportRoomsLOVRequest) XHotelid(xHotelid string) ApiGetHotelInterfaceImportRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHotelInterfaceImportRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHotelInterfaceImportRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHotelInterfaceImportRoomsLOVRequest) ParameterName(parameterName []string) ApiGetHotelInterfaceImportRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHotelInterfaceImportRoomsLOVRequest) ParameterValue(parameterValue []string) ApiGetHotelInterfaceImportRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHotelInterfaceImportRoomsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHotelInterfaceImportRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelInterfaceImportRoomsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelInterfaceImportRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelInterfaceImportRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelInterfaceImportRoomsLOVExecute(r)
}

/*
GetHotelInterfaceImportRoomsLOV Fetch List Of Values for Hotel Interface Import Rooms

 <p><strong>OperationId:</strong>getHotelInterfaceImportRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HotelInterfaceImportRooms LOV
 @return ApiGetHotelInterfaceImportRoomsLOVRequest
*/
func (a *LOVApiService) GetHotelInterfaceImportRoomsLOV(ctx context.Context, hotelId string) ApiGetHotelInterfaceImportRoomsLOVRequest {
	return ApiGetHotelInterfaceImportRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelInterfaceImportRoomsLOVExecute(r ApiGetHotelInterfaceImportRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelInterfaceImportRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hotelInterfaceImportRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelRateTierLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelRateTierLOVRequest) Authorization(authorization string) ApiGetHotelRateTierLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelRateTierLOVRequest) XAppKey(xAppKey string) ApiGetHotelRateTierLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelRateTierLOVRequest) XHotelid(xHotelid string) ApiGetHotelRateTierLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHotelRateTierLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHotelRateTierLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHotelRateTierLOVRequest) ParameterName(parameterName []string) ApiGetHotelRateTierLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHotelRateTierLOVRequest) ParameterValue(parameterValue []string) ApiGetHotelRateTierLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHotelRateTierLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHotelRateTierLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelRateTierLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelRateTierLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelRateTierLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelRateTierLOVExecute(r)
}

/*
GetHotelRateTierLOV Fetch List Of Values for Hotel Rate Tier

 <p><strong>OperationId:</strong>getHotelRateTierLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HotelRateTier LOV
 @return ApiGetHotelRateTierLOVRequest
*/
func (a *LOVApiService) GetHotelRateTierLOV(ctx context.Context, hotelId string) ApiGetHotelRateTierLOVRequest {
	return ApiGetHotelRateTierLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelRateTierLOVExecute(r ApiGetHotelRateTierLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelRateTierLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hotelRateTier"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelsForARProfileLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelsForARProfileLOVRequest) Authorization(authorization string) ApiGetHotelsForARProfileLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelsForARProfileLOVRequest) XAppKey(xAppKey string) ApiGetHotelsForARProfileLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelsForARProfileLOVRequest) XHotelid(xHotelid string) ApiGetHotelsForARProfileLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHotelsForARProfileLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHotelsForARProfileLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHotelsForARProfileLOVRequest) ParameterName(parameterName []string) ApiGetHotelsForARProfileLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHotelsForARProfileLOVRequest) ParameterValue(parameterValue []string) ApiGetHotelsForARProfileLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHotelsForARProfileLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHotelsForARProfileLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelsForARProfileLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelsForARProfileLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelsForARProfileLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelsForARProfileLOVExecute(r)
}

/*
GetHotelsForARProfileLOV Fetch List Of Values for Hotels For ARProfile

 <p><strong>OperationId:</strong>getHotelsForARProfileLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch HotelsForARProfile LOV
 @return ApiGetHotelsForARProfileLOVRequest
*/
func (a *LOVApiService) GetHotelsForARProfileLOV(ctx context.Context, profileId string) ApiGetHotelsForARProfileLOVRequest {
	return ApiGetHotelsForARProfileLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelsForARProfileLOVExecute(r ApiGetHotelsForARProfileLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelsForARProfileLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/profiles/{profileId}/hotelsForARProfile"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHotelsForSnCLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	cateringEvents string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHotelsForSnCLOVRequest) Authorization(authorization string) ApiGetHotelsForSnCLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHotelsForSnCLOVRequest) XAppKey(xAppKey string) ApiGetHotelsForSnCLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHotelsForSnCLOVRequest) XHotelid(xHotelid string) ApiGetHotelsForSnCLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHotelsForSnCLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHotelsForSnCLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHotelsForSnCLOVRequest) ParameterName(parameterName []string) ApiGetHotelsForSnCLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHotelsForSnCLOVRequest) ParameterValue(parameterValue []string) ApiGetHotelsForSnCLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHotelsForSnCLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHotelsForSnCLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHotelsForSnCLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHotelsForSnCLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHotelsForSnCLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelsForSnCLOVExecute(r)
}

/*
GetHotelsForSnCLOV Fetch List Of Values for Hotels For Sn C

 <p><strong>OperationId:</strong>getHotelsForSnCLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringEvents Value of the parameter 'cateringEvents' which is required to fetch HotelsForSnC LOV
 @return ApiGetHotelsForSnCLOVRequest
*/
func (a *LOVApiService) GetHotelsForSnCLOV(ctx context.Context, cateringEvents string) ApiGetHotelsForSnCLOVRequest {
	return ApiGetHotelsForSnCLOVRequest{
		ApiService: a,
		ctx: ctx,
		cateringEvents: cateringEvents,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelsForSnCLOVExecute(r ApiGetHotelsForSnCLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelsForSnCLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/cateringEvents/{cateringEvents}/hotelsForSnC"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringEvents"+"}", url.PathEscape(parameterValueToString(r.cateringEvents, "cateringEvents")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringEvents) < 1 {
		return localVarReturnValue, nil, reportError("cateringEvents must have at least 1 elements")
	}
	if strlen(r.cateringEvents) > 2000 {
		return localVarReturnValue, nil, reportError("cateringEvents must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHouseKeepingRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHouseKeepingRoomsLOVRequest) Authorization(authorization string) ApiGetHouseKeepingRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHouseKeepingRoomsLOVRequest) XAppKey(xAppKey string) ApiGetHouseKeepingRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHouseKeepingRoomsLOVRequest) XHotelid(xHotelid string) ApiGetHouseKeepingRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHouseKeepingRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHouseKeepingRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHouseKeepingRoomsLOVRequest) ParameterName(parameterName []string) ApiGetHouseKeepingRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHouseKeepingRoomsLOVRequest) ParameterValue(parameterValue []string) ApiGetHouseKeepingRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHouseKeepingRoomsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHouseKeepingRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHouseKeepingRoomsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHouseKeepingRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHouseKeepingRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHouseKeepingRoomsLOVExecute(r)
}

/*
GetHouseKeepingRoomsLOV Fetch List Of Values for House Keeping Rooms

 <p><strong>OperationId:</strong>getHouseKeepingRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HouseKeepingRooms LOV
 @return ApiGetHouseKeepingRoomsLOVRequest
*/
func (a *LOVApiService) GetHouseKeepingRoomsLOV(ctx context.Context, hotelId string) ApiGetHouseKeepingRoomsLOVRequest {
	return ApiGetHouseKeepingRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHouseKeepingRoomsLOVExecute(r ApiGetHouseKeepingRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHouseKeepingRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/houseKeepingRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHouseKeepingSectionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHouseKeepingSectionsLOVRequest) Authorization(authorization string) ApiGetHouseKeepingSectionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHouseKeepingSectionsLOVRequest) XAppKey(xAppKey string) ApiGetHouseKeepingSectionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHouseKeepingSectionsLOVRequest) XHotelid(xHotelid string) ApiGetHouseKeepingSectionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHouseKeepingSectionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHouseKeepingSectionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHouseKeepingSectionsLOVRequest) ParameterName(parameterName []string) ApiGetHouseKeepingSectionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHouseKeepingSectionsLOVRequest) ParameterValue(parameterValue []string) ApiGetHouseKeepingSectionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHouseKeepingSectionsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHouseKeepingSectionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHouseKeepingSectionsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHouseKeepingSectionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHouseKeepingSectionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHouseKeepingSectionsLOVExecute(r)
}

/*
GetHouseKeepingSectionsLOV Fetch List Of Values for House Keeping Sections

 <p><strong>OperationId:</strong>getHouseKeepingSectionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HouseKeepingSections LOV
 @return ApiGetHouseKeepingSectionsLOVRequest
*/
func (a *LOVApiService) GetHouseKeepingSectionsLOV(ctx context.Context, hotelId string) ApiGetHouseKeepingSectionsLOVRequest {
	return ApiGetHouseKeepingSectionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHouseKeepingSectionsLOVExecute(r ApiGetHouseKeepingSectionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHouseKeepingSectionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/houseKeepingSections"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHousekeepingCreditRulesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetHousekeepingCreditRulesLOVRequest) Authorization(authorization string) ApiGetHousekeepingCreditRulesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetHousekeepingCreditRulesLOVRequest) XAppKey(xAppKey string) ApiGetHousekeepingCreditRulesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetHousekeepingCreditRulesLOVRequest) XHotelid(xHotelid string) ApiGetHousekeepingCreditRulesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetHousekeepingCreditRulesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetHousekeepingCreditRulesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetHousekeepingCreditRulesLOVRequest) ParameterName(parameterName []string) ApiGetHousekeepingCreditRulesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetHousekeepingCreditRulesLOVRequest) ParameterValue(parameterValue []string) ApiGetHousekeepingCreditRulesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetHousekeepingCreditRulesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetHousekeepingCreditRulesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetHousekeepingCreditRulesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetHousekeepingCreditRulesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetHousekeepingCreditRulesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHousekeepingCreditRulesLOVExecute(r)
}

/*
GetHousekeepingCreditRulesLOV Fetch List Of Values for Housekeeping Credit Rules

 <p><strong>OperationId:</strong>getHousekeepingCreditRulesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HousekeepingCreditRules LOV
 @return ApiGetHousekeepingCreditRulesLOVRequest
*/
func (a *LOVApiService) GetHousekeepingCreditRulesLOV(ctx context.Context, hotelId string) ApiGetHousekeepingCreditRulesLOVRequest {
	return ApiGetHousekeepingCreditRulesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHousekeepingCreditRulesLOVExecute(r ApiGetHousekeepingCreditRulesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHousekeepingCreditRulesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/housekeepingCreditRules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIfcRightsViewLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	category string
	ifcId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetIfcRightsViewLOVRequest) Authorization(authorization string) ApiGetIfcRightsViewLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetIfcRightsViewLOVRequest) XAppKey(xAppKey string) ApiGetIfcRightsViewLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetIfcRightsViewLOVRequest) XHotelid(xHotelid string) ApiGetIfcRightsViewLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetIfcRightsViewLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetIfcRightsViewLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetIfcRightsViewLOVRequest) ParameterName(parameterName []string) ApiGetIfcRightsViewLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetIfcRightsViewLOVRequest) ParameterValue(parameterValue []string) ApiGetIfcRightsViewLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetIfcRightsViewLOVRequest) XExternalsystem(xExternalsystem string) ApiGetIfcRightsViewLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetIfcRightsViewLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetIfcRightsViewLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetIfcRightsViewLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetIfcRightsViewLOVExecute(r)
}

/*
GetIfcRightsViewLOV Fetch List Of Values for Ifc Rights View

 <p><strong>OperationId:</strong>getIfcRightsViewLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param category Value of the parameter 'category' which is required to fetch IfcRightsView LOV
 @param ifcId Value of the parameter 'ifcId' which is required to fetch IfcRightsView LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch IfcRightsView LOV
 @return ApiGetIfcRightsViewLOVRequest
*/
func (a *LOVApiService) GetIfcRightsViewLOV(ctx context.Context, category string, ifcId string, hotelId string) ApiGetIfcRightsViewLOVRequest {
	return ApiGetIfcRightsViewLOVRequest{
		ApiService: a,
		ctx: ctx,
		category: category,
		ifcId: ifcId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetIfcRightsViewLOVExecute(r ApiGetIfcRightsViewLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetIfcRightsViewLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/ifcId/{ifcId}/category/{category}/ifcRightsView"
	localVarPath = strings.Replace(localVarPath, "{"+"category"+"}", url.PathEscape(parameterValueToString(r.category, "category")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ifcId"+"}", url.PathEscape(parameterValueToString(r.ifcId, "ifcId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.category) < 1 {
		return localVarReturnValue, nil, reportError("category must have at least 1 elements")
	}
	if strlen(r.category) > 2000 {
		return localVarReturnValue, nil, reportError("category must have less than 2000 elements")
	}
	if strlen(r.ifcId) < 1 {
		return localVarReturnValue, nil, reportError("ifcId must have at least 1 elements")
	}
	if strlen(r.ifcId) > 2000 {
		return localVarReturnValue, nil, reportError("ifcId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImbalanceVerificationTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetImbalanceVerificationTypesLOVRequest) Authorization(authorization string) ApiGetImbalanceVerificationTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetImbalanceVerificationTypesLOVRequest) XAppKey(xAppKey string) ApiGetImbalanceVerificationTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetImbalanceVerificationTypesLOVRequest) XHotelid(xHotelid string) ApiGetImbalanceVerificationTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetImbalanceVerificationTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetImbalanceVerificationTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetImbalanceVerificationTypesLOVRequest) ParameterName(parameterName []string) ApiGetImbalanceVerificationTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetImbalanceVerificationTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetImbalanceVerificationTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetImbalanceVerificationTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetImbalanceVerificationTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetImbalanceVerificationTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetImbalanceVerificationTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetImbalanceVerificationTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetImbalanceVerificationTypesLOVExecute(r)
}

/*
GetImbalanceVerificationTypesLOV Fetch List Of Values for Imbalance Verification Types

 <p><strong>OperationId:</strong>getImbalanceVerificationTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ImbalanceVerificationTypes LOV
 @return ApiGetImbalanceVerificationTypesLOVRequest
*/
func (a *LOVApiService) GetImbalanceVerificationTypesLOV(ctx context.Context, hotelId string) ApiGetImbalanceVerificationTypesLOVRequest {
	return ApiGetImbalanceVerificationTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetImbalanceVerificationTypesLOVExecute(r ApiGetImbalanceVerificationTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetImbalanceVerificationTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/imbalanceVerificationTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceAutoBalanceLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceAutoBalanceLOVRequest) Authorization(authorization string) ApiGetInterfaceAutoBalanceLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceAutoBalanceLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceAutoBalanceLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceAutoBalanceLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceAutoBalanceLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceAutoBalanceLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceAutoBalanceLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceAutoBalanceLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceAutoBalanceLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceAutoBalanceLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceAutoBalanceLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceAutoBalanceLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceAutoBalanceLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceAutoBalanceLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceAutoBalanceLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceAutoBalanceLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceAutoBalanceLOVExecute(r)
}

/*
GetInterfaceAutoBalanceLOV Fetch List Of Values for Interface Auto Balance

 <p><strong>OperationId:</strong>getInterfaceAutoBalanceLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceAutoBalance LOV
 @return ApiGetInterfaceAutoBalanceLOVRequest
*/
func (a *LOVApiService) GetInterfaceAutoBalanceLOV(ctx context.Context, hotelId string) ApiGetInterfaceAutoBalanceLOVRequest {
	return ApiGetInterfaceAutoBalanceLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceAutoBalanceLOVExecute(r ApiGetInterfaceAutoBalanceLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceAutoBalanceLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceAutoBalance"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceDataRequestMarketCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceDataRequestMarketCodeLOVRequest) Authorization(authorization string) ApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceDataRequestMarketCodeLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceDataRequestMarketCodeLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceDataRequestMarketCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceDataRequestMarketCodeLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceDataRequestMarketCodeLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceDataRequestMarketCodeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceDataRequestMarketCodeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceDataRequestMarketCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceDataRequestMarketCodeLOVExecute(r)
}

/*
GetInterfaceDataRequestMarketCodeLOV Fetch List Of Values for Interface Data Request Market Code

 <p><strong>OperationId:</strong>getInterfaceDataRequestMarketCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceDataRequestMarketCode LOV
 @return ApiGetInterfaceDataRequestMarketCodeLOVRequest
*/
func (a *LOVApiService) GetInterfaceDataRequestMarketCodeLOV(ctx context.Context, hotelId string) ApiGetInterfaceDataRequestMarketCodeLOVRequest {
	return ApiGetInterfaceDataRequestMarketCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceDataRequestMarketCodeLOVExecute(r ApiGetInterfaceDataRequestMarketCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceDataRequestMarketCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceDataRequestMarketCode"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceDataRequestMarketGroupLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceDataRequestMarketGroupLOVRequest) Authorization(authorization string) ApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceDataRequestMarketGroupLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceDataRequestMarketGroupLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceDataRequestMarketGroupLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceDataRequestMarketGroupLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceDataRequestMarketGroupLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceDataRequestMarketGroupLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceDataRequestMarketGroupLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceDataRequestMarketGroupLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceDataRequestMarketGroupLOVExecute(r)
}

/*
GetInterfaceDataRequestMarketGroupLOV Fetch List Of Values for Interface Data Request Market Group

 <p><strong>OperationId:</strong>getInterfaceDataRequestMarketGroupLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceDataRequestMarketGroup LOV
 @return ApiGetInterfaceDataRequestMarketGroupLOVRequest
*/
func (a *LOVApiService) GetInterfaceDataRequestMarketGroupLOV(ctx context.Context, hotelId string) ApiGetInterfaceDataRequestMarketGroupLOVRequest {
	return ApiGetInterfaceDataRequestMarketGroupLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceDataRequestMarketGroupLOVExecute(r ApiGetInterfaceDataRequestMarketGroupLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceDataRequestMarketGroupLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceDataRequestMarketGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceDataRequestRoomClassLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceDataRequestRoomClassLOVRequest) Authorization(authorization string) ApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceDataRequestRoomClassLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceDataRequestRoomClassLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceDataRequestRoomClassLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceDataRequestRoomClassLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceDataRequestRoomClassLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceDataRequestRoomClassLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceDataRequestRoomClassLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceDataRequestRoomClassLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceDataRequestRoomClassLOVExecute(r)
}

/*
GetInterfaceDataRequestRoomClassLOV Fetch List Of Values for Interface Data Request Room Class

 <p><strong>OperationId:</strong>getInterfaceDataRequestRoomClassLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceDataRequestRoomClass LOV
 @return ApiGetInterfaceDataRequestRoomClassLOVRequest
*/
func (a *LOVApiService) GetInterfaceDataRequestRoomClassLOV(ctx context.Context, hotelId string) ApiGetInterfaceDataRequestRoomClassLOVRequest {
	return ApiGetInterfaceDataRequestRoomClassLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceDataRequestRoomClassLOVExecute(r ApiGetInterfaceDataRequestRoomClassLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceDataRequestRoomClassLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceDataRequestRoomClass"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceDataRequestRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceDataRequestRoomTypesLOVRequest) Authorization(authorization string) ApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceDataRequestRoomTypesLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceDataRequestRoomTypesLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceDataRequestRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceDataRequestRoomTypesLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceDataRequestRoomTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceDataRequestRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceDataRequestRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceDataRequestRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceDataRequestRoomTypesLOVExecute(r)
}

/*
GetInterfaceDataRequestRoomTypesLOV Fetch List Of Values for Interface Data Request Room Types

 <p><strong>OperationId:</strong>getInterfaceDataRequestRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceDataRequestRoomTypes LOV
 @return ApiGetInterfaceDataRequestRoomTypesLOVRequest
*/
func (a *LOVApiService) GetInterfaceDataRequestRoomTypesLOV(ctx context.Context, hotelId string) ApiGetInterfaceDataRequestRoomTypesLOVRequest {
	return ApiGetInterfaceDataRequestRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceDataRequestRoomTypesLOVExecute(r ApiGetInterfaceDataRequestRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceDataRequestRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceDataRequestRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceDataRequestSourceCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceDataRequestSourceCodeLOVRequest) Authorization(authorization string) ApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceDataRequestSourceCodeLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceDataRequestSourceCodeLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceDataRequestSourceCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceDataRequestSourceCodeLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceDataRequestSourceCodeLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceDataRequestSourceCodeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceDataRequestSourceCodeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceDataRequestSourceCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceDataRequestSourceCodeLOVExecute(r)
}

/*
GetInterfaceDataRequestSourceCodeLOV Fetch List Of Values for Interface Data Request Source Code

 <p><strong>OperationId:</strong>getInterfaceDataRequestSourceCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceDataRequestSourceCode LOV
 @return ApiGetInterfaceDataRequestSourceCodeLOVRequest
*/
func (a *LOVApiService) GetInterfaceDataRequestSourceCodeLOV(ctx context.Context, hotelId string) ApiGetInterfaceDataRequestSourceCodeLOVRequest {
	return ApiGetInterfaceDataRequestSourceCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceDataRequestSourceCodeLOVExecute(r ApiGetInterfaceDataRequestSourceCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceDataRequestSourceCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceDataRequestSourceCode"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceDataRequestSourceGroupLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceDataRequestSourceGroupLOVRequest) Authorization(authorization string) ApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceDataRequestSourceGroupLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceDataRequestSourceGroupLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceDataRequestSourceGroupLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceDataRequestSourceGroupLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceDataRequestSourceGroupLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceDataRequestSourceGroupLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceDataRequestSourceGroupLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceDataRequestSourceGroupLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceDataRequestSourceGroupLOVExecute(r)
}

/*
GetInterfaceDataRequestSourceGroupLOV Fetch List Of Values for Interface Data Request Source Group

 <p><strong>OperationId:</strong>getInterfaceDataRequestSourceGroupLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceDataRequestSourceGroup LOV
 @return ApiGetInterfaceDataRequestSourceGroupLOVRequest
*/
func (a *LOVApiService) GetInterfaceDataRequestSourceGroupLOV(ctx context.Context, hotelId string) ApiGetInterfaceDataRequestSourceGroupLOVRequest {
	return ApiGetInterfaceDataRequestSourceGroupLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceDataRequestSourceGroupLOVExecute(r ApiGetInterfaceDataRequestSourceGroupLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceDataRequestSourceGroupLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceDataRequestSourceGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfacePseudoRoomLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfacePseudoRoomLOVRequest) Authorization(authorization string) ApiGetInterfacePseudoRoomLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfacePseudoRoomLOVRequest) XAppKey(xAppKey string) ApiGetInterfacePseudoRoomLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfacePseudoRoomLOVRequest) XHotelid(xHotelid string) ApiGetInterfacePseudoRoomLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfacePseudoRoomLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfacePseudoRoomLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfacePseudoRoomLOVRequest) ParameterName(parameterName []string) ApiGetInterfacePseudoRoomLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfacePseudoRoomLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfacePseudoRoomLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfacePseudoRoomLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfacePseudoRoomLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfacePseudoRoomLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfacePseudoRoomLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfacePseudoRoomLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfacePseudoRoomLOVExecute(r)
}

/*
GetInterfacePseudoRoomLOV Fetch List Of Values for Interface Pseudo Room

 <p><strong>OperationId:</strong>getInterfacePseudoRoomLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfacePseudoRoom LOV
 @return ApiGetInterfacePseudoRoomLOVRequest
*/
func (a *LOVApiService) GetInterfacePseudoRoomLOV(ctx context.Context, hotelId string) ApiGetInterfacePseudoRoomLOVRequest {
	return ApiGetInterfacePseudoRoomLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfacePseudoRoomLOVExecute(r ApiGetInterfacePseudoRoomLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfacePseudoRoomLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfacePseudoRoom"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceResyncFunctionSpaceLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceResyncFunctionSpaceLOVRequest) Authorization(authorization string) ApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceResyncFunctionSpaceLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceResyncFunctionSpaceLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceResyncFunctionSpaceLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceResyncFunctionSpaceLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceResyncFunctionSpaceLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceResyncFunctionSpaceLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceResyncFunctionSpaceLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceResyncFunctionSpaceLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceResyncFunctionSpaceLOVExecute(r)
}

/*
GetInterfaceResyncFunctionSpaceLOV Fetch List Of Values for Interface Resync Function Space

 <p><strong>OperationId:</strong>getInterfaceResyncFunctionSpaceLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceResyncFunctionSpace LOV
 @return ApiGetInterfaceResyncFunctionSpaceLOVRequest
*/
func (a *LOVApiService) GetInterfaceResyncFunctionSpaceLOV(ctx context.Context, hotelId string) ApiGetInterfaceResyncFunctionSpaceLOVRequest {
	return ApiGetInterfaceResyncFunctionSpaceLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceResyncFunctionSpaceLOVExecute(r ApiGetInterfaceResyncFunctionSpaceLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceResyncFunctionSpaceLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceResyncFunctionSpace"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceResyncOwnerContractLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceResyncOwnerContractLOVRequest) Authorization(authorization string) ApiGetInterfaceResyncOwnerContractLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceResyncOwnerContractLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceResyncOwnerContractLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceResyncOwnerContractLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceResyncOwnerContractLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceResyncOwnerContractLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceResyncOwnerContractLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceResyncOwnerContractLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceResyncOwnerContractLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceResyncOwnerContractLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceResyncOwnerContractLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceResyncOwnerContractLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceResyncOwnerContractLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceResyncOwnerContractLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceResyncOwnerContractLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceResyncOwnerContractLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceResyncOwnerContractLOVExecute(r)
}

/*
GetInterfaceResyncOwnerContractLOV Fetch List Of Values for Interface Resync Owner Contract

 <p><strong>OperationId:</strong>getInterfaceResyncOwnerContractLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceResyncOwnerContract LOV
 @return ApiGetInterfaceResyncOwnerContractLOVRequest
*/
func (a *LOVApiService) GetInterfaceResyncOwnerContractLOV(ctx context.Context, hotelId string) ApiGetInterfaceResyncOwnerContractLOVRequest {
	return ApiGetInterfaceResyncOwnerContractLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceResyncOwnerContractLOVExecute(r ApiGetInterfaceResyncOwnerContractLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceResyncOwnerContractLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceResyncOwnerContract"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceResyncOwnerContractRoomLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceResyncOwnerContractRoomLOVRequest) Authorization(authorization string) ApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceResyncOwnerContractRoomLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceResyncOwnerContractRoomLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceResyncOwnerContractRoomLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceResyncOwnerContractRoomLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceResyncOwnerContractRoomLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceResyncOwnerContractRoomLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceResyncOwnerContractRoomLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceResyncOwnerContractRoomLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceResyncOwnerContractRoomLOVExecute(r)
}

/*
GetInterfaceResyncOwnerContractRoomLOV Fetch List Of Values for Interface Resync Owner Contract Room

 <p><strong>OperationId:</strong>getInterfaceResyncOwnerContractRoomLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceResyncOwnerContractRoom LOV
 @return ApiGetInterfaceResyncOwnerContractRoomLOVRequest
*/
func (a *LOVApiService) GetInterfaceResyncOwnerContractRoomLOV(ctx context.Context, hotelId string) ApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	return ApiGetInterfaceResyncOwnerContractRoomLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceResyncOwnerContractRoomLOVExecute(r ApiGetInterfaceResyncOwnerContractRoomLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceResyncOwnerContractRoomLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceResyncOwnerContractRoom"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceResyncProductsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceResyncProductsLOVRequest) Authorization(authorization string) ApiGetInterfaceResyncProductsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceResyncProductsLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceResyncProductsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceResyncProductsLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceResyncProductsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceResyncProductsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceResyncProductsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceResyncProductsLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceResyncProductsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceResyncProductsLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceResyncProductsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceResyncProductsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceResyncProductsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceResyncProductsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceResyncProductsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceResyncProductsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceResyncProductsLOVExecute(r)
}

/*
GetInterfaceResyncProductsLOV Fetch List Of Values for Interface Resync Products

 <p><strong>OperationId:</strong>getInterfaceResyncProductsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceResyncProducts LOV
 @return ApiGetInterfaceResyncProductsLOVRequest
*/
func (a *LOVApiService) GetInterfaceResyncProductsLOV(ctx context.Context, hotelId string) ApiGetInterfaceResyncProductsLOVRequest {
	return ApiGetInterfaceResyncProductsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceResyncProductsLOVExecute(r ApiGetInterfaceResyncProductsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceResyncProductsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceResyncProducts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceRevenueCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	logo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceRevenueCodeLOVRequest) Authorization(authorization string) ApiGetInterfaceRevenueCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceRevenueCodeLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceRevenueCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceRevenueCodeLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceRevenueCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceRevenueCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceRevenueCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceRevenueCodeLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceRevenueCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceRevenueCodeLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceRevenueCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceRevenueCodeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceRevenueCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceRevenueCodeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceRevenueCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceRevenueCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceRevenueCodeLOVExecute(r)
}

/*
GetInterfaceRevenueCodeLOV Fetch List Of Values for Interface Revenue Code

 <p><strong>OperationId:</strong>getInterfaceRevenueCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param logo Value of the parameter 'logo' which is required to fetch InterfaceRevenueCode LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceRevenueCode LOV
 @return ApiGetInterfaceRevenueCodeLOVRequest
*/
func (a *LOVApiService) GetInterfaceRevenueCodeLOV(ctx context.Context, logo string, hotelId string) ApiGetInterfaceRevenueCodeLOVRequest {
	return ApiGetInterfaceRevenueCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		logo: logo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceRevenueCodeLOVExecute(r ApiGetInterfaceRevenueCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceRevenueCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/logo/{logo}/interfaceRevenueCode"
	localVarPath = strings.Replace(localVarPath, "{"+"logo"+"}", url.PathEscape(parameterValueToString(r.logo, "logo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.logo) < 1 {
		return localVarReturnValue, nil, reportError("logo must have at least 1 elements")
	}
	if strlen(r.logo) > 2000 {
		return localVarReturnValue, nil, reportError("logo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceTabColumnsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	tableName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceTabColumnsLOVRequest) Authorization(authorization string) ApiGetInterfaceTabColumnsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceTabColumnsLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceTabColumnsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceTabColumnsLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceTabColumnsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceTabColumnsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceTabColumnsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceTabColumnsLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceTabColumnsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceTabColumnsLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceTabColumnsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceTabColumnsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceTabColumnsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceTabColumnsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceTabColumnsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceTabColumnsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceTabColumnsLOVExecute(r)
}

/*
GetInterfaceTabColumnsLOV Fetch List Of Values for Interface Tab Columns

 <p><strong>OperationId:</strong>getInterfaceTabColumnsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Value of the parameter 'tableName' which is required to fetch InterfaceTabColumns LOV
 @return ApiGetInterfaceTabColumnsLOVRequest
*/
func (a *LOVApiService) GetInterfaceTabColumnsLOV(ctx context.Context, tableName string) ApiGetInterfaceTabColumnsLOVRequest {
	return ApiGetInterfaceTabColumnsLOVRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceTabColumnsLOVExecute(r ApiGetInterfaceTabColumnsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceTabColumnsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/tableName/{tableName}/interfaceTabColumns"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.tableName) < 1 {
		return localVarReturnValue, nil, reportError("tableName must have at least 1 elements")
	}
	if strlen(r.tableName) > 2000 {
		return localVarReturnValue, nil, reportError("tableName must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceTrxCodesAllChargesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceTrxCodesAllChargesLOVRequest) Authorization(authorization string) ApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceTrxCodesAllChargesLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceTrxCodesAllChargesLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceTrxCodesAllChargesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceTrxCodesAllChargesLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceTrxCodesAllChargesLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceTrxCodesAllChargesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceTrxCodesAllChargesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceTrxCodesAllChargesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceTrxCodesAllChargesLOVExecute(r)
}

/*
GetInterfaceTrxCodesAllChargesLOV Fetch List Of Values for Interface Trx Codes All Charges

 <p><strong>OperationId:</strong>getInterfaceTrxCodesAllChargesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceTrxCodesAllCharges LOV
 @return ApiGetInterfaceTrxCodesAllChargesLOVRequest
*/
func (a *LOVApiService) GetInterfaceTrxCodesAllChargesLOV(ctx context.Context, hotelId string) ApiGetInterfaceTrxCodesAllChargesLOVRequest {
	return ApiGetInterfaceTrxCodesAllChargesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceTrxCodesAllChargesLOVExecute(r ApiGetInterfaceTrxCodesAllChargesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceTrxCodesAllChargesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceTrxCodesAllCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInterfaceTrxCodesMinibarLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInterfaceTrxCodesMinibarLOVRequest) Authorization(authorization string) ApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInterfaceTrxCodesMinibarLOVRequest) XAppKey(xAppKey string) ApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInterfaceTrxCodesMinibarLOVRequest) XHotelid(xHotelid string) ApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInterfaceTrxCodesMinibarLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInterfaceTrxCodesMinibarLOVRequest) ParameterName(parameterName []string) ApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInterfaceTrxCodesMinibarLOVRequest) ParameterValue(parameterValue []string) ApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInterfaceTrxCodesMinibarLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInterfaceTrxCodesMinibarLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInterfaceTrxCodesMinibarLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceTrxCodesMinibarLOVExecute(r)
}

/*
GetInterfaceTrxCodesMinibarLOV Fetch List Of Values for Interface Trx Codes Minibar

 <p><strong>OperationId:</strong>getInterfaceTrxCodesMinibarLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceTrxCodesMinibar LOV
 @return ApiGetInterfaceTrxCodesMinibarLOVRequest
*/
func (a *LOVApiService) GetInterfaceTrxCodesMinibarLOV(ctx context.Context, hotelId string) ApiGetInterfaceTrxCodesMinibarLOVRequest {
	return ApiGetInterfaceTrxCodesMinibarLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceTrxCodesMinibarLOVExecute(r ApiGetInterfaceTrxCodesMinibarLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceTrxCodesMinibarLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceTrxCodesMinibar"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvItemsClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInvItemsClassesLOVRequest) Authorization(authorization string) ApiGetInvItemsClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInvItemsClassesLOVRequest) XAppKey(xAppKey string) ApiGetInvItemsClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInvItemsClassesLOVRequest) XHotelid(xHotelid string) ApiGetInvItemsClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInvItemsClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInvItemsClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInvItemsClassesLOVRequest) ParameterName(parameterName []string) ApiGetInvItemsClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInvItemsClassesLOVRequest) ParameterValue(parameterValue []string) ApiGetInvItemsClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInvItemsClassesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInvItemsClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInvItemsClassesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInvItemsClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInvItemsClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInvItemsClassesLOVExecute(r)
}

/*
GetInvItemsClassesLOV Fetch List Of Values for Inv Items Classes

 <p><strong>OperationId:</strong>getInvItemsClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InvItemsClasses LOV
 @return ApiGetInvItemsClassesLOVRequest
*/
func (a *LOVApiService) GetInvItemsClassesLOV(ctx context.Context, hotelId string) ApiGetInvItemsClassesLOVRequest {
	return ApiGetInvItemsClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInvItemsClassesLOVExecute(r ApiGetInvItemsClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInvItemsClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/invItemsClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvItemsPoolsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInvItemsPoolsLOVRequest) Authorization(authorization string) ApiGetInvItemsPoolsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInvItemsPoolsLOVRequest) XAppKey(xAppKey string) ApiGetInvItemsPoolsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInvItemsPoolsLOVRequest) XHotelid(xHotelid string) ApiGetInvItemsPoolsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInvItemsPoolsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInvItemsPoolsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInvItemsPoolsLOVRequest) ParameterName(parameterName []string) ApiGetInvItemsPoolsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInvItemsPoolsLOVRequest) ParameterValue(parameterValue []string) ApiGetInvItemsPoolsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInvItemsPoolsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInvItemsPoolsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInvItemsPoolsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInvItemsPoolsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInvItemsPoolsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInvItemsPoolsLOVExecute(r)
}

/*
GetInvItemsPoolsLOV Fetch List Of Values for Inv Items Pools

 <p><strong>OperationId:</strong>getInvItemsPoolsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InvItemsPools LOV
 @return ApiGetInvItemsPoolsLOVRequest
*/
func (a *LOVApiService) GetInvItemsPoolsLOV(ctx context.Context, hotelId string) ApiGetInvItemsPoolsLOVRequest {
	return ApiGetInvItemsPoolsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInvItemsPoolsLOVExecute(r ApiGetInvItemsPoolsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInvItemsPoolsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/invItemsPools"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInventoryItemAttributesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	itemId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInventoryItemAttributesLOVRequest) Authorization(authorization string) ApiGetInventoryItemAttributesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInventoryItemAttributesLOVRequest) XAppKey(xAppKey string) ApiGetInventoryItemAttributesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInventoryItemAttributesLOVRequest) XHotelid(xHotelid string) ApiGetInventoryItemAttributesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInventoryItemAttributesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInventoryItemAttributesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInventoryItemAttributesLOVRequest) ParameterName(parameterName []string) ApiGetInventoryItemAttributesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInventoryItemAttributesLOVRequest) ParameterValue(parameterValue []string) ApiGetInventoryItemAttributesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInventoryItemAttributesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInventoryItemAttributesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInventoryItemAttributesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInventoryItemAttributesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInventoryItemAttributesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInventoryItemAttributesLOVExecute(r)
}

/*
GetInventoryItemAttributesLOV Fetch List Of Values for Inventory Item Attributes

 <p><strong>OperationId:</strong>getInventoryItemAttributesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Value of the parameter 'itemId' which is required to fetch InventoryItemAttributes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InventoryItemAttributes LOV
 @return ApiGetInventoryItemAttributesLOVRequest
*/
func (a *LOVApiService) GetInventoryItemAttributesLOV(ctx context.Context, itemId string, hotelId string) ApiGetInventoryItemAttributesLOVRequest {
	return ApiGetInventoryItemAttributesLOVRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInventoryItemAttributesLOVExecute(r ApiGetInventoryItemAttributesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInventoryItemAttributesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/itemId/{itemId}/inventoryItemAttributes"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.itemId) < 1 {
		return localVarReturnValue, nil, reportError("itemId must have at least 1 elements")
	}
	if strlen(r.itemId) > 2000 {
		return localVarReturnValue, nil, reportError("itemId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInventoryItemRatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	itemId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInventoryItemRatesLOVRequest) Authorization(authorization string) ApiGetInventoryItemRatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInventoryItemRatesLOVRequest) XAppKey(xAppKey string) ApiGetInventoryItemRatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInventoryItemRatesLOVRequest) XHotelid(xHotelid string) ApiGetInventoryItemRatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInventoryItemRatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInventoryItemRatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInventoryItemRatesLOVRequest) ParameterName(parameterName []string) ApiGetInventoryItemRatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInventoryItemRatesLOVRequest) ParameterValue(parameterValue []string) ApiGetInventoryItemRatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInventoryItemRatesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInventoryItemRatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInventoryItemRatesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInventoryItemRatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInventoryItemRatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInventoryItemRatesLOVExecute(r)
}

/*
GetInventoryItemRatesLOV Fetch List Of Values for Inventory Item Rates

 <p><strong>OperationId:</strong>getInventoryItemRatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Value of the parameter 'itemId' which is required to fetch InventoryItemRates LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InventoryItemRates LOV
 @return ApiGetInventoryItemRatesLOVRequest
*/
func (a *LOVApiService) GetInventoryItemRatesLOV(ctx context.Context, itemId string, hotelId string) ApiGetInventoryItemRatesLOVRequest {
	return ApiGetInventoryItemRatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInventoryItemRatesLOVExecute(r ApiGetInventoryItemRatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInventoryItemRatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/itemId/{itemId}/inventoryItemRates"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.itemId) < 1 {
		return localVarReturnValue, nil, reportError("itemId must have at least 1 elements")
	}
	if strlen(r.itemId) > 2000 {
		return localVarReturnValue, nil, reportError("itemId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInventoryItemTemplateItemsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInventoryItemTemplateItemsLOVRequest) Authorization(authorization string) ApiGetInventoryItemTemplateItemsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInventoryItemTemplateItemsLOVRequest) XAppKey(xAppKey string) ApiGetInventoryItemTemplateItemsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInventoryItemTemplateItemsLOVRequest) XHotelid(xHotelid string) ApiGetInventoryItemTemplateItemsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInventoryItemTemplateItemsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInventoryItemTemplateItemsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInventoryItemTemplateItemsLOVRequest) ParameterName(parameterName []string) ApiGetInventoryItemTemplateItemsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInventoryItemTemplateItemsLOVRequest) ParameterValue(parameterValue []string) ApiGetInventoryItemTemplateItemsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInventoryItemTemplateItemsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInventoryItemTemplateItemsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInventoryItemTemplateItemsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInventoryItemTemplateItemsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInventoryItemTemplateItemsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInventoryItemTemplateItemsLOVExecute(r)
}

/*
GetInventoryItemTemplateItemsLOV Fetch List Of Values for Inventory Item Template Items

 <p><strong>OperationId:</strong>getInventoryItemTemplateItemsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InventoryItemTemplateItems LOV
 @return ApiGetInventoryItemTemplateItemsLOVRequest
*/
func (a *LOVApiService) GetInventoryItemTemplateItemsLOV(ctx context.Context, hotelId string) ApiGetInventoryItemTemplateItemsLOVRequest {
	return ApiGetInventoryItemTemplateItemsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInventoryItemTemplateItemsLOVExecute(r ApiGetInventoryItemTemplateItemsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInventoryItemTemplateItemsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/inventoryItemTemplateItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInventoryItemsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	sellInEvent string
	sellInReservation string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetInventoryItemsLOVRequest) Authorization(authorization string) ApiGetInventoryItemsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetInventoryItemsLOVRequest) XAppKey(xAppKey string) ApiGetInventoryItemsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetInventoryItemsLOVRequest) XHotelid(xHotelid string) ApiGetInventoryItemsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetInventoryItemsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetInventoryItemsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetInventoryItemsLOVRequest) ParameterName(parameterName []string) ApiGetInventoryItemsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetInventoryItemsLOVRequest) ParameterValue(parameterValue []string) ApiGetInventoryItemsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetInventoryItemsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetInventoryItemsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetInventoryItemsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetInventoryItemsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetInventoryItemsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInventoryItemsLOVExecute(r)
}

/*
GetInventoryItemsLOV Fetch List Of Values for Inventory Items

 <p><strong>OperationId:</strong>getInventoryItemsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sellInEvent Value of the parameter 'sellInEvent' which is required to fetch InventoryItems LOV
 @param sellInReservation Value of the parameter 'sellInReservation' which is required to fetch InventoryItems LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InventoryItems LOV
 @return ApiGetInventoryItemsLOVRequest
*/
func (a *LOVApiService) GetInventoryItemsLOV(ctx context.Context, sellInEvent string, sellInReservation string, hotelId string) ApiGetInventoryItemsLOVRequest {
	return ApiGetInventoryItemsLOVRequest{
		ApiService: a,
		ctx: ctx,
		sellInEvent: sellInEvent,
		sellInReservation: sellInReservation,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInventoryItemsLOVExecute(r ApiGetInventoryItemsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInventoryItemsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/sellInReservation/{sellInReservation}/sellInEvent/{sellInEvent}/inventoryItems"
	localVarPath = strings.Replace(localVarPath, "{"+"sellInEvent"+"}", url.PathEscape(parameterValueToString(r.sellInEvent, "sellInEvent")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sellInReservation"+"}", url.PathEscape(parameterValueToString(r.sellInReservation, "sellInReservation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sellInEvent) < 1 {
		return localVarReturnValue, nil, reportError("sellInEvent must have at least 1 elements")
	}
	if strlen(r.sellInEvent) > 2000 {
		return localVarReturnValue, nil, reportError("sellInEvent must have less than 2000 elements")
	}
	if strlen(r.sellInReservation) < 1 {
		return localVarReturnValue, nil, reportError("sellInReservation must have at least 1 elements")
	}
	if strlen(r.sellInReservation) > 2000 {
		return localVarReturnValue, nil, reportError("sellInReservation must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetItemClassesLOVRequest) Authorization(authorization string) ApiGetItemClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetItemClassesLOVRequest) XAppKey(xAppKey string) ApiGetItemClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetItemClassesLOVRequest) XHotelid(xHotelid string) ApiGetItemClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetItemClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetItemClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetItemClassesLOVRequest) ParameterName(parameterName []string) ApiGetItemClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetItemClassesLOVRequest) ParameterValue(parameterValue []string) ApiGetItemClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetItemClassesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetItemClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetItemClassesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetItemClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetItemClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetItemClassesLOVExecute(r)
}

/*
GetItemClassesLOV Fetch List Of Values for Item Classes

 <p><strong>OperationId:</strong>getItemClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ItemClasses LOV
 @return ApiGetItemClassesLOVRequest
*/
func (a *LOVApiService) GetItemClassesLOV(ctx context.Context, hotelId string) ApiGetItemClassesLOVRequest {
	return ApiGetItemClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetItemClassesLOVExecute(r ApiGetItemClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetItemClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/itemClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetItemCodesLOVRequest) Authorization(authorization string) ApiGetItemCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetItemCodesLOVRequest) XAppKey(xAppKey string) ApiGetItemCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetItemCodesLOVRequest) XHotelid(xHotelid string) ApiGetItemCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetItemCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetItemCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetItemCodesLOVRequest) ParameterName(parameterName []string) ApiGetItemCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetItemCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetItemCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetItemCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetItemCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetItemCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetItemCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetItemCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetItemCodesLOVExecute(r)
}

/*
GetItemCodesLOV Fetch List Of Values for Item Codes

 <p><strong>OperationId:</strong>getItemCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ItemCodes LOV
 @return ApiGetItemCodesLOVRequest
*/
func (a *LOVApiService) GetItemCodesLOV(ctx context.Context, hotelId string) ApiGetItemCodesLOVRequest {
	return ApiGetItemCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetItemCodesLOVExecute(r ApiGetItemCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetItemCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/itemCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemPriceCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	itemId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetItemPriceCodeLOVRequest) Authorization(authorization string) ApiGetItemPriceCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetItemPriceCodeLOVRequest) XAppKey(xAppKey string) ApiGetItemPriceCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetItemPriceCodeLOVRequest) XHotelid(xHotelid string) ApiGetItemPriceCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetItemPriceCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetItemPriceCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetItemPriceCodeLOVRequest) ParameterName(parameterName []string) ApiGetItemPriceCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetItemPriceCodeLOVRequest) ParameterValue(parameterValue []string) ApiGetItemPriceCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetItemPriceCodeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetItemPriceCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetItemPriceCodeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetItemPriceCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetItemPriceCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetItemPriceCodeLOVExecute(r)
}

/*
GetItemPriceCodeLOV Fetch List Of Values for Item Price Code

 <p><strong>OperationId:</strong>getItemPriceCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Value of the parameter 'itemId' which is required to fetch ItemPriceCode LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ItemPriceCode LOV
 @return ApiGetItemPriceCodeLOVRequest
*/
func (a *LOVApiService) GetItemPriceCodeLOV(ctx context.Context, itemId string, hotelId string) ApiGetItemPriceCodeLOVRequest {
	return ApiGetItemPriceCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetItemPriceCodeLOVExecute(r ApiGetItemPriceCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetItemPriceCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/itemId/{itemId}/itemPriceCode"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.itemId) < 1 {
		return localVarReturnValue, nil, reportError("itemId must have at least 1 elements")
	}
	if strlen(r.itemId) > 2000 {
		return localVarReturnValue, nil, reportError("itemId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemVendorLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	itemId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetItemVendorLOVRequest) Authorization(authorization string) ApiGetItemVendorLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetItemVendorLOVRequest) XAppKey(xAppKey string) ApiGetItemVendorLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetItemVendorLOVRequest) XHotelid(xHotelid string) ApiGetItemVendorLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetItemVendorLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetItemVendorLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetItemVendorLOVRequest) ParameterName(parameterName []string) ApiGetItemVendorLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetItemVendorLOVRequest) ParameterValue(parameterValue []string) ApiGetItemVendorLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetItemVendorLOVRequest) XExternalsystem(xExternalsystem string) ApiGetItemVendorLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetItemVendorLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetItemVendorLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetItemVendorLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetItemVendorLOVExecute(r)
}

/*
GetItemVendorLOV Fetch List Of Values for Item Vendor

 <p><strong>OperationId:</strong>getItemVendorLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Value of the parameter 'itemId' which is required to fetch ItemVendor LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ItemVendor LOV
 @return ApiGetItemVendorLOVRequest
*/
func (a *LOVApiService) GetItemVendorLOV(ctx context.Context, itemId string, hotelId string) ApiGetItemVendorLOVRequest {
	return ApiGetItemVendorLOVRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetItemVendorLOVExecute(r ApiGetItemVendorLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetItemVendorLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/itemId/{itemId}/itemVendor"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.itemId) < 1 {
		return localVarReturnValue, nil, reportError("itemId must have at least 1 elements")
	}
	if strlen(r.itemId) > 2000 {
		return localVarReturnValue, nil, reportError("itemId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobTitlesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetJobTitlesLOVRequest) Authorization(authorization string) ApiGetJobTitlesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetJobTitlesLOVRequest) XAppKey(xAppKey string) ApiGetJobTitlesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetJobTitlesLOVRequest) XHotelid(xHotelid string) ApiGetJobTitlesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetJobTitlesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetJobTitlesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetJobTitlesLOVRequest) ParameterName(parameterName []string) ApiGetJobTitlesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetJobTitlesLOVRequest) ParameterValue(parameterValue []string) ApiGetJobTitlesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetJobTitlesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetJobTitlesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetJobTitlesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetJobTitlesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetJobTitlesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetJobTitlesLOVExecute(r)
}

/*
GetJobTitlesLOV Fetch List Of Values for Job Titles

 <p><strong>OperationId:</strong>getJobTitlesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch JobTitles LOV
 @return ApiGetJobTitlesLOVRequest
*/
func (a *LOVApiService) GetJobTitlesLOV(ctx context.Context, hotelId string) ApiGetJobTitlesLOVRequest {
	return ApiGetJobTitlesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetJobTitlesLOVExecute(r ApiGetJobTitlesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetJobTitlesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/jobTitles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKeyOptionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetKeyOptionsLOVRequest) Authorization(authorization string) ApiGetKeyOptionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetKeyOptionsLOVRequest) XAppKey(xAppKey string) ApiGetKeyOptionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetKeyOptionsLOVRequest) XHotelid(xHotelid string) ApiGetKeyOptionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetKeyOptionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetKeyOptionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetKeyOptionsLOVRequest) ParameterName(parameterName []string) ApiGetKeyOptionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetKeyOptionsLOVRequest) ParameterValue(parameterValue []string) ApiGetKeyOptionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetKeyOptionsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetKeyOptionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetKeyOptionsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetKeyOptionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetKeyOptionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetKeyOptionsLOVExecute(r)
}

/*
GetKeyOptionsLOV Fetch List Of Values for Key Options

 <p><strong>OperationId:</strong>getKeyOptionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch KeyOptions LOV
 @return ApiGetKeyOptionsLOVRequest
*/
func (a *LOVApiService) GetKeyOptionsLOV(ctx context.Context, hotelId string) ApiGetKeyOptionsLOVRequest {
	return ApiGetKeyOptionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetKeyOptionsLOVExecute(r ApiGetKeyOptionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetKeyOptionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/keyOptions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLOVNamesRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetLOVNamesRequest) Authorization(authorization string) ApiGetLOVNamesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetLOVNamesRequest) XAppKey(xAppKey string) ApiGetLOVNamesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetLOVNamesRequest) XHotelid(xHotelid string) ApiGetLOVNamesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiGetLOVNamesRequest) XExternalsystem(xExternalsystem string) ApiGetLOVNamesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetLOVNamesRequest) AcceptLanguage(acceptLanguage string) ApiGetLOVNamesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetLOVNamesRequest) Execute() (*ListOfValueNames, *http.Response, error) {
	return r.ApiService.GetLOVNamesExecute(r)
}

/*
GetLOVNames Fetch Names

 <p><strong>OperationId:</strong>getLOVNames</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLOVNamesRequest
*/
func (a *LOVApiService) GetLOVNames(ctx context.Context) ApiGetLOVNamesRequest {
	return ApiGetLOVNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOfValueNames
func (a *LOVApiService) GetLOVNamesExecute(r ApiGetLOVNamesRequest) (*ListOfValueNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValueNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetLOVNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLicensesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetLicensesLOVRequest) Authorization(authorization string) ApiGetLicensesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetLicensesLOVRequest) XAppKey(xAppKey string) ApiGetLicensesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetLicensesLOVRequest) XHotelid(xHotelid string) ApiGetLicensesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetLicensesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetLicensesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetLicensesLOVRequest) ParameterName(parameterName []string) ApiGetLicensesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetLicensesLOVRequest) ParameterValue(parameterValue []string) ApiGetLicensesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetLicensesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetLicensesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetLicensesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetLicensesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetLicensesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetLicensesLOVExecute(r)
}

/*
GetLicensesLOV Fetch List Of Values for Licenses

 <p><strong>OperationId:</strong>getLicensesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Licenses LOV
 @return ApiGetLicensesLOVRequest
*/
func (a *LOVApiService) GetLicensesLOV(ctx context.Context, hotelId string) ApiGetLicensesLOVRequest {
	return ApiGetLicensesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetLicensesLOVExecute(r ApiGetLicensesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetLicensesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/licenses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListOfValuesRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	name string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetListOfValuesRequest) Authorization(authorization string) ApiGetListOfValuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetListOfValuesRequest) XAppKey(xAppKey string) ApiGetListOfValuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetListOfValuesRequest) XHotelid(xHotelid string) ApiGetListOfValuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetListOfValuesRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetListOfValuesRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetListOfValuesRequest) ParameterName(parameterName []string) ApiGetListOfValuesRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetListOfValuesRequest) ParameterValue(parameterValue []string) ApiGetListOfValuesRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetListOfValuesRequest) XExternalsystem(xExternalsystem string) ApiGetListOfValuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetListOfValuesRequest) AcceptLanguage(acceptLanguage string) ApiGetListOfValuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetListOfValuesRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetListOfValuesExecute(r)
}

/*
GetListOfValues Fetch List Of Values for the given name of the LOV

 <p><strong>OperationId:</strong>getListOfValues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name LOV Name which is required to fetch the values
 @return ApiGetListOfValuesRequest
*/
func (a *LOVApiService) GetListOfValues(ctx context.Context, name string) ApiGetListOfValuesRequest {
	return ApiGetListOfValuesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetListOfValuesExecute(r ApiGetListOfValuesRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetListOfValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.name) < 1 {
		return localVarReturnValue, nil, reportError("name must have at least 1 elements")
	}
	if strlen(r.name) > 2000 {
		return localVarReturnValue, nil, reportError("name must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLocatorQuickTextsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetLocatorQuickTextsLOVRequest) Authorization(authorization string) ApiGetLocatorQuickTextsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetLocatorQuickTextsLOVRequest) XAppKey(xAppKey string) ApiGetLocatorQuickTextsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetLocatorQuickTextsLOVRequest) XHotelid(xHotelid string) ApiGetLocatorQuickTextsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetLocatorQuickTextsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetLocatorQuickTextsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetLocatorQuickTextsLOVRequest) ParameterName(parameterName []string) ApiGetLocatorQuickTextsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetLocatorQuickTextsLOVRequest) ParameterValue(parameterValue []string) ApiGetLocatorQuickTextsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetLocatorQuickTextsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetLocatorQuickTextsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetLocatorQuickTextsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetLocatorQuickTextsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetLocatorQuickTextsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetLocatorQuickTextsLOVExecute(r)
}

/*
GetLocatorQuickTextsLOV Fetch List Of Values for Locator Quick Texts

 <p><strong>OperationId:</strong>getLocatorQuickTextsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch LocatorQuickTexts LOV
 @return ApiGetLocatorQuickTextsLOVRequest
*/
func (a *LOVApiService) GetLocatorQuickTextsLOV(ctx context.Context, hotelId string) ApiGetLocatorQuickTextsLOVRequest {
	return ApiGetLocatorQuickTextsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetLocatorQuickTextsLOVExecute(r ApiGetLocatorQuickTextsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetLocatorQuickTextsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/locatorQuickTexts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMailGenericLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	sourceIdIn string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMailGenericLOVRequest) Authorization(authorization string) ApiGetMailGenericLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMailGenericLOVRequest) XAppKey(xAppKey string) ApiGetMailGenericLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMailGenericLOVRequest) XHotelid(xHotelid string) ApiGetMailGenericLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMailGenericLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMailGenericLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMailGenericLOVRequest) ParameterName(parameterName []string) ApiGetMailGenericLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMailGenericLOVRequest) ParameterValue(parameterValue []string) ApiGetMailGenericLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMailGenericLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMailGenericLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMailGenericLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMailGenericLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMailGenericLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMailGenericLOVExecute(r)
}

/*
GetMailGenericLOV Fetch List Of Values for Mail Generic

 <p><strong>OperationId:</strong>getMailGenericLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceIdIn Value of the parameter 'sourceIdIn' which is required to fetch MailGeneric LOV
 @return ApiGetMailGenericLOVRequest
*/
func (a *LOVApiService) GetMailGenericLOV(ctx context.Context, sourceIdIn string) ApiGetMailGenericLOVRequest {
	return ApiGetMailGenericLOVRequest{
		ApiService: a,
		ctx: ctx,
		sourceIdIn: sourceIdIn,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMailGenericLOVExecute(r ApiGetMailGenericLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMailGenericLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/sourceIdIn/{sourceIdIn}/mailGeneric"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceIdIn"+"}", url.PathEscape(parameterValueToString(r.sourceIdIn, "sourceIdIn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceIdIn) < 1 {
		return localVarReturnValue, nil, reportError("sourceIdIn must have at least 1 elements")
	}
	if strlen(r.sourceIdIn) > 2000 {
		return localVarReturnValue, nil, reportError("sourceIdIn must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagerReportDetailsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetManagerReportDetailsLOVRequest) Authorization(authorization string) ApiGetManagerReportDetailsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetManagerReportDetailsLOVRequest) XAppKey(xAppKey string) ApiGetManagerReportDetailsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetManagerReportDetailsLOVRequest) XHotelid(xHotelid string) ApiGetManagerReportDetailsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetManagerReportDetailsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetManagerReportDetailsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetManagerReportDetailsLOVRequest) ParameterName(parameterName []string) ApiGetManagerReportDetailsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetManagerReportDetailsLOVRequest) ParameterValue(parameterValue []string) ApiGetManagerReportDetailsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetManagerReportDetailsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetManagerReportDetailsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetManagerReportDetailsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetManagerReportDetailsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetManagerReportDetailsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetManagerReportDetailsLOVExecute(r)
}

/*
GetManagerReportDetailsLOV Fetch List Of Values for Manager Report Details

 <p><strong>OperationId:</strong>getManagerReportDetailsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ManagerReportDetails LOV
 @return ApiGetManagerReportDetailsLOVRequest
*/
func (a *LOVApiService) GetManagerReportDetailsLOV(ctx context.Context, hotelId string) ApiGetManagerReportDetailsLOVRequest {
	return ApiGetManagerReportDetailsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetManagerReportDetailsLOVExecute(r ApiGetManagerReportDetailsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetManagerReportDetailsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/managerReportDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagersReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetManagersReportsLOVRequest) Authorization(authorization string) ApiGetManagersReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetManagersReportsLOVRequest) XAppKey(xAppKey string) ApiGetManagersReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetManagersReportsLOVRequest) XHotelid(xHotelid string) ApiGetManagersReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetManagersReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetManagersReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetManagersReportsLOVRequest) ParameterName(parameterName []string) ApiGetManagersReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetManagersReportsLOVRequest) ParameterValue(parameterValue []string) ApiGetManagersReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetManagersReportsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetManagersReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetManagersReportsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetManagersReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetManagersReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetManagersReportsLOVExecute(r)
}

/*
GetManagersReportsLOV Fetch List Of Values for Managers Reports

 <p><strong>OperationId:</strong>getManagersReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ManagersReports LOV
 @return ApiGetManagersReportsLOVRequest
*/
func (a *LOVApiService) GetManagersReportsLOV(ctx context.Context, hotelId string) ApiGetManagersReportsLOVRequest {
	return ApiGetManagersReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetManagersReportsLOVExecute(r ApiGetManagersReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetManagersReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/managersReports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMarketGroupsLOVRequest) Authorization(authorization string) ApiGetMarketGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMarketGroupsLOVRequest) XAppKey(xAppKey string) ApiGetMarketGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMarketGroupsLOVRequest) XHotelid(xHotelid string) ApiGetMarketGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMarketGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMarketGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMarketGroupsLOVRequest) ParameterName(parameterName []string) ApiGetMarketGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMarketGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetMarketGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMarketGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMarketGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMarketGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMarketGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMarketGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMarketGroupsLOVExecute(r)
}

/*
GetMarketGroupsLOV Fetch List Of Values for Market Groups

 <p><strong>OperationId:</strong>getMarketGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MarketGroups LOV
 @return ApiGetMarketGroupsLOVRequest
*/
func (a *LOVApiService) GetMarketGroupsLOV(ctx context.Context, hotelId string) ApiGetMarketGroupsLOVRequest {
	return ApiGetMarketGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMarketGroupsLOVExecute(r ApiGetMarketGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMarketGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/marketGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketSegmentLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMarketSegmentLOVRequest) Authorization(authorization string) ApiGetMarketSegmentLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMarketSegmentLOVRequest) XAppKey(xAppKey string) ApiGetMarketSegmentLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMarketSegmentLOVRequest) XHotelid(xHotelid string) ApiGetMarketSegmentLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMarketSegmentLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMarketSegmentLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMarketSegmentLOVRequest) ParameterName(parameterName []string) ApiGetMarketSegmentLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMarketSegmentLOVRequest) ParameterValue(parameterValue []string) ApiGetMarketSegmentLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMarketSegmentLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMarketSegmentLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMarketSegmentLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMarketSegmentLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMarketSegmentLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMarketSegmentLOVExecute(r)
}

/*
GetMarketSegmentLOV Fetch List Of Values for Market Segment

 <p><strong>OperationId:</strong>getMarketSegmentLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MarketSegment LOV
 @return ApiGetMarketSegmentLOVRequest
*/
func (a *LOVApiService) GetMarketSegmentLOV(ctx context.Context, hotelId string) ApiGetMarketSegmentLOVRequest {
	return ApiGetMarketSegmentLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMarketSegmentLOVExecute(r ApiGetMarketSegmentLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMarketSegmentLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/marketSegment"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMasterBlockLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMasterBlockLOVRequest) Authorization(authorization string) ApiGetMasterBlockLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMasterBlockLOVRequest) XAppKey(xAppKey string) ApiGetMasterBlockLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMasterBlockLOVRequest) XHotelid(xHotelid string) ApiGetMasterBlockLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMasterBlockLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMasterBlockLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMasterBlockLOVRequest) ParameterName(parameterName []string) ApiGetMasterBlockLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMasterBlockLOVRequest) ParameterValue(parameterValue []string) ApiGetMasterBlockLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMasterBlockLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMasterBlockLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMasterBlockLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMasterBlockLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMasterBlockLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMasterBlockLOVExecute(r)
}

/*
GetMasterBlockLOV Fetch List Of Values for Master Block

 <p><strong>OperationId:</strong>getMasterBlockLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MasterBlock LOV
 @return ApiGetMasterBlockLOVRequest
*/
func (a *LOVApiService) GetMasterBlockLOV(ctx context.Context, hotelId string) ApiGetMasterBlockLOVRequest {
	return ApiGetMasterBlockLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMasterBlockLOVExecute(r ApiGetMasterBlockLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMasterBlockLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/masterBlock"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipAwardFinTrxLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipAwardFinTrxLOVRequest) Authorization(authorization string) ApiGetMembershipAwardFinTrxLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipAwardFinTrxLOVRequest) XAppKey(xAppKey string) ApiGetMembershipAwardFinTrxLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipAwardFinTrxLOVRequest) XHotelid(xHotelid string) ApiGetMembershipAwardFinTrxLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipAwardFinTrxLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipAwardFinTrxLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipAwardFinTrxLOVRequest) ParameterName(parameterName []string) ApiGetMembershipAwardFinTrxLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipAwardFinTrxLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipAwardFinTrxLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipAwardFinTrxLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipAwardFinTrxLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipAwardFinTrxLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipAwardFinTrxLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipAwardFinTrxLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipAwardFinTrxLOVExecute(r)
}

/*
GetMembershipAwardFinTrxLOV Fetch List Of Values for Membership Award Fin Trx

 <p><strong>OperationId:</strong>getMembershipAwardFinTrxLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MembershipAwardFinTrx LOV
 @return ApiGetMembershipAwardFinTrxLOVRequest
*/
func (a *LOVApiService) GetMembershipAwardFinTrxLOV(ctx context.Context, hotelId string) ApiGetMembershipAwardFinTrxLOVRequest {
	return ApiGetMembershipAwardFinTrxLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipAwardFinTrxLOVExecute(r ApiGetMembershipAwardFinTrxLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipAwardFinTrxLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/membershipAwardFinTrx"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipAwardProductsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipAwardProductsLOVRequest) Authorization(authorization string) ApiGetMembershipAwardProductsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipAwardProductsLOVRequest) XAppKey(xAppKey string) ApiGetMembershipAwardProductsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipAwardProductsLOVRequest) XHotelid(xHotelid string) ApiGetMembershipAwardProductsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipAwardProductsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipAwardProductsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipAwardProductsLOVRequest) ParameterName(parameterName []string) ApiGetMembershipAwardProductsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipAwardProductsLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipAwardProductsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipAwardProductsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipAwardProductsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipAwardProductsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipAwardProductsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipAwardProductsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipAwardProductsLOVExecute(r)
}

/*
GetMembershipAwardProductsLOV Fetch List Of Values for Membership Award Products

 <p><strong>OperationId:</strong>getMembershipAwardProductsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MembershipAwardProducts LOV
 @return ApiGetMembershipAwardProductsLOVRequest
*/
func (a *LOVApiService) GetMembershipAwardProductsLOV(ctx context.Context, hotelId string) ApiGetMembershipAwardProductsLOVRequest {
	return ApiGetMembershipAwardProductsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipAwardProductsLOVExecute(r ApiGetMembershipAwardProductsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipAwardProductsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/membershipAwardProducts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipAwardRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipAwardRateCodesLOVRequest) Authorization(authorization string) ApiGetMembershipAwardRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipAwardRateCodesLOVRequest) XAppKey(xAppKey string) ApiGetMembershipAwardRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipAwardRateCodesLOVRequest) XHotelid(xHotelid string) ApiGetMembershipAwardRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipAwardRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipAwardRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipAwardRateCodesLOVRequest) ParameterName(parameterName []string) ApiGetMembershipAwardRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipAwardRateCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipAwardRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipAwardRateCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipAwardRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipAwardRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipAwardRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipAwardRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipAwardRateCodesLOVExecute(r)
}

/*
GetMembershipAwardRateCodesLOV Fetch List Of Values for Membership Award Rate Codes

 <p><strong>OperationId:</strong>getMembershipAwardRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MembershipAwardRateCodes LOV
 @return ApiGetMembershipAwardRateCodesLOVRequest
*/
func (a *LOVApiService) GetMembershipAwardRateCodesLOV(ctx context.Context, hotelId string) ApiGetMembershipAwardRateCodesLOVRequest {
	return ApiGetMembershipAwardRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipAwardRateCodesLOVExecute(r ApiGetMembershipAwardRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipAwardRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/membershipAwardRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipAwardUpgradeRoomGroupLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipAwardUpgradeRoomGroupLOVRequest) Authorization(authorization string) ApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipAwardUpgradeRoomGroupLOVRequest) XAppKey(xAppKey string) ApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipAwardUpgradeRoomGroupLOVRequest) XHotelid(xHotelid string) ApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipAwardUpgradeRoomGroupLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipAwardUpgradeRoomGroupLOVRequest) ParameterName(parameterName []string) ApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipAwardUpgradeRoomGroupLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipAwardUpgradeRoomGroupLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipAwardUpgradeRoomGroupLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipAwardUpgradeRoomGroupLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipAwardUpgradeRoomGroupLOVExecute(r)
}

/*
GetMembershipAwardUpgradeRoomGroupLOV Fetch List Of Values for Membership Award Upgrade Room Group

 <p><strong>OperationId:</strong>getMembershipAwardUpgradeRoomGroupLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MembershipAwardUpgradeRoomGroup LOV
 @return ApiGetMembershipAwardUpgradeRoomGroupLOVRequest
*/
func (a *LOVApiService) GetMembershipAwardUpgradeRoomGroupLOV(ctx context.Context, hotelId string) ApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	return ApiGetMembershipAwardUpgradeRoomGroupLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipAwardUpgradeRoomGroupLOVExecute(r ApiGetMembershipAwardUpgradeRoomGroupLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipAwardUpgradeRoomGroupLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/membershipAwardUpgradeRoomGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipAwardUpgradeRoomLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipAwardUpgradeRoomLOVRequest) Authorization(authorization string) ApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipAwardUpgradeRoomLOVRequest) XAppKey(xAppKey string) ApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipAwardUpgradeRoomLOVRequest) XHotelid(xHotelid string) ApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipAwardUpgradeRoomLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipAwardUpgradeRoomLOVRequest) ParameterName(parameterName []string) ApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipAwardUpgradeRoomLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipAwardUpgradeRoomLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipAwardUpgradeRoomLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipAwardUpgradeRoomLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipAwardUpgradeRoomLOVExecute(r)
}

/*
GetMembershipAwardUpgradeRoomLOV Fetch List Of Values for Membership Award Upgrade Room

 <p><strong>OperationId:</strong>getMembershipAwardUpgradeRoomLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MembershipAwardUpgradeRoom LOV
 @return ApiGetMembershipAwardUpgradeRoomLOVRequest
*/
func (a *LOVApiService) GetMembershipAwardUpgradeRoomLOV(ctx context.Context, hotelId string) ApiGetMembershipAwardUpgradeRoomLOVRequest {
	return ApiGetMembershipAwardUpgradeRoomLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipAwardUpgradeRoomLOVExecute(r ApiGetMembershipAwardUpgradeRoomLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipAwardUpgradeRoomLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/membershipAwardUpgradeRoom"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipBenefitProgramLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipBenefitProgramLOVRequest) Authorization(authorization string) ApiGetMembershipBenefitProgramLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipBenefitProgramLOVRequest) XAppKey(xAppKey string) ApiGetMembershipBenefitProgramLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipBenefitProgramLOVRequest) XHotelid(xHotelid string) ApiGetMembershipBenefitProgramLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipBenefitProgramLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipBenefitProgramLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipBenefitProgramLOVRequest) ParameterName(parameterName []string) ApiGetMembershipBenefitProgramLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipBenefitProgramLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipBenefitProgramLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipBenefitProgramLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipBenefitProgramLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipBenefitProgramLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipBenefitProgramLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipBenefitProgramLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipBenefitProgramLOVExecute(r)
}

/*
GetMembershipBenefitProgramLOV Fetch List Of Values for Membership Benefit Program

 <p><strong>OperationId:</strong>getMembershipBenefitProgramLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipType Value of the parameter 'membershipType' which is required to fetch MembershipBenefitProgram LOV
 @return ApiGetMembershipBenefitProgramLOVRequest
*/
func (a *LOVApiService) GetMembershipBenefitProgramLOV(ctx context.Context, membershipType string) ApiGetMembershipBenefitProgramLOVRequest {
	return ApiGetMembershipBenefitProgramLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipType: membershipType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipBenefitProgramLOVExecute(r ApiGetMembershipBenefitProgramLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipBenefitProgramLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipType/{membershipType}/membershipBenefitProgram"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipBenefitsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipBenefitsLOVRequest) Authorization(authorization string) ApiGetMembershipBenefitsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipBenefitsLOVRequest) XAppKey(xAppKey string) ApiGetMembershipBenefitsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipBenefitsLOVRequest) XHotelid(xHotelid string) ApiGetMembershipBenefitsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipBenefitsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipBenefitsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipBenefitsLOVRequest) ParameterName(parameterName []string) ApiGetMembershipBenefitsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipBenefitsLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipBenefitsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipBenefitsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipBenefitsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipBenefitsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipBenefitsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipBenefitsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipBenefitsLOVExecute(r)
}

/*
GetMembershipBenefitsLOV Fetch List Of Values for Membership Benefits

 <p><strong>OperationId:</strong>getMembershipBenefitsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipType Value of the parameter 'membershipType' which is required to fetch MembershipBenefits LOV
 @return ApiGetMembershipBenefitsLOVRequest
*/
func (a *LOVApiService) GetMembershipBenefitsLOV(ctx context.Context, membershipType string) ApiGetMembershipBenefitsLOVRequest {
	return ApiGetMembershipBenefitsLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipType: membershipType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipBenefitsLOVExecute(r ApiGetMembershipBenefitsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipBenefitsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipType/{membershipType}/membershipBenefits"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipCardFeeAmountLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipLevel string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipCardFeeAmountLOVRequest) Authorization(authorization string) ApiGetMembershipCardFeeAmountLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipCardFeeAmountLOVRequest) XAppKey(xAppKey string) ApiGetMembershipCardFeeAmountLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipCardFeeAmountLOVRequest) XHotelid(xHotelid string) ApiGetMembershipCardFeeAmountLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipCardFeeAmountLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipCardFeeAmountLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipCardFeeAmountLOVRequest) ParameterName(parameterName []string) ApiGetMembershipCardFeeAmountLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipCardFeeAmountLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipCardFeeAmountLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipCardFeeAmountLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipCardFeeAmountLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipCardFeeAmountLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipCardFeeAmountLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipCardFeeAmountLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipCardFeeAmountLOVExecute(r)
}

/*
GetMembershipCardFeeAmountLOV Fetch List Of Values for Membership Card Fee Amount

 <p><strong>OperationId:</strong>getMembershipCardFeeAmountLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipLevel Value of the parameter 'membershipLevel' which is required to fetch MembershipCardFeeAmount LOV
 @return ApiGetMembershipCardFeeAmountLOVRequest
*/
func (a *LOVApiService) GetMembershipCardFeeAmountLOV(ctx context.Context, membershipLevel string) ApiGetMembershipCardFeeAmountLOVRequest {
	return ApiGetMembershipCardFeeAmountLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipLevel: membershipLevel,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipCardFeeAmountLOVExecute(r ApiGetMembershipCardFeeAmountLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipCardFeeAmountLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipLevel/{membershipLevel}/membershipCardFeeAmount"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipLevel"+"}", url.PathEscape(parameterValueToString(r.membershipLevel, "membershipLevel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipLevel) < 1 {
		return localVarReturnValue, nil, reportError("membershipLevel must have at least 1 elements")
	}
	if strlen(r.membershipLevel) > 2000 {
		return localVarReturnValue, nil, reportError("membershipLevel must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipClassTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	loyalty string
	airlines string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipClassTypesLOVRequest) Authorization(authorization string) ApiGetMembershipClassTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipClassTypesLOVRequest) XAppKey(xAppKey string) ApiGetMembershipClassTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipClassTypesLOVRequest) XHotelid(xHotelid string) ApiGetMembershipClassTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipClassTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipClassTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipClassTypesLOVRequest) ParameterName(parameterName []string) ApiGetMembershipClassTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipClassTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipClassTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipClassTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipClassTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipClassTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipClassTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipClassTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipClassTypesLOVExecute(r)
}

/*
GetMembershipClassTypesLOV Fetch List Of Values for Membership Class Types

 <p><strong>OperationId:</strong>getMembershipClassTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param loyalty Value of the parameter 'loyalty' which is required to fetch MembershipClassTypes LOV
 @param airlines Value of the parameter 'airlines' which is required to fetch MembershipClassTypes LOV
 @return ApiGetMembershipClassTypesLOVRequest
*/
func (a *LOVApiService) GetMembershipClassTypesLOV(ctx context.Context, loyalty string, airlines string) ApiGetMembershipClassTypesLOVRequest {
	return ApiGetMembershipClassTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		loyalty: loyalty,
		airlines: airlines,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipClassTypesLOVExecute(r ApiGetMembershipClassTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipClassTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/airlines/{airlines}/loyalty/{loyalty}/membershipClassTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"loyalty"+"}", url.PathEscape(parameterValueToString(r.loyalty, "loyalty")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"airlines"+"}", url.PathEscape(parameterValueToString(r.airlines, "airlines")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.loyalty) < 1 {
		return localVarReturnValue, nil, reportError("loyalty must have at least 1 elements")
	}
	if strlen(r.loyalty) > 2000 {
		return localVarReturnValue, nil, reportError("loyalty must have less than 2000 elements")
	}
	if strlen(r.airlines) < 1 {
		return localVarReturnValue, nil, reportError("airlines must have at least 1 elements")
	}
	if strlen(r.airlines) > 2000 {
		return localVarReturnValue, nil, reportError("airlines must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipMaxDowngradeLevelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipType string
	membershipLevelRank string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipMaxDowngradeLevelLOVRequest) Authorization(authorization string) ApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipMaxDowngradeLevelLOVRequest) XAppKey(xAppKey string) ApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipMaxDowngradeLevelLOVRequest) XHotelid(xHotelid string) ApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipMaxDowngradeLevelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipMaxDowngradeLevelLOVRequest) ParameterName(parameterName []string) ApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipMaxDowngradeLevelLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipMaxDowngradeLevelLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipMaxDowngradeLevelLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipMaxDowngradeLevelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipMaxDowngradeLevelLOVExecute(r)
}

/*
GetMembershipMaxDowngradeLevelLOV Fetch List Of Values for Membership Max Downgrade Level

 <p><strong>OperationId:</strong>getMembershipMaxDowngradeLevelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipType Value of the parameter 'membershipType' which is required to fetch MembershipMaxDowngradeLevel LOV
 @param membershipLevelRank Value of the parameter 'membershipLevelRank' which is required to fetch MembershipMaxDowngradeLevel LOV
 @return ApiGetMembershipMaxDowngradeLevelLOVRequest
*/
func (a *LOVApiService) GetMembershipMaxDowngradeLevelLOV(ctx context.Context, membershipType string, membershipLevelRank string) ApiGetMembershipMaxDowngradeLevelLOVRequest {
	return ApiGetMembershipMaxDowngradeLevelLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipType: membershipType,
		membershipLevelRank: membershipLevelRank,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipMaxDowngradeLevelLOVExecute(r ApiGetMembershipMaxDowngradeLevelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipMaxDowngradeLevelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipLevelRank/{membershipLevelRank}/membershipType/{membershipType}/membershipMaxDowngradeLevel"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"membershipLevelRank"+"}", url.PathEscape(parameterValueToString(r.membershipLevelRank, "membershipLevelRank")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}
	if strlen(r.membershipLevelRank) < 1 {
		return localVarReturnValue, nil, reportError("membershipLevelRank must have at least 1 elements")
	}
	if strlen(r.membershipLevelRank) > 2000 {
		return localVarReturnValue, nil, reportError("membershipLevelRank must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipPointsRuleCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipPointsRuleCodesLOVRequest) Authorization(authorization string) ApiGetMembershipPointsRuleCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipPointsRuleCodesLOVRequest) XAppKey(xAppKey string) ApiGetMembershipPointsRuleCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipPointsRuleCodesLOVRequest) XHotelid(xHotelid string) ApiGetMembershipPointsRuleCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipPointsRuleCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipPointsRuleCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipPointsRuleCodesLOVRequest) ParameterName(parameterName []string) ApiGetMembershipPointsRuleCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipPointsRuleCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipPointsRuleCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipPointsRuleCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipPointsRuleCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipPointsRuleCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipPointsRuleCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipPointsRuleCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipPointsRuleCodesLOVExecute(r)
}

/*
GetMembershipPointsRuleCodesLOV Fetch List Of Values for Membership Points Rule Codes

 <p><strong>OperationId:</strong>getMembershipPointsRuleCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipType Value of the parameter 'membershipType' which is required to fetch MembershipPointsRuleCodes LOV
 @return ApiGetMembershipPointsRuleCodesLOVRequest
*/
func (a *LOVApiService) GetMembershipPointsRuleCodesLOV(ctx context.Context, membershipType string) ApiGetMembershipPointsRuleCodesLOVRequest {
	return ApiGetMembershipPointsRuleCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipType: membershipType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipPointsRuleCodesLOVExecute(r ApiGetMembershipPointsRuleCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipPointsRuleCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipType/{membershipType}/membershipPointsRuleCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipPromotionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipId string
	beginDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipPromotionsLOVRequest) Authorization(authorization string) ApiGetMembershipPromotionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipPromotionsLOVRequest) XAppKey(xAppKey string) ApiGetMembershipPromotionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipPromotionsLOVRequest) XHotelid(xHotelid string) ApiGetMembershipPromotionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipPromotionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipPromotionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipPromotionsLOVRequest) ParameterName(parameterName []string) ApiGetMembershipPromotionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipPromotionsLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipPromotionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipPromotionsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipPromotionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipPromotionsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipPromotionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipPromotionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipPromotionsLOVExecute(r)
}

/*
GetMembershipPromotionsLOV Fetch List Of Values for Membership Promotions

 <p><strong>OperationId:</strong>getMembershipPromotionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Value of the parameter 'membershipId' which is required to fetch MembershipPromotions LOV
 @param beginDate Value of the parameter 'beginDate' which is required to fetch MembershipPromotions LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MembershipPromotions LOV
 @return ApiGetMembershipPromotionsLOVRequest
*/
func (a *LOVApiService) GetMembershipPromotionsLOV(ctx context.Context, membershipId string, beginDate string, hotelId string) ApiGetMembershipPromotionsLOVRequest {
	return ApiGetMembershipPromotionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
		beginDate: beginDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipPromotionsLOVExecute(r ApiGetMembershipPromotionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipPromotionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/beginDate/{beginDate}/membershipId/{membershipId}/membershipPromotions"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"beginDate"+"}", url.PathEscape(parameterValueToString(r.beginDate, "beginDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if strlen(r.beginDate) < 1 {
		return localVarReturnValue, nil, reportError("beginDate must have at least 1 elements")
	}
	if strlen(r.beginDate) > 2000 {
		return localVarReturnValue, nil, reportError("beginDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipStatementBatchListLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipStatementBatchListLOVRequest) Authorization(authorization string) ApiGetMembershipStatementBatchListLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipStatementBatchListLOVRequest) XAppKey(xAppKey string) ApiGetMembershipStatementBatchListLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipStatementBatchListLOVRequest) XHotelid(xHotelid string) ApiGetMembershipStatementBatchListLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipStatementBatchListLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipStatementBatchListLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipStatementBatchListLOVRequest) ParameterName(parameterName []string) ApiGetMembershipStatementBatchListLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipStatementBatchListLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipStatementBatchListLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipStatementBatchListLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipStatementBatchListLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipStatementBatchListLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipStatementBatchListLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipStatementBatchListLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipStatementBatchListLOVExecute(r)
}

/*
GetMembershipStatementBatchListLOV Fetch List Of Values for Membership Statement Batch List

 <p><strong>OperationId:</strong>getMembershipStatementBatchListLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Value of the parameter 'membershipId' which is required to fetch MembershipStatementBatchList LOV
 @return ApiGetMembershipStatementBatchListLOVRequest
*/
func (a *LOVApiService) GetMembershipStatementBatchListLOV(ctx context.Context, membershipId string) ApiGetMembershipStatementBatchListLOVRequest {
	return ApiGetMembershipStatementBatchListLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipStatementBatchListLOVExecute(r ApiGetMembershipStatementBatchListLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipStatementBatchListLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipId/{membershipId}/membershipStatementBatchList"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipTotalPointsAvailableLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipTotalPointsAvailableLOVRequest) Authorization(authorization string) ApiGetMembershipTotalPointsAvailableLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipTotalPointsAvailableLOVRequest) XAppKey(xAppKey string) ApiGetMembershipTotalPointsAvailableLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipTotalPointsAvailableLOVRequest) XHotelid(xHotelid string) ApiGetMembershipTotalPointsAvailableLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipTotalPointsAvailableLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipTotalPointsAvailableLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipTotalPointsAvailableLOVRequest) ParameterName(parameterName []string) ApiGetMembershipTotalPointsAvailableLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipTotalPointsAvailableLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipTotalPointsAvailableLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipTotalPointsAvailableLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipTotalPointsAvailableLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipTotalPointsAvailableLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipTotalPointsAvailableLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipTotalPointsAvailableLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipTotalPointsAvailableLOVExecute(r)
}

/*
GetMembershipTotalPointsAvailableLOV Fetch List Of Values for Membership Total Points Available

 <p><strong>OperationId:</strong>getMembershipTotalPointsAvailableLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Value of the parameter 'membershipId' which is required to fetch MembershipTotalPointsAvailable LOV
 @return ApiGetMembershipTotalPointsAvailableLOVRequest
*/
func (a *LOVApiService) GetMembershipTotalPointsAvailableLOV(ctx context.Context, membershipId string) ApiGetMembershipTotalPointsAvailableLOVRequest {
	return ApiGetMembershipTotalPointsAvailableLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipTotalPointsAvailableLOVExecute(r ApiGetMembershipTotalPointsAvailableLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipTotalPointsAvailableLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipId/{membershipId}/membershipTotalPointsAvailable"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembershipTransferPointsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMembershipTransferPointsLOVRequest) Authorization(authorization string) ApiGetMembershipTransferPointsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMembershipTransferPointsLOVRequest) XAppKey(xAppKey string) ApiGetMembershipTransferPointsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMembershipTransferPointsLOVRequest) XHotelid(xHotelid string) ApiGetMembershipTransferPointsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMembershipTransferPointsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMembershipTransferPointsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMembershipTransferPointsLOVRequest) ParameterName(parameterName []string) ApiGetMembershipTransferPointsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMembershipTransferPointsLOVRequest) ParameterValue(parameterValue []string) ApiGetMembershipTransferPointsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMembershipTransferPointsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMembershipTransferPointsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMembershipTransferPointsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMembershipTransferPointsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMembershipTransferPointsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipTransferPointsLOVExecute(r)
}

/*
GetMembershipTransferPointsLOV Fetch List Of Values for Membership Transfer Points

 <p><strong>OperationId:</strong>getMembershipTransferPointsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch MembershipTransferPoints LOV
 @return ApiGetMembershipTransferPointsLOVRequest
*/
func (a *LOVApiService) GetMembershipTransferPointsLOV(ctx context.Context, profileId string) ApiGetMembershipTransferPointsLOVRequest {
	return ApiGetMembershipTransferPointsLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipTransferPointsLOVExecute(r ApiGetMembershipTransferPointsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipTransferPointsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/profiles/{profileId}/membershipTransferPoints"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMenuClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMenuClassesLOVRequest) Authorization(authorization string) ApiGetMenuClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMenuClassesLOVRequest) XAppKey(xAppKey string) ApiGetMenuClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMenuClassesLOVRequest) XHotelid(xHotelid string) ApiGetMenuClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMenuClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMenuClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMenuClassesLOVRequest) ParameterName(parameterName []string) ApiGetMenuClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMenuClassesLOVRequest) ParameterValue(parameterValue []string) ApiGetMenuClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMenuClassesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMenuClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMenuClassesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMenuClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMenuClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMenuClassesLOVExecute(r)
}

/*
GetMenuClassesLOV Fetch List Of Values for Menu Classes

 <p><strong>OperationId:</strong>getMenuClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MenuClasses LOV
 @return ApiGetMenuClassesLOVRequest
*/
func (a *LOVApiService) GetMenuClassesLOV(ctx context.Context, hotelId string) ApiGetMenuClassesLOVRequest {
	return ApiGetMenuClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMenuClassesLOVExecute(r ApiGetMenuClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMenuClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/menuClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMenuItemsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMenuItemsLOVRequest) Authorization(authorization string) ApiGetMenuItemsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMenuItemsLOVRequest) XAppKey(xAppKey string) ApiGetMenuItemsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMenuItemsLOVRequest) XHotelid(xHotelid string) ApiGetMenuItemsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMenuItemsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMenuItemsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMenuItemsLOVRequest) ParameterName(parameterName []string) ApiGetMenuItemsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMenuItemsLOVRequest) ParameterValue(parameterValue []string) ApiGetMenuItemsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMenuItemsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMenuItemsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMenuItemsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMenuItemsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMenuItemsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMenuItemsLOVExecute(r)
}

/*
GetMenuItemsLOV Fetch List Of Values for Menu Items

 <p><strong>OperationId:</strong>getMenuItemsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MenuItems LOV
 @return ApiGetMenuItemsLOVRequest
*/
func (a *LOVApiService) GetMenuItemsLOV(ctx context.Context, hotelId string) ApiGetMenuItemsLOVRequest {
	return ApiGetMenuItemsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMenuItemsLOVExecute(r ApiGetMenuItemsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMenuItemsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/menuItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMenuLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	menuClassId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMenuLOVRequest) Authorization(authorization string) ApiGetMenuLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMenuLOVRequest) XAppKey(xAppKey string) ApiGetMenuLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMenuLOVRequest) XHotelid(xHotelid string) ApiGetMenuLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetMenuLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetMenuLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetMenuLOVRequest) ParameterName(parameterName []string) ApiGetMenuLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetMenuLOVRequest) ParameterValue(parameterValue []string) ApiGetMenuLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetMenuLOVRequest) XExternalsystem(xExternalsystem string) ApiGetMenuLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMenuLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetMenuLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMenuLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMenuLOVExecute(r)
}

/*
GetMenuLOV Fetch List Of Values for Menu

 <p><strong>OperationId:</strong>getMenuLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param menuClassId Value of the parameter 'menuClassId' which is required to fetch Menu LOV
 @return ApiGetMenuLOVRequest
*/
func (a *LOVApiService) GetMenuLOV(ctx context.Context, menuClassId string) ApiGetMenuLOVRequest {
	return ApiGetMenuLOVRequest{
		ApiService: a,
		ctx: ctx,
		menuClassId: menuClassId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMenuLOVExecute(r ApiGetMenuLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMenuLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/menuClassId/{menuClassId}/menu"
	localVarPath = strings.Replace(localVarPath, "{"+"menuClassId"+"}", url.PathEscape(parameterValueToString(r.menuClassId, "menuClassId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.menuClassId) < 1 {
		return localVarReturnValue, nil, reportError("menuClassId must have at least 1 elements")
	}
	if strlen(r.menuClassId) > 2000 {
		return localVarReturnValue, nil, reportError("menuClassId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNegotiatedRateHotelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetNegotiatedRateHotelsLOVRequest) Authorization(authorization string) ApiGetNegotiatedRateHotelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetNegotiatedRateHotelsLOVRequest) XAppKey(xAppKey string) ApiGetNegotiatedRateHotelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetNegotiatedRateHotelsLOVRequest) XHotelid(xHotelid string) ApiGetNegotiatedRateHotelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetNegotiatedRateHotelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetNegotiatedRateHotelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetNegotiatedRateHotelsLOVRequest) ParameterName(parameterName []string) ApiGetNegotiatedRateHotelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetNegotiatedRateHotelsLOVRequest) ParameterValue(parameterValue []string) ApiGetNegotiatedRateHotelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetNegotiatedRateHotelsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetNegotiatedRateHotelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetNegotiatedRateHotelsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetNegotiatedRateHotelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetNegotiatedRateHotelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetNegotiatedRateHotelsLOVExecute(r)
}

/*
GetNegotiatedRateHotelsLOV Fetch List Of Values for Negotiated Rate Hotels

 <p><strong>OperationId:</strong>getNegotiatedRateHotelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch NegotiatedRateHotels LOV
 @return ApiGetNegotiatedRateHotelsLOVRequest
*/
func (a *LOVApiService) GetNegotiatedRateHotelsLOV(ctx context.Context, profileId string) ApiGetNegotiatedRateHotelsLOVRequest {
	return ApiGetNegotiatedRateHotelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetNegotiatedRateHotelsLOVExecute(r ApiGetNegotiatedRateHotelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetNegotiatedRateHotelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/profiles/{profileId}/negotiatedRateHotels"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNegotiatedRatesHotelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	rateCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetNegotiatedRatesHotelsLOVRequest) Authorization(authorization string) ApiGetNegotiatedRatesHotelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetNegotiatedRatesHotelsLOVRequest) XAppKey(xAppKey string) ApiGetNegotiatedRatesHotelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetNegotiatedRatesHotelsLOVRequest) XHotelid(xHotelid string) ApiGetNegotiatedRatesHotelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetNegotiatedRatesHotelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetNegotiatedRatesHotelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetNegotiatedRatesHotelsLOVRequest) ParameterName(parameterName []string) ApiGetNegotiatedRatesHotelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetNegotiatedRatesHotelsLOVRequest) ParameterValue(parameterValue []string) ApiGetNegotiatedRatesHotelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetNegotiatedRatesHotelsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetNegotiatedRatesHotelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetNegotiatedRatesHotelsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetNegotiatedRatesHotelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetNegotiatedRatesHotelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetNegotiatedRatesHotelsLOVExecute(r)
}

/*
GetNegotiatedRatesHotelsLOV Fetch List Of Values for Negotiated Rates Hotels

 <p><strong>OperationId:</strong>getNegotiatedRatesHotelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch NegotiatedRatesHotels LOV
 @param rateCode Value of the parameter 'rateCode' which is required to fetch NegotiatedRatesHotels LOV
 @return ApiGetNegotiatedRatesHotelsLOVRequest
*/
func (a *LOVApiService) GetNegotiatedRatesHotelsLOV(ctx context.Context, profileId string, rateCode string) ApiGetNegotiatedRatesHotelsLOVRequest {
	return ApiGetNegotiatedRatesHotelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		rateCode: rateCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetNegotiatedRatesHotelsLOVExecute(r ApiGetNegotiatedRatesHotelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetNegotiatedRatesHotelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/rateCode/{rateCode}/profiles/{profileId}/negotiatedRatesHotels"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNoteTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	departmentType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetNoteTypesLOVRequest) Authorization(authorization string) ApiGetNoteTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetNoteTypesLOVRequest) XAppKey(xAppKey string) ApiGetNoteTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetNoteTypesLOVRequest) XHotelid(xHotelid string) ApiGetNoteTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetNoteTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetNoteTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetNoteTypesLOVRequest) ParameterName(parameterName []string) ApiGetNoteTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetNoteTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetNoteTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetNoteTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetNoteTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetNoteTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetNoteTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetNoteTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetNoteTypesLOVExecute(r)
}

/*
GetNoteTypesLOV Fetch List Of Values for Note Types

 <p><strong>OperationId:</strong>getNoteTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departmentType Value of the parameter 'departmentType' which is required to fetch NoteTypes LOV
 @return ApiGetNoteTypesLOVRequest
*/
func (a *LOVApiService) GetNoteTypesLOV(ctx context.Context, departmentType string) ApiGetNoteTypesLOVRequest {
	return ApiGetNoteTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		departmentType: departmentType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetNoteTypesLOVExecute(r ApiGetNoteTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetNoteTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/departments/{departmentType}/noteTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"departmentType"+"}", url.PathEscape(parameterValueToString(r.departmentType, "departmentType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departmentType) < 1 {
		return localVarReturnValue, nil, reportError("departmentType must have at least 1 elements")
	}
	if strlen(r.departmentType) > 2000 {
		return localVarReturnValue, nil, reportError("departmentType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOSAActivityTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetOSAActivityTypesLOVRequest) Authorization(authorization string) ApiGetOSAActivityTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetOSAActivityTypesLOVRequest) XAppKey(xAppKey string) ApiGetOSAActivityTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetOSAActivityTypesLOVRequest) XHotelid(xHotelid string) ApiGetOSAActivityTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetOSAActivityTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetOSAActivityTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetOSAActivityTypesLOVRequest) ParameterName(parameterName []string) ApiGetOSAActivityTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetOSAActivityTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetOSAActivityTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetOSAActivityTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetOSAActivityTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetOSAActivityTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetOSAActivityTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetOSAActivityTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetOSAActivityTypesLOVExecute(r)
}

/*
GetOSAActivityTypesLOV Fetch List Of Values for OSAActivity Types

 <p><strong>OperationId:</strong>getOSAActivityTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch OSAActivityTypes LOV
 @return ApiGetOSAActivityTypesLOVRequest
*/
func (a *LOVApiService) GetOSAActivityTypesLOV(ctx context.Context, hotelId string) ApiGetOSAActivityTypesLOVRequest {
	return ApiGetOSAActivityTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetOSAActivityTypesLOVExecute(r ApiGetOSAActivityTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetOSAActivityTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/osaActivityTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOXIInterfaceReferencesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetOXIInterfaceReferencesLOVRequest) Authorization(authorization string) ApiGetOXIInterfaceReferencesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetOXIInterfaceReferencesLOVRequest) XAppKey(xAppKey string) ApiGetOXIInterfaceReferencesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetOXIInterfaceReferencesLOVRequest) XHotelid(xHotelid string) ApiGetOXIInterfaceReferencesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetOXIInterfaceReferencesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetOXIInterfaceReferencesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetOXIInterfaceReferencesLOVRequest) ParameterName(parameterName []string) ApiGetOXIInterfaceReferencesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetOXIInterfaceReferencesLOVRequest) ParameterValue(parameterValue []string) ApiGetOXIInterfaceReferencesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetOXIInterfaceReferencesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetOXIInterfaceReferencesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetOXIInterfaceReferencesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetOXIInterfaceReferencesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetOXIInterfaceReferencesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetOXIInterfaceReferencesLOVExecute(r)
}

/*
GetOXIInterfaceReferencesLOV Fetch List Of Values for OXIInterface References

 <p><strong>OperationId:</strong>getOXIInterfaceReferencesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch OXIInterfaceReferences LOV
 @return ApiGetOXIInterfaceReferencesLOVRequest
*/
func (a *LOVApiService) GetOXIInterfaceReferencesLOV(ctx context.Context, hotelId string) ApiGetOXIInterfaceReferencesLOVRequest {
	return ApiGetOXIInterfaceReferencesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetOXIInterfaceReferencesLOVExecute(r ApiGetOXIInterfaceReferencesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetOXIInterfaceReferencesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/oxiInterfaceReferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOXIInterfaceResortsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetOXIInterfaceResortsLOVRequest) Authorization(authorization string) ApiGetOXIInterfaceResortsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetOXIInterfaceResortsLOVRequest) XAppKey(xAppKey string) ApiGetOXIInterfaceResortsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetOXIInterfaceResortsLOVRequest) XHotelid(xHotelid string) ApiGetOXIInterfaceResortsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetOXIInterfaceResortsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetOXIInterfaceResortsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetOXIInterfaceResortsLOVRequest) ParameterName(parameterName []string) ApiGetOXIInterfaceResortsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetOXIInterfaceResortsLOVRequest) ParameterValue(parameterValue []string) ApiGetOXIInterfaceResortsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetOXIInterfaceResortsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetOXIInterfaceResortsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetOXIInterfaceResortsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetOXIInterfaceResortsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetOXIInterfaceResortsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetOXIInterfaceResortsLOVExecute(r)
}

/*
GetOXIInterfaceResortsLOV Fetch List Of Values for OXIInterface Resorts

 <p><strong>OperationId:</strong>getOXIInterfaceResortsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch OXIInterfaceResorts LOV
 @return ApiGetOXIInterfaceResortsLOVRequest
*/
func (a *LOVApiService) GetOXIInterfaceResortsLOV(ctx context.Context, hotelId string) ApiGetOXIInterfaceResortsLOVRequest {
	return ApiGetOXIInterfaceResortsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetOXIInterfaceResortsLOVExecute(r ApiGetOXIInterfaceResortsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetOXIInterfaceResortsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/oxiInterfaceResorts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOXIInterfacesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetOXIInterfacesLOVRequest) Authorization(authorization string) ApiGetOXIInterfacesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetOXIInterfacesLOVRequest) XAppKey(xAppKey string) ApiGetOXIInterfacesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetOXIInterfacesLOVRequest) XHotelid(xHotelid string) ApiGetOXIInterfacesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetOXIInterfacesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetOXIInterfacesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetOXIInterfacesLOVRequest) ParameterName(parameterName []string) ApiGetOXIInterfacesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetOXIInterfacesLOVRequest) ParameterValue(parameterValue []string) ApiGetOXIInterfacesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetOXIInterfacesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetOXIInterfacesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetOXIInterfacesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetOXIInterfacesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetOXIInterfacesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetOXIInterfacesLOVExecute(r)
}

/*
GetOXIInterfacesLOV Fetch List Of Values for OXIInterfaces

 <p><strong>OperationId:</strong>getOXIInterfacesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch OXIInterfaces LOV
 @return ApiGetOXIInterfacesLOVRequest
*/
func (a *LOVApiService) GetOXIInterfacesLOV(ctx context.Context, hotelId string) ApiGetOXIInterfacesLOVRequest {
	return ApiGetOXIInterfacesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetOXIInterfacesLOVExecute(r ApiGetOXIInterfacesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetOXIInterfacesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/oxiInterfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOXIResortsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	interfaceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetOXIResortsLOVRequest) Authorization(authorization string) ApiGetOXIResortsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetOXIResortsLOVRequest) XAppKey(xAppKey string) ApiGetOXIResortsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetOXIResortsLOVRequest) XHotelid(xHotelid string) ApiGetOXIResortsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetOXIResortsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetOXIResortsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetOXIResortsLOVRequest) ParameterName(parameterName []string) ApiGetOXIResortsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetOXIResortsLOVRequest) ParameterValue(parameterValue []string) ApiGetOXIResortsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetOXIResortsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetOXIResortsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetOXIResortsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetOXIResortsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetOXIResortsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetOXIResortsLOVExecute(r)
}

/*
GetOXIResortsLOV Fetch List Of Values for OXIResorts

 <p><strong>OperationId:</strong>getOXIResortsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Value of the parameter 'interfaceId' which is required to fetch OXIResorts LOV
 @return ApiGetOXIResortsLOVRequest
*/
func (a *LOVApiService) GetOXIResortsLOV(ctx context.Context, interfaceId string) ApiGetOXIResortsLOVRequest {
	return ApiGetOXIResortsLOVRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetOXIResortsLOVExecute(r ApiGetOXIResortsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetOXIResortsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/interfaceId/{interfaceId}/oxiResorts"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganizationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	actionTask string
	chainCode string
	roles string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetOrganizationsLOVRequest) Authorization(authorization string) ApiGetOrganizationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetOrganizationsLOVRequest) XAppKey(xAppKey string) ApiGetOrganizationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetOrganizationsLOVRequest) XHotelid(xHotelid string) ApiGetOrganizationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetOrganizationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetOrganizationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetOrganizationsLOVRequest) ParameterName(parameterName []string) ApiGetOrganizationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetOrganizationsLOVRequest) ParameterValue(parameterValue []string) ApiGetOrganizationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetOrganizationsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetOrganizationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetOrganizationsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetOrganizationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetOrganizationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetOrganizationsLOVExecute(r)
}

/*
GetOrganizationsLOV Fetch List Of Values for Organizations

 <p><strong>OperationId:</strong>getOrganizationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionTask Value of the parameter 'actionTask' which is required to fetch Organizations LOV
 @param chainCode Value of the parameter 'chainCode' which is required to fetch Organizations LOV
 @param roles Value of the parameter 'roles' which is required to fetch Organizations LOV
 @return ApiGetOrganizationsLOVRequest
*/
func (a *LOVApiService) GetOrganizationsLOV(ctx context.Context, actionTask string, chainCode string, roles string) ApiGetOrganizationsLOVRequest {
	return ApiGetOrganizationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		actionTask: actionTask,
		chainCode: chainCode,
		roles: roles,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetOrganizationsLOVExecute(r ApiGetOrganizationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetOrganizationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/roles/{roles}/chainCode/{chainCode}/actionTask/{actionTask}/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"actionTask"+"}", url.PathEscape(parameterValueToString(r.actionTask, "actionTask")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roles"+"}", url.PathEscape(parameterValueToString(r.roles, "roles")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.actionTask) < 1 {
		return localVarReturnValue, nil, reportError("actionTask must have at least 1 elements")
	}
	if strlen(r.actionTask) > 2000 {
		return localVarReturnValue, nil, reportError("actionTask must have less than 2000 elements")
	}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}
	if strlen(r.roles) < 1 {
		return localVarReturnValue, nil, reportError("roles must have at least 1 elements")
	}
	if strlen(r.roles) > 2000 {
		return localVarReturnValue, nil, reportError("roles must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPackForecastGroupCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPackForecastGroupCodeLOVRequest) Authorization(authorization string) ApiGetPackForecastGroupCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPackForecastGroupCodeLOVRequest) XAppKey(xAppKey string) ApiGetPackForecastGroupCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPackForecastGroupCodeLOVRequest) XHotelid(xHotelid string) ApiGetPackForecastGroupCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPackForecastGroupCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPackForecastGroupCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPackForecastGroupCodeLOVRequest) ParameterName(parameterName []string) ApiGetPackForecastGroupCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPackForecastGroupCodeLOVRequest) ParameterValue(parameterValue []string) ApiGetPackForecastGroupCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPackForecastGroupCodeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPackForecastGroupCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPackForecastGroupCodeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPackForecastGroupCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPackForecastGroupCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPackForecastGroupCodeLOVExecute(r)
}

/*
GetPackForecastGroupCodeLOV Fetch List Of Values for Pack Forecast Group Code

 <p><strong>OperationId:</strong>getPackForecastGroupCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PackForecastGroupCode LOV
 @return ApiGetPackForecastGroupCodeLOVRequest
*/
func (a *LOVApiService) GetPackForecastGroupCodeLOV(ctx context.Context, hotelId string) ApiGetPackForecastGroupCodeLOVRequest {
	return ApiGetPackForecastGroupCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPackForecastGroupCodeLOVExecute(r ApiGetPackForecastGroupCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPackForecastGroupCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/packForecastGroupCode"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPackageArrangementAssociationLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	arrangementCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPackageArrangementAssociationLOVRequest) Authorization(authorization string) ApiGetPackageArrangementAssociationLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPackageArrangementAssociationLOVRequest) XAppKey(xAppKey string) ApiGetPackageArrangementAssociationLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPackageArrangementAssociationLOVRequest) XHotelid(xHotelid string) ApiGetPackageArrangementAssociationLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPackageArrangementAssociationLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPackageArrangementAssociationLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPackageArrangementAssociationLOVRequest) ParameterName(parameterName []string) ApiGetPackageArrangementAssociationLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPackageArrangementAssociationLOVRequest) ParameterValue(parameterValue []string) ApiGetPackageArrangementAssociationLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPackageArrangementAssociationLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPackageArrangementAssociationLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPackageArrangementAssociationLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPackageArrangementAssociationLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPackageArrangementAssociationLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPackageArrangementAssociationLOVExecute(r)
}

/*
GetPackageArrangementAssociationLOV Fetch List Of Values for Package Arrangement Association

 <p><strong>OperationId:</strong>getPackageArrangementAssociationLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param arrangementCode Value of the parameter 'arrangementCode' which is required to fetch PackageArrangementAssociation LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PackageArrangementAssociation LOV
 @return ApiGetPackageArrangementAssociationLOVRequest
*/
func (a *LOVApiService) GetPackageArrangementAssociationLOV(ctx context.Context, arrangementCode string, hotelId string) ApiGetPackageArrangementAssociationLOVRequest {
	return ApiGetPackageArrangementAssociationLOVRequest{
		ApiService: a,
		ctx: ctx,
		arrangementCode: arrangementCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPackageArrangementAssociationLOVExecute(r ApiGetPackageArrangementAssociationLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPackageArrangementAssociationLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arrangementCode/{arrangementCode}/packageArrangementAssociation"
	localVarPath = strings.Replace(localVarPath, "{"+"arrangementCode"+"}", url.PathEscape(parameterValueToString(r.arrangementCode, "arrangementCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.arrangementCode) < 1 {
		return localVarReturnValue, nil, reportError("arrangementCode must have at least 1 elements")
	}
	if strlen(r.arrangementCode) > 2000 {
		return localVarReturnValue, nil, reportError("arrangementCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetParameterActiveUnderChainLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	chainCode string
	parameter string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetParameterActiveUnderChainLOVRequest) Authorization(authorization string) ApiGetParameterActiveUnderChainLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetParameterActiveUnderChainLOVRequest) XAppKey(xAppKey string) ApiGetParameterActiveUnderChainLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetParameterActiveUnderChainLOVRequest) XHotelid(xHotelid string) ApiGetParameterActiveUnderChainLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetParameterActiveUnderChainLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetParameterActiveUnderChainLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetParameterActiveUnderChainLOVRequest) ParameterName(parameterName []string) ApiGetParameterActiveUnderChainLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetParameterActiveUnderChainLOVRequest) ParameterValue(parameterValue []string) ApiGetParameterActiveUnderChainLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetParameterActiveUnderChainLOVRequest) XExternalsystem(xExternalsystem string) ApiGetParameterActiveUnderChainLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetParameterActiveUnderChainLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetParameterActiveUnderChainLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetParameterActiveUnderChainLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetParameterActiveUnderChainLOVExecute(r)
}

/*
GetParameterActiveUnderChainLOV Fetch List Of Values for Parameter Active Under Chain

 <p><strong>OperationId:</strong>getParameterActiveUnderChainLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainCode Value of the parameter 'chainCode' which is required to fetch ParameterActiveUnderChain LOV
 @param parameter Value of the parameter 'parameter' which is required to fetch ParameterActiveUnderChain LOV
 @return ApiGetParameterActiveUnderChainLOVRequest
*/
func (a *LOVApiService) GetParameterActiveUnderChainLOV(ctx context.Context, chainCode string, parameter string) ApiGetParameterActiveUnderChainLOVRequest {
	return ApiGetParameterActiveUnderChainLOVRequest{
		ApiService: a,
		ctx: ctx,
		chainCode: chainCode,
		parameter: parameter,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetParameterActiveUnderChainLOVExecute(r ApiGetParameterActiveUnderChainLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetParameterActiveUnderChainLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/parameterName/{parameter}/chainCode/{chainCode}/parameterActiveUnderChain"
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parameter"+"}", url.PathEscape(parameterValueToString(r.parameter, "parameter")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}
	if strlen(r.parameter) < 1 {
		return localVarReturnValue, nil, reportError("parameter must have at least 1 elements")
	}
	if strlen(r.parameter) > 2000 {
		return localVarReturnValue, nil, reportError("parameter must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPaymentMethodsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPaymentMethodsLOVRequest) Authorization(authorization string) ApiGetPaymentMethodsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPaymentMethodsLOVRequest) XAppKey(xAppKey string) ApiGetPaymentMethodsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPaymentMethodsLOVRequest) XHotelid(xHotelid string) ApiGetPaymentMethodsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPaymentMethodsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPaymentMethodsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPaymentMethodsLOVRequest) ParameterName(parameterName []string) ApiGetPaymentMethodsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPaymentMethodsLOVRequest) ParameterValue(parameterValue []string) ApiGetPaymentMethodsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPaymentMethodsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPaymentMethodsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPaymentMethodsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPaymentMethodsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPaymentMethodsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPaymentMethodsLOVExecute(r)
}

/*
GetPaymentMethodsLOV Fetch List Of Values for Payment Methods

 <p><strong>OperationId:</strong>getPaymentMethodsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PaymentMethods LOV
 @return ApiGetPaymentMethodsLOVRequest
*/
func (a *LOVApiService) GetPaymentMethodsLOV(ctx context.Context, hotelId string) ApiGetPaymentMethodsLOVRequest {
	return ApiGetPaymentMethodsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPaymentMethodsLOVExecute(r ApiGetPaymentMethodsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPaymentMethodsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/paymentMethods"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPaymentTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPaymentTypesLOVRequest) Authorization(authorization string) ApiGetPaymentTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPaymentTypesLOVRequest) XAppKey(xAppKey string) ApiGetPaymentTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPaymentTypesLOVRequest) XHotelid(xHotelid string) ApiGetPaymentTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPaymentTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPaymentTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPaymentTypesLOVRequest) ParameterName(parameterName []string) ApiGetPaymentTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPaymentTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetPaymentTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPaymentTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPaymentTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPaymentTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPaymentTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPaymentTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPaymentTypesLOVExecute(r)
}

/*
GetPaymentTypesLOV Fetch List Of Values for Payment Types

 <p><strong>OperationId:</strong>getPaymentTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PaymentTypes LOV
 @return ApiGetPaymentTypesLOVRequest
*/
func (a *LOVApiService) GetPaymentTypesLOV(ctx context.Context, hotelId string) ApiGetPaymentTypesLOVRequest {
	return ApiGetPaymentTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPaymentTypesLOVExecute(r ApiGetPaymentTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPaymentTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/paymentTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPeriodSetupLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPeriodSetupLOVRequest) Authorization(authorization string) ApiGetPeriodSetupLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPeriodSetupLOVRequest) XAppKey(xAppKey string) ApiGetPeriodSetupLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPeriodSetupLOVRequest) XHotelid(xHotelid string) ApiGetPeriodSetupLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPeriodSetupLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPeriodSetupLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPeriodSetupLOVRequest) ParameterName(parameterName []string) ApiGetPeriodSetupLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPeriodSetupLOVRequest) ParameterValue(parameterValue []string) ApiGetPeriodSetupLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPeriodSetupLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPeriodSetupLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPeriodSetupLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPeriodSetupLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPeriodSetupLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPeriodSetupLOVExecute(r)
}

/*
GetPeriodSetupLOV Fetch List Of Values for Period Setup

 <p><strong>OperationId:</strong>getPeriodSetupLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PeriodSetup LOV
 @return ApiGetPeriodSetupLOVRequest
*/
func (a *LOVApiService) GetPeriodSetupLOV(ctx context.Context, hotelId string) ApiGetPeriodSetupLOVRequest {
	return ApiGetPeriodSetupLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPeriodSetupLOVExecute(r ApiGetPeriodSetupLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPeriodSetupLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/periodSetup"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPeriodsSetupLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPeriodsSetupLOVRequest) Authorization(authorization string) ApiGetPeriodsSetupLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPeriodsSetupLOVRequest) XAppKey(xAppKey string) ApiGetPeriodsSetupLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPeriodsSetupLOVRequest) XHotelid(xHotelid string) ApiGetPeriodsSetupLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPeriodsSetupLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPeriodsSetupLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPeriodsSetupLOVRequest) ParameterName(parameterName []string) ApiGetPeriodsSetupLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPeriodsSetupLOVRequest) ParameterValue(parameterValue []string) ApiGetPeriodsSetupLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPeriodsSetupLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPeriodsSetupLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPeriodsSetupLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPeriodsSetupLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPeriodsSetupLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPeriodsSetupLOVExecute(r)
}

/*
GetPeriodsSetupLOV Fetch List Of Values for Periods Setup

 <p><strong>OperationId:</strong>getPeriodsSetupLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PeriodsSetup LOV
 @return ApiGetPeriodsSetupLOVRequest
*/
func (a *LOVApiService) GetPeriodsSetupLOV(ctx context.Context, hotelId string) ApiGetPeriodsSetupLOVRequest {
	return ApiGetPeriodsSetupLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPeriodsSetupLOVExecute(r ApiGetPeriodsSetupLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPeriodsSetupLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/periodsSetup"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPostalCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	country string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPostalCodesLOVRequest) Authorization(authorization string) ApiGetPostalCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPostalCodesLOVRequest) XAppKey(xAppKey string) ApiGetPostalCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPostalCodesLOVRequest) XHotelid(xHotelid string) ApiGetPostalCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPostalCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPostalCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPostalCodesLOVRequest) ParameterName(parameterName []string) ApiGetPostalCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPostalCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetPostalCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPostalCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPostalCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPostalCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPostalCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPostalCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPostalCodesLOVExecute(r)
}

/*
GetPostalCodesLOV Fetch List Of Values for Postal Codes

 <p><strong>OperationId:</strong>getPostalCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param country Value of the parameter 'country' which is required to fetch PostalCodes LOV
 @return ApiGetPostalCodesLOVRequest
*/
func (a *LOVApiService) GetPostalCodesLOV(ctx context.Context, country string) ApiGetPostalCodesLOVRequest {
	return ApiGetPostalCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		country: country,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPostalCodesLOVExecute(r ApiGetPostalCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPostalCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/country/{country}/postalCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", url.PathEscape(parameterValueToString(r.country, "country")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.country) < 1 {
		return localVarReturnValue, nil, reportError("country must have at least 1 elements")
	}
	if strlen(r.country) > 2000 {
		return localVarReturnValue, nil, reportError("country must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPostingRoomLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPostingRoomLOVRequest) Authorization(authorization string) ApiGetPostingRoomLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPostingRoomLOVRequest) XAppKey(xAppKey string) ApiGetPostingRoomLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPostingRoomLOVRequest) XHotelid(xHotelid string) ApiGetPostingRoomLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPostingRoomLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPostingRoomLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPostingRoomLOVRequest) ParameterName(parameterName []string) ApiGetPostingRoomLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPostingRoomLOVRequest) ParameterValue(parameterValue []string) ApiGetPostingRoomLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPostingRoomLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPostingRoomLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPostingRoomLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPostingRoomLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPostingRoomLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPostingRoomLOVExecute(r)
}

/*
GetPostingRoomLOV Fetch List Of Values for Posting Room

 <p><strong>OperationId:</strong>getPostingRoomLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PostingRoom LOV
 @return ApiGetPostingRoomLOVRequest
*/
func (a *LOVApiService) GetPostingRoomLOV(ctx context.Context, hotelId string) ApiGetPostingRoomLOVRequest {
	return ApiGetPostingRoomLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPostingRoomLOVExecute(r ApiGetPostingRoomLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPostingRoomLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/postingRoom"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPostingTransactionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPostingTransactionCodesLOVRequest) Authorization(authorization string) ApiGetPostingTransactionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPostingTransactionCodesLOVRequest) XAppKey(xAppKey string) ApiGetPostingTransactionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPostingTransactionCodesLOVRequest) XHotelid(xHotelid string) ApiGetPostingTransactionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPostingTransactionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPostingTransactionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPostingTransactionCodesLOVRequest) ParameterName(parameterName []string) ApiGetPostingTransactionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPostingTransactionCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetPostingTransactionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPostingTransactionCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPostingTransactionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPostingTransactionCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPostingTransactionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPostingTransactionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPostingTransactionCodesLOVExecute(r)
}

/*
GetPostingTransactionCodesLOV Fetch List Of Values for Posting Transaction Codes

 <p><strong>OperationId:</strong>getPostingTransactionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PostingTransactionCodes LOV
 @return ApiGetPostingTransactionCodesLOVRequest
*/
func (a *LOVApiService) GetPostingTransactionCodesLOV(ctx context.Context, hotelId string) ApiGetPostingTransactionCodesLOVRequest {
	return ApiGetPostingTransactionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPostingTransactionCodesLOVExecute(r ApiGetPostingTransactionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPostingTransactionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/postingTransactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPreferenceSubgroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	preferenceGroup string
	chainCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPreferenceSubgroupsLOVRequest) Authorization(authorization string) ApiGetPreferenceSubgroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPreferenceSubgroupsLOVRequest) XAppKey(xAppKey string) ApiGetPreferenceSubgroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPreferenceSubgroupsLOVRequest) XHotelid(xHotelid string) ApiGetPreferenceSubgroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPreferenceSubgroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPreferenceSubgroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPreferenceSubgroupsLOVRequest) ParameterName(parameterName []string) ApiGetPreferenceSubgroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPreferenceSubgroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetPreferenceSubgroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPreferenceSubgroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPreferenceSubgroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPreferenceSubgroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPreferenceSubgroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPreferenceSubgroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPreferenceSubgroupsLOVExecute(r)
}

/*
GetPreferenceSubgroupsLOV Fetch List Of Values for Preference Subgroups

 <p><strong>OperationId:</strong>getPreferenceSubgroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param preferenceGroup Value of the parameter 'preferenceGroup' which is required to fetch PreferenceSubgroups LOV
 @param chainCode Value of the parameter 'chainCode' which is required to fetch PreferenceSubgroups LOV
 @return ApiGetPreferenceSubgroupsLOVRequest
*/
func (a *LOVApiService) GetPreferenceSubgroupsLOV(ctx context.Context, preferenceGroup string, chainCode string) ApiGetPreferenceSubgroupsLOVRequest {
	return ApiGetPreferenceSubgroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		preferenceGroup: preferenceGroup,
		chainCode: chainCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPreferenceSubgroupsLOVExecute(r ApiGetPreferenceSubgroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPreferenceSubgroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/chainCode/{chainCode}/preferenceGroup/{preferenceGroup}/preferenceSubgroups"
	localVarPath = strings.Replace(localVarPath, "{"+"preferenceGroup"+"}", url.PathEscape(parameterValueToString(r.preferenceGroup, "preferenceGroup")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.preferenceGroup) < 1 {
		return localVarReturnValue, nil, reportError("preferenceGroup must have at least 1 elements")
	}
	if strlen(r.preferenceGroup) > 2000 {
		return localVarReturnValue, nil, reportError("preferenceGroup must have less than 2000 elements")
	}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPreferencesMultiHotelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	preferenceGroup string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPreferencesMultiHotelsLOVRequest) Authorization(authorization string) ApiGetPreferencesMultiHotelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPreferencesMultiHotelsLOVRequest) XAppKey(xAppKey string) ApiGetPreferencesMultiHotelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPreferencesMultiHotelsLOVRequest) XHotelid(xHotelid string) ApiGetPreferencesMultiHotelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPreferencesMultiHotelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPreferencesMultiHotelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPreferencesMultiHotelsLOVRequest) ParameterName(parameterName []string) ApiGetPreferencesMultiHotelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPreferencesMultiHotelsLOVRequest) ParameterValue(parameterValue []string) ApiGetPreferencesMultiHotelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPreferencesMultiHotelsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPreferencesMultiHotelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPreferencesMultiHotelsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPreferencesMultiHotelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPreferencesMultiHotelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPreferencesMultiHotelsLOVExecute(r)
}

/*
GetPreferencesMultiHotelsLOV Fetch List Of Values for Preferences Multi Hotels

 <p><strong>OperationId:</strong>getPreferencesMultiHotelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param preferenceGroup Value of the parameter 'preferenceGroup' which is required to fetch PreferencesMultiHotels LOV
 @return ApiGetPreferencesMultiHotelsLOVRequest
*/
func (a *LOVApiService) GetPreferencesMultiHotelsLOV(ctx context.Context, preferenceGroup string) ApiGetPreferencesMultiHotelsLOVRequest {
	return ApiGetPreferencesMultiHotelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		preferenceGroup: preferenceGroup,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPreferencesMultiHotelsLOVExecute(r ApiGetPreferencesMultiHotelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPreferencesMultiHotelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/preferenceGroup/{preferenceGroup}/preferencesMultiHotels"
	localVarPath = strings.Replace(localVarPath, "{"+"preferenceGroup"+"}", url.PathEscape(parameterValueToString(r.preferenceGroup, "preferenceGroup")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.preferenceGroup) < 1 {
		return localVarReturnValue, nil, reportError("preferenceGroup must have at least 1 elements")
	}
	if strlen(r.preferenceGroup) > 2000 {
		return localVarReturnValue, nil, reportError("preferenceGroup must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPrepaidCardInterfacesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPrepaidCardInterfacesLOVRequest) Authorization(authorization string) ApiGetPrepaidCardInterfacesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPrepaidCardInterfacesLOVRequest) XAppKey(xAppKey string) ApiGetPrepaidCardInterfacesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPrepaidCardInterfacesLOVRequest) XHotelid(xHotelid string) ApiGetPrepaidCardInterfacesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPrepaidCardInterfacesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPrepaidCardInterfacesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPrepaidCardInterfacesLOVRequest) ParameterName(parameterName []string) ApiGetPrepaidCardInterfacesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPrepaidCardInterfacesLOVRequest) ParameterValue(parameterValue []string) ApiGetPrepaidCardInterfacesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPrepaidCardInterfacesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPrepaidCardInterfacesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPrepaidCardInterfacesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPrepaidCardInterfacesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPrepaidCardInterfacesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPrepaidCardInterfacesLOVExecute(r)
}

/*
GetPrepaidCardInterfacesLOV Fetch List Of Values for Prepaid Card Interfaces

 <p><strong>OperationId:</strong>getPrepaidCardInterfacesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PrepaidCardInterfaces LOV
 @return ApiGetPrepaidCardInterfacesLOVRequest
*/
func (a *LOVApiService) GetPrepaidCardInterfacesLOV(ctx context.Context, hotelId string) ApiGetPrepaidCardInterfacesLOVRequest {
	return ApiGetPrepaidCardInterfacesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPrepaidCardInterfacesLOVExecute(r ApiGetPrepaidCardInterfacesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPrepaidCardInterfacesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/prepaidCardInterfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPrintersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	alertPrinters string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPrintersLOVRequest) Authorization(authorization string) ApiGetPrintersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPrintersLOVRequest) XAppKey(xAppKey string) ApiGetPrintersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPrintersLOVRequest) XHotelid(xHotelid string) ApiGetPrintersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPrintersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPrintersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPrintersLOVRequest) ParameterName(parameterName []string) ApiGetPrintersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPrintersLOVRequest) ParameterValue(parameterValue []string) ApiGetPrintersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPrintersLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPrintersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPrintersLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPrintersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPrintersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPrintersLOVExecute(r)
}

/*
GetPrintersLOV Fetch List Of Values for Printers

 <p><strong>OperationId:</strong>getPrintersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertPrinters Value of the parameter 'alertPrinters' which is required to fetch Printers LOV
 @return ApiGetPrintersLOVRequest
*/
func (a *LOVApiService) GetPrintersLOV(ctx context.Context, alertPrinters string) ApiGetPrintersLOVRequest {
	return ApiGetPrintersLOVRequest{
		ApiService: a,
		ctx: ctx,
		alertPrinters: alertPrinters,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPrintersLOVExecute(r ApiGetPrintersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPrintersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/alertPrinters/{alertPrinters}/printers"
	localVarPath = strings.Replace(localVarPath, "{"+"alertPrinters"+"}", url.PathEscape(parameterValueToString(r.alertPrinters, "alertPrinters")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.alertPrinters) < 1 {
		return localVarReturnValue, nil, reportError("alertPrinters must have at least 1 elements")
	}
	if strlen(r.alertPrinters) > 2000 {
		return localVarReturnValue, nil, reportError("alertPrinters must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPrioritiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPrioritiesLOVRequest) Authorization(authorization string) ApiGetPrioritiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPrioritiesLOVRequest) XAppKey(xAppKey string) ApiGetPrioritiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPrioritiesLOVRequest) XHotelid(xHotelid string) ApiGetPrioritiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPrioritiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPrioritiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPrioritiesLOVRequest) ParameterName(parameterName []string) ApiGetPrioritiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPrioritiesLOVRequest) ParameterValue(parameterValue []string) ApiGetPrioritiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPrioritiesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPrioritiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPrioritiesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPrioritiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPrioritiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPrioritiesLOVExecute(r)
}

/*
GetPrioritiesLOV Fetch List Of Values for Priorities

 <p><strong>OperationId:</strong>getPrioritiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Priorities LOV
 @return ApiGetPrioritiesLOVRequest
*/
func (a *LOVApiService) GetPrioritiesLOV(ctx context.Context, hotelId string) ApiGetPrioritiesLOVRequest {
	return ApiGetPrioritiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPrioritiesLOVExecute(r ApiGetPrioritiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPrioritiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/priorities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileCommunicationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileCommunicationsLOVRequest) Authorization(authorization string) ApiGetProfileCommunicationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileCommunicationsLOVRequest) XAppKey(xAppKey string) ApiGetProfileCommunicationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileCommunicationsLOVRequest) XHotelid(xHotelid string) ApiGetProfileCommunicationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetProfileCommunicationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetProfileCommunicationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetProfileCommunicationsLOVRequest) ParameterName(parameterName []string) ApiGetProfileCommunicationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetProfileCommunicationsLOVRequest) ParameterValue(parameterValue []string) ApiGetProfileCommunicationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetProfileCommunicationsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetProfileCommunicationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileCommunicationsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileCommunicationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileCommunicationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileCommunicationsLOVExecute(r)
}

/*
GetProfileCommunicationsLOV Fetch List Of Values for Profile Communications

 <p><strong>OperationId:</strong>getProfileCommunicationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch ProfileCommunications LOV
 @return ApiGetProfileCommunicationsLOVRequest
*/
func (a *LOVApiService) GetProfileCommunicationsLOV(ctx context.Context, profileId string) ApiGetProfileCommunicationsLOVRequest {
	return ApiGetProfileCommunicationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileCommunicationsLOVExecute(r ApiGetProfileCommunicationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileCommunicationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/profiles/{profileId}/profileCommunications"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileEnrollmentMatchCriteriaLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	nameType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileEnrollmentMatchCriteriaLOVRequest) Authorization(authorization string) ApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileEnrollmentMatchCriteriaLOVRequest) XAppKey(xAppKey string) ApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileEnrollmentMatchCriteriaLOVRequest) XHotelid(xHotelid string) ApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetProfileEnrollmentMatchCriteriaLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetProfileEnrollmentMatchCriteriaLOVRequest) ParameterName(parameterName []string) ApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetProfileEnrollmentMatchCriteriaLOVRequest) ParameterValue(parameterValue []string) ApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetProfileEnrollmentMatchCriteriaLOVRequest) XExternalsystem(xExternalsystem string) ApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileEnrollmentMatchCriteriaLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileEnrollmentMatchCriteriaLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileEnrollmentMatchCriteriaLOVExecute(r)
}

/*
GetProfileEnrollmentMatchCriteriaLOV Fetch List Of Values for Profile Enrollment Match Criteria

 <p><strong>OperationId:</strong>getProfileEnrollmentMatchCriteriaLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameType Value of the parameter 'nameType' which is required to fetch ProfileEnrollmentMatchCriteria LOV
 @return ApiGetProfileEnrollmentMatchCriteriaLOVRequest
*/
func (a *LOVApiService) GetProfileEnrollmentMatchCriteriaLOV(ctx context.Context, nameType string) ApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	return ApiGetProfileEnrollmentMatchCriteriaLOVRequest{
		ApiService: a,
		ctx: ctx,
		nameType: nameType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileEnrollmentMatchCriteriaLOVExecute(r ApiGetProfileEnrollmentMatchCriteriaLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileEnrollmentMatchCriteriaLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/nameType/{nameType}/profileEnrollmentMatchCriteria"
	localVarPath = strings.Replace(localVarPath, "{"+"nameType"+"}", url.PathEscape(parameterValueToString(r.nameType, "nameType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.nameType) < 1 {
		return localVarReturnValue, nil, reportError("nameType must have at least 1 elements")
	}
	if strlen(r.nameType) > 2000 {
		return localVarReturnValue, nil, reportError("nameType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	nameType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) Authorization(authorization string) ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) XAppKey(xAppKey string) ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) XHotelid(xHotelid string) ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) ParameterName(parameterName []string) ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) ParameterValue(parameterValue []string) ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) XExternalsystem(xExternalsystem string) ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileEnrollmentRuleDoNotMergeCriteriaLOVExecute(r)
}

/*
GetProfileEnrollmentRuleDoNotMergeCriteriaLOV Fetch List Of Values for Profile Enrollment Rule Do Not Merge Criteria

 <p><strong>OperationId:</strong>getProfileEnrollmentRuleDoNotMergeCriteriaLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameType Value of the parameter 'nameType' which is required to fetch ProfileEnrollmentRuleDoNotMergeCriteria LOV
 @return ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest
*/
func (a *LOVApiService) GetProfileEnrollmentRuleDoNotMergeCriteriaLOV(ctx context.Context, nameType string) ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	return ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest{
		ApiService: a,
		ctx: ctx,
		nameType: nameType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileEnrollmentRuleDoNotMergeCriteriaLOVExecute(r ApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileEnrollmentRuleDoNotMergeCriteriaLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/nameType/{nameType}/profileEnrollmentRuleDoNotMergeCriteria"
	localVarPath = strings.Replace(localVarPath, "{"+"nameType"+"}", url.PathEscape(parameterValueToString(r.nameType, "nameType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.nameType) < 1 {
		return localVarReturnValue, nil, reportError("nameType must have at least 1 elements")
	}
	if strlen(r.nameType) > 2000 {
		return localVarReturnValue, nil, reportError("nameType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	nameType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) Authorization(authorization string) ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) XAppKey(xAppKey string) ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) XHotelid(xHotelid string) ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) ParameterName(parameterName []string) ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) ParameterValue(parameterValue []string) ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) XExternalsystem(xExternalsystem string) ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileEnrollmentRuleFilterCriteriaLOVExecute(r)
}

/*
GetProfileEnrollmentRuleFilterCriteriaLOV Fetch List Of Values for Profile Enrollment Rule Filter Criteria

 <p><strong>OperationId:</strong>getProfileEnrollmentRuleFilterCriteriaLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameType Value of the parameter 'nameType' which is required to fetch ProfileEnrollmentRuleFilterCriteria LOV
 @return ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest
*/
func (a *LOVApiService) GetProfileEnrollmentRuleFilterCriteriaLOV(ctx context.Context, nameType string) ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	return ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest{
		ApiService: a,
		ctx: ctx,
		nameType: nameType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileEnrollmentRuleFilterCriteriaLOVExecute(r ApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileEnrollmentRuleFilterCriteriaLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/nameType/{nameType}/profileEnrollmentRuleFilterCriteria"
	localVarPath = strings.Replace(localVarPath, "{"+"nameType"+"}", url.PathEscape(parameterValueToString(r.nameType, "nameType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.nameType) < 1 {
		return localVarReturnValue, nil, reportError("nameType must have at least 1 elements")
	}
	if strlen(r.nameType) > 2000 {
		return localVarReturnValue, nil, reportError("nameType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileHotelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	taxTypeCheck string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileHotelsLOVRequest) Authorization(authorization string) ApiGetProfileHotelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileHotelsLOVRequest) XAppKey(xAppKey string) ApiGetProfileHotelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileHotelsLOVRequest) XHotelid(xHotelid string) ApiGetProfileHotelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetProfileHotelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetProfileHotelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetProfileHotelsLOVRequest) ParameterName(parameterName []string) ApiGetProfileHotelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetProfileHotelsLOVRequest) ParameterValue(parameterValue []string) ApiGetProfileHotelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetProfileHotelsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetProfileHotelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileHotelsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileHotelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileHotelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileHotelsLOVExecute(r)
}

/*
GetProfileHotelsLOV Fetch List Of Values for Profile Hotels

 <p><strong>OperationId:</strong>getProfileHotelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxTypeCheck Value of the parameter 'taxTypeCheck' which is required to fetch ProfileHotels LOV
 @param profileId Value of the parameter 'profileId' which is required to fetch ProfileHotels LOV
 @return ApiGetProfileHotelsLOVRequest
*/
func (a *LOVApiService) GetProfileHotelsLOV(ctx context.Context, taxTypeCheck string, profileId string) ApiGetProfileHotelsLOVRequest {
	return ApiGetProfileHotelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		taxTypeCheck: taxTypeCheck,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileHotelsLOVExecute(r ApiGetProfileHotelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileHotelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/profiles/{profileId}/taxTypeCheck/{taxTypeCheck}/profileHotels"
	localVarPath = strings.Replace(localVarPath, "{"+"taxTypeCheck"+"}", url.PathEscape(parameterValueToString(r.taxTypeCheck, "taxTypeCheck")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxTypeCheck) < 1 {
		return localVarReturnValue, nil, reportError("taxTypeCheck must have at least 1 elements")
	}
	if strlen(r.taxTypeCheck) > 2000 {
		return localVarReturnValue, nil, reportError("taxTypeCheck must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileIdentificationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileIdentificationsLOVRequest) Authorization(authorization string) ApiGetProfileIdentificationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileIdentificationsLOVRequest) XAppKey(xAppKey string) ApiGetProfileIdentificationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileIdentificationsLOVRequest) XHotelid(xHotelid string) ApiGetProfileIdentificationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetProfileIdentificationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetProfileIdentificationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetProfileIdentificationsLOVRequest) ParameterName(parameterName []string) ApiGetProfileIdentificationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetProfileIdentificationsLOVRequest) ParameterValue(parameterValue []string) ApiGetProfileIdentificationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetProfileIdentificationsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetProfileIdentificationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileIdentificationsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileIdentificationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileIdentificationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileIdentificationsLOVExecute(r)
}

/*
GetProfileIdentificationsLOV Fetch List Of Values for Profile Identifications

 <p><strong>OperationId:</strong>getProfileIdentificationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch ProfileIdentifications LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ProfileIdentifications LOV
 @return ApiGetProfileIdentificationsLOVRequest
*/
func (a *LOVApiService) GetProfileIdentificationsLOV(ctx context.Context, profileId string, hotelId string) ApiGetProfileIdentificationsLOVRequest {
	return ApiGetProfileIdentificationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileIdentificationsLOVExecute(r ApiGetProfileIdentificationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileIdentificationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/profiles/{profileId}/profileIdentifications"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileNameValidationsTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	operaParam string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetProfileNameValidationsTypeLOVRequest) Authorization(authorization string) ApiGetProfileNameValidationsTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetProfileNameValidationsTypeLOVRequest) XAppKey(xAppKey string) ApiGetProfileNameValidationsTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetProfileNameValidationsTypeLOVRequest) XHotelid(xHotelid string) ApiGetProfileNameValidationsTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetProfileNameValidationsTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetProfileNameValidationsTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetProfileNameValidationsTypeLOVRequest) ParameterName(parameterName []string) ApiGetProfileNameValidationsTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetProfileNameValidationsTypeLOVRequest) ParameterValue(parameterValue []string) ApiGetProfileNameValidationsTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetProfileNameValidationsTypeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetProfileNameValidationsTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetProfileNameValidationsTypeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetProfileNameValidationsTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetProfileNameValidationsTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileNameValidationsTypeLOVExecute(r)
}

/*
GetProfileNameValidationsTypeLOV Fetch List Of Values for Profile Name Validations Type

 <p><strong>OperationId:</strong>getProfileNameValidationsTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operaParam Value of the parameter 'operaParam' which is required to fetch ProfileNameValidationsType LOV
 @return ApiGetProfileNameValidationsTypeLOVRequest
*/
func (a *LOVApiService) GetProfileNameValidationsTypeLOV(ctx context.Context, operaParam string) ApiGetProfileNameValidationsTypeLOVRequest {
	return ApiGetProfileNameValidationsTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		operaParam: operaParam,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileNameValidationsTypeLOVExecute(r ApiGetProfileNameValidationsTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileNameValidationsTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/operaParam/{operaParam}/profileNameValidationsType"
	localVarPath = strings.Replace(localVarPath, "{"+"operaParam"+"}", url.PathEscape(parameterValueToString(r.operaParam, "operaParam")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.operaParam) < 1 {
		return localVarReturnValue, nil, reportError("operaParam must have at least 1 elements")
	}
	if strlen(r.operaParam) > 2000 {
		return localVarReturnValue, nil, reportError("operaParam must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPromoGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPromoGroupsLOVRequest) Authorization(authorization string) ApiGetPromoGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPromoGroupsLOVRequest) XAppKey(xAppKey string) ApiGetPromoGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPromoGroupsLOVRequest) XHotelid(xHotelid string) ApiGetPromoGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPromoGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPromoGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPromoGroupsLOVRequest) ParameterName(parameterName []string) ApiGetPromoGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPromoGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetPromoGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPromoGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPromoGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPromoGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPromoGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPromoGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPromoGroupsLOVExecute(r)
}

/*
GetPromoGroupsLOV Fetch List Of Values for Promo Groups

 <p><strong>OperationId:</strong>getPromoGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PromoGroups LOV
 @return ApiGetPromoGroupsLOVRequest
*/
func (a *LOVApiService) GetPromoGroupsLOV(ctx context.Context, hotelId string) ApiGetPromoGroupsLOVRequest {
	return ApiGetPromoGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPromoGroupsLOVExecute(r ApiGetPromoGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPromoGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/promoGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPromoRatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	promoCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPromoRatesLOVRequest) Authorization(authorization string) ApiGetPromoRatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPromoRatesLOVRequest) XAppKey(xAppKey string) ApiGetPromoRatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPromoRatesLOVRequest) XHotelid(xHotelid string) ApiGetPromoRatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPromoRatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPromoRatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPromoRatesLOVRequest) ParameterName(parameterName []string) ApiGetPromoRatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPromoRatesLOVRequest) ParameterValue(parameterValue []string) ApiGetPromoRatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPromoRatesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPromoRatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPromoRatesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPromoRatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPromoRatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPromoRatesLOVExecute(r)
}

/*
GetPromoRatesLOV Fetch List Of Values for Promo Rates

 <p><strong>OperationId:</strong>getPromoRatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param promoCode Value of the parameter 'promoCode' which is required to fetch PromoRates LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PromoRates LOV
 @return ApiGetPromoRatesLOVRequest
*/
func (a *LOVApiService) GetPromoRatesLOV(ctx context.Context, promoCode string, hotelId string) ApiGetPromoRatesLOVRequest {
	return ApiGetPromoRatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		promoCode: promoCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPromoRatesLOVExecute(r ApiGetPromoRatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPromoRatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/promoCode/{promoCode}/promoRates"
	localVarPath = strings.Replace(localVarPath, "{"+"promoCode"+"}", url.PathEscape(parameterValueToString(r.promoCode, "promoCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.promoCode) < 1 {
		return localVarReturnValue, nil, reportError("promoCode must have at least 1 elements")
	}
	if strlen(r.promoCode) > 2000 {
		return localVarReturnValue, nil, reportError("promoCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPropertyAmenitiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPropertyAmenitiesLOVRequest) Authorization(authorization string) ApiGetPropertyAmenitiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPropertyAmenitiesLOVRequest) XAppKey(xAppKey string) ApiGetPropertyAmenitiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPropertyAmenitiesLOVRequest) XHotelid(xHotelid string) ApiGetPropertyAmenitiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPropertyAmenitiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPropertyAmenitiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPropertyAmenitiesLOVRequest) ParameterName(parameterName []string) ApiGetPropertyAmenitiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPropertyAmenitiesLOVRequest) ParameterValue(parameterValue []string) ApiGetPropertyAmenitiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPropertyAmenitiesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPropertyAmenitiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPropertyAmenitiesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPropertyAmenitiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPropertyAmenitiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPropertyAmenitiesLOVExecute(r)
}

/*
GetPropertyAmenitiesLOV Fetch List Of Values for Property Amenities

 <p><strong>OperationId:</strong>getPropertyAmenitiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PropertyAmenities LOV
 @return ApiGetPropertyAmenitiesLOVRequest
*/
func (a *LOVApiService) GetPropertyAmenitiesLOV(ctx context.Context, hotelId string) ApiGetPropertyAmenitiesLOVRequest {
	return ApiGetPropertyAmenitiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPropertyAmenitiesLOVExecute(r ApiGetPropertyAmenitiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPropertyAmenitiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/propertyAmenities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublisherPropertiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	subscriber string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetPublisherPropertiesLOVRequest) Authorization(authorization string) ApiGetPublisherPropertiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetPublisherPropertiesLOVRequest) XAppKey(xAppKey string) ApiGetPublisherPropertiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetPublisherPropertiesLOVRequest) XHotelid(xHotelid string) ApiGetPublisherPropertiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetPublisherPropertiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetPublisherPropertiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetPublisherPropertiesLOVRequest) ParameterName(parameterName []string) ApiGetPublisherPropertiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetPublisherPropertiesLOVRequest) ParameterValue(parameterValue []string) ApiGetPublisherPropertiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetPublisherPropertiesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetPublisherPropertiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetPublisherPropertiesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetPublisherPropertiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetPublisherPropertiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPublisherPropertiesLOVExecute(r)
}

/*
GetPublisherPropertiesLOV Fetch List Of Values for Publisher Properties

 <p><strong>OperationId:</strong>getPublisherPropertiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriber Value of the parameter 'subscriber' which is required to fetch PublisherProperties LOV
 @return ApiGetPublisherPropertiesLOVRequest
*/
func (a *LOVApiService) GetPublisherPropertiesLOV(ctx context.Context, subscriber string) ApiGetPublisherPropertiesLOVRequest {
	return ApiGetPublisherPropertiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		subscriber: subscriber,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPublisherPropertiesLOVExecute(r ApiGetPublisherPropertiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPublisherPropertiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/subscriber/{subscriber}/publisherProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber"+"}", url.PathEscape(parameterValueToString(r.subscriber, "subscriber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.subscriber) < 1 {
		return localVarReturnValue, nil, reportError("subscriber must have at least 1 elements")
	}
	if strlen(r.subscriber) > 2000 {
		return localVarReturnValue, nil, reportError("subscriber must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQueueNameLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelCodeList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetQueueNameLOVRequest) Authorization(authorization string) ApiGetQueueNameLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetQueueNameLOVRequest) XAppKey(xAppKey string) ApiGetQueueNameLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetQueueNameLOVRequest) XHotelid(xHotelid string) ApiGetQueueNameLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetQueueNameLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetQueueNameLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetQueueNameLOVRequest) ParameterName(parameterName []string) ApiGetQueueNameLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetQueueNameLOVRequest) ParameterValue(parameterValue []string) ApiGetQueueNameLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetQueueNameLOVRequest) XExternalsystem(xExternalsystem string) ApiGetQueueNameLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetQueueNameLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetQueueNameLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetQueueNameLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetQueueNameLOVExecute(r)
}

/*
GetQueueNameLOV Fetch List Of Values for Queue Name

 <p><strong>OperationId:</strong>getQueueNameLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelCodeList Value of the parameter 'hotelCodeList' which is required to fetch QueueName LOV
 @return ApiGetQueueNameLOVRequest
*/
func (a *LOVApiService) GetQueueNameLOV(ctx context.Context, hotelCodeList string) ApiGetQueueNameLOVRequest {
	return ApiGetQueueNameLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelCodeList: hotelCodeList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetQueueNameLOVExecute(r ApiGetQueueNameLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetQueueNameLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotelCodeList/{hotelCodeList}/queueName"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelCodeList"+"}", url.PathEscape(parameterValueToString(r.hotelCodeList, "hotelCodeList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelCodeList) < 1 {
		return localVarReturnValue, nil, reportError("hotelCodeList must have at least 1 elements")
	}
	if strlen(r.hotelCodeList) > 2000 {
		return localVarReturnValue, nil, reportError("hotelCodeList must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuickTextsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	departmentId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetQuickTextsLOVRequest) Authorization(authorization string) ApiGetQuickTextsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetQuickTextsLOVRequest) XAppKey(xAppKey string) ApiGetQuickTextsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetQuickTextsLOVRequest) XHotelid(xHotelid string) ApiGetQuickTextsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetQuickTextsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetQuickTextsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetQuickTextsLOVRequest) ParameterName(parameterName []string) ApiGetQuickTextsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetQuickTextsLOVRequest) ParameterValue(parameterValue []string) ApiGetQuickTextsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetQuickTextsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetQuickTextsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetQuickTextsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetQuickTextsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetQuickTextsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetQuickTextsLOVExecute(r)
}

/*
GetQuickTextsLOV Fetch List Of Values for Quick Texts

 <p><strong>OperationId:</strong>getQuickTextsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departmentId Value of the parameter 'departmentId' which is required to fetch QuickTexts LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch QuickTexts LOV
 @return ApiGetQuickTextsLOVRequest
*/
func (a *LOVApiService) GetQuickTextsLOV(ctx context.Context, departmentId string, hotelId string) ApiGetQuickTextsLOVRequest {
	return ApiGetQuickTextsLOVRequest{
		ApiService: a,
		ctx: ctx,
		departmentId: departmentId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetQuickTextsLOVExecute(r ApiGetQuickTextsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetQuickTextsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/departmentId/{departmentId}/quickTexts"
	localVarPath = strings.Replace(localVarPath, "{"+"departmentId"+"}", url.PathEscape(parameterValueToString(r.departmentId, "departmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departmentId) < 1 {
		return localVarReturnValue, nil, reportError("departmentId must have at least 1 elements")
	}
	if strlen(r.departmentId) > 2000 {
		return localVarReturnValue, nil, reportError("departmentId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRateCategoriesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRateCategoriesLOVRequest) Authorization(authorization string) ApiGetRateCategoriesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRateCategoriesLOVRequest) XAppKey(xAppKey string) ApiGetRateCategoriesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRateCategoriesLOVRequest) XHotelid(xHotelid string) ApiGetRateCategoriesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRateCategoriesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRateCategoriesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRateCategoriesLOVRequest) ParameterName(parameterName []string) ApiGetRateCategoriesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRateCategoriesLOVRequest) ParameterValue(parameterValue []string) ApiGetRateCategoriesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRateCategoriesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRateCategoriesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRateCategoriesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRateCategoriesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRateCategoriesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateCategoriesLOVExecute(r)
}

/*
GetRateCategoriesLOV Fetch List Of Values for Rate Categories

 <p><strong>OperationId:</strong>getRateCategoriesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateCategories LOV
 @return ApiGetRateCategoriesLOVRequest
*/
func (a *LOVApiService) GetRateCategoriesLOV(ctx context.Context, hotelId string) ApiGetRateCategoriesLOVRequest {
	return ApiGetRateCategoriesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateCategoriesLOVExecute(r ApiGetRateCategoriesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateCategoriesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCategories"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRateCodeGlobalDescEditLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRateCodeGlobalDescEditLOVRequest) Authorization(authorization string) ApiGetRateCodeGlobalDescEditLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRateCodeGlobalDescEditLOVRequest) XAppKey(xAppKey string) ApiGetRateCodeGlobalDescEditLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRateCodeGlobalDescEditLOVRequest) XHotelid(xHotelid string) ApiGetRateCodeGlobalDescEditLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRateCodeGlobalDescEditLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRateCodeGlobalDescEditLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRateCodeGlobalDescEditLOVRequest) ParameterName(parameterName []string) ApiGetRateCodeGlobalDescEditLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRateCodeGlobalDescEditLOVRequest) ParameterValue(parameterValue []string) ApiGetRateCodeGlobalDescEditLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRateCodeGlobalDescEditLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRateCodeGlobalDescEditLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRateCodeGlobalDescEditLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRateCodeGlobalDescEditLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRateCodeGlobalDescEditLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateCodeGlobalDescEditLOVExecute(r)
}

/*
GetRateCodeGlobalDescEditLOV Fetch List Of Values for Rate Code Global Desc Edit

 <p><strong>OperationId:</strong>getRateCodeGlobalDescEditLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateCodeGlobalDescEdit LOV
 @return ApiGetRateCodeGlobalDescEditLOVRequest
*/
func (a *LOVApiService) GetRateCodeGlobalDescEditLOV(ctx context.Context, hotelId string) ApiGetRateCodeGlobalDescEditLOVRequest {
	return ApiGetRateCodeGlobalDescEditLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateCodeGlobalDescEditLOVExecute(r ApiGetRateCodeGlobalDescEditLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateCodeGlobalDescEditLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCodeGlobalDescEdit"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRateCodesByTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	rateCodeType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRateCodesByTypeLOVRequest) Authorization(authorization string) ApiGetRateCodesByTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRateCodesByTypeLOVRequest) XAppKey(xAppKey string) ApiGetRateCodesByTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRateCodesByTypeLOVRequest) XHotelid(xHotelid string) ApiGetRateCodesByTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRateCodesByTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRateCodesByTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRateCodesByTypeLOVRequest) ParameterName(parameterName []string) ApiGetRateCodesByTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRateCodesByTypeLOVRequest) ParameterValue(parameterValue []string) ApiGetRateCodesByTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRateCodesByTypeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRateCodesByTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRateCodesByTypeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRateCodesByTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRateCodesByTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateCodesByTypeLOVExecute(r)
}

/*
GetRateCodesByTypeLOV Fetch List Of Values for Rate Codes By Type

 <p><strong>OperationId:</strong>getRateCodesByTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCodeType Value of the parameter 'rateCodeType' which is required to fetch RateCodesByType LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateCodesByType LOV
 @return ApiGetRateCodesByTypeLOVRequest
*/
func (a *LOVApiService) GetRateCodesByTypeLOV(ctx context.Context, rateCodeType string, hotelId string) ApiGetRateCodesByTypeLOVRequest {
	return ApiGetRateCodesByTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		rateCodeType: rateCodeType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateCodesByTypeLOVExecute(r ApiGetRateCodesByTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateCodesByTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCodeType/{rateCodeType}/rateCodesByType"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCodeType"+"}", url.PathEscape(parameterValueToString(r.rateCodeType, "rateCodeType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCodeType) < 1 {
		return localVarReturnValue, nil, reportError("rateCodeType must have at least 1 elements")
	}
	if strlen(r.rateCodeType) > 2000 {
		return localVarReturnValue, nil, reportError("rateCodeType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRateCodesValidLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRateCodesValidLOVRequest) Authorization(authorization string) ApiGetRateCodesValidLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRateCodesValidLOVRequest) XAppKey(xAppKey string) ApiGetRateCodesValidLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRateCodesValidLOVRequest) XHotelid(xHotelid string) ApiGetRateCodesValidLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRateCodesValidLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRateCodesValidLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRateCodesValidLOVRequest) ParameterName(parameterName []string) ApiGetRateCodesValidLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRateCodesValidLOVRequest) ParameterValue(parameterValue []string) ApiGetRateCodesValidLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRateCodesValidLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRateCodesValidLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRateCodesValidLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRateCodesValidLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRateCodesValidLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateCodesValidLOVExecute(r)
}

/*
GetRateCodesValidLOV Fetch List Of Values for Rate Codes Valid

 <p><strong>OperationId:</strong>getRateCodesValidLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateCodesValid LOV
 @return ApiGetRateCodesValidLOVRequest
*/
func (a *LOVApiService) GetRateCodesValidLOV(ctx context.Context, hotelId string) ApiGetRateCodesValidLOVRequest {
	return ApiGetRateCodesValidLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateCodesValidLOVExecute(r ApiGetRateCodesValidLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateCodesValidLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCodesValid"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRateCommissionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRateCommissionCodesLOVRequest) Authorization(authorization string) ApiGetRateCommissionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRateCommissionCodesLOVRequest) XAppKey(xAppKey string) ApiGetRateCommissionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRateCommissionCodesLOVRequest) XHotelid(xHotelid string) ApiGetRateCommissionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRateCommissionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRateCommissionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRateCommissionCodesLOVRequest) ParameterName(parameterName []string) ApiGetRateCommissionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRateCommissionCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetRateCommissionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRateCommissionCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRateCommissionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRateCommissionCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRateCommissionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRateCommissionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateCommissionCodesLOVExecute(r)
}

/*
GetRateCommissionCodesLOV Fetch List Of Values for Rate Commission Codes

 <p><strong>OperationId:</strong>getRateCommissionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateCommissionCodes LOV
 @return ApiGetRateCommissionCodesLOVRequest
*/
func (a *LOVApiService) GetRateCommissionCodesLOV(ctx context.Context, hotelId string) ApiGetRateCommissionCodesLOVRequest {
	return ApiGetRateCommissionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateCommissionCodesLOVExecute(r ApiGetRateCommissionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateCommissionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCommissionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRateConfigCurrenciesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRateConfigCurrenciesLOVRequest) Authorization(authorization string) ApiGetRateConfigCurrenciesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRateConfigCurrenciesLOVRequest) XAppKey(xAppKey string) ApiGetRateConfigCurrenciesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRateConfigCurrenciesLOVRequest) XHotelid(xHotelid string) ApiGetRateConfigCurrenciesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRateConfigCurrenciesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRateConfigCurrenciesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRateConfigCurrenciesLOVRequest) ParameterName(parameterName []string) ApiGetRateConfigCurrenciesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRateConfigCurrenciesLOVRequest) ParameterValue(parameterValue []string) ApiGetRateConfigCurrenciesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRateConfigCurrenciesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRateConfigCurrenciesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRateConfigCurrenciesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRateConfigCurrenciesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRateConfigCurrenciesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateConfigCurrenciesLOVExecute(r)
}

/*
GetRateConfigCurrenciesLOV Fetch List Of Values for Rate Config Currencies

 <p><strong>OperationId:</strong>getRateConfigCurrenciesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateConfigCurrencies LOV
 @return ApiGetRateConfigCurrenciesLOVRequest
*/
func (a *LOVApiService) GetRateConfigCurrenciesLOV(ctx context.Context, hotelId string) ApiGetRateConfigCurrenciesLOVRequest {
	return ApiGetRateConfigCurrenciesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateConfigCurrenciesLOVExecute(r ApiGetRateConfigCurrenciesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateConfigCurrenciesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateConfigCurrencies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRateGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRateGroupsLOVRequest) Authorization(authorization string) ApiGetRateGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRateGroupsLOVRequest) XAppKey(xAppKey string) ApiGetRateGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRateGroupsLOVRequest) XHotelid(xHotelid string) ApiGetRateGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRateGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRateGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRateGroupsLOVRequest) ParameterName(parameterName []string) ApiGetRateGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRateGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetRateGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRateGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRateGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRateGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRateGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRateGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateGroupsLOVExecute(r)
}

/*
GetRateGroupsLOV Fetch List Of Values for Rate Groups

 <p><strong>OperationId:</strong>getRateGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateGroups LOV
 @return ApiGetRateGroupsLOVRequest
*/
func (a *LOVApiService) GetRateGroupsLOV(ctx context.Context, hotelId string) ApiGetRateGroupsLOVRequest {
	return ApiGetRateGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateGroupsLOVExecute(r ApiGetRateGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRatePlanForMassRateLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	rateCodeType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRatePlanForMassRateLOVRequest) Authorization(authorization string) ApiGetRatePlanForMassRateLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRatePlanForMassRateLOVRequest) XAppKey(xAppKey string) ApiGetRatePlanForMassRateLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRatePlanForMassRateLOVRequest) XHotelid(xHotelid string) ApiGetRatePlanForMassRateLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRatePlanForMassRateLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRatePlanForMassRateLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRatePlanForMassRateLOVRequest) ParameterName(parameterName []string) ApiGetRatePlanForMassRateLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRatePlanForMassRateLOVRequest) ParameterValue(parameterValue []string) ApiGetRatePlanForMassRateLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRatePlanForMassRateLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRatePlanForMassRateLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRatePlanForMassRateLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRatePlanForMassRateLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRatePlanForMassRateLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRatePlanForMassRateLOVExecute(r)
}

/*
GetRatePlanForMassRateLOV Fetch List Of Values for Rate Plan For Mass Rate

 <p><strong>OperationId:</strong>getRatePlanForMassRateLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCodeType Value of the parameter 'rateCodeType' which is required to fetch RatePlanForMassRate LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RatePlanForMassRate LOV
 @return ApiGetRatePlanForMassRateLOVRequest
*/
func (a *LOVApiService) GetRatePlanForMassRateLOV(ctx context.Context, rateCodeType string, hotelId string) ApiGetRatePlanForMassRateLOVRequest {
	return ApiGetRatePlanForMassRateLOVRequest{
		ApiService: a,
		ctx: ctx,
		rateCodeType: rateCodeType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRatePlanForMassRateLOVExecute(r ApiGetRatePlanForMassRateLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRatePlanForMassRateLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCodeType/{rateCodeType}/ratePlanForMassRate"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCodeType"+"}", url.PathEscape(parameterValueToString(r.rateCodeType, "rateCodeType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCodeType) < 1 {
		return localVarReturnValue, nil, reportError("rateCodeType must have at least 1 elements")
	}
	if strlen(r.rateCodeType) > 2000 {
		return localVarReturnValue, nil, reportError("rateCodeType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRatePlansForYieldAsConfigLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	rateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRatePlansForYieldAsConfigLOVRequest) Authorization(authorization string) ApiGetRatePlansForYieldAsConfigLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRatePlansForYieldAsConfigLOVRequest) XAppKey(xAppKey string) ApiGetRatePlansForYieldAsConfigLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRatePlansForYieldAsConfigLOVRequest) XHotelid(xHotelid string) ApiGetRatePlansForYieldAsConfigLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRatePlansForYieldAsConfigLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRatePlansForYieldAsConfigLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRatePlansForYieldAsConfigLOVRequest) ParameterName(parameterName []string) ApiGetRatePlansForYieldAsConfigLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRatePlansForYieldAsConfigLOVRequest) ParameterValue(parameterValue []string) ApiGetRatePlansForYieldAsConfigLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRatePlansForYieldAsConfigLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRatePlansForYieldAsConfigLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRatePlansForYieldAsConfigLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRatePlansForYieldAsConfigLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRatePlansForYieldAsConfigLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRatePlansForYieldAsConfigLOVExecute(r)
}

/*
GetRatePlansForYieldAsConfigLOV Fetch List Of Values for Rate Plans For Yield As Config

 <p><strong>OperationId:</strong>getRatePlansForYieldAsConfigLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCode Value of the parameter 'rateCode' which is required to fetch RatePlansForYieldAsConfig LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RatePlansForYieldAsConfig LOV
 @return ApiGetRatePlansForYieldAsConfigLOVRequest
*/
func (a *LOVApiService) GetRatePlansForYieldAsConfigLOV(ctx context.Context, rateCode string, hotelId string) ApiGetRatePlansForYieldAsConfigLOVRequest {
	return ApiGetRatePlansForYieldAsConfigLOVRequest{
		ApiService: a,
		ctx: ctx,
		rateCode: rateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRatePlansForYieldAsConfigLOVExecute(r ApiGetRatePlansForYieldAsConfigLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRatePlansForYieldAsConfigLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCode/{rateCode}/ratePlansForYieldAsConfig"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRatePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRatePlansLOVRequest) Authorization(authorization string) ApiGetRatePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRatePlansLOVRequest) XAppKey(xAppKey string) ApiGetRatePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRatePlansLOVRequest) XHotelid(xHotelid string) ApiGetRatePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRatePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRatePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRatePlansLOVRequest) ParameterName(parameterName []string) ApiGetRatePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRatePlansLOVRequest) ParameterValue(parameterValue []string) ApiGetRatePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRatePlansLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRatePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRatePlansLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRatePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRatePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRatePlansLOVExecute(r)
}

/*
GetRatePlansLOV Fetch List Of Values for Rate Plans

 <p><strong>OperationId:</strong>getRatePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RatePlans LOV
 @return ApiGetRatePlansLOVRequest
*/
func (a *LOVApiService) GetRatePlansLOV(ctx context.Context, hotelId string) ApiGetRatePlansLOVRequest {
	return ApiGetRatePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRatePlansLOVExecute(r ApiGetRatePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRatePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/ratePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepBlockCodesParamOffLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepBlockCodesParamOffLOVRequest) Authorization(authorization string) ApiGetRepBlockCodesParamOffLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepBlockCodesParamOffLOVRequest) XAppKey(xAppKey string) ApiGetRepBlockCodesParamOffLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepBlockCodesParamOffLOVRequest) XHotelid(xHotelid string) ApiGetRepBlockCodesParamOffLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepBlockCodesParamOffLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepBlockCodesParamOffLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepBlockCodesParamOffLOVRequest) ParameterName(parameterName []string) ApiGetRepBlockCodesParamOffLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepBlockCodesParamOffLOVRequest) ParameterValue(parameterValue []string) ApiGetRepBlockCodesParamOffLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepBlockCodesParamOffLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepBlockCodesParamOffLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepBlockCodesParamOffLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepBlockCodesParamOffLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepBlockCodesParamOffLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepBlockCodesParamOffLOVExecute(r)
}

/*
GetRepBlockCodesParamOffLOV Fetch List Of Values for Rep Block Codes Param Off

 <p><strong>OperationId:</strong>getRepBlockCodesParamOffLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepBlockCodesParamOff LOV
 @return ApiGetRepBlockCodesParamOffLOVRequest
*/
func (a *LOVApiService) GetRepBlockCodesParamOffLOV(ctx context.Context, hotelId string) ApiGetRepBlockCodesParamOffLOVRequest {
	return ApiGetRepBlockCodesParamOffLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepBlockCodesParamOffLOVExecute(r ApiGetRepBlockCodesParamOffLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepBlockCodesParamOffLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repBlockCodesParamOff"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepBlockCodesParamOnLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepBlockCodesParamOnLOVRequest) Authorization(authorization string) ApiGetRepBlockCodesParamOnLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepBlockCodesParamOnLOVRequest) XAppKey(xAppKey string) ApiGetRepBlockCodesParamOnLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepBlockCodesParamOnLOVRequest) XHotelid(xHotelid string) ApiGetRepBlockCodesParamOnLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepBlockCodesParamOnLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepBlockCodesParamOnLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepBlockCodesParamOnLOVRequest) ParameterName(parameterName []string) ApiGetRepBlockCodesParamOnLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepBlockCodesParamOnLOVRequest) ParameterValue(parameterValue []string) ApiGetRepBlockCodesParamOnLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepBlockCodesParamOnLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepBlockCodesParamOnLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepBlockCodesParamOnLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepBlockCodesParamOnLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepBlockCodesParamOnLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepBlockCodesParamOnLOVExecute(r)
}

/*
GetRepBlockCodesParamOnLOV Fetch List Of Values for Rep Block Codes Param On

 <p><strong>OperationId:</strong>getRepBlockCodesParamOnLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepBlockCodesParamOn LOV
 @return ApiGetRepBlockCodesParamOnLOVRequest
*/
func (a *LOVApiService) GetRepBlockCodesParamOnLOV(ctx context.Context, hotelId string) ApiGetRepBlockCodesParamOnLOVRequest {
	return ApiGetRepBlockCodesParamOnLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepBlockCodesParamOnLOVExecute(r ApiGetRepBlockCodesParamOnLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepBlockCodesParamOnLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repBlockCodesParamOn"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepCalendarMonthsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	year string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepCalendarMonthsLOVRequest) Authorization(authorization string) ApiGetRepCalendarMonthsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepCalendarMonthsLOVRequest) XAppKey(xAppKey string) ApiGetRepCalendarMonthsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepCalendarMonthsLOVRequest) XHotelid(xHotelid string) ApiGetRepCalendarMonthsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepCalendarMonthsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepCalendarMonthsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepCalendarMonthsLOVRequest) ParameterName(parameterName []string) ApiGetRepCalendarMonthsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepCalendarMonthsLOVRequest) ParameterValue(parameterValue []string) ApiGetRepCalendarMonthsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepCalendarMonthsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepCalendarMonthsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepCalendarMonthsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepCalendarMonthsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepCalendarMonthsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepCalendarMonthsLOVExecute(r)
}

/*
GetRepCalendarMonthsLOV Fetch List Of Values for Rep Calendar Months

 <p><strong>OperationId:</strong>getRepCalendarMonthsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param year Value of the parameter 'year' which is required to fetch RepCalendarMonths LOV
 @return ApiGetRepCalendarMonthsLOVRequest
*/
func (a *LOVApiService) GetRepCalendarMonthsLOV(ctx context.Context, year string) ApiGetRepCalendarMonthsLOVRequest {
	return ApiGetRepCalendarMonthsLOVRequest{
		ApiService: a,
		ctx: ctx,
		year: year,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepCalendarMonthsLOVExecute(r ApiGetRepCalendarMonthsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepCalendarMonthsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/year/{year}/repCalendarMonths"
	localVarPath = strings.Replace(localVarPath, "{"+"year"+"}", url.PathEscape(parameterValueToString(r.year, "year")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.year) < 1 {
		return localVarReturnValue, nil, reportError("year must have at least 1 elements")
	}
	if strlen(r.year) > 2000 {
		return localVarReturnValue, nil, reportError("year must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepCalendarWeeksLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	year string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepCalendarWeeksLOVRequest) Authorization(authorization string) ApiGetRepCalendarWeeksLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepCalendarWeeksLOVRequest) XAppKey(xAppKey string) ApiGetRepCalendarWeeksLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepCalendarWeeksLOVRequest) XHotelid(xHotelid string) ApiGetRepCalendarWeeksLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepCalendarWeeksLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepCalendarWeeksLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepCalendarWeeksLOVRequest) ParameterName(parameterName []string) ApiGetRepCalendarWeeksLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepCalendarWeeksLOVRequest) ParameterValue(parameterValue []string) ApiGetRepCalendarWeeksLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepCalendarWeeksLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepCalendarWeeksLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepCalendarWeeksLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepCalendarWeeksLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepCalendarWeeksLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepCalendarWeeksLOVExecute(r)
}

/*
GetRepCalendarWeeksLOV Fetch List Of Values for Rep Calendar Weeks

 <p><strong>OperationId:</strong>getRepCalendarWeeksLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param year Value of the parameter 'year' which is required to fetch RepCalendarWeeks LOV
 @return ApiGetRepCalendarWeeksLOVRequest
*/
func (a *LOVApiService) GetRepCalendarWeeksLOV(ctx context.Context, year string) ApiGetRepCalendarWeeksLOVRequest {
	return ApiGetRepCalendarWeeksLOVRequest{
		ApiService: a,
		ctx: ctx,
		year: year,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepCalendarWeeksLOVExecute(r ApiGetRepCalendarWeeksLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepCalendarWeeksLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/year/{year}/repCalendarWeeks"
	localVarPath = strings.Replace(localVarPath, "{"+"year"+"}", url.PathEscape(parameterValueToString(r.year, "year")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.year) < 1 {
		return localVarReturnValue, nil, reportError("year must have at least 1 elements")
	}
	if strlen(r.year) > 2000 {
		return localVarReturnValue, nil, reportError("year must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepCalendarYearsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	period string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepCalendarYearsLOVRequest) Authorization(authorization string) ApiGetRepCalendarYearsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepCalendarYearsLOVRequest) XAppKey(xAppKey string) ApiGetRepCalendarYearsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepCalendarYearsLOVRequest) XHotelid(xHotelid string) ApiGetRepCalendarYearsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepCalendarYearsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepCalendarYearsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepCalendarYearsLOVRequest) ParameterName(parameterName []string) ApiGetRepCalendarYearsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepCalendarYearsLOVRequest) ParameterValue(parameterValue []string) ApiGetRepCalendarYearsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepCalendarYearsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepCalendarYearsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepCalendarYearsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepCalendarYearsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepCalendarYearsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepCalendarYearsLOVExecute(r)
}

/*
GetRepCalendarYearsLOV Fetch List Of Values for Rep Calendar Years

 <p><strong>OperationId:</strong>getRepCalendarYearsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param period Value of the parameter 'period' which is required to fetch RepCalendarYears LOV
 @return ApiGetRepCalendarYearsLOVRequest
*/
func (a *LOVApiService) GetRepCalendarYearsLOV(ctx context.Context, period string) ApiGetRepCalendarYearsLOVRequest {
	return ApiGetRepCalendarYearsLOVRequest{
		ApiService: a,
		ctx: ctx,
		period: period,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepCalendarYearsLOVExecute(r ApiGetRepCalendarYearsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepCalendarYearsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/period/{period}/repCalendarYears"
	localVarPath = strings.Replace(localVarPath, "{"+"period"+"}", url.PathEscape(parameterValueToString(r.period, "period")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.period) < 1 {
		return localVarReturnValue, nil, reportError("period must have at least 1 elements")
	}
	if strlen(r.period) > 2000 {
		return localVarReturnValue, nil, reportError("period must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepCashiersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepCashiersLOVRequest) Authorization(authorization string) ApiGetRepCashiersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepCashiersLOVRequest) XAppKey(xAppKey string) ApiGetRepCashiersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepCashiersLOVRequest) XHotelid(xHotelid string) ApiGetRepCashiersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepCashiersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepCashiersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepCashiersLOVRequest) ParameterName(parameterName []string) ApiGetRepCashiersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepCashiersLOVRequest) ParameterValue(parameterValue []string) ApiGetRepCashiersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepCashiersLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepCashiersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepCashiersLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepCashiersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepCashiersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepCashiersLOVExecute(r)
}

/*
GetRepCashiersLOV Fetch List Of Values for Rep Cashiers

 <p><strong>OperationId:</strong>getRepCashiersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepCashiers LOV
 @return ApiGetRepCashiersLOVRequest
*/
func (a *LOVApiService) GetRepCashiersLOV(ctx context.Context, hotelId string) ApiGetRepCashiersLOVRequest {
	return ApiGetRepCashiersLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepCashiersLOVExecute(r ApiGetRepCashiersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepCashiersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repCashiers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepContactListLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepContactListLOVRequest) Authorization(authorization string) ApiGetRepContactListLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepContactListLOVRequest) XAppKey(xAppKey string) ApiGetRepContactListLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepContactListLOVRequest) XHotelid(xHotelid string) ApiGetRepContactListLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepContactListLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepContactListLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepContactListLOVRequest) ParameterName(parameterName []string) ApiGetRepContactListLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepContactListLOVRequest) ParameterValue(parameterValue []string) ApiGetRepContactListLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepContactListLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepContactListLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepContactListLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepContactListLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepContactListLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepContactListLOVExecute(r)
}

/*
GetRepContactListLOV Fetch List Of Values for Rep Contact List

 <p><strong>OperationId:</strong>getRepContactListLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepContactList LOV
 @return ApiGetRepContactListLOVRequest
*/
func (a *LOVApiService) GetRepContactListLOV(ctx context.Context, hotelId string) ApiGetRepContactListLOVRequest {
	return ApiGetRepContactListLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepContactListLOVExecute(r ApiGetRepContactListLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepContactListLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repContactList"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepCurrenciesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepCurrenciesLOVRequest) Authorization(authorization string) ApiGetRepCurrenciesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepCurrenciesLOVRequest) XAppKey(xAppKey string) ApiGetRepCurrenciesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepCurrenciesLOVRequest) XHotelid(xHotelid string) ApiGetRepCurrenciesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepCurrenciesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepCurrenciesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepCurrenciesLOVRequest) ParameterName(parameterName []string) ApiGetRepCurrenciesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepCurrenciesLOVRequest) ParameterValue(parameterValue []string) ApiGetRepCurrenciesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepCurrenciesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepCurrenciesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepCurrenciesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepCurrenciesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepCurrenciesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepCurrenciesLOVExecute(r)
}

/*
GetRepCurrenciesLOV Fetch List Of Values for Rep Currencies

 <p><strong>OperationId:</strong>getRepCurrenciesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepCurrencies LOV
 @return ApiGetRepCurrenciesLOVRequest
*/
func (a *LOVApiService) GetRepCurrenciesLOV(ctx context.Context, hotelId string) ApiGetRepCurrenciesLOVRequest {
	return ApiGetRepCurrenciesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepCurrenciesLOVExecute(r ApiGetRepCurrenciesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepCurrenciesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repCurrencies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepDepartmentsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepDepartmentsLOVRequest) Authorization(authorization string) ApiGetRepDepartmentsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepDepartmentsLOVRequest) XAppKey(xAppKey string) ApiGetRepDepartmentsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepDepartmentsLOVRequest) XHotelid(xHotelid string) ApiGetRepDepartmentsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepDepartmentsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepDepartmentsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepDepartmentsLOVRequest) ParameterName(parameterName []string) ApiGetRepDepartmentsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepDepartmentsLOVRequest) ParameterValue(parameterValue []string) ApiGetRepDepartmentsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepDepartmentsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepDepartmentsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepDepartmentsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepDepartmentsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepDepartmentsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepDepartmentsLOVExecute(r)
}

/*
GetRepDepartmentsLOV Fetch List Of Values for Rep Departments

 <p><strong>OperationId:</strong>getRepDepartmentsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepDepartments LOV
 @return ApiGetRepDepartmentsLOVRequest
*/
func (a *LOVApiService) GetRepDepartmentsLOV(ctx context.Context, hotelId string) ApiGetRepDepartmentsLOVRequest {
	return ApiGetRepDepartmentsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepDepartmentsLOVExecute(r ApiGetRepDepartmentsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepDepartmentsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repDepartments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepFiscalMonthsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fiscalYearId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepFiscalMonthsLOVRequest) Authorization(authorization string) ApiGetRepFiscalMonthsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepFiscalMonthsLOVRequest) XAppKey(xAppKey string) ApiGetRepFiscalMonthsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepFiscalMonthsLOVRequest) XHotelid(xHotelid string) ApiGetRepFiscalMonthsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepFiscalMonthsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepFiscalMonthsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepFiscalMonthsLOVRequest) ParameterName(parameterName []string) ApiGetRepFiscalMonthsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepFiscalMonthsLOVRequest) ParameterValue(parameterValue []string) ApiGetRepFiscalMonthsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepFiscalMonthsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepFiscalMonthsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepFiscalMonthsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepFiscalMonthsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepFiscalMonthsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepFiscalMonthsLOVExecute(r)
}

/*
GetRepFiscalMonthsLOV Fetch List Of Values for Rep Fiscal Months

 <p><strong>OperationId:</strong>getRepFiscalMonthsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fiscalYearId Value of the parameter 'fiscalYearId' which is required to fetch RepFiscalMonths LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepFiscalMonths LOV
 @return ApiGetRepFiscalMonthsLOVRequest
*/
func (a *LOVApiService) GetRepFiscalMonthsLOV(ctx context.Context, fiscalYearId string, hotelId string) ApiGetRepFiscalMonthsLOVRequest {
	return ApiGetRepFiscalMonthsLOVRequest{
		ApiService: a,
		ctx: ctx,
		fiscalYearId: fiscalYearId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepFiscalMonthsLOVExecute(r ApiGetRepFiscalMonthsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepFiscalMonthsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fiscalYearId/{fiscalYearId}/repFiscalMonths"
	localVarPath = strings.Replace(localVarPath, "{"+"fiscalYearId"+"}", url.PathEscape(parameterValueToString(r.fiscalYearId, "fiscalYearId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fiscalYearId) < 1 {
		return localVarReturnValue, nil, reportError("fiscalYearId must have at least 1 elements")
	}
	if strlen(r.fiscalYearId) > 2000 {
		return localVarReturnValue, nil, reportError("fiscalYearId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepFiscalWeeksLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fiscalYearId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepFiscalWeeksLOVRequest) Authorization(authorization string) ApiGetRepFiscalWeeksLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepFiscalWeeksLOVRequest) XAppKey(xAppKey string) ApiGetRepFiscalWeeksLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepFiscalWeeksLOVRequest) XHotelid(xHotelid string) ApiGetRepFiscalWeeksLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepFiscalWeeksLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepFiscalWeeksLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepFiscalWeeksLOVRequest) ParameterName(parameterName []string) ApiGetRepFiscalWeeksLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepFiscalWeeksLOVRequest) ParameterValue(parameterValue []string) ApiGetRepFiscalWeeksLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepFiscalWeeksLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepFiscalWeeksLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepFiscalWeeksLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepFiscalWeeksLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepFiscalWeeksLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepFiscalWeeksLOVExecute(r)
}

/*
GetRepFiscalWeeksLOV Fetch List Of Values for Rep Fiscal Weeks

 <p><strong>OperationId:</strong>getRepFiscalWeeksLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fiscalYearId Value of the parameter 'fiscalYearId' which is required to fetch RepFiscalWeeks LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepFiscalWeeks LOV
 @return ApiGetRepFiscalWeeksLOVRequest
*/
func (a *LOVApiService) GetRepFiscalWeeksLOV(ctx context.Context, fiscalYearId string, hotelId string) ApiGetRepFiscalWeeksLOVRequest {
	return ApiGetRepFiscalWeeksLOVRequest{
		ApiService: a,
		ctx: ctx,
		fiscalYearId: fiscalYearId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepFiscalWeeksLOVExecute(r ApiGetRepFiscalWeeksLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepFiscalWeeksLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fiscalYearId/{fiscalYearId}/repFiscalWeeks"
	localVarPath = strings.Replace(localVarPath, "{"+"fiscalYearId"+"}", url.PathEscape(parameterValueToString(r.fiscalYearId, "fiscalYearId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fiscalYearId) < 1 {
		return localVarReturnValue, nil, reportError("fiscalYearId must have at least 1 elements")
	}
	if strlen(r.fiscalYearId) > 2000 {
		return localVarReturnValue, nil, reportError("fiscalYearId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepFiscalYearsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepFiscalYearsLOVRequest) Authorization(authorization string) ApiGetRepFiscalYearsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepFiscalYearsLOVRequest) XAppKey(xAppKey string) ApiGetRepFiscalYearsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepFiscalYearsLOVRequest) XHotelid(xHotelid string) ApiGetRepFiscalYearsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepFiscalYearsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepFiscalYearsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepFiscalYearsLOVRequest) ParameterName(parameterName []string) ApiGetRepFiscalYearsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepFiscalYearsLOVRequest) ParameterValue(parameterValue []string) ApiGetRepFiscalYearsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepFiscalYearsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepFiscalYearsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepFiscalYearsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepFiscalYearsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepFiscalYearsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepFiscalYearsLOVExecute(r)
}

/*
GetRepFiscalYearsLOV Fetch List Of Values for Rep Fiscal Years

 <p><strong>OperationId:</strong>getRepFiscalYearsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepFiscalYears LOV
 @return ApiGetRepFiscalYearsLOVRequest
*/
func (a *LOVApiService) GetRepFiscalYearsLOV(ctx context.Context, hotelId string) ApiGetRepFiscalYearsLOVRequest {
	return ApiGetRepFiscalYearsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepFiscalYearsLOVExecute(r ApiGetRepFiscalYearsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepFiscalYearsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repFiscalYears"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepForeignCurrenciesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepForeignCurrenciesLOVRequest) Authorization(authorization string) ApiGetRepForeignCurrenciesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepForeignCurrenciesLOVRequest) XAppKey(xAppKey string) ApiGetRepForeignCurrenciesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepForeignCurrenciesLOVRequest) XHotelid(xHotelid string) ApiGetRepForeignCurrenciesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepForeignCurrenciesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepForeignCurrenciesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepForeignCurrenciesLOVRequest) ParameterName(parameterName []string) ApiGetRepForeignCurrenciesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepForeignCurrenciesLOVRequest) ParameterValue(parameterValue []string) ApiGetRepForeignCurrenciesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepForeignCurrenciesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepForeignCurrenciesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepForeignCurrenciesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepForeignCurrenciesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepForeignCurrenciesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepForeignCurrenciesLOVExecute(r)
}

/*
GetRepForeignCurrenciesLOV Fetch List Of Values for Rep Foreign Currencies

 <p><strong>OperationId:</strong>getRepForeignCurrenciesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepForeignCurrencies LOV
 @return ApiGetRepForeignCurrenciesLOVRequest
*/
func (a *LOVApiService) GetRepForeignCurrenciesLOV(ctx context.Context, hotelId string) ApiGetRepForeignCurrenciesLOVRequest {
	return ApiGetRepForeignCurrenciesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepForeignCurrenciesLOVExecute(r ApiGetRepForeignCurrenciesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepForeignCurrenciesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repForeignCurrencies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepGroupReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	groupName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepGroupReportsLOVRequest) Authorization(authorization string) ApiGetRepGroupReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepGroupReportsLOVRequest) XAppKey(xAppKey string) ApiGetRepGroupReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepGroupReportsLOVRequest) XHotelid(xHotelid string) ApiGetRepGroupReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepGroupReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepGroupReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepGroupReportsLOVRequest) ParameterName(parameterName []string) ApiGetRepGroupReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepGroupReportsLOVRequest) ParameterValue(parameterValue []string) ApiGetRepGroupReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepGroupReportsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepGroupReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepGroupReportsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepGroupReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepGroupReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepGroupReportsLOVExecute(r)
}

/*
GetRepGroupReportsLOV Fetch List Of Values for Rep Group Reports

 <p><strong>OperationId:</strong>getRepGroupReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Value of the parameter 'groupName' which is required to fetch RepGroupReports LOV
 @return ApiGetRepGroupReportsLOVRequest
*/
func (a *LOVApiService) GetRepGroupReportsLOV(ctx context.Context, groupName string) ApiGetRepGroupReportsLOVRequest {
	return ApiGetRepGroupReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepGroupReportsLOVExecute(r ApiGetRepGroupReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepGroupReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/groupName/{groupName}/repGroupReports"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupName) < 1 {
		return localVarReturnValue, nil, reportError("groupName must have at least 1 elements")
	}
	if strlen(r.groupName) > 2000 {
		return localVarReturnValue, nil, reportError("groupName must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepGroupsLOVRequest) Authorization(authorization string) ApiGetRepGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepGroupsLOVRequest) XAppKey(xAppKey string) ApiGetRepGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepGroupsLOVRequest) XHotelid(xHotelid string) ApiGetRepGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepGroupsLOVRequest) ParameterName(parameterName []string) ApiGetRepGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetRepGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepGroupsLOVExecute(r)
}

/*
GetRepGroupsLOV Fetch List Of Values for Rep Groups

 <p><strong>OperationId:</strong>getRepGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepGroups LOV
 @return ApiGetRepGroupsLOVRequest
*/
func (a *LOVApiService) GetRepGroupsLOV(ctx context.Context, hotelId string) ApiGetRepGroupsLOVRequest {
	return ApiGetRepGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepGroupsLOVExecute(r ApiGetRepGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepInventoryItemPoolsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepInventoryItemPoolsLOVRequest) Authorization(authorization string) ApiGetRepInventoryItemPoolsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepInventoryItemPoolsLOVRequest) XAppKey(xAppKey string) ApiGetRepInventoryItemPoolsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepInventoryItemPoolsLOVRequest) XHotelid(xHotelid string) ApiGetRepInventoryItemPoolsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepInventoryItemPoolsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepInventoryItemPoolsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepInventoryItemPoolsLOVRequest) ParameterName(parameterName []string) ApiGetRepInventoryItemPoolsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepInventoryItemPoolsLOVRequest) ParameterValue(parameterValue []string) ApiGetRepInventoryItemPoolsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepInventoryItemPoolsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepInventoryItemPoolsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepInventoryItemPoolsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepInventoryItemPoolsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepInventoryItemPoolsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepInventoryItemPoolsLOVExecute(r)
}

/*
GetRepInventoryItemPoolsLOV Fetch List Of Values for Rep Inventory Item Pools

 <p><strong>OperationId:</strong>getRepInventoryItemPoolsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepInventoryItemPools LOV
 @return ApiGetRepInventoryItemPoolsLOVRequest
*/
func (a *LOVApiService) GetRepInventoryItemPoolsLOV(ctx context.Context, hotelId string) ApiGetRepInventoryItemPoolsLOVRequest {
	return ApiGetRepInventoryItemPoolsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepInventoryItemPoolsLOVExecute(r ApiGetRepInventoryItemPoolsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepInventoryItemPoolsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repInventoryItemPools"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepMarketCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepMarketCodesLOVRequest) Authorization(authorization string) ApiGetRepMarketCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepMarketCodesLOVRequest) XAppKey(xAppKey string) ApiGetRepMarketCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepMarketCodesLOVRequest) XHotelid(xHotelid string) ApiGetRepMarketCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepMarketCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepMarketCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepMarketCodesLOVRequest) ParameterName(parameterName []string) ApiGetRepMarketCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepMarketCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetRepMarketCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepMarketCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepMarketCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepMarketCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepMarketCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepMarketCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepMarketCodesLOVExecute(r)
}

/*
GetRepMarketCodesLOV Fetch List Of Values for Rep Market Codes

 <p><strong>OperationId:</strong>getRepMarketCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepMarketCodes LOV
 @return ApiGetRepMarketCodesLOVRequest
*/
func (a *LOVApiService) GetRepMarketCodesLOV(ctx context.Context, hotelId string) ApiGetRepMarketCodesLOVRequest {
	return ApiGetRepMarketCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepMarketCodesLOVExecute(r ApiGetRepMarketCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepMarketCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repMarketCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepOwnerCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelCodesList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepOwnerCodesLOVRequest) Authorization(authorization string) ApiGetRepOwnerCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepOwnerCodesLOVRequest) XAppKey(xAppKey string) ApiGetRepOwnerCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepOwnerCodesLOVRequest) XHotelid(xHotelid string) ApiGetRepOwnerCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepOwnerCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepOwnerCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepOwnerCodesLOVRequest) ParameterName(parameterName []string) ApiGetRepOwnerCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepOwnerCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetRepOwnerCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepOwnerCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepOwnerCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepOwnerCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepOwnerCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepOwnerCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepOwnerCodesLOVExecute(r)
}

/*
GetRepOwnerCodesLOV Fetch List Of Values for Rep Owner Codes

 <p><strong>OperationId:</strong>getRepOwnerCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelCodesList Value of the parameter 'hotelCodesList' which is required to fetch RepOwnerCodes LOV
 @return ApiGetRepOwnerCodesLOVRequest
*/
func (a *LOVApiService) GetRepOwnerCodesLOV(ctx context.Context, hotelCodesList string) ApiGetRepOwnerCodesLOVRequest {
	return ApiGetRepOwnerCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelCodesList: hotelCodesList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepOwnerCodesLOVExecute(r ApiGetRepOwnerCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepOwnerCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotelCodesList/{hotelCodesList}/repOwnerCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelCodesList"+"}", url.PathEscape(parameterValueToString(r.hotelCodesList, "hotelCodesList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelCodesList) < 1 {
		return localVarReturnValue, nil, reportError("hotelCodesList must have at least 1 elements")
	}
	if strlen(r.hotelCodesList) > 2000 {
		return localVarReturnValue, nil, reportError("hotelCodesList must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepRatePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	propertyList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepRatePlansLOVRequest) Authorization(authorization string) ApiGetRepRatePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepRatePlansLOVRequest) XAppKey(xAppKey string) ApiGetRepRatePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepRatePlansLOVRequest) XHotelid(xHotelid string) ApiGetRepRatePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepRatePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepRatePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepRatePlansLOVRequest) ParameterName(parameterName []string) ApiGetRepRatePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepRatePlansLOVRequest) ParameterValue(parameterValue []string) ApiGetRepRatePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepRatePlansLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepRatePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepRatePlansLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepRatePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepRatePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepRatePlansLOVExecute(r)
}

/*
GetRepRatePlansLOV Fetch List Of Values for Rep Rate Plans

 <p><strong>OperationId:</strong>getRepRatePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param propertyList Value of the parameter 'propertyList' which is required to fetch RepRatePlans LOV
 @return ApiGetRepRatePlansLOVRequest
*/
func (a *LOVApiService) GetRepRatePlansLOV(ctx context.Context, propertyList string) ApiGetRepRatePlansLOVRequest {
	return ApiGetRepRatePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		propertyList: propertyList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepRatePlansLOVExecute(r ApiGetRepRatePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepRatePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/propertyList/{propertyList}/repRatePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"propertyList"+"}", url.PathEscape(parameterValueToString(r.propertyList, "propertyList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.propertyList) < 1 {
		return localVarReturnValue, nil, reportError("propertyList must have at least 1 elements")
	}
	if strlen(r.propertyList) > 2000 {
		return localVarReturnValue, nil, reportError("propertyList must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepRoomStatusesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepRoomStatusesLOVRequest) Authorization(authorization string) ApiGetRepRoomStatusesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepRoomStatusesLOVRequest) XAppKey(xAppKey string) ApiGetRepRoomStatusesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepRoomStatusesLOVRequest) XHotelid(xHotelid string) ApiGetRepRoomStatusesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepRoomStatusesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepRoomStatusesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepRoomStatusesLOVRequest) ParameterName(parameterName []string) ApiGetRepRoomStatusesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepRoomStatusesLOVRequest) ParameterValue(parameterValue []string) ApiGetRepRoomStatusesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepRoomStatusesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepRoomStatusesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepRoomStatusesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepRoomStatusesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepRoomStatusesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepRoomStatusesLOVExecute(r)
}

/*
GetRepRoomStatusesLOV Fetch List Of Values for Rep Room Statuses

 <p><strong>OperationId:</strong>getRepRoomStatusesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepRoomStatuses LOV
 @return ApiGetRepRoomStatusesLOVRequest
*/
func (a *LOVApiService) GetRepRoomStatusesLOV(ctx context.Context, hotelId string) ApiGetRepRoomStatusesLOVRequest {
	return ApiGetRepRoomStatusesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepRoomStatusesLOVExecute(r ApiGetRepRoomStatusesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepRoomStatusesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repRoomStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepRoomTypeMultiHotelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelCodeList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepRoomTypeMultiHotelLOVRequest) Authorization(authorization string) ApiGetRepRoomTypeMultiHotelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepRoomTypeMultiHotelLOVRequest) XAppKey(xAppKey string) ApiGetRepRoomTypeMultiHotelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepRoomTypeMultiHotelLOVRequest) XHotelid(xHotelid string) ApiGetRepRoomTypeMultiHotelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepRoomTypeMultiHotelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepRoomTypeMultiHotelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepRoomTypeMultiHotelLOVRequest) ParameterName(parameterName []string) ApiGetRepRoomTypeMultiHotelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepRoomTypeMultiHotelLOVRequest) ParameterValue(parameterValue []string) ApiGetRepRoomTypeMultiHotelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepRoomTypeMultiHotelLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepRoomTypeMultiHotelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepRoomTypeMultiHotelLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepRoomTypeMultiHotelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepRoomTypeMultiHotelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepRoomTypeMultiHotelLOVExecute(r)
}

/*
GetRepRoomTypeMultiHotelLOV Fetch List Of Values for Rep Room Type Multi Hotel

 <p><strong>OperationId:</strong>getRepRoomTypeMultiHotelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelCodeList Value of the parameter 'hotelCodeList' which is required to fetch RepRoomTypeMultiHotel LOV
 @return ApiGetRepRoomTypeMultiHotelLOVRequest
*/
func (a *LOVApiService) GetRepRoomTypeMultiHotelLOV(ctx context.Context, hotelCodeList string) ApiGetRepRoomTypeMultiHotelLOVRequest {
	return ApiGetRepRoomTypeMultiHotelLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelCodeList: hotelCodeList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepRoomTypeMultiHotelLOVExecute(r ApiGetRepRoomTypeMultiHotelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepRoomTypeMultiHotelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotelCodeList/{hotelCodeList}/repRoomTypeMultiHotel"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelCodeList"+"}", url.PathEscape(parameterValueToString(r.hotelCodeList, "hotelCodeList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelCodeList) < 1 {
		return localVarReturnValue, nil, reportError("hotelCodeList must have at least 1 elements")
	}
	if strlen(r.hotelCodeList) > 2000 {
		return localVarReturnValue, nil, reportError("hotelCodeList must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepRoomTypesLOVRequest) Authorization(authorization string) ApiGetRepRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepRoomTypesLOVRequest) XAppKey(xAppKey string) ApiGetRepRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepRoomTypesLOVRequest) XHotelid(xHotelid string) ApiGetRepRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepRoomTypesLOVRequest) ParameterName(parameterName []string) ApiGetRepRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepRoomTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetRepRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepRoomTypesLOVExecute(r)
}

/*
GetRepRoomTypesLOV Fetch List Of Values for Rep Room Types

 <p><strong>OperationId:</strong>getRepRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepRoomTypes LOV
 @return ApiGetRepRoomTypesLOVRequest
*/
func (a *LOVApiService) GetRepRoomTypesLOV(ctx context.Context, hotelId string) ApiGetRepRoomTypesLOVRequest {
	return ApiGetRepRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepRoomTypesLOVExecute(r ApiGetRepRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepRoomsLOVRequest) Authorization(authorization string) ApiGetRepRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepRoomsLOVRequest) XAppKey(xAppKey string) ApiGetRepRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepRoomsLOVRequest) XHotelid(xHotelid string) ApiGetRepRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepRoomsLOVRequest) ParameterName(parameterName []string) ApiGetRepRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepRoomsLOVRequest) ParameterValue(parameterValue []string) ApiGetRepRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepRoomsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepRoomsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepRoomsLOVExecute(r)
}

/*
GetRepRoomsLOV Fetch List Of Values for Rep Rooms

 <p><strong>OperationId:</strong>getRepRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepRooms LOV
 @return ApiGetRepRoomsLOVRequest
*/
func (a *LOVApiService) GetRepRoomsLOV(ctx context.Context, hotelId string) ApiGetRepRoomsLOVRequest {
	return ApiGetRepRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepRoomsLOVExecute(r ApiGetRepRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepRoomsStatLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	toDate string
	fromDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepRoomsStatLOVRequest) Authorization(authorization string) ApiGetRepRoomsStatLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepRoomsStatLOVRequest) XAppKey(xAppKey string) ApiGetRepRoomsStatLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepRoomsStatLOVRequest) XHotelid(xHotelid string) ApiGetRepRoomsStatLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepRoomsStatLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepRoomsStatLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepRoomsStatLOVRequest) ParameterName(parameterName []string) ApiGetRepRoomsStatLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepRoomsStatLOVRequest) ParameterValue(parameterValue []string) ApiGetRepRoomsStatLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepRoomsStatLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepRoomsStatLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepRoomsStatLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepRoomsStatLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepRoomsStatLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepRoomsStatLOVExecute(r)
}

/*
GetRepRoomsStatLOV Fetch List Of Values for Rep Rooms Stat

 <p><strong>OperationId:</strong>getRepRoomsStatLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param toDate Value of the parameter 'toDate' which is required to fetch RepRoomsStat LOV
 @param fromDate Value of the parameter 'fromDate' which is required to fetch RepRoomsStat LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepRoomsStat LOV
 @return ApiGetRepRoomsStatLOVRequest
*/
func (a *LOVApiService) GetRepRoomsStatLOV(ctx context.Context, toDate string, fromDate string, hotelId string) ApiGetRepRoomsStatLOVRequest {
	return ApiGetRepRoomsStatLOVRequest{
		ApiService: a,
		ctx: ctx,
		toDate: toDate,
		fromDate: fromDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepRoomsStatLOVExecute(r ApiGetRepRoomsStatLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepRoomsStatLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fromDate/{fromDate}/toDate/{toDate}/repRoomsStat"
	localVarPath = strings.Replace(localVarPath, "{"+"toDate"+"}", url.PathEscape(parameterValueToString(r.toDate, "toDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fromDate"+"}", url.PathEscape(parameterValueToString(r.fromDate, "fromDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.toDate) < 1 {
		return localVarReturnValue, nil, reportError("toDate must have at least 1 elements")
	}
	if strlen(r.toDate) > 2000 {
		return localVarReturnValue, nil, reportError("toDate must have less than 2000 elements")
	}
	if strlen(r.fromDate) < 1 {
		return localVarReturnValue, nil, reportError("fromDate must have at least 1 elements")
	}
	if strlen(r.fromDate) > 2000 {
		return localVarReturnValue, nil, reportError("fromDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepServiceRequestCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepServiceRequestCodesLOVRequest) Authorization(authorization string) ApiGetRepServiceRequestCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepServiceRequestCodesLOVRequest) XAppKey(xAppKey string) ApiGetRepServiceRequestCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepServiceRequestCodesLOVRequest) XHotelid(xHotelid string) ApiGetRepServiceRequestCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepServiceRequestCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepServiceRequestCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepServiceRequestCodesLOVRequest) ParameterName(parameterName []string) ApiGetRepServiceRequestCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepServiceRequestCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetRepServiceRequestCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepServiceRequestCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepServiceRequestCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepServiceRequestCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepServiceRequestCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepServiceRequestCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepServiceRequestCodesLOVExecute(r)
}

/*
GetRepServiceRequestCodesLOV Fetch List Of Values for Rep Service Request Codes

 <p><strong>OperationId:</strong>getRepServiceRequestCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepServiceRequestCodes LOV
 @return ApiGetRepServiceRequestCodesLOVRequest
*/
func (a *LOVApiService) GetRepServiceRequestCodesLOV(ctx context.Context, hotelId string) ApiGetRepServiceRequestCodesLOVRequest {
	return ApiGetRepServiceRequestCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepServiceRequestCodesLOVExecute(r ApiGetRepServiceRequestCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepServiceRequestCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repServiceRequestCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepTransactionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepTransactionCodesLOVRequest) Authorization(authorization string) ApiGetRepTransactionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepTransactionCodesLOVRequest) XAppKey(xAppKey string) ApiGetRepTransactionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepTransactionCodesLOVRequest) XHotelid(xHotelid string) ApiGetRepTransactionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepTransactionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepTransactionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepTransactionCodesLOVRequest) ParameterName(parameterName []string) ApiGetRepTransactionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepTransactionCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetRepTransactionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepTransactionCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepTransactionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepTransactionCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepTransactionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepTransactionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepTransactionCodesLOVExecute(r)
}

/*
GetRepTransactionCodesLOV Fetch List Of Values for Rep Transaction Codes

 <p><strong>OperationId:</strong>getRepTransactionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepTransactionCodes LOV
 @return ApiGetRepTransactionCodesLOVRequest
*/
func (a *LOVApiService) GetRepTransactionCodesLOV(ctx context.Context, hotelId string) ApiGetRepTransactionCodesLOVRequest {
	return ApiGetRepTransactionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepTransactionCodesLOVExecute(r ApiGetRepTransactionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepTransactionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repTransactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepTraveAgtCalendarYearLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRepTraveAgtCalendarYearLOVRequest) Authorization(authorization string) ApiGetRepTraveAgtCalendarYearLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRepTraveAgtCalendarYearLOVRequest) XAppKey(xAppKey string) ApiGetRepTraveAgtCalendarYearLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRepTraveAgtCalendarYearLOVRequest) XHotelid(xHotelid string) ApiGetRepTraveAgtCalendarYearLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRepTraveAgtCalendarYearLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRepTraveAgtCalendarYearLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRepTraveAgtCalendarYearLOVRequest) ParameterName(parameterName []string) ApiGetRepTraveAgtCalendarYearLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRepTraveAgtCalendarYearLOVRequest) ParameterValue(parameterValue []string) ApiGetRepTraveAgtCalendarYearLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRepTraveAgtCalendarYearLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRepTraveAgtCalendarYearLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRepTraveAgtCalendarYearLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRepTraveAgtCalendarYearLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRepTraveAgtCalendarYearLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepTraveAgtCalendarYearLOVExecute(r)
}

/*
GetRepTraveAgtCalendarYearLOV Fetch List Of Values for Rep Trave Agt Calendar Year

 <p><strong>OperationId:</strong>getRepTraveAgtCalendarYearLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepTraveAgtCalendarYear LOV
 @return ApiGetRepTraveAgtCalendarYearLOVRequest
*/
func (a *LOVApiService) GetRepTraveAgtCalendarYearLOV(ctx context.Context, hotelId string) ApiGetRepTraveAgtCalendarYearLOVRequest {
	return ApiGetRepTraveAgtCalendarYearLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepTraveAgtCalendarYearLOVExecute(r ApiGetRepTraveAgtCalendarYearLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepTraveAgtCalendarYearLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repTraveAgtCalendarYear"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportsGenericLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	parameter string
	moduleId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReportsGenericLOVRequest) Authorization(authorization string) ApiGetReportsGenericLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetReportsGenericLOVRequest) XAppKey(xAppKey string) ApiGetReportsGenericLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReportsGenericLOVRequest) XHotelid(xHotelid string) ApiGetReportsGenericLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetReportsGenericLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetReportsGenericLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetReportsGenericLOVRequest) ParameterName(parameterName []string) ApiGetReportsGenericLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetReportsGenericLOVRequest) ParameterValue(parameterValue []string) ApiGetReportsGenericLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetReportsGenericLOVRequest) XExternalsystem(xExternalsystem string) ApiGetReportsGenericLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReportsGenericLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetReportsGenericLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReportsGenericLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReportsGenericLOVExecute(r)
}

/*
GetReportsGenericLOV Fetch List Of Values for Reports Generic

 <p><strong>OperationId:</strong>getReportsGenericLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parameter Value of the parameter 'parameter' which is required to fetch ReportsGeneric LOV
 @param moduleId Value of the parameter 'moduleId' which is required to fetch ReportsGeneric LOV
 @return ApiGetReportsGenericLOVRequest
*/
func (a *LOVApiService) GetReportsGenericLOV(ctx context.Context, parameter string, moduleId string) ApiGetReportsGenericLOVRequest {
	return ApiGetReportsGenericLOVRequest{
		ApiService: a,
		ctx: ctx,
		parameter: parameter,
		moduleId: moduleId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReportsGenericLOVExecute(r ApiGetReportsGenericLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReportsGenericLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/moduleId/{moduleId}/parameterName/{parameter}/reportsGeneric"
	localVarPath = strings.Replace(localVarPath, "{"+"parameter"+"}", url.PathEscape(parameterValueToString(r.parameter, "parameter")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"moduleId"+"}", url.PathEscape(parameterValueToString(r.moduleId, "moduleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.parameter) < 1 {
		return localVarReturnValue, nil, reportError("parameter must have at least 1 elements")
	}
	if strlen(r.parameter) > 2000 {
		return localVarReturnValue, nil, reportError("parameter must have less than 2000 elements")
	}
	if strlen(r.moduleId) < 1 {
		return localVarReturnValue, nil, reportError("moduleId must have at least 1 elements")
	}
	if strlen(r.moduleId) > 2000 {
		return localVarReturnValue, nil, reportError("moduleId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResStatReportRateCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	endDate string
	beginDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResStatReportRateCodeLOVRequest) Authorization(authorization string) ApiGetResStatReportRateCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResStatReportRateCodeLOVRequest) XAppKey(xAppKey string) ApiGetResStatReportRateCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResStatReportRateCodeLOVRequest) XHotelid(xHotelid string) ApiGetResStatReportRateCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResStatReportRateCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResStatReportRateCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResStatReportRateCodeLOVRequest) ParameterName(parameterName []string) ApiGetResStatReportRateCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResStatReportRateCodeLOVRequest) ParameterValue(parameterValue []string) ApiGetResStatReportRateCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResStatReportRateCodeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResStatReportRateCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResStatReportRateCodeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResStatReportRateCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResStatReportRateCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResStatReportRateCodeLOVExecute(r)
}

/*
GetResStatReportRateCodeLOV Fetch List Of Values for Res Stat Report Rate Code

 <p><strong>OperationId:</strong>getResStatReportRateCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endDate Value of the parameter 'endDate' which is required to fetch ResStatReportRateCode LOV
 @param beginDate Value of the parameter 'beginDate' which is required to fetch ResStatReportRateCode LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResStatReportRateCode LOV
 @return ApiGetResStatReportRateCodeLOVRequest
*/
func (a *LOVApiService) GetResStatReportRateCodeLOV(ctx context.Context, endDate string, beginDate string, hotelId string) ApiGetResStatReportRateCodeLOVRequest {
	return ApiGetResStatReportRateCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		endDate: endDate,
		beginDate: beginDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResStatReportRateCodeLOVExecute(r ApiGetResStatReportRateCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResStatReportRateCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/beginDate/{beginDate}/endDate/{endDate}/resStatReportRateCode"
	localVarPath = strings.Replace(localVarPath, "{"+"endDate"+"}", url.PathEscape(parameterValueToString(r.endDate, "endDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"beginDate"+"}", url.PathEscape(parameterValueToString(r.beginDate, "beginDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.endDate) < 1 {
		return localVarReturnValue, nil, reportError("endDate must have at least 1 elements")
	}
	if strlen(r.endDate) > 2000 {
		return localVarReturnValue, nil, reportError("endDate must have less than 2000 elements")
	}
	if strlen(r.beginDate) < 1 {
		return localVarReturnValue, nil, reportError("beginDate must have at least 1 elements")
	}
	if strlen(r.beginDate) > 2000 {
		return localVarReturnValue, nil, reportError("beginDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationBasedBlocksLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationBasedBlocksLOVRequest) Authorization(authorization string) ApiGetReservationBasedBlocksLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetReservationBasedBlocksLOVRequest) XAppKey(xAppKey string) ApiGetReservationBasedBlocksLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationBasedBlocksLOVRequest) XHotelid(xHotelid string) ApiGetReservationBasedBlocksLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetReservationBasedBlocksLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetReservationBasedBlocksLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetReservationBasedBlocksLOVRequest) ParameterName(parameterName []string) ApiGetReservationBasedBlocksLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetReservationBasedBlocksLOVRequest) ParameterValue(parameterValue []string) ApiGetReservationBasedBlocksLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetReservationBasedBlocksLOVRequest) XExternalsystem(xExternalsystem string) ApiGetReservationBasedBlocksLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationBasedBlocksLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationBasedBlocksLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationBasedBlocksLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationBasedBlocksLOVExecute(r)
}

/*
GetReservationBasedBlocksLOV Fetch List Of Values for Reservation Based Blocks

 <p><strong>OperationId:</strong>getReservationBasedBlocksLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationBasedBlocks LOV
 @return ApiGetReservationBasedBlocksLOVRequest
*/
func (a *LOVApiService) GetReservationBasedBlocksLOV(ctx context.Context, hotelId string) ApiGetReservationBasedBlocksLOVRequest {
	return ApiGetReservationBasedBlocksLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationBasedBlocksLOVExecute(r ApiGetReservationBasedBlocksLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationBasedBlocksLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/reservationBasedBlocks"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationBasedProfilesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationBasedProfilesLOVRequest) Authorization(authorization string) ApiGetReservationBasedProfilesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetReservationBasedProfilesLOVRequest) XAppKey(xAppKey string) ApiGetReservationBasedProfilesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationBasedProfilesLOVRequest) XHotelid(xHotelid string) ApiGetReservationBasedProfilesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetReservationBasedProfilesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetReservationBasedProfilesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetReservationBasedProfilesLOVRequest) ParameterName(parameterName []string) ApiGetReservationBasedProfilesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetReservationBasedProfilesLOVRequest) ParameterValue(parameterValue []string) ApiGetReservationBasedProfilesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetReservationBasedProfilesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetReservationBasedProfilesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationBasedProfilesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationBasedProfilesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationBasedProfilesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationBasedProfilesLOVExecute(r)
}

/*
GetReservationBasedProfilesLOV Fetch List Of Values for Reservation Based Profiles

 <p><strong>OperationId:</strong>getReservationBasedProfilesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationBasedProfiles LOV
 @return ApiGetReservationBasedProfilesLOVRequest
*/
func (a *LOVApiService) GetReservationBasedProfilesLOV(ctx context.Context, hotelId string) ApiGetReservationBasedProfilesLOVRequest {
	return ApiGetReservationBasedProfilesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationBasedProfilesLOVExecute(r ApiGetReservationBasedProfilesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationBasedProfilesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/reservationBasedProfiles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationPackagesGroupItemsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	group string
	arrival string
	children string
	adults string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationPackagesGroupItemsLOVRequest) Authorization(authorization string) ApiGetReservationPackagesGroupItemsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetReservationPackagesGroupItemsLOVRequest) XAppKey(xAppKey string) ApiGetReservationPackagesGroupItemsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationPackagesGroupItemsLOVRequest) XHotelid(xHotelid string) ApiGetReservationPackagesGroupItemsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetReservationPackagesGroupItemsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetReservationPackagesGroupItemsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetReservationPackagesGroupItemsLOVRequest) ParameterName(parameterName []string) ApiGetReservationPackagesGroupItemsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetReservationPackagesGroupItemsLOVRequest) ParameterValue(parameterValue []string) ApiGetReservationPackagesGroupItemsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetReservationPackagesGroupItemsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetReservationPackagesGroupItemsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationPackagesGroupItemsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationPackagesGroupItemsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationPackagesGroupItemsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationPackagesGroupItemsLOVExecute(r)
}

/*
GetReservationPackagesGroupItemsLOV Fetch List Of Values for Reservation Packages Group Items

 <p><strong>OperationId:</strong>getReservationPackagesGroupItemsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param group Value of the parameter 'group' which is required to fetch ReservationPackagesGroupItems LOV
 @param arrival Value of the parameter 'arrival' which is required to fetch ReservationPackagesGroupItems LOV
 @param children Value of the parameter 'children' which is required to fetch ReservationPackagesGroupItems LOV
 @param adults Value of the parameter 'adults' which is required to fetch ReservationPackagesGroupItems LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationPackagesGroupItems LOV
 @return ApiGetReservationPackagesGroupItemsLOVRequest
*/
func (a *LOVApiService) GetReservationPackagesGroupItemsLOV(ctx context.Context, group string, arrival string, children string, adults string, hotelId string) ApiGetReservationPackagesGroupItemsLOVRequest {
	return ApiGetReservationPackagesGroupItemsLOVRequest{
		ApiService: a,
		ctx: ctx,
		group: group,
		arrival: arrival,
		children: children,
		adults: adults,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationPackagesGroupItemsLOVExecute(r ApiGetReservationPackagesGroupItemsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationPackagesGroupItemsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/adults/{adults}/children/{children}/arrival/{arrival}/group/{group}/reservationPackagesGroupItems"
	localVarPath = strings.Replace(localVarPath, "{"+"group"+"}", url.PathEscape(parameterValueToString(r.group, "group")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"arrival"+"}", url.PathEscape(parameterValueToString(r.arrival, "arrival")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"children"+"}", url.PathEscape(parameterValueToString(r.children, "children")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"adults"+"}", url.PathEscape(parameterValueToString(r.adults, "adults")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.group) < 1 {
		return localVarReturnValue, nil, reportError("group must have at least 1 elements")
	}
	if strlen(r.group) > 2000 {
		return localVarReturnValue, nil, reportError("group must have less than 2000 elements")
	}
	if strlen(r.arrival) < 1 {
		return localVarReturnValue, nil, reportError("arrival must have at least 1 elements")
	}
	if strlen(r.arrival) > 2000 {
		return localVarReturnValue, nil, reportError("arrival must have less than 2000 elements")
	}
	if strlen(r.children) < 1 {
		return localVarReturnValue, nil, reportError("children must have at least 1 elements")
	}
	if strlen(r.children) > 2000 {
		return localVarReturnValue, nil, reportError("children must have less than 2000 elements")
	}
	if strlen(r.adults) < 1 {
		return localVarReturnValue, nil, reportError("adults must have at least 1 elements")
	}
	if strlen(r.adults) > 2000 {
		return localVarReturnValue, nil, reportError("adults must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationPackagesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	departure string
	arrival string
	children string
	adults string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationPackagesLOVRequest) Authorization(authorization string) ApiGetReservationPackagesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetReservationPackagesLOVRequest) XAppKey(xAppKey string) ApiGetReservationPackagesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationPackagesLOVRequest) XHotelid(xHotelid string) ApiGetReservationPackagesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetReservationPackagesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetReservationPackagesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetReservationPackagesLOVRequest) ParameterName(parameterName []string) ApiGetReservationPackagesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetReservationPackagesLOVRequest) ParameterValue(parameterValue []string) ApiGetReservationPackagesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetReservationPackagesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetReservationPackagesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationPackagesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationPackagesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationPackagesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationPackagesLOVExecute(r)
}

/*
GetReservationPackagesLOV Fetch List Of Values for Reservation Packages

 <p><strong>OperationId:</strong>getReservationPackagesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departure Value of the parameter 'departure' which is required to fetch ReservationPackages LOV
 @param arrival Value of the parameter 'arrival' which is required to fetch ReservationPackages LOV
 @param children Value of the parameter 'children' which is required to fetch ReservationPackages LOV
 @param adults Value of the parameter 'adults' which is required to fetch ReservationPackages LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationPackages LOV
 @return ApiGetReservationPackagesLOVRequest
*/
func (a *LOVApiService) GetReservationPackagesLOV(ctx context.Context, departure string, arrival string, children string, adults string, hotelId string) ApiGetReservationPackagesLOVRequest {
	return ApiGetReservationPackagesLOVRequest{
		ApiService: a,
		ctx: ctx,
		departure: departure,
		arrival: arrival,
		children: children,
		adults: adults,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationPackagesLOVExecute(r ApiGetReservationPackagesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationPackagesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/adults/{adults}/children/{children}/arrival/{arrival}/departure/{departure}/reservationPackages"
	localVarPath = strings.Replace(localVarPath, "{"+"departure"+"}", url.PathEscape(parameterValueToString(r.departure, "departure")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"arrival"+"}", url.PathEscape(parameterValueToString(r.arrival, "arrival")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"children"+"}", url.PathEscape(parameterValueToString(r.children, "children")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"adults"+"}", url.PathEscape(parameterValueToString(r.adults, "adults")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departure) < 1 {
		return localVarReturnValue, nil, reportError("departure must have at least 1 elements")
	}
	if strlen(r.departure) > 2000 {
		return localVarReturnValue, nil, reportError("departure must have less than 2000 elements")
	}
	if strlen(r.arrival) < 1 {
		return localVarReturnValue, nil, reportError("arrival must have at least 1 elements")
	}
	if strlen(r.arrival) > 2000 {
		return localVarReturnValue, nil, reportError("arrival must have less than 2000 elements")
	}
	if strlen(r.children) < 1 {
		return localVarReturnValue, nil, reportError("children must have at least 1 elements")
	}
	if strlen(r.children) > 2000 {
		return localVarReturnValue, nil, reportError("children must have less than 2000 elements")
	}
	if strlen(r.adults) < 1 {
		return localVarReturnValue, nil, reportError("adults must have at least 1 elements")
	}
	if strlen(r.adults) > 2000 {
		return localVarReturnValue, nil, reportError("adults must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationPreferencesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationPreferencesLOVRequest) Authorization(authorization string) ApiGetReservationPreferencesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetReservationPreferencesLOVRequest) XAppKey(xAppKey string) ApiGetReservationPreferencesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationPreferencesLOVRequest) XHotelid(xHotelid string) ApiGetReservationPreferencesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetReservationPreferencesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetReservationPreferencesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetReservationPreferencesLOVRequest) ParameterName(parameterName []string) ApiGetReservationPreferencesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetReservationPreferencesLOVRequest) ParameterValue(parameterValue []string) ApiGetReservationPreferencesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetReservationPreferencesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetReservationPreferencesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationPreferencesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationPreferencesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationPreferencesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationPreferencesLOVExecute(r)
}

/*
GetReservationPreferencesLOV Fetch List Of Values for Reservation Preferences

 <p><strong>OperationId:</strong>getReservationPreferencesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationPreferences LOV
 @return ApiGetReservationPreferencesLOVRequest
*/
func (a *LOVApiService) GetReservationPreferencesLOV(ctx context.Context, hotelId string) ApiGetReservationPreferencesLOVRequest {
	return ApiGetReservationPreferencesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationPreferencesLOVExecute(r ApiGetReservationPreferencesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationPreferencesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/reservationPreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationStatusesHotelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationStatusesHotelLOVRequest) Authorization(authorization string) ApiGetReservationStatusesHotelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetReservationStatusesHotelLOVRequest) XAppKey(xAppKey string) ApiGetReservationStatusesHotelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationStatusesHotelLOVRequest) XHotelid(xHotelid string) ApiGetReservationStatusesHotelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetReservationStatusesHotelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetReservationStatusesHotelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetReservationStatusesHotelLOVRequest) ParameterName(parameterName []string) ApiGetReservationStatusesHotelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetReservationStatusesHotelLOVRequest) ParameterValue(parameterValue []string) ApiGetReservationStatusesHotelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetReservationStatusesHotelLOVRequest) XExternalsystem(xExternalsystem string) ApiGetReservationStatusesHotelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationStatusesHotelLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationStatusesHotelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationStatusesHotelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationStatusesHotelLOVExecute(r)
}

/*
GetReservationStatusesHotelLOV Fetch List Of Values for Reservation Statuses Hotel

 <p><strong>OperationId:</strong>getReservationStatusesHotelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationStatusesHotel LOV
 @return ApiGetReservationStatusesHotelLOVRequest
*/
func (a *LOVApiService) GetReservationStatusesHotelLOV(ctx context.Context, hotelId string) ApiGetReservationStatusesHotelLOVRequest {
	return ApiGetReservationStatusesHotelLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationStatusesHotelLOVExecute(r ApiGetReservationStatusesHotelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationStatusesHotelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/reservationStatusesHotel"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationTicketsCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	departure string
	arrival string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationTicketsCodesLOVRequest) Authorization(authorization string) ApiGetReservationTicketsCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetReservationTicketsCodesLOVRequest) XAppKey(xAppKey string) ApiGetReservationTicketsCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationTicketsCodesLOVRequest) XHotelid(xHotelid string) ApiGetReservationTicketsCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetReservationTicketsCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetReservationTicketsCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetReservationTicketsCodesLOVRequest) ParameterName(parameterName []string) ApiGetReservationTicketsCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetReservationTicketsCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetReservationTicketsCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetReservationTicketsCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetReservationTicketsCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationTicketsCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationTicketsCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationTicketsCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationTicketsCodesLOVExecute(r)
}

/*
GetReservationTicketsCodesLOV Fetch List Of Values for Reservation Tickets Codes

 <p><strong>OperationId:</strong>getReservationTicketsCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departure Value of the parameter 'departure' which is required to fetch ReservationTicketsCodes LOV
 @param arrival Value of the parameter 'arrival' which is required to fetch ReservationTicketsCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationTicketsCodes LOV
 @return ApiGetReservationTicketsCodesLOVRequest
*/
func (a *LOVApiService) GetReservationTicketsCodesLOV(ctx context.Context, departure string, arrival string, hotelId string) ApiGetReservationTicketsCodesLOVRequest {
	return ApiGetReservationTicketsCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		departure: departure,
		arrival: arrival,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationTicketsCodesLOVExecute(r ApiGetReservationTicketsCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationTicketsCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arrival/{arrival}/departure/{departure}/reservationTicketsCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"departure"+"}", url.PathEscape(parameterValueToString(r.departure, "departure")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"arrival"+"}", url.PathEscape(parameterValueToString(r.arrival, "arrival")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departure) < 1 {
		return localVarReturnValue, nil, reportError("departure must have at least 1 elements")
	}
	if strlen(r.departure) > 2000 {
		return localVarReturnValue, nil, reportError("departure must have less than 2000 elements")
	}
	if strlen(r.arrival) < 1 {
		return localVarReturnValue, nil, reportError("arrival must have at least 1 elements")
	}
	if strlen(r.arrival) > 2000 {
		return localVarReturnValue, nil, reportError("arrival must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReservationTicketsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	resvNameId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetReservationTicketsLOVRequest) Authorization(authorization string) ApiGetReservationTicketsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetReservationTicketsLOVRequest) XAppKey(xAppKey string) ApiGetReservationTicketsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetReservationTicketsLOVRequest) XHotelid(xHotelid string) ApiGetReservationTicketsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetReservationTicketsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetReservationTicketsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetReservationTicketsLOVRequest) ParameterName(parameterName []string) ApiGetReservationTicketsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetReservationTicketsLOVRequest) ParameterValue(parameterValue []string) ApiGetReservationTicketsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetReservationTicketsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetReservationTicketsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetReservationTicketsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetReservationTicketsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetReservationTicketsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationTicketsLOVExecute(r)
}

/*
GetReservationTicketsLOV Fetch List Of Values for Reservation Tickets

 <p><strong>OperationId:</strong>getReservationTicketsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resvNameId Value of the parameter 'resvNameId' which is required to fetch ReservationTickets LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationTickets LOV
 @return ApiGetReservationTicketsLOVRequest
*/
func (a *LOVApiService) GetReservationTicketsLOV(ctx context.Context, resvNameId string, hotelId string) ApiGetReservationTicketsLOVRequest {
	return ApiGetReservationTicketsLOVRequest{
		ApiService: a,
		ctx: ctx,
		resvNameId: resvNameId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationTicketsLOVExecute(r ApiGetReservationTicketsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationTicketsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resvNameId/{resvNameId}/reservationTickets"
	localVarPath = strings.Replace(localVarPath, "{"+"resvNameId"+"}", url.PathEscape(parameterValueToString(r.resvNameId, "resvNameId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.resvNameId) < 1 {
		return localVarReturnValue, nil, reportError("resvNameId must have at least 1 elements")
	}
	if strlen(r.resvNameId) > 2000 {
		return localVarReturnValue, nil, reportError("resvNameId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResortAirportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResortAirportsLOVRequest) Authorization(authorization string) ApiGetResortAirportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResortAirportsLOVRequest) XAppKey(xAppKey string) ApiGetResortAirportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResortAirportsLOVRequest) XHotelid(xHotelid string) ApiGetResortAirportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResortAirportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResortAirportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResortAirportsLOVRequest) ParameterName(parameterName []string) ApiGetResortAirportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResortAirportsLOVRequest) ParameterValue(parameterValue []string) ApiGetResortAirportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResortAirportsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResortAirportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResortAirportsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResortAirportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResortAirportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortAirportsLOVExecute(r)
}

/*
GetResortAirportsLOV Fetch List Of Values for Resort Airports

 <p><strong>OperationId:</strong>getResortAirportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortAirports LOV
 @return ApiGetResortAirportsLOVRequest
*/
func (a *LOVApiService) GetResortAirportsLOV(ctx context.Context, hotelId string) ApiGetResortAirportsLOVRequest {
	return ApiGetResortAirportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortAirportsLOVExecute(r ApiGetResortAirportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortAirportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortAirports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResortCROsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResortCROsLOVRequest) Authorization(authorization string) ApiGetResortCROsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResortCROsLOVRequest) XAppKey(xAppKey string) ApiGetResortCROsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResortCROsLOVRequest) XHotelid(xHotelid string) ApiGetResortCROsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResortCROsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResortCROsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResortCROsLOVRequest) ParameterName(parameterName []string) ApiGetResortCROsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResortCROsLOVRequest) ParameterValue(parameterValue []string) ApiGetResortCROsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResortCROsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResortCROsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResortCROsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResortCROsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResortCROsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortCROsLOVExecute(r)
}

/*
GetResortCROsLOV Fetch List Of Values for Resort CROs

 <p><strong>OperationId:</strong>getResortCROsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortCROs LOV
 @return ApiGetResortCROsLOVRequest
*/
func (a *LOVApiService) GetResortCROsLOV(ctx context.Context, hotelId string) ApiGetResortCROsLOVRequest {
	return ApiGetResortCROsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortCROsLOVExecute(r ApiGetResortCROsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortCROsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortCROs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResortGuaranteeCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResortGuaranteeCodesLOVRequest) Authorization(authorization string) ApiGetResortGuaranteeCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResortGuaranteeCodesLOVRequest) XAppKey(xAppKey string) ApiGetResortGuaranteeCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResortGuaranteeCodesLOVRequest) XHotelid(xHotelid string) ApiGetResortGuaranteeCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResortGuaranteeCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResortGuaranteeCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResortGuaranteeCodesLOVRequest) ParameterName(parameterName []string) ApiGetResortGuaranteeCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResortGuaranteeCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetResortGuaranteeCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResortGuaranteeCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResortGuaranteeCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResortGuaranteeCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResortGuaranteeCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResortGuaranteeCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortGuaranteeCodesLOVExecute(r)
}

/*
GetResortGuaranteeCodesLOV Fetch List Of Values for Resort Guarantee Codes

 <p><strong>OperationId:</strong>getResortGuaranteeCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortGuaranteeCodes LOV
 @return ApiGetResortGuaranteeCodesLOVRequest
*/
func (a *LOVApiService) GetResortGuaranteeCodesLOV(ctx context.Context, hotelId string) ApiGetResortGuaranteeCodesLOVRequest {
	return ApiGetResortGuaranteeCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortGuaranteeCodesLOVExecute(r ApiGetResortGuaranteeCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortGuaranteeCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortGuaranteeCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResortInventoryItemsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	sellInEvent string
	sellInReservation string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResortInventoryItemsLOVRequest) Authorization(authorization string) ApiGetResortInventoryItemsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResortInventoryItemsLOVRequest) XAppKey(xAppKey string) ApiGetResortInventoryItemsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResortInventoryItemsLOVRequest) XHotelid(xHotelid string) ApiGetResortInventoryItemsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResortInventoryItemsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResortInventoryItemsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResortInventoryItemsLOVRequest) ParameterName(parameterName []string) ApiGetResortInventoryItemsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResortInventoryItemsLOVRequest) ParameterValue(parameterValue []string) ApiGetResortInventoryItemsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResortInventoryItemsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResortInventoryItemsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResortInventoryItemsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResortInventoryItemsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResortInventoryItemsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortInventoryItemsLOVExecute(r)
}

/*
GetResortInventoryItemsLOV Fetch List Of Values for Resort Inventory Items

 <p><strong>OperationId:</strong>getResortInventoryItemsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sellInEvent Value of the parameter 'sellInEvent' which is required to fetch ResortInventoryItems LOV
 @param sellInReservation Value of the parameter 'sellInReservation' which is required to fetch ResortInventoryItems LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortInventoryItems LOV
 @return ApiGetResortInventoryItemsLOVRequest
*/
func (a *LOVApiService) GetResortInventoryItemsLOV(ctx context.Context, sellInEvent string, sellInReservation string, hotelId string) ApiGetResortInventoryItemsLOVRequest {
	return ApiGetResortInventoryItemsLOVRequest{
		ApiService: a,
		ctx: ctx,
		sellInEvent: sellInEvent,
		sellInReservation: sellInReservation,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortInventoryItemsLOVExecute(r ApiGetResortInventoryItemsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortInventoryItemsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/sellInReservation/{sellInReservation}/sellInEvent/{sellInEvent}/resortInventoryItems"
	localVarPath = strings.Replace(localVarPath, "{"+"sellInEvent"+"}", url.PathEscape(parameterValueToString(r.sellInEvent, "sellInEvent")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sellInReservation"+"}", url.PathEscape(parameterValueToString(r.sellInReservation, "sellInReservation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sellInEvent) < 1 {
		return localVarReturnValue, nil, reportError("sellInEvent must have at least 1 elements")
	}
	if strlen(r.sellInEvent) > 2000 {
		return localVarReturnValue, nil, reportError("sellInEvent must have less than 2000 elements")
	}
	if strlen(r.sellInReservation) < 1 {
		return localVarReturnValue, nil, reportError("sellInReservation must have at least 1 elements")
	}
	if strlen(r.sellInReservation) > 2000 {
		return localVarReturnValue, nil, reportError("sellInReservation must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResortMarketCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResortMarketCodesLOVRequest) Authorization(authorization string) ApiGetResortMarketCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResortMarketCodesLOVRequest) XAppKey(xAppKey string) ApiGetResortMarketCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResortMarketCodesLOVRequest) XHotelid(xHotelid string) ApiGetResortMarketCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResortMarketCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResortMarketCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResortMarketCodesLOVRequest) ParameterName(parameterName []string) ApiGetResortMarketCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResortMarketCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetResortMarketCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResortMarketCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResortMarketCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResortMarketCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResortMarketCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResortMarketCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortMarketCodesLOVExecute(r)
}

/*
GetResortMarketCodesLOV Fetch List Of Values for Resort Market Codes

 <p><strong>OperationId:</strong>getResortMarketCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortMarketCodes LOV
 @return ApiGetResortMarketCodesLOVRequest
*/
func (a *LOVApiService) GetResortMarketCodesLOV(ctx context.Context, hotelId string) ApiGetResortMarketCodesLOVRequest {
	return ApiGetResortMarketCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortMarketCodesLOVExecute(r ApiGetResortMarketCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortMarketCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortMarketCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResortRateClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResortRateClassesLOVRequest) Authorization(authorization string) ApiGetResortRateClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResortRateClassesLOVRequest) XAppKey(xAppKey string) ApiGetResortRateClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResortRateClassesLOVRequest) XHotelid(xHotelid string) ApiGetResortRateClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResortRateClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResortRateClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResortRateClassesLOVRequest) ParameterName(parameterName []string) ApiGetResortRateClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResortRateClassesLOVRequest) ParameterValue(parameterValue []string) ApiGetResortRateClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResortRateClassesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResortRateClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResortRateClassesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResortRateClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResortRateClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortRateClassesLOVExecute(r)
}

/*
GetResortRateClassesLOV Fetch List Of Values for Resort Rate Classes

 <p><strong>OperationId:</strong>getResortRateClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortRateClasses LOV
 @return ApiGetResortRateClassesLOVRequest
*/
func (a *LOVApiService) GetResortRateClassesLOV(ctx context.Context, hotelId string) ApiGetResortRateClassesLOVRequest {
	return ApiGetResortRateClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortRateClassesLOVExecute(r ApiGetResortRateClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortRateClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortRateClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResortRestrictionStatusesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResortRestrictionStatusesLOVRequest) Authorization(authorization string) ApiGetResortRestrictionStatusesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResortRestrictionStatusesLOVRequest) XAppKey(xAppKey string) ApiGetResortRestrictionStatusesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResortRestrictionStatusesLOVRequest) XHotelid(xHotelid string) ApiGetResortRestrictionStatusesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResortRestrictionStatusesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResortRestrictionStatusesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResortRestrictionStatusesLOVRequest) ParameterName(parameterName []string) ApiGetResortRestrictionStatusesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResortRestrictionStatusesLOVRequest) ParameterValue(parameterValue []string) ApiGetResortRestrictionStatusesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResortRestrictionStatusesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResortRestrictionStatusesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResortRestrictionStatusesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResortRestrictionStatusesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResortRestrictionStatusesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortRestrictionStatusesLOVExecute(r)
}

/*
GetResortRestrictionStatusesLOV Fetch List Of Values for Resort Restriction Statuses

 <p><strong>OperationId:</strong>getResortRestrictionStatusesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortRestrictionStatuses LOV
 @return ApiGetResortRestrictionStatusesLOVRequest
*/
func (a *LOVApiService) GetResortRestrictionStatusesLOV(ctx context.Context, hotelId string) ApiGetResortRestrictionStatusesLOVRequest {
	return ApiGetResortRestrictionStatusesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortRestrictionStatusesLOVExecute(r ApiGetResortRestrictionStatusesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortRestrictionStatusesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortRestrictionStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResortRoomNumbersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResortRoomNumbersLOVRequest) Authorization(authorization string) ApiGetResortRoomNumbersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResortRoomNumbersLOVRequest) XAppKey(xAppKey string) ApiGetResortRoomNumbersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResortRoomNumbersLOVRequest) XHotelid(xHotelid string) ApiGetResortRoomNumbersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResortRoomNumbersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResortRoomNumbersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResortRoomNumbersLOVRequest) ParameterName(parameterName []string) ApiGetResortRoomNumbersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResortRoomNumbersLOVRequest) ParameterValue(parameterValue []string) ApiGetResortRoomNumbersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResortRoomNumbersLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResortRoomNumbersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResortRoomNumbersLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResortRoomNumbersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResortRoomNumbersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortRoomNumbersLOVExecute(r)
}

/*
GetResortRoomNumbersLOV Fetch List Of Values for Resort Room Numbers

 <p><strong>OperationId:</strong>getResortRoomNumbersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortRoomNumbers LOV
 @return ApiGetResortRoomNumbersLOVRequest
*/
func (a *LOVApiService) GetResortRoomNumbersLOV(ctx context.Context, hotelId string) ApiGetResortRoomNumbersLOVRequest {
	return ApiGetResortRoomNumbersLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortRoomNumbersLOVExecute(r ApiGetResortRoomNumbersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortRoomNumbersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortRoomNumbers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResortRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResortRoomTypesLOVRequest) Authorization(authorization string) ApiGetResortRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResortRoomTypesLOVRequest) XAppKey(xAppKey string) ApiGetResortRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResortRoomTypesLOVRequest) XHotelid(xHotelid string) ApiGetResortRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResortRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResortRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResortRoomTypesLOVRequest) ParameterName(parameterName []string) ApiGetResortRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResortRoomTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetResortRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResortRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResortRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResortRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResortRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResortRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortRoomTypesLOVExecute(r)
}

/*
GetResortRoomTypesLOV Fetch List Of Values for Resort Room Types

 <p><strong>OperationId:</strong>getResortRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortRoomTypes LOV
 @return ApiGetResortRoomTypesLOVRequest
*/
func (a *LOVApiService) GetResortRoomTypesLOV(ctx context.Context, hotelId string) ApiGetResortRoomTypesLOVRequest {
	return ApiGetResortRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortRoomTypesLOVExecute(r ApiGetResortRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResortTransportationLabelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResortTransportationLabelsLOVRequest) Authorization(authorization string) ApiGetResortTransportationLabelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResortTransportationLabelsLOVRequest) XAppKey(xAppKey string) ApiGetResortTransportationLabelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResortTransportationLabelsLOVRequest) XHotelid(xHotelid string) ApiGetResortTransportationLabelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResortTransportationLabelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResortTransportationLabelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResortTransportationLabelsLOVRequest) ParameterName(parameterName []string) ApiGetResortTransportationLabelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResortTransportationLabelsLOVRequest) ParameterValue(parameterValue []string) ApiGetResortTransportationLabelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResortTransportationLabelsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResortTransportationLabelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResortTransportationLabelsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResortTransportationLabelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResortTransportationLabelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortTransportationLabelsLOVExecute(r)
}

/*
GetResortTransportationLabelsLOV Fetch List Of Values for Resort Transportation Labels

 <p><strong>OperationId:</strong>getResortTransportationLabelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortTransportationLabels LOV
 @return ApiGetResortTransportationLabelsLOVRequest
*/
func (a *LOVApiService) GetResortTransportationLabelsLOV(ctx context.Context, hotelId string) ApiGetResortTransportationLabelsLOVRequest {
	return ApiGetResortTransportationLabelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortTransportationLabelsLOVExecute(r ApiGetResortTransportationLabelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortTransportationLabelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortTransportationLabels"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResourceItemClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResourceItemClassesLOVRequest) Authorization(authorization string) ApiGetResourceItemClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResourceItemClassesLOVRequest) XAppKey(xAppKey string) ApiGetResourceItemClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResourceItemClassesLOVRequest) XHotelid(xHotelid string) ApiGetResourceItemClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResourceItemClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResourceItemClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResourceItemClassesLOVRequest) ParameterName(parameterName []string) ApiGetResourceItemClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResourceItemClassesLOVRequest) ParameterValue(parameterValue []string) ApiGetResourceItemClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResourceItemClassesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResourceItemClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResourceItemClassesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResourceItemClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResourceItemClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResourceItemClassesLOVExecute(r)
}

/*
GetResourceItemClassesLOV Fetch List Of Values for Resource Item Classes

 <p><strong>OperationId:</strong>getResourceItemClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResourceItemClasses LOV
 @return ApiGetResourceItemClassesLOVRequest
*/
func (a *LOVApiService) GetResourceItemClassesLOV(ctx context.Context, hotelId string) ApiGetResourceItemClassesLOVRequest {
	return ApiGetResourceItemClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResourceItemClassesLOVExecute(r ApiGetResourceItemClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResourceItemClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resourceItemClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResvAutoAttachRulesCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResvAutoAttachRulesCodesLOVRequest) Authorization(authorization string) ApiGetResvAutoAttachRulesCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResvAutoAttachRulesCodesLOVRequest) XAppKey(xAppKey string) ApiGetResvAutoAttachRulesCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResvAutoAttachRulesCodesLOVRequest) XHotelid(xHotelid string) ApiGetResvAutoAttachRulesCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResvAutoAttachRulesCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResvAutoAttachRulesCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResvAutoAttachRulesCodesLOVRequest) ParameterName(parameterName []string) ApiGetResvAutoAttachRulesCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResvAutoAttachRulesCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetResvAutoAttachRulesCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResvAutoAttachRulesCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResvAutoAttachRulesCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResvAutoAttachRulesCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResvAutoAttachRulesCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResvAutoAttachRulesCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResvAutoAttachRulesCodesLOVExecute(r)
}

/*
GetResvAutoAttachRulesCodesLOV Fetch List Of Values for Resv Auto Attach Rules Codes

 <p><strong>OperationId:</strong>getResvAutoAttachRulesCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResvAutoAttachRulesCodes LOV
 @return ApiGetResvAutoAttachRulesCodesLOVRequest
*/
func (a *LOVApiService) GetResvAutoAttachRulesCodesLOV(ctx context.Context, hotelId string) ApiGetResvAutoAttachRulesCodesLOVRequest {
	return ApiGetResvAutoAttachRulesCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResvAutoAttachRulesCodesLOVExecute(r ApiGetResvAutoAttachRulesCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResvAutoAttachRulesCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resvAutoAttachRulesCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResvAutoAttachRulesRuleTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResvAutoAttachRulesRuleTypeLOVRequest) Authorization(authorization string) ApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResvAutoAttachRulesRuleTypeLOVRequest) XAppKey(xAppKey string) ApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResvAutoAttachRulesRuleTypeLOVRequest) XHotelid(xHotelid string) ApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResvAutoAttachRulesRuleTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResvAutoAttachRulesRuleTypeLOVRequest) ParameterName(parameterName []string) ApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResvAutoAttachRulesRuleTypeLOVRequest) ParameterValue(parameterValue []string) ApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResvAutoAttachRulesRuleTypeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResvAutoAttachRulesRuleTypeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResvAutoAttachRulesRuleTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResvAutoAttachRulesRuleTypeLOVExecute(r)
}

/*
GetResvAutoAttachRulesRuleTypeLOV Fetch List Of Values for Resv Auto Attach Rules Rule Type

 <p><strong>OperationId:</strong>getResvAutoAttachRulesRuleTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResvAutoAttachRulesRuleType LOV
 @return ApiGetResvAutoAttachRulesRuleTypeLOVRequest
*/
func (a *LOVApiService) GetResvAutoAttachRulesRuleTypeLOV(ctx context.Context, hotelId string) ApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	return ApiGetResvAutoAttachRulesRuleTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResvAutoAttachRulesRuleTypeLOVExecute(r ApiGetResvAutoAttachRulesRuleTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResvAutoAttachRulesRuleTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resvAutoAttachRulesRuleType"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResvBasedProfilesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResvBasedProfilesLOVRequest) Authorization(authorization string) ApiGetResvBasedProfilesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResvBasedProfilesLOVRequest) XAppKey(xAppKey string) ApiGetResvBasedProfilesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResvBasedProfilesLOVRequest) XHotelid(xHotelid string) ApiGetResvBasedProfilesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResvBasedProfilesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResvBasedProfilesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResvBasedProfilesLOVRequest) ParameterName(parameterName []string) ApiGetResvBasedProfilesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResvBasedProfilesLOVRequest) ParameterValue(parameterValue []string) ApiGetResvBasedProfilesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResvBasedProfilesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResvBasedProfilesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResvBasedProfilesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResvBasedProfilesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResvBasedProfilesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResvBasedProfilesLOVExecute(r)
}

/*
GetResvBasedProfilesLOV Fetch List Of Values for Resv Based Profiles

 <p><strong>OperationId:</strong>getResvBasedProfilesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResvBasedProfiles LOV
 @return ApiGetResvBasedProfilesLOVRequest
*/
func (a *LOVApiService) GetResvBasedProfilesLOV(ctx context.Context, hotelId string) ApiGetResvBasedProfilesLOVRequest {
	return ApiGetResvBasedProfilesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResvBasedProfilesLOVExecute(r ApiGetResvBasedProfilesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResvBasedProfilesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resvBasedProfiles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResvTransactionDiversionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	resvNameId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetResvTransactionDiversionCodesLOVRequest) Authorization(authorization string) ApiGetResvTransactionDiversionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetResvTransactionDiversionCodesLOVRequest) XAppKey(xAppKey string) ApiGetResvTransactionDiversionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetResvTransactionDiversionCodesLOVRequest) XHotelid(xHotelid string) ApiGetResvTransactionDiversionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetResvTransactionDiversionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetResvTransactionDiversionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetResvTransactionDiversionCodesLOVRequest) ParameterName(parameterName []string) ApiGetResvTransactionDiversionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetResvTransactionDiversionCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetResvTransactionDiversionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetResvTransactionDiversionCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetResvTransactionDiversionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetResvTransactionDiversionCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetResvTransactionDiversionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetResvTransactionDiversionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResvTransactionDiversionCodesLOVExecute(r)
}

/*
GetResvTransactionDiversionCodesLOV Fetch List Of Values for Resv Transaction Diversion Codes

 <p><strong>OperationId:</strong>getResvTransactionDiversionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resvNameId Value of the parameter 'resvNameId' which is required to fetch ResvTransactionDiversionCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResvTransactionDiversionCodes LOV
 @return ApiGetResvTransactionDiversionCodesLOVRequest
*/
func (a *LOVApiService) GetResvTransactionDiversionCodesLOV(ctx context.Context, resvNameId string, hotelId string) ApiGetResvTransactionDiversionCodesLOVRequest {
	return ApiGetResvTransactionDiversionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		resvNameId: resvNameId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResvTransactionDiversionCodesLOVExecute(r ApiGetResvTransactionDiversionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResvTransactionDiversionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resvNameId/{resvNameId}/resvTransactionDiversionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"resvNameId"+"}", url.PathEscape(parameterValueToString(r.resvNameId, "resvNameId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.resvNameId) < 1 {
		return localVarReturnValue, nil, reportError("resvNameId must have at least 1 elements")
	}
	if strlen(r.resvNameId) > 2000 {
		return localVarReturnValue, nil, reportError("resvNameId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRevenueBucketTrxCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bucketType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRevenueBucketTrxCodesLOVRequest) Authorization(authorization string) ApiGetRevenueBucketTrxCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRevenueBucketTrxCodesLOVRequest) XAppKey(xAppKey string) ApiGetRevenueBucketTrxCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRevenueBucketTrxCodesLOVRequest) XHotelid(xHotelid string) ApiGetRevenueBucketTrxCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRevenueBucketTrxCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRevenueBucketTrxCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRevenueBucketTrxCodesLOVRequest) ParameterName(parameterName []string) ApiGetRevenueBucketTrxCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRevenueBucketTrxCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetRevenueBucketTrxCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRevenueBucketTrxCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRevenueBucketTrxCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRevenueBucketTrxCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRevenueBucketTrxCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRevenueBucketTrxCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRevenueBucketTrxCodesLOVExecute(r)
}

/*
GetRevenueBucketTrxCodesLOV Fetch List Of Values for Revenue Bucket Trx Codes

 <p><strong>OperationId:</strong>getRevenueBucketTrxCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketType Value of the parameter 'bucketType' which is required to fetch RevenueBucketTrxCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RevenueBucketTrxCodes LOV
 @return ApiGetRevenueBucketTrxCodesLOVRequest
*/
func (a *LOVApiService) GetRevenueBucketTrxCodesLOV(ctx context.Context, bucketType string, hotelId string) ApiGetRevenueBucketTrxCodesLOVRequest {
	return ApiGetRevenueBucketTrxCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bucketType: bucketType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRevenueBucketTrxCodesLOVExecute(r ApiGetRevenueBucketTrxCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRevenueBucketTrxCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/bucketType/{bucketType}/revenueBucketTrxCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"bucketType"+"}", url.PathEscape(parameterValueToString(r.bucketType, "bucketType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bucketType) < 1 {
		return localVarReturnValue, nil, reportError("bucketType must have at least 1 elements")
	}
	if strlen(r.bucketType) > 2000 {
		return localVarReturnValue, nil, reportError("bucketType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRevenueBucketsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	type_ string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRevenueBucketsLOVRequest) Authorization(authorization string) ApiGetRevenueBucketsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRevenueBucketsLOVRequest) XAppKey(xAppKey string) ApiGetRevenueBucketsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRevenueBucketsLOVRequest) XHotelid(xHotelid string) ApiGetRevenueBucketsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRevenueBucketsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRevenueBucketsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRevenueBucketsLOVRequest) ParameterName(parameterName []string) ApiGetRevenueBucketsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRevenueBucketsLOVRequest) ParameterValue(parameterValue []string) ApiGetRevenueBucketsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRevenueBucketsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRevenueBucketsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRevenueBucketsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRevenueBucketsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRevenueBucketsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRevenueBucketsLOVExecute(r)
}

/*
GetRevenueBucketsLOV Fetch List Of Values for Revenue Buckets

 <p><strong>OperationId:</strong>getRevenueBucketsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Value of the parameter 'type' which is required to fetch RevenueBuckets LOV
 @return ApiGetRevenueBucketsLOVRequest
*/
func (a *LOVApiService) GetRevenueBucketsLOV(ctx context.Context, type_ string) ApiGetRevenueBucketsLOVRequest {
	return ApiGetRevenueBucketsLOVRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRevenueBucketsLOVExecute(r ApiGetRevenueBucketsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRevenueBucketsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/type/{type}/revenueBuckets"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.type_) < 1 {
		return localVarReturnValue, nil, reportError("type_ must have at least 1 elements")
	}
	if strlen(r.type_) > 2000 {
		return localVarReturnValue, nil, reportError("type_ must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRevenueTypeMappingSpaceLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRevenueTypeMappingSpaceLOVRequest) Authorization(authorization string) ApiGetRevenueTypeMappingSpaceLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRevenueTypeMappingSpaceLOVRequest) XAppKey(xAppKey string) ApiGetRevenueTypeMappingSpaceLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRevenueTypeMappingSpaceLOVRequest) XHotelid(xHotelid string) ApiGetRevenueTypeMappingSpaceLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRevenueTypeMappingSpaceLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRevenueTypeMappingSpaceLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRevenueTypeMappingSpaceLOVRequest) ParameterName(parameterName []string) ApiGetRevenueTypeMappingSpaceLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRevenueTypeMappingSpaceLOVRequest) ParameterValue(parameterValue []string) ApiGetRevenueTypeMappingSpaceLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRevenueTypeMappingSpaceLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRevenueTypeMappingSpaceLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRevenueTypeMappingSpaceLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRevenueTypeMappingSpaceLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRevenueTypeMappingSpaceLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRevenueTypeMappingSpaceLOVExecute(r)
}

/*
GetRevenueTypeMappingSpaceLOV Fetch List Of Values for Revenue Type Mapping Space

 <p><strong>OperationId:</strong>getRevenueTypeMappingSpaceLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RevenueTypeMappingSpace LOV
 @return ApiGetRevenueTypeMappingSpaceLOVRequest
*/
func (a *LOVApiService) GetRevenueTypeMappingSpaceLOV(ctx context.Context, hotelId string) ApiGetRevenueTypeMappingSpaceLOVRequest {
	return ApiGetRevenueTypeMappingSpaceLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRevenueTypeMappingSpaceLOVExecute(r ApiGetRevenueTypeMappingSpaceLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRevenueTypeMappingSpaceLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/revenueTypeMappingSpace"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRevenueTypeMappingTrxCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRevenueTypeMappingTrxCodesLOVRequest) Authorization(authorization string) ApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRevenueTypeMappingTrxCodesLOVRequest) XAppKey(xAppKey string) ApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRevenueTypeMappingTrxCodesLOVRequest) XHotelid(xHotelid string) ApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRevenueTypeMappingTrxCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRevenueTypeMappingTrxCodesLOVRequest) ParameterName(parameterName []string) ApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRevenueTypeMappingTrxCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRevenueTypeMappingTrxCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRevenueTypeMappingTrxCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRevenueTypeMappingTrxCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRevenueTypeMappingTrxCodesLOVExecute(r)
}

/*
GetRevenueTypeMappingTrxCodesLOV Fetch List Of Values for Revenue Type Mapping Trx Codes

 <p><strong>OperationId:</strong>getRevenueTypeMappingTrxCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RevenueTypeMappingTrxCodes LOV
 @return ApiGetRevenueTypeMappingTrxCodesLOVRequest
*/
func (a *LOVApiService) GetRevenueTypeMappingTrxCodesLOV(ctx context.Context, hotelId string) ApiGetRevenueTypeMappingTrxCodesLOVRequest {
	return ApiGetRevenueTypeMappingTrxCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRevenueTypeMappingTrxCodesLOVExecute(r ApiGetRevenueTypeMappingTrxCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRevenueTypeMappingTrxCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/revenueTypeMappingTrxCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRolesForLevelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	levelCode string
	roleLevel string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRolesForLevelLOVRequest) Authorization(authorization string) ApiGetRolesForLevelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRolesForLevelLOVRequest) XAppKey(xAppKey string) ApiGetRolesForLevelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRolesForLevelLOVRequest) XHotelid(xHotelid string) ApiGetRolesForLevelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRolesForLevelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRolesForLevelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRolesForLevelLOVRequest) ParameterName(parameterName []string) ApiGetRolesForLevelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRolesForLevelLOVRequest) ParameterValue(parameterValue []string) ApiGetRolesForLevelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRolesForLevelLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRolesForLevelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRolesForLevelLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRolesForLevelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRolesForLevelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRolesForLevelLOVExecute(r)
}

/*
GetRolesForLevelLOV Fetch List Of Values for Roles For Level

 <p><strong>OperationId:</strong>getRolesForLevelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelCode Value of the parameter 'levelCode' which is required to fetch RolesForLevel LOV
 @param roleLevel Value of the parameter 'roleLevel' which is required to fetch RolesForLevel LOV
 @return ApiGetRolesForLevelLOVRequest
*/
func (a *LOVApiService) GetRolesForLevelLOV(ctx context.Context, levelCode string, roleLevel string) ApiGetRolesForLevelLOVRequest {
	return ApiGetRolesForLevelLOVRequest{
		ApiService: a,
		ctx: ctx,
		levelCode: levelCode,
		roleLevel: roleLevel,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRolesForLevelLOVExecute(r ApiGetRolesForLevelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRolesForLevelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/roleLevel/{roleLevel}/levelCode/{levelCode}/rolesForLevel"
	localVarPath = strings.Replace(localVarPath, "{"+"levelCode"+"}", url.PathEscape(parameterValueToString(r.levelCode, "levelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleLevel"+"}", url.PathEscape(parameterValueToString(r.roleLevel, "roleLevel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.levelCode) < 1 {
		return localVarReturnValue, nil, reportError("levelCode must have at least 1 elements")
	}
	if strlen(r.levelCode) > 2000 {
		return localVarReturnValue, nil, reportError("levelCode must have less than 2000 elements")
	}
	if strlen(r.roleLevel) < 1 {
		return localVarReturnValue, nil, reportError("roleLevel must have at least 1 elements")
	}
	if strlen(r.roleLevel) > 2000 {
		return localVarReturnValue, nil, reportError("roleLevel must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomClassCategoriesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomClassCategoriesLOVRequest) Authorization(authorization string) ApiGetRoomClassCategoriesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomClassCategoriesLOVRequest) XAppKey(xAppKey string) ApiGetRoomClassCategoriesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomClassCategoriesLOVRequest) XHotelid(xHotelid string) ApiGetRoomClassCategoriesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomClassCategoriesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomClassCategoriesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomClassCategoriesLOVRequest) ParameterName(parameterName []string) ApiGetRoomClassCategoriesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomClassCategoriesLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomClassCategoriesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomClassCategoriesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomClassCategoriesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomClassCategoriesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomClassCategoriesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomClassCategoriesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomClassCategoriesLOVExecute(r)
}

/*
GetRoomClassCategoriesLOV Fetch List Of Values for Room Class Categories

 <p><strong>OperationId:</strong>getRoomClassCategoriesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomClassCategories LOV
 @return ApiGetRoomClassCategoriesLOVRequest
*/
func (a *LOVApiService) GetRoomClassCategoriesLOV(ctx context.Context, hotelId string) ApiGetRoomClassCategoriesLOVRequest {
	return ApiGetRoomClassCategoriesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomClassCategoriesLOVExecute(r ApiGetRoomClassCategoriesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomClassCategoriesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomClassCategories"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomClassMultiPropertyLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelCodeList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomClassMultiPropertyLOVRequest) Authorization(authorization string) ApiGetRoomClassMultiPropertyLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomClassMultiPropertyLOVRequest) XAppKey(xAppKey string) ApiGetRoomClassMultiPropertyLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomClassMultiPropertyLOVRequest) XHotelid(xHotelid string) ApiGetRoomClassMultiPropertyLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomClassMultiPropertyLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomClassMultiPropertyLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomClassMultiPropertyLOVRequest) ParameterName(parameterName []string) ApiGetRoomClassMultiPropertyLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomClassMultiPropertyLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomClassMultiPropertyLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomClassMultiPropertyLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomClassMultiPropertyLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomClassMultiPropertyLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomClassMultiPropertyLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomClassMultiPropertyLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomClassMultiPropertyLOVExecute(r)
}

/*
GetRoomClassMultiPropertyLOV Fetch List Of Values for Room Class Multi Property

 <p><strong>OperationId:</strong>getRoomClassMultiPropertyLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelCodeList Value of the parameter 'hotelCodeList' which is required to fetch RoomClassMultiProperty LOV
 @return ApiGetRoomClassMultiPropertyLOVRequest
*/
func (a *LOVApiService) GetRoomClassMultiPropertyLOV(ctx context.Context, hotelCodeList string) ApiGetRoomClassMultiPropertyLOVRequest {
	return ApiGetRoomClassMultiPropertyLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelCodeList: hotelCodeList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomClassMultiPropertyLOVExecute(r ApiGetRoomClassMultiPropertyLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomClassMultiPropertyLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotelCodeList/{hotelCodeList}/roomClassMultiProperty"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelCodeList"+"}", url.PathEscape(parameterValueToString(r.hotelCodeList, "hotelCodeList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelCodeList) < 1 {
		return localVarReturnValue, nil, reportError("hotelCodeList must have at least 1 elements")
	}
	if strlen(r.hotelCodeList) > 2000 {
		return localVarReturnValue, nil, reportError("hotelCodeList must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomClassesLOVRequest) Authorization(authorization string) ApiGetRoomClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomClassesLOVRequest) XAppKey(xAppKey string) ApiGetRoomClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomClassesLOVRequest) XHotelid(xHotelid string) ApiGetRoomClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomClassesLOVRequest) ParameterName(parameterName []string) ApiGetRoomClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomClassesLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomClassesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomClassesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomClassesLOVExecute(r)
}

/*
GetRoomClassesLOV Fetch List Of Values for Room Classes

 <p><strong>OperationId:</strong>getRoomClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomClasses LOV
 @return ApiGetRoomClassesLOVRequest
*/
func (a *LOVApiService) GetRoomClassesLOV(ctx context.Context, hotelId string) ApiGetRoomClassesLOVRequest {
	return ApiGetRoomClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomClassesLOVExecute(r ApiGetRoomClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomFeaturesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomFeaturesLOVRequest) Authorization(authorization string) ApiGetRoomFeaturesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomFeaturesLOVRequest) XAppKey(xAppKey string) ApiGetRoomFeaturesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomFeaturesLOVRequest) XHotelid(xHotelid string) ApiGetRoomFeaturesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomFeaturesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomFeaturesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomFeaturesLOVRequest) ParameterName(parameterName []string) ApiGetRoomFeaturesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomFeaturesLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomFeaturesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomFeaturesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomFeaturesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomFeaturesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomFeaturesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomFeaturesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomFeaturesLOVExecute(r)
}

/*
GetRoomFeaturesLOV Fetch List Of Values for Room Features

 <p><strong>OperationId:</strong>getRoomFeaturesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomFeatures LOV
 @return ApiGetRoomFeaturesLOVRequest
*/
func (a *LOVApiService) GetRoomFeaturesLOV(ctx context.Context, hotelId string) ApiGetRoomFeaturesLOVRequest {
	return ApiGetRoomFeaturesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomFeaturesLOVExecute(r ApiGetRoomFeaturesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomFeaturesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomFeatures"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomHierarchyClassesCopyLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	property string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomHierarchyClassesCopyLOVRequest) Authorization(authorization string) ApiGetRoomHierarchyClassesCopyLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomHierarchyClassesCopyLOVRequest) XAppKey(xAppKey string) ApiGetRoomHierarchyClassesCopyLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomHierarchyClassesCopyLOVRequest) XHotelid(xHotelid string) ApiGetRoomHierarchyClassesCopyLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomHierarchyClassesCopyLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomHierarchyClassesCopyLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomHierarchyClassesCopyLOVRequest) ParameterName(parameterName []string) ApiGetRoomHierarchyClassesCopyLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomHierarchyClassesCopyLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomHierarchyClassesCopyLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomHierarchyClassesCopyLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomHierarchyClassesCopyLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomHierarchyClassesCopyLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomHierarchyClassesCopyLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomHierarchyClassesCopyLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomHierarchyClassesCopyLOVExecute(r)
}

/*
GetRoomHierarchyClassesCopyLOV Fetch List Of Values for Room Hierarchy Classes Copy

 <p><strong>OperationId:</strong>getRoomHierarchyClassesCopyLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param property Value of the parameter 'property' which is required to fetch RoomHierarchyClassesCopy LOV
 @return ApiGetRoomHierarchyClassesCopyLOVRequest
*/
func (a *LOVApiService) GetRoomHierarchyClassesCopyLOV(ctx context.Context, property string) ApiGetRoomHierarchyClassesCopyLOVRequest {
	return ApiGetRoomHierarchyClassesCopyLOVRequest{
		ApiService: a,
		ctx: ctx,
		property: property,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomHierarchyClassesCopyLOVExecute(r ApiGetRoomHierarchyClassesCopyLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomHierarchyClassesCopyLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/property/{property}/roomHierarchyClassesCopy"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.property) < 1 {
		return localVarReturnValue, nil, reportError("property must have at least 1 elements")
	}
	if strlen(r.property) > 2000 {
		return localVarReturnValue, nil, reportError("property must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomHierarchyRoomClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	property string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomHierarchyRoomClassesLOVRequest) Authorization(authorization string) ApiGetRoomHierarchyRoomClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomHierarchyRoomClassesLOVRequest) XAppKey(xAppKey string) ApiGetRoomHierarchyRoomClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomHierarchyRoomClassesLOVRequest) XHotelid(xHotelid string) ApiGetRoomHierarchyRoomClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomHierarchyRoomClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomHierarchyRoomClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomHierarchyRoomClassesLOVRequest) ParameterName(parameterName []string) ApiGetRoomHierarchyRoomClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomHierarchyRoomClassesLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomHierarchyRoomClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomHierarchyRoomClassesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomHierarchyRoomClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomHierarchyRoomClassesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomHierarchyRoomClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomHierarchyRoomClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomHierarchyRoomClassesLOVExecute(r)
}

/*
GetRoomHierarchyRoomClassesLOV Fetch List Of Values for Room Hierarchy Room Classes

 <p><strong>OperationId:</strong>getRoomHierarchyRoomClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param property Value of the parameter 'property' which is required to fetch RoomHierarchyRoomClasses LOV
 @return ApiGetRoomHierarchyRoomClassesLOVRequest
*/
func (a *LOVApiService) GetRoomHierarchyRoomClassesLOV(ctx context.Context, property string) ApiGetRoomHierarchyRoomClassesLOVRequest {
	return ApiGetRoomHierarchyRoomClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		property: property,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomHierarchyRoomClassesLOVExecute(r ApiGetRoomHierarchyRoomClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomHierarchyRoomClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/property/{property}/roomHierarchyRoomClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.property) < 1 {
		return localVarReturnValue, nil, reportError("property must have at least 1 elements")
	}
	if strlen(r.property) > 2000 {
		return localVarReturnValue, nil, reportError("property must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomHierarchyRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	property string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomHierarchyRoomTypesLOVRequest) Authorization(authorization string) ApiGetRoomHierarchyRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomHierarchyRoomTypesLOVRequest) XAppKey(xAppKey string) ApiGetRoomHierarchyRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomHierarchyRoomTypesLOVRequest) XHotelid(xHotelid string) ApiGetRoomHierarchyRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomHierarchyRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomHierarchyRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomHierarchyRoomTypesLOVRequest) ParameterName(parameterName []string) ApiGetRoomHierarchyRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomHierarchyRoomTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomHierarchyRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomHierarchyRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomHierarchyRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomHierarchyRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomHierarchyRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomHierarchyRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomHierarchyRoomTypesLOVExecute(r)
}

/*
GetRoomHierarchyRoomTypesLOV Fetch List Of Values for Room Hierarchy Room Types

 <p><strong>OperationId:</strong>getRoomHierarchyRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param property Value of the parameter 'property' which is required to fetch RoomHierarchyRoomTypes LOV
 @return ApiGetRoomHierarchyRoomTypesLOVRequest
*/
func (a *LOVApiService) GetRoomHierarchyRoomTypesLOV(ctx context.Context, property string) ApiGetRoomHierarchyRoomTypesLOVRequest {
	return ApiGetRoomHierarchyRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		property: property,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomHierarchyRoomTypesLOVExecute(r ApiGetRoomHierarchyRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomHierarchyRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/property/{property}/roomHierarchyRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.property) < 1 {
		return localVarReturnValue, nil, reportError("property must have at least 1 elements")
	}
	if strlen(r.property) > 2000 {
		return localVarReturnValue, nil, reportError("property must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomHierarchyTypesCopyLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	property string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomHierarchyTypesCopyLOVRequest) Authorization(authorization string) ApiGetRoomHierarchyTypesCopyLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomHierarchyTypesCopyLOVRequest) XAppKey(xAppKey string) ApiGetRoomHierarchyTypesCopyLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomHierarchyTypesCopyLOVRequest) XHotelid(xHotelid string) ApiGetRoomHierarchyTypesCopyLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomHierarchyTypesCopyLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomHierarchyTypesCopyLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomHierarchyTypesCopyLOVRequest) ParameterName(parameterName []string) ApiGetRoomHierarchyTypesCopyLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomHierarchyTypesCopyLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomHierarchyTypesCopyLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomHierarchyTypesCopyLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomHierarchyTypesCopyLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomHierarchyTypesCopyLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomHierarchyTypesCopyLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomHierarchyTypesCopyLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomHierarchyTypesCopyLOVExecute(r)
}

/*
GetRoomHierarchyTypesCopyLOV Fetch List Of Values for Room Hierarchy Types Copy

 <p><strong>OperationId:</strong>getRoomHierarchyTypesCopyLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param property Value of the parameter 'property' which is required to fetch RoomHierarchyTypesCopy LOV
 @return ApiGetRoomHierarchyTypesCopyLOVRequest
*/
func (a *LOVApiService) GetRoomHierarchyTypesCopyLOV(ctx context.Context, property string) ApiGetRoomHierarchyTypesCopyLOVRequest {
	return ApiGetRoomHierarchyTypesCopyLOVRequest{
		ApiService: a,
		ctx: ctx,
		property: property,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomHierarchyTypesCopyLOVExecute(r ApiGetRoomHierarchyTypesCopyLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomHierarchyTypesCopyLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/property/{property}/roomHierarchyTypesCopy"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.property) < 1 {
		return localVarReturnValue, nil, reportError("property must have at least 1 elements")
	}
	if strlen(r.property) > 2000 {
		return localVarReturnValue, nil, reportError("property must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomHoldConditionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomHoldConditionsLOVRequest) Authorization(authorization string) ApiGetRoomHoldConditionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomHoldConditionsLOVRequest) XAppKey(xAppKey string) ApiGetRoomHoldConditionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomHoldConditionsLOVRequest) XHotelid(xHotelid string) ApiGetRoomHoldConditionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomHoldConditionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomHoldConditionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomHoldConditionsLOVRequest) ParameterName(parameterName []string) ApiGetRoomHoldConditionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomHoldConditionsLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomHoldConditionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomHoldConditionsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomHoldConditionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomHoldConditionsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomHoldConditionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomHoldConditionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomHoldConditionsLOVExecute(r)
}

/*
GetRoomHoldConditionsLOV Fetch List Of Values for Room Hold Conditions

 <p><strong>OperationId:</strong>getRoomHoldConditionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomHoldConditions LOV
 @return ApiGetRoomHoldConditionsLOVRequest
*/
func (a *LOVApiService) GetRoomHoldConditionsLOV(ctx context.Context, hotelId string) ApiGetRoomHoldConditionsLOVRequest {
	return ApiGetRoomHoldConditionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomHoldConditionsLOVExecute(r ApiGetRoomHoldConditionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomHoldConditionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomHoldConditions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomMaintenanceLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomMaintenanceLOVRequest) Authorization(authorization string) ApiGetRoomMaintenanceLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomMaintenanceLOVRequest) XAppKey(xAppKey string) ApiGetRoomMaintenanceLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomMaintenanceLOVRequest) XHotelid(xHotelid string) ApiGetRoomMaintenanceLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomMaintenanceLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomMaintenanceLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomMaintenanceLOVRequest) ParameterName(parameterName []string) ApiGetRoomMaintenanceLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomMaintenanceLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomMaintenanceLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomMaintenanceLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomMaintenanceLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomMaintenanceLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomMaintenanceLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomMaintenanceLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomMaintenanceLOVExecute(r)
}

/*
GetRoomMaintenanceLOV Fetch List Of Values for Room Maintenance

 <p><strong>OperationId:</strong>getRoomMaintenanceLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomMaintenance LOV
 @return ApiGetRoomMaintenanceLOVRequest
*/
func (a *LOVApiService) GetRoomMaintenanceLOV(ctx context.Context, hotelId string) ApiGetRoomMaintenanceLOVRequest {
	return ApiGetRoomMaintenanceLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomMaintenanceLOVExecute(r ApiGetRoomMaintenanceLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomMaintenanceLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomMaintenance"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomPoolRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomPool string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomPoolRoomTypesLOVRequest) Authorization(authorization string) ApiGetRoomPoolRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomPoolRoomTypesLOVRequest) XAppKey(xAppKey string) ApiGetRoomPoolRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomPoolRoomTypesLOVRequest) XHotelid(xHotelid string) ApiGetRoomPoolRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomPoolRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomPoolRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomPoolRoomTypesLOVRequest) ParameterName(parameterName []string) ApiGetRoomPoolRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomPoolRoomTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomPoolRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomPoolRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomPoolRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomPoolRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomPoolRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomPoolRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomPoolRoomTypesLOVExecute(r)
}

/*
GetRoomPoolRoomTypesLOV Fetch List Of Values for Room Pool Room Types

 <p><strong>OperationId:</strong>getRoomPoolRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomPool Value of the parameter 'roomPool' which is required to fetch RoomPoolRoomTypes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomPoolRoomTypes LOV
 @return ApiGetRoomPoolRoomTypesLOVRequest
*/
func (a *LOVApiService) GetRoomPoolRoomTypesLOV(ctx context.Context, roomPool string, hotelId string) ApiGetRoomPoolRoomTypesLOVRequest {
	return ApiGetRoomPoolRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomPool: roomPool,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomPoolRoomTypesLOVExecute(r ApiGetRoomPoolRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomPoolRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomPool/{roomPool}/roomPoolRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"roomPool"+"}", url.PathEscape(parameterValueToString(r.roomPool, "roomPool")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomPool) < 1 {
		return localVarReturnValue, nil, reportError("roomPool must have at least 1 elements")
	}
	if strlen(r.roomPool) > 2000 {
		return localVarReturnValue, nil, reportError("roomPool must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomPoolsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomPoolsLOVRequest) Authorization(authorization string) ApiGetRoomPoolsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomPoolsLOVRequest) XAppKey(xAppKey string) ApiGetRoomPoolsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomPoolsLOVRequest) XHotelid(xHotelid string) ApiGetRoomPoolsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomPoolsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomPoolsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomPoolsLOVRequest) ParameterName(parameterName []string) ApiGetRoomPoolsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomPoolsLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomPoolsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomPoolsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomPoolsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomPoolsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomPoolsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomPoolsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomPoolsLOVExecute(r)
}

/*
GetRoomPoolsLOV Fetch List Of Values for Room Pools

 <p><strong>OperationId:</strong>getRoomPoolsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomPools LOV
 @return ApiGetRoomPoolsLOVRequest
*/
func (a *LOVApiService) GetRoomPoolsLOV(ctx context.Context, hotelId string) ApiGetRoomPoolsLOVRequest {
	return ApiGetRoomPoolsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomPoolsLOVExecute(r ApiGetRoomPoolsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomPoolsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomPools"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomRatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	room string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomRatesLOVRequest) Authorization(authorization string) ApiGetRoomRatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomRatesLOVRequest) XAppKey(xAppKey string) ApiGetRoomRatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomRatesLOVRequest) XHotelid(xHotelid string) ApiGetRoomRatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomRatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomRatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomRatesLOVRequest) ParameterName(parameterName []string) ApiGetRoomRatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomRatesLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomRatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomRatesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomRatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomRatesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomRatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomRatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomRatesLOVExecute(r)
}

/*
GetRoomRatesLOV Fetch List Of Values for Room Rates

 <p><strong>OperationId:</strong>getRoomRatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param room Value of the parameter 'room' which is required to fetch RoomRates LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomRates LOV
 @return ApiGetRoomRatesLOVRequest
*/
func (a *LOVApiService) GetRoomRatesLOV(ctx context.Context, room string, hotelId string) ApiGetRoomRatesLOVRequest {
	return ApiGetRoomRatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		room: room,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomRatesLOVExecute(r ApiGetRoomRatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomRatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/room/{room}/roomRates"
	localVarPath = strings.Replace(localVarPath, "{"+"room"+"}", url.PathEscape(parameterValueToString(r.room, "room")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.room) < 1 {
		return localVarReturnValue, nil, reportError("room must have at least 1 elements")
	}
	if strlen(r.room) > 2000 {
		return localVarReturnValue, nil, reportError("room must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomReservationStatusLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeDayUse string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomReservationStatusLOVRequest) Authorization(authorization string) ApiGetRoomReservationStatusLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomReservationStatusLOVRequest) XAppKey(xAppKey string) ApiGetRoomReservationStatusLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomReservationStatusLOVRequest) XHotelid(xHotelid string) ApiGetRoomReservationStatusLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomReservationStatusLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomReservationStatusLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomReservationStatusLOVRequest) ParameterName(parameterName []string) ApiGetRoomReservationStatusLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomReservationStatusLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomReservationStatusLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomReservationStatusLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomReservationStatusLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomReservationStatusLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomReservationStatusLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomReservationStatusLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomReservationStatusLOVExecute(r)
}

/*
GetRoomReservationStatusLOV Fetch List Of Values for Room Reservation Status

 <p><strong>OperationId:</strong>getRoomReservationStatusLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeDayUse Value of the parameter 'includeDayUse' which is required to fetch RoomReservationStatus LOV
 @return ApiGetRoomReservationStatusLOVRequest
*/
func (a *LOVApiService) GetRoomReservationStatusLOV(ctx context.Context, includeDayUse string) ApiGetRoomReservationStatusLOVRequest {
	return ApiGetRoomReservationStatusLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeDayUse: includeDayUse,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomReservationStatusLOVExecute(r ApiGetRoomReservationStatusLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomReservationStatusLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeDayUse/{includeDayUse}/roomReservationStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"includeDayUse"+"}", url.PathEscape(parameterValueToString(r.includeDayUse, "includeDayUse")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeDayUse) < 1 {
		return localVarReturnValue, nil, reportError("includeDayUse must have at least 1 elements")
	}
	if strlen(r.includeDayUse) > 2000 {
		return localVarReturnValue, nil, reportError("includeDayUse must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomRevenueTrxCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomRevenueTrxCodesLOVRequest) Authorization(authorization string) ApiGetRoomRevenueTrxCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomRevenueTrxCodesLOVRequest) XAppKey(xAppKey string) ApiGetRoomRevenueTrxCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomRevenueTrxCodesLOVRequest) XHotelid(xHotelid string) ApiGetRoomRevenueTrxCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomRevenueTrxCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomRevenueTrxCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomRevenueTrxCodesLOVRequest) ParameterName(parameterName []string) ApiGetRoomRevenueTrxCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomRevenueTrxCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomRevenueTrxCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomRevenueTrxCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomRevenueTrxCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomRevenueTrxCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomRevenueTrxCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomRevenueTrxCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomRevenueTrxCodesLOVExecute(r)
}

/*
GetRoomRevenueTrxCodesLOV Fetch List Of Values for Room Revenue Trx Codes

 <p><strong>OperationId:</strong>getRoomRevenueTrxCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomRevenueTrxCodes LOV
 @return ApiGetRoomRevenueTrxCodesLOVRequest
*/
func (a *LOVApiService) GetRoomRevenueTrxCodesLOV(ctx context.Context, hotelId string) ApiGetRoomRevenueTrxCodesLOVRequest {
	return ApiGetRoomRevenueTrxCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomRevenueTrxCodesLOVExecute(r ApiGetRoomRevenueTrxCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomRevenueTrxCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomRevenueTrxCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomRotationGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomRotationGroupsLOVRequest) Authorization(authorization string) ApiGetRoomRotationGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomRotationGroupsLOVRequest) XAppKey(xAppKey string) ApiGetRoomRotationGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomRotationGroupsLOVRequest) XHotelid(xHotelid string) ApiGetRoomRotationGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomRotationGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomRotationGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomRotationGroupsLOVRequest) ParameterName(parameterName []string) ApiGetRoomRotationGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomRotationGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomRotationGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomRotationGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomRotationGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomRotationGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomRotationGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomRotationGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomRotationGroupsLOVExecute(r)
}

/*
GetRoomRotationGroupsLOV Fetch List Of Values for Room Rotation Groups

 <p><strong>OperationId:</strong>getRoomRotationGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomRotationGroups LOV
 @return ApiGetRoomRotationGroupsLOVRequest
*/
func (a *LOVApiService) GetRoomRotationGroupsLOV(ctx context.Context, hotelId string) ApiGetRoomRotationGroupsLOVRequest {
	return ApiGetRoomRotationGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomRotationGroupsLOVExecute(r ApiGetRoomRotationGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomRotationGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomRotationGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomRotationUnitGradesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomRotationUnitGradesLOVRequest) Authorization(authorization string) ApiGetRoomRotationUnitGradesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomRotationUnitGradesLOVRequest) XAppKey(xAppKey string) ApiGetRoomRotationUnitGradesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomRotationUnitGradesLOVRequest) XHotelid(xHotelid string) ApiGetRoomRotationUnitGradesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomRotationUnitGradesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomRotationUnitGradesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomRotationUnitGradesLOVRequest) ParameterName(parameterName []string) ApiGetRoomRotationUnitGradesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomRotationUnitGradesLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomRotationUnitGradesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomRotationUnitGradesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomRotationUnitGradesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomRotationUnitGradesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomRotationUnitGradesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomRotationUnitGradesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomRotationUnitGradesLOVExecute(r)
}

/*
GetRoomRotationUnitGradesLOV Fetch List Of Values for Room Rotation Unit Grades

 <p><strong>OperationId:</strong>getRoomRotationUnitGradesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomRotationUnitGrades LOV
 @return ApiGetRoomRotationUnitGradesLOVRequest
*/
func (a *LOVApiService) GetRoomRotationUnitGradesLOV(ctx context.Context, hotelId string) ApiGetRoomRotationUnitGradesLOVRequest {
	return ApiGetRoomRotationUnitGradesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomRotationUnitGradesLOVExecute(r ApiGetRoomRotationUnitGradesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomRotationUnitGradesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomRotationUnitGrades"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomSpecialsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomSpecialsLOVRequest) Authorization(authorization string) ApiGetRoomSpecialsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomSpecialsLOVRequest) XAppKey(xAppKey string) ApiGetRoomSpecialsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomSpecialsLOVRequest) XHotelid(xHotelid string) ApiGetRoomSpecialsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomSpecialsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomSpecialsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomSpecialsLOVRequest) ParameterName(parameterName []string) ApiGetRoomSpecialsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomSpecialsLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomSpecialsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomSpecialsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomSpecialsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomSpecialsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomSpecialsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomSpecialsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomSpecialsLOVExecute(r)
}

/*
GetRoomSpecialsLOV Fetch List Of Values for Room Specials

 <p><strong>OperationId:</strong>getRoomSpecialsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomSpecials LOV
 @return ApiGetRoomSpecialsLOVRequest
*/
func (a *LOVApiService) GetRoomSpecialsLOV(ctx context.Context, hotelId string) ApiGetRoomSpecialsLOVRequest {
	return ApiGetRoomSpecialsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomSpecialsLOVExecute(r ApiGetRoomSpecialsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomSpecialsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomSpecials"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomTypePoolLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomTypePoolLOVRequest) Authorization(authorization string) ApiGetRoomTypePoolLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomTypePoolLOVRequest) XAppKey(xAppKey string) ApiGetRoomTypePoolLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomTypePoolLOVRequest) XHotelid(xHotelid string) ApiGetRoomTypePoolLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomTypePoolLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomTypePoolLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomTypePoolLOVRequest) ParameterName(parameterName []string) ApiGetRoomTypePoolLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomTypePoolLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomTypePoolLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomTypePoolLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomTypePoolLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomTypePoolLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomTypePoolLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomTypePoolLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomTypePoolLOVExecute(r)
}

/*
GetRoomTypePoolLOV Fetch List Of Values for Room Type Pool

 <p><strong>OperationId:</strong>getRoomTypePoolLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomTypePool LOV
 @return ApiGetRoomTypePoolLOVRequest
*/
func (a *LOVApiService) GetRoomTypePoolLOV(ctx context.Context, hotelId string) ApiGetRoomTypePoolLOVRequest {
	return ApiGetRoomTypePoolLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomTypePoolLOVExecute(r ApiGetRoomTypePoolLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomTypePoolLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomTypePool"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomTypesForMassRateLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	ratePlanCodes string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomTypesForMassRateLOVRequest) Authorization(authorization string) ApiGetRoomTypesForMassRateLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomTypesForMassRateLOVRequest) XAppKey(xAppKey string) ApiGetRoomTypesForMassRateLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomTypesForMassRateLOVRequest) XHotelid(xHotelid string) ApiGetRoomTypesForMassRateLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomTypesForMassRateLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomTypesForMassRateLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomTypesForMassRateLOVRequest) ParameterName(parameterName []string) ApiGetRoomTypesForMassRateLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomTypesForMassRateLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomTypesForMassRateLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomTypesForMassRateLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomTypesForMassRateLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomTypesForMassRateLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomTypesForMassRateLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomTypesForMassRateLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomTypesForMassRateLOVExecute(r)
}

/*
GetRoomTypesForMassRateLOV Fetch List Of Values for Room Types For Mass Rate

 <p><strong>OperationId:</strong>getRoomTypesForMassRateLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCodes Value of the parameter 'ratePlanCodes' which is required to fetch RoomTypesForMassRate LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomTypesForMassRate LOV
 @return ApiGetRoomTypesForMassRateLOVRequest
*/
func (a *LOVApiService) GetRoomTypesForMassRateLOV(ctx context.Context, ratePlanCodes string, hotelId string) ApiGetRoomTypesForMassRateLOVRequest {
	return ApiGetRoomTypesForMassRateLOVRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCodes: ratePlanCodes,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomTypesForMassRateLOVExecute(r ApiGetRoomTypesForMassRateLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomTypesForMassRateLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/ratePlanCodes/{ratePlanCodes}/roomTypesForMassRate"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCodes"+"}", url.PathEscape(parameterValueToString(r.ratePlanCodes, "ratePlanCodes")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCodes) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCodes must have at least 1 elements")
	}
	if strlen(r.ratePlanCodes) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCodes must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomTypesLOVRequest) Authorization(authorization string) ApiGetRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomTypesLOVRequest) XAppKey(xAppKey string) ApiGetRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomTypesLOVRequest) XHotelid(xHotelid string) ApiGetRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomTypesLOVRequest) ParameterName(parameterName []string) ApiGetRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomTypesLOVExecute(r)
}

/*
GetRoomTypesLOV Fetch List Of Values for Room Types

 <p><strong>OperationId:</strong>getRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomTypes LOV
 @return ApiGetRoomTypesLOVRequest
*/
func (a *LOVApiService) GetRoomTypesLOV(ctx context.Context, hotelId string) ApiGetRoomTypesLOVRequest {
	return ApiGetRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomTypesLOVExecute(r ApiGetRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomingListHKRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	departure string
	arrival string
	roomType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomingListHKRoomsLOVRequest) Authorization(authorization string) ApiGetRoomingListHKRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomingListHKRoomsLOVRequest) XAppKey(xAppKey string) ApiGetRoomingListHKRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomingListHKRoomsLOVRequest) XHotelid(xHotelid string) ApiGetRoomingListHKRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomingListHKRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomingListHKRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomingListHKRoomsLOVRequest) ParameterName(parameterName []string) ApiGetRoomingListHKRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomingListHKRoomsLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomingListHKRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomingListHKRoomsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomingListHKRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomingListHKRoomsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomingListHKRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomingListHKRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomingListHKRoomsLOVExecute(r)
}

/*
GetRoomingListHKRoomsLOV Fetch List Of Values for Rooming List HKRooms

 <p><strong>OperationId:</strong>getRoomingListHKRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departure Value of the parameter 'departure' which is required to fetch RoomingListHKRooms LOV
 @param arrival Value of the parameter 'arrival' which is required to fetch RoomingListHKRooms LOV
 @param roomType Value of the parameter 'roomType' which is required to fetch RoomingListHKRooms LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomingListHKRooms LOV
 @return ApiGetRoomingListHKRoomsLOVRequest
*/
func (a *LOVApiService) GetRoomingListHKRoomsLOV(ctx context.Context, departure string, arrival string, roomType string, hotelId string) ApiGetRoomingListHKRoomsLOVRequest {
	return ApiGetRoomingListHKRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		departure: departure,
		arrival: arrival,
		roomType: roomType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomingListHKRoomsLOVExecute(r ApiGetRoomingListHKRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomingListHKRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomType/{roomType}/arrival/{arrival}/departure/{departure}/roomingListHKRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"departure"+"}", url.PathEscape(parameterValueToString(r.departure, "departure")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"arrival"+"}", url.PathEscape(parameterValueToString(r.arrival, "arrival")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roomType"+"}", url.PathEscape(parameterValueToString(r.roomType, "roomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departure) < 1 {
		return localVarReturnValue, nil, reportError("departure must have at least 1 elements")
	}
	if strlen(r.departure) > 2000 {
		return localVarReturnValue, nil, reportError("departure must have less than 2000 elements")
	}
	if strlen(r.arrival) < 1 {
		return localVarReturnValue, nil, reportError("arrival must have at least 1 elements")
	}
	if strlen(r.arrival) > 2000 {
		return localVarReturnValue, nil, reportError("arrival must have less than 2000 elements")
	}
	if strlen(r.roomType) < 1 {
		return localVarReturnValue, nil, reportError("roomType must have at least 1 elements")
	}
	if strlen(r.roomType) > 2000 {
		return localVarReturnValue, nil, reportError("roomType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomsKeyGenerationLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomsKeyGenerationLOVRequest) Authorization(authorization string) ApiGetRoomsKeyGenerationLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomsKeyGenerationLOVRequest) XAppKey(xAppKey string) ApiGetRoomsKeyGenerationLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomsKeyGenerationLOVRequest) XHotelid(xHotelid string) ApiGetRoomsKeyGenerationLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomsKeyGenerationLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomsKeyGenerationLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomsKeyGenerationLOVRequest) ParameterName(parameterName []string) ApiGetRoomsKeyGenerationLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomsKeyGenerationLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomsKeyGenerationLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomsKeyGenerationLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomsKeyGenerationLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomsKeyGenerationLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomsKeyGenerationLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomsKeyGenerationLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomsKeyGenerationLOVExecute(r)
}

/*
GetRoomsKeyGenerationLOV Fetch List Of Values for Rooms Key Generation

 <p><strong>OperationId:</strong>getRoomsKeyGenerationLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomsKeyGeneration LOV
 @return ApiGetRoomsKeyGenerationLOVRequest
*/
func (a *LOVApiService) GetRoomsKeyGenerationLOV(ctx context.Context, hotelId string) ApiGetRoomsKeyGenerationLOVRequest {
	return ApiGetRoomsKeyGenerationLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomsKeyGenerationLOVExecute(r ApiGetRoomsKeyGenerationLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomsKeyGenerationLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomsKeyGeneration"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoomsLOVRequest) Authorization(authorization string) ApiGetRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoomsLOVRequest) XAppKey(xAppKey string) ApiGetRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoomsLOVRequest) XHotelid(xHotelid string) ApiGetRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoomsLOVRequest) ParameterName(parameterName []string) ApiGetRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoomsLOVRequest) ParameterValue(parameterValue []string) ApiGetRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoomsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoomsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomsLOVExecute(r)
}

/*
GetRoomsLOV Fetch List Of Values for Rooms

 <p><strong>OperationId:</strong>getRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Rooms LOV
 @return ApiGetRoomsLOVRequest
*/
func (a *LOVApiService) GetRoomsLOV(ctx context.Context, hotelId string) ApiGetRoomsLOVRequest {
	return ApiGetRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomsLOVExecute(r ApiGetRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoutingInstructionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetRoutingInstructionsLOVRequest) Authorization(authorization string) ApiGetRoutingInstructionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetRoutingInstructionsLOVRequest) XAppKey(xAppKey string) ApiGetRoutingInstructionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetRoutingInstructionsLOVRequest) XHotelid(xHotelid string) ApiGetRoutingInstructionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetRoutingInstructionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetRoutingInstructionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetRoutingInstructionsLOVRequest) ParameterName(parameterName []string) ApiGetRoutingInstructionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetRoutingInstructionsLOVRequest) ParameterValue(parameterValue []string) ApiGetRoutingInstructionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetRoutingInstructionsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetRoutingInstructionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetRoutingInstructionsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetRoutingInstructionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetRoutingInstructionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoutingInstructionsLOVExecute(r)
}

/*
GetRoutingInstructionsLOV Fetch List Of Values for Routing Instructions

 <p><strong>OperationId:</strong>getRoutingInstructionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoutingInstructions LOV
 @return ApiGetRoutingInstructionsLOVRequest
*/
func (a *LOVApiService) GetRoutingInstructionsLOV(ctx context.Context, hotelId string) ApiGetRoutingInstructionsLOVRequest {
	return ApiGetRoutingInstructionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoutingInstructionsLOVExecute(r ApiGetRoutingInstructionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoutingInstructionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/routingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSalesManagerGoalPeriodLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetSalesManagerGoalPeriodLOVRequest) Authorization(authorization string) ApiGetSalesManagerGoalPeriodLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetSalesManagerGoalPeriodLOVRequest) XAppKey(xAppKey string) ApiGetSalesManagerGoalPeriodLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetSalesManagerGoalPeriodLOVRequest) XHotelid(xHotelid string) ApiGetSalesManagerGoalPeriodLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetSalesManagerGoalPeriodLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetSalesManagerGoalPeriodLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetSalesManagerGoalPeriodLOVRequest) ParameterName(parameterName []string) ApiGetSalesManagerGoalPeriodLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetSalesManagerGoalPeriodLOVRequest) ParameterValue(parameterValue []string) ApiGetSalesManagerGoalPeriodLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetSalesManagerGoalPeriodLOVRequest) XExternalsystem(xExternalsystem string) ApiGetSalesManagerGoalPeriodLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetSalesManagerGoalPeriodLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetSalesManagerGoalPeriodLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetSalesManagerGoalPeriodLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSalesManagerGoalPeriodLOVExecute(r)
}

/*
GetSalesManagerGoalPeriodLOV Fetch List Of Values for Sales Manager Goal Period

 <p><strong>OperationId:</strong>getSalesManagerGoalPeriodLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SalesManagerGoalPeriod LOV
 @return ApiGetSalesManagerGoalPeriodLOVRequest
*/
func (a *LOVApiService) GetSalesManagerGoalPeriodLOV(ctx context.Context, hotelId string) ApiGetSalesManagerGoalPeriodLOVRequest {
	return ApiGetSalesManagerGoalPeriodLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSalesManagerGoalPeriodLOVExecute(r ApiGetSalesManagerGoalPeriodLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSalesManagerGoalPeriodLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/salesManagerGoalPeriod"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScheduledReportsExportLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetScheduledReportsExportLOVRequest) Authorization(authorization string) ApiGetScheduledReportsExportLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetScheduledReportsExportLOVRequest) XAppKey(xAppKey string) ApiGetScheduledReportsExportLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetScheduledReportsExportLOVRequest) XHotelid(xHotelid string) ApiGetScheduledReportsExportLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetScheduledReportsExportLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetScheduledReportsExportLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetScheduledReportsExportLOVRequest) ParameterName(parameterName []string) ApiGetScheduledReportsExportLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetScheduledReportsExportLOVRequest) ParameterValue(parameterValue []string) ApiGetScheduledReportsExportLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetScheduledReportsExportLOVRequest) XExternalsystem(xExternalsystem string) ApiGetScheduledReportsExportLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetScheduledReportsExportLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetScheduledReportsExportLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetScheduledReportsExportLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetScheduledReportsExportLOVExecute(r)
}

/*
GetScheduledReportsExportLOV Fetch List Of Values for Scheduled Reports Export

 <p><strong>OperationId:</strong>getScheduledReportsExportLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ScheduledReportsExport LOV
 @return ApiGetScheduledReportsExportLOVRequest
*/
func (a *LOVApiService) GetScheduledReportsExportLOV(ctx context.Context, hotelId string) ApiGetScheduledReportsExportLOVRequest {
	return ApiGetScheduledReportsExportLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetScheduledReportsExportLOVExecute(r ApiGetScheduledReportsExportLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetScheduledReportsExportLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/scheduledReportsExport"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScreenCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	screenArea string
	screenType string
	chainCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetScreenCodesLOVRequest) Authorization(authorization string) ApiGetScreenCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetScreenCodesLOVRequest) XAppKey(xAppKey string) ApiGetScreenCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetScreenCodesLOVRequest) XHotelid(xHotelid string) ApiGetScreenCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetScreenCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetScreenCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetScreenCodesLOVRequest) ParameterName(parameterName []string) ApiGetScreenCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetScreenCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetScreenCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetScreenCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetScreenCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetScreenCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetScreenCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetScreenCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetScreenCodesLOVExecute(r)
}

/*
GetScreenCodesLOV Fetch List Of Values for Screen Codes

 <p><strong>OperationId:</strong>getScreenCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param screenArea Value of the parameter 'screenArea' which is required to fetch ScreenCodes LOV
 @param screenType Value of the parameter 'screenType' which is required to fetch ScreenCodes LOV
 @param chainCode Value of the parameter 'chainCode' which is required to fetch ScreenCodes LOV
 @return ApiGetScreenCodesLOVRequest
*/
func (a *LOVApiService) GetScreenCodesLOV(ctx context.Context, screenArea string, screenType string, chainCode string) ApiGetScreenCodesLOVRequest {
	return ApiGetScreenCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		screenArea: screenArea,
		screenType: screenType,
		chainCode: chainCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetScreenCodesLOVExecute(r ApiGetScreenCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetScreenCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/chainCode/{chainCode}/screenType/{screenType}/screenArea/{screenArea}/screenCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"screenArea"+"}", url.PathEscape(parameterValueToString(r.screenArea, "screenArea")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"screenType"+"}", url.PathEscape(parameterValueToString(r.screenType, "screenType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.screenArea) < 1 {
		return localVarReturnValue, nil, reportError("screenArea must have at least 1 elements")
	}
	if strlen(r.screenArea) > 2000 {
		return localVarReturnValue, nil, reportError("screenArea must have less than 2000 elements")
	}
	if strlen(r.screenType) < 1 {
		return localVarReturnValue, nil, reportError("screenType must have at least 1 elements")
	}
	if strlen(r.screenType) > 2000 {
		return localVarReturnValue, nil, reportError("screenType must have less than 2000 elements")
	}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScreenStyleCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	screenCode string
	chainCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetScreenStyleCodesLOVRequest) Authorization(authorization string) ApiGetScreenStyleCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetScreenStyleCodesLOVRequest) XAppKey(xAppKey string) ApiGetScreenStyleCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetScreenStyleCodesLOVRequest) XHotelid(xHotelid string) ApiGetScreenStyleCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetScreenStyleCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetScreenStyleCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetScreenStyleCodesLOVRequest) ParameterName(parameterName []string) ApiGetScreenStyleCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetScreenStyleCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetScreenStyleCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetScreenStyleCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetScreenStyleCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetScreenStyleCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetScreenStyleCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetScreenStyleCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetScreenStyleCodesLOVExecute(r)
}

/*
GetScreenStyleCodesLOV Fetch List Of Values for Screen Style Codes

 <p><strong>OperationId:</strong>getScreenStyleCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param screenCode Value of the parameter 'screenCode' which is required to fetch ScreenStyleCodes LOV
 @param chainCode Value of the parameter 'chainCode' which is required to fetch ScreenStyleCodes LOV
 @return ApiGetScreenStyleCodesLOVRequest
*/
func (a *LOVApiService) GetScreenStyleCodesLOV(ctx context.Context, screenCode string, chainCode string) ApiGetScreenStyleCodesLOVRequest {
	return ApiGetScreenStyleCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		screenCode: screenCode,
		chainCode: chainCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetScreenStyleCodesLOVExecute(r ApiGetScreenStyleCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetScreenStyleCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/chainCode/{chainCode}/screenCode/{screenCode}/screenStyleCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"screenCode"+"}", url.PathEscape(parameterValueToString(r.screenCode, "screenCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.screenCode) < 1 {
		return localVarReturnValue, nil, reportError("screenCode must have at least 1 elements")
	}
	if strlen(r.screenCode) > 2000 {
		return localVarReturnValue, nil, reportError("screenCode must have less than 2000 elements")
	}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceNameLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	protocol string
	outboundType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetServiceNameLOVRequest) Authorization(authorization string) ApiGetServiceNameLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetServiceNameLOVRequest) XAppKey(xAppKey string) ApiGetServiceNameLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetServiceNameLOVRequest) XHotelid(xHotelid string) ApiGetServiceNameLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetServiceNameLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetServiceNameLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetServiceNameLOVRequest) ParameterName(parameterName []string) ApiGetServiceNameLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetServiceNameLOVRequest) ParameterValue(parameterValue []string) ApiGetServiceNameLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetServiceNameLOVRequest) XExternalsystem(xExternalsystem string) ApiGetServiceNameLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetServiceNameLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetServiceNameLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetServiceNameLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetServiceNameLOVExecute(r)
}

/*
GetServiceNameLOV Fetch List Of Values for Service Name

 <p><strong>OperationId:</strong>getServiceNameLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param protocol Value of the parameter 'protocol' which is required to fetch ServiceName LOV
 @param outboundType Value of the parameter 'outboundType' which is required to fetch ServiceName LOV
 @return ApiGetServiceNameLOVRequest
*/
func (a *LOVApiService) GetServiceNameLOV(ctx context.Context, protocol string, outboundType string) ApiGetServiceNameLOVRequest {
	return ApiGetServiceNameLOVRequest{
		ApiService: a,
		ctx: ctx,
		protocol: protocol,
		outboundType: outboundType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetServiceNameLOVExecute(r ApiGetServiceNameLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetServiceNameLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/outboundType/{outboundType}/protocol/{protocol}/outboundServiceNames"
	localVarPath = strings.Replace(localVarPath, "{"+"protocol"+"}", url.PathEscape(parameterValueToString(r.protocol, "protocol")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"outboundType"+"}", url.PathEscape(parameterValueToString(r.outboundType, "outboundType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.protocol) < 1 {
		return localVarReturnValue, nil, reportError("protocol must have at least 1 elements")
	}
	if strlen(r.protocol) > 2000 {
		return localVarReturnValue, nil, reportError("protocol must have less than 2000 elements")
	}
	if strlen(r.outboundType) < 1 {
		return localVarReturnValue, nil, reportError("outboundType must have at least 1 elements")
	}
	if strlen(r.outboundType) > 2000 {
		return localVarReturnValue, nil, reportError("outboundType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceRequestCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetServiceRequestCodesLOVRequest) Authorization(authorization string) ApiGetServiceRequestCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetServiceRequestCodesLOVRequest) XAppKey(xAppKey string) ApiGetServiceRequestCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetServiceRequestCodesLOVRequest) XHotelid(xHotelid string) ApiGetServiceRequestCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetServiceRequestCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetServiceRequestCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetServiceRequestCodesLOVRequest) ParameterName(parameterName []string) ApiGetServiceRequestCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetServiceRequestCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetServiceRequestCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetServiceRequestCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetServiceRequestCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetServiceRequestCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetServiceRequestCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetServiceRequestCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetServiceRequestCodesLOVExecute(r)
}

/*
GetServiceRequestCodesLOV Fetch List Of Values for Service Request Codes

 <p><strong>OperationId:</strong>getServiceRequestCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ServiceRequestCodes LOV
 @return ApiGetServiceRequestCodesLOVRequest
*/
func (a *LOVApiService) GetServiceRequestCodesLOV(ctx context.Context, hotelId string) ApiGetServiceRequestCodesLOVRequest {
	return ApiGetServiceRequestCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetServiceRequestCodesLOVExecute(r ApiGetServiceRequestCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetServiceRequestCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/serviceRequestCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSetupStylesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetSetupStylesLOVRequest) Authorization(authorization string) ApiGetSetupStylesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetSetupStylesLOVRequest) XAppKey(xAppKey string) ApiGetSetupStylesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetSetupStylesLOVRequest) XHotelid(xHotelid string) ApiGetSetupStylesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetSetupStylesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetSetupStylesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetSetupStylesLOVRequest) ParameterName(parameterName []string) ApiGetSetupStylesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetSetupStylesLOVRequest) ParameterValue(parameterValue []string) ApiGetSetupStylesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetSetupStylesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetSetupStylesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetSetupStylesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetSetupStylesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetSetupStylesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSetupStylesLOVExecute(r)
}

/*
GetSetupStylesLOV Fetch List Of Values for Setup Styles

 <p><strong>OperationId:</strong>getSetupStylesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SetupStyles LOV
 @return ApiGetSetupStylesLOVRequest
*/
func (a *LOVApiService) GetSetupStylesLOV(ctx context.Context, hotelId string) ApiGetSetupStylesLOVRequest {
	return ApiGetSetupStylesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSetupStylesLOVExecute(r ApiGetSetupStylesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSetupStylesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/setupStyles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShiftReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetShiftReportsLOVRequest) Authorization(authorization string) ApiGetShiftReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetShiftReportsLOVRequest) XAppKey(xAppKey string) ApiGetShiftReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetShiftReportsLOVRequest) XHotelid(xHotelid string) ApiGetShiftReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetShiftReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetShiftReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetShiftReportsLOVRequest) ParameterName(parameterName []string) ApiGetShiftReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetShiftReportsLOVRequest) ParameterValue(parameterValue []string) ApiGetShiftReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetShiftReportsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetShiftReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetShiftReportsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetShiftReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetShiftReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetShiftReportsLOVExecute(r)
}

/*
GetShiftReportsLOV Fetch List Of Values for Shift Reports

 <p><strong>OperationId:</strong>getShiftReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ShiftReports LOV
 @return ApiGetShiftReportsLOVRequest
*/
func (a *LOVApiService) GetShiftReportsLOV(ctx context.Context, hotelId string) ApiGetShiftReportsLOVRequest {
	return ApiGetShiftReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetShiftReportsLOVExecute(r ApiGetShiftReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetShiftReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/shiftReports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShiftReportsNoParamLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	shiftGroupId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetShiftReportsNoParamLOVRequest) Authorization(authorization string) ApiGetShiftReportsNoParamLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetShiftReportsNoParamLOVRequest) XAppKey(xAppKey string) ApiGetShiftReportsNoParamLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetShiftReportsNoParamLOVRequest) XHotelid(xHotelid string) ApiGetShiftReportsNoParamLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetShiftReportsNoParamLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetShiftReportsNoParamLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetShiftReportsNoParamLOVRequest) ParameterName(parameterName []string) ApiGetShiftReportsNoParamLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetShiftReportsNoParamLOVRequest) ParameterValue(parameterValue []string) ApiGetShiftReportsNoParamLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetShiftReportsNoParamLOVRequest) XExternalsystem(xExternalsystem string) ApiGetShiftReportsNoParamLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetShiftReportsNoParamLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetShiftReportsNoParamLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetShiftReportsNoParamLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetShiftReportsNoParamLOVExecute(r)
}

/*
GetShiftReportsNoParamLOV Fetch List Of Values for Shift Reports No Param

 <p><strong>OperationId:</strong>getShiftReportsNoParamLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shiftGroupId Value of the parameter 'shiftGroupId' which is required to fetch ShiftReportsNoParam LOV
 @return ApiGetShiftReportsNoParamLOVRequest
*/
func (a *LOVApiService) GetShiftReportsNoParamLOV(ctx context.Context, shiftGroupId string) ApiGetShiftReportsNoParamLOVRequest {
	return ApiGetShiftReportsNoParamLOVRequest{
		ApiService: a,
		ctx: ctx,
		shiftGroupId: shiftGroupId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetShiftReportsNoParamLOVExecute(r ApiGetShiftReportsNoParamLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetShiftReportsNoParamLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/shiftGroupId/{shiftGroupId}/shiftReportsNoParam"
	localVarPath = strings.Replace(localVarPath, "{"+"shiftGroupId"+"}", url.PathEscape(parameterValueToString(r.shiftGroupId, "shiftGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.shiftGroupId) < 1 {
		return localVarReturnValue, nil, reportError("shiftGroupId must have at least 1 elements")
	}
	if strlen(r.shiftGroupId) > 2000 {
		return localVarReturnValue, nil, reportError("shiftGroupId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSitePlanSectionTypeLinksLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	sectionType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetSitePlanSectionTypeLinksLOVRequest) Authorization(authorization string) ApiGetSitePlanSectionTypeLinksLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetSitePlanSectionTypeLinksLOVRequest) XAppKey(xAppKey string) ApiGetSitePlanSectionTypeLinksLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetSitePlanSectionTypeLinksLOVRequest) XHotelid(xHotelid string) ApiGetSitePlanSectionTypeLinksLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetSitePlanSectionTypeLinksLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetSitePlanSectionTypeLinksLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetSitePlanSectionTypeLinksLOVRequest) ParameterName(parameterName []string) ApiGetSitePlanSectionTypeLinksLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetSitePlanSectionTypeLinksLOVRequest) ParameterValue(parameterValue []string) ApiGetSitePlanSectionTypeLinksLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetSitePlanSectionTypeLinksLOVRequest) XExternalsystem(xExternalsystem string) ApiGetSitePlanSectionTypeLinksLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetSitePlanSectionTypeLinksLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetSitePlanSectionTypeLinksLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetSitePlanSectionTypeLinksLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSitePlanSectionTypeLinksLOVExecute(r)
}

/*
GetSitePlanSectionTypeLinksLOV Fetch List Of Values for Site Plan Section Type Links

 <p><strong>OperationId:</strong>getSitePlanSectionTypeLinksLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionType Value of the parameter 'sectionType' which is required to fetch SitePlanSectionTypeLinks LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SitePlanSectionTypeLinks LOV
 @return ApiGetSitePlanSectionTypeLinksLOVRequest
*/
func (a *LOVApiService) GetSitePlanSectionTypeLinksLOV(ctx context.Context, sectionType string, hotelId string) ApiGetSitePlanSectionTypeLinksLOVRequest {
	return ApiGetSitePlanSectionTypeLinksLOVRequest{
		ApiService: a,
		ctx: ctx,
		sectionType: sectionType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSitePlanSectionTypeLinksLOVExecute(r ApiGetSitePlanSectionTypeLinksLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSitePlanSectionTypeLinksLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/sectionType/{sectionType}/sitePlanSectionTypeLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionType"+"}", url.PathEscape(parameterValueToString(r.sectionType, "sectionType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sectionType) < 1 {
		return localVarReturnValue, nil, reportError("sectionType must have at least 1 elements")
	}
	if strlen(r.sectionType) > 2000 {
		return localVarReturnValue, nil, reportError("sectionType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSitePlanSectionTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	siteType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetSitePlanSectionTypesLOVRequest) Authorization(authorization string) ApiGetSitePlanSectionTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetSitePlanSectionTypesLOVRequest) XAppKey(xAppKey string) ApiGetSitePlanSectionTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetSitePlanSectionTypesLOVRequest) XHotelid(xHotelid string) ApiGetSitePlanSectionTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetSitePlanSectionTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetSitePlanSectionTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetSitePlanSectionTypesLOVRequest) ParameterName(parameterName []string) ApiGetSitePlanSectionTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetSitePlanSectionTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetSitePlanSectionTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetSitePlanSectionTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetSitePlanSectionTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetSitePlanSectionTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetSitePlanSectionTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetSitePlanSectionTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSitePlanSectionTypesLOVExecute(r)
}

/*
GetSitePlanSectionTypesLOV Fetch List Of Values for Site Plan Section Types

 <p><strong>OperationId:</strong>getSitePlanSectionTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteType Value of the parameter 'siteType' which is required to fetch SitePlanSectionTypes LOV
 @return ApiGetSitePlanSectionTypesLOVRequest
*/
func (a *LOVApiService) GetSitePlanSectionTypesLOV(ctx context.Context, siteType string) ApiGetSitePlanSectionTypesLOVRequest {
	return ApiGetSitePlanSectionTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		siteType: siteType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSitePlanSectionTypesLOVExecute(r ApiGetSitePlanSectionTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSitePlanSectionTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/siteType/{siteType}/sitePlanSectionTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"siteType"+"}", url.PathEscape(parameterValueToString(r.siteType, "siteType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.siteType) < 1 {
		return localVarReturnValue, nil, reportError("siteType must have at least 1 elements")
	}
	if strlen(r.siteType) > 2000 {
		return localVarReturnValue, nil, reportError("siteType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSitePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	siteType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetSitePlansLOVRequest) Authorization(authorization string) ApiGetSitePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetSitePlansLOVRequest) XAppKey(xAppKey string) ApiGetSitePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetSitePlansLOVRequest) XHotelid(xHotelid string) ApiGetSitePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetSitePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetSitePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetSitePlansLOVRequest) ParameterName(parameterName []string) ApiGetSitePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetSitePlansLOVRequest) ParameterValue(parameterValue []string) ApiGetSitePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetSitePlansLOVRequest) XExternalsystem(xExternalsystem string) ApiGetSitePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetSitePlansLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetSitePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetSitePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSitePlansLOVExecute(r)
}

/*
GetSitePlansLOV Fetch List Of Values for Site Plans

 <p><strong>OperationId:</strong>getSitePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteType Value of the parameter 'siteType' which is required to fetch SitePlans LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SitePlans LOV
 @return ApiGetSitePlansLOVRequest
*/
func (a *LOVApiService) GetSitePlansLOV(ctx context.Context, siteType string, hotelId string) ApiGetSitePlansLOVRequest {
	return ApiGetSitePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		siteType: siteType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSitePlansLOVExecute(r ApiGetSitePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSitePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/siteType/{siteType}/sitePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"siteType"+"}", url.PathEscape(parameterValueToString(r.siteType, "siteType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.siteType) < 1 {
		return localVarReturnValue, nil, reportError("siteType must have at least 1 elements")
	}
	if strlen(r.siteType) > 2000 {
		return localVarReturnValue, nil, reportError("siteType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSourceGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeInactive string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetSourceGroupsLOVRequest) Authorization(authorization string) ApiGetSourceGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetSourceGroupsLOVRequest) XAppKey(xAppKey string) ApiGetSourceGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetSourceGroupsLOVRequest) XHotelid(xHotelid string) ApiGetSourceGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetSourceGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetSourceGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetSourceGroupsLOVRequest) ParameterName(parameterName []string) ApiGetSourceGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetSourceGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetSourceGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetSourceGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetSourceGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetSourceGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetSourceGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetSourceGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSourceGroupsLOVExecute(r)
}

/*
GetSourceGroupsLOV Fetch List Of Values for Source Groups

 <p><strong>OperationId:</strong>getSourceGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeInactive Value of the parameter 'includeInactive' which is required to fetch SourceGroups LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SourceGroups LOV
 @return ApiGetSourceGroupsLOVRequest
*/
func (a *LOVApiService) GetSourceGroupsLOV(ctx context.Context, includeInactive string, hotelId string) ApiGetSourceGroupsLOVRequest {
	return ApiGetSourceGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeInactive: includeInactive,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSourceGroupsLOVExecute(r ApiGetSourceGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSourceGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/includeInactive/{includeInactive}/sourceGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"includeInactive"+"}", url.PathEscape(parameterValueToString(r.includeInactive, "includeInactive")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeInactive) < 1 {
		return localVarReturnValue, nil, reportError("includeInactive must have at least 1 elements")
	}
	if strlen(r.includeInactive) > 2000 {
		return localVarReturnValue, nil, reportError("includeInactive must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpacesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetSpacesLOVRequest) Authorization(authorization string) ApiGetSpacesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetSpacesLOVRequest) XAppKey(xAppKey string) ApiGetSpacesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetSpacesLOVRequest) XHotelid(xHotelid string) ApiGetSpacesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetSpacesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetSpacesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetSpacesLOVRequest) ParameterName(parameterName []string) ApiGetSpacesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetSpacesLOVRequest) ParameterValue(parameterValue []string) ApiGetSpacesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetSpacesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetSpacesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetSpacesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetSpacesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetSpacesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSpacesLOVExecute(r)
}

/*
GetSpacesLOV Fetch List Of Values for Spaces

 <p><strong>OperationId:</strong>getSpacesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Spaces LOV
 @return ApiGetSpacesLOVRequest
*/
func (a *LOVApiService) GetSpacesLOV(ctx context.Context, hotelId string) ApiGetSpacesLOVRequest {
	return ApiGetSpacesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSpacesLOVExecute(r ApiGetSpacesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSpacesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/spaces"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpecialRequestsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetSpecialRequestsLOVRequest) Authorization(authorization string) ApiGetSpecialRequestsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetSpecialRequestsLOVRequest) XAppKey(xAppKey string) ApiGetSpecialRequestsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetSpecialRequestsLOVRequest) XHotelid(xHotelid string) ApiGetSpecialRequestsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetSpecialRequestsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetSpecialRequestsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetSpecialRequestsLOVRequest) ParameterName(parameterName []string) ApiGetSpecialRequestsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetSpecialRequestsLOVRequest) ParameterValue(parameterValue []string) ApiGetSpecialRequestsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetSpecialRequestsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetSpecialRequestsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetSpecialRequestsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetSpecialRequestsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetSpecialRequestsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSpecialRequestsLOVExecute(r)
}

/*
GetSpecialRequestsLOV Fetch List Of Values for Special Requests

 <p><strong>OperationId:</strong>getSpecialRequestsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SpecialRequests LOV
 @return ApiGetSpecialRequestsLOVRequest
*/
func (a *LOVApiService) GetSpecialRequestsLOV(ctx context.Context, hotelId string) ApiGetSpecialRequestsLOVRequest {
	return ApiGetSpecialRequestsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSpecialRequestsLOVExecute(r ApiGetSpecialRequestsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSpecialRequestsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/specialRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpecialsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetSpecialsLOVRequest) Authorization(authorization string) ApiGetSpecialsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetSpecialsLOVRequest) XAppKey(xAppKey string) ApiGetSpecialsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetSpecialsLOVRequest) XHotelid(xHotelid string) ApiGetSpecialsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetSpecialsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetSpecialsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetSpecialsLOVRequest) ParameterName(parameterName []string) ApiGetSpecialsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetSpecialsLOVRequest) ParameterValue(parameterValue []string) ApiGetSpecialsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetSpecialsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetSpecialsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetSpecialsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetSpecialsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetSpecialsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSpecialsLOVExecute(r)
}

/*
GetSpecialsLOV Fetch List Of Values for Specials

 <p><strong>OperationId:</strong>getSpecialsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Specials LOV
 @return ApiGetSpecialsLOVRequest
*/
func (a *LOVApiService) GetSpecialsLOV(ctx context.Context, hotelId string) ApiGetSpecialsLOVRequest {
	return ApiGetSpecialsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSpecialsLOVExecute(r ApiGetSpecialsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSpecialsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/specials"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStageProfilesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	criteria string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetStageProfilesLOVRequest) Authorization(authorization string) ApiGetStageProfilesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetStageProfilesLOVRequest) XAppKey(xAppKey string) ApiGetStageProfilesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetStageProfilesLOVRequest) XHotelid(xHotelid string) ApiGetStageProfilesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetStageProfilesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetStageProfilesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetStageProfilesLOVRequest) ParameterName(parameterName []string) ApiGetStageProfilesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetStageProfilesLOVRequest) ParameterValue(parameterValue []string) ApiGetStageProfilesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetStageProfilesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetStageProfilesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetStageProfilesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetStageProfilesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetStageProfilesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetStageProfilesLOVExecute(r)
}

/*
GetStageProfilesLOV Fetch List Of Values for Stage Profiles

 <p><strong>OperationId:</strong>getStageProfilesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param criteria Value of the parameter 'criteria' which is required to fetch StageProfiles LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch StageProfiles LOV
 @return ApiGetStageProfilesLOVRequest
*/
func (a *LOVApiService) GetStageProfilesLOV(ctx context.Context, criteria string, hotelId string) ApiGetStageProfilesLOVRequest {
	return ApiGetStageProfilesLOVRequest{
		ApiService: a,
		ctx: ctx,
		criteria: criteria,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetStageProfilesLOVExecute(r ApiGetStageProfilesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetStageProfilesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/criteria/{criteria}/stageProfiles"
	localVarPath = strings.Replace(localVarPath, "{"+"criteria"+"}", url.PathEscape(parameterValueToString(r.criteria, "criteria")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.criteria) < 1 {
		return localVarReturnValue, nil, reportError("criteria must have at least 1 elements")
	}
	if strlen(r.criteria) > 2000 {
		return localVarReturnValue, nil, reportError("criteria must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStagedProfilePreferencesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	resortNameId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetStagedProfilePreferencesLOVRequest) Authorization(authorization string) ApiGetStagedProfilePreferencesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetStagedProfilePreferencesLOVRequest) XAppKey(xAppKey string) ApiGetStagedProfilePreferencesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetStagedProfilePreferencesLOVRequest) XHotelid(xHotelid string) ApiGetStagedProfilePreferencesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetStagedProfilePreferencesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetStagedProfilePreferencesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetStagedProfilePreferencesLOVRequest) ParameterName(parameterName []string) ApiGetStagedProfilePreferencesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetStagedProfilePreferencesLOVRequest) ParameterValue(parameterValue []string) ApiGetStagedProfilePreferencesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetStagedProfilePreferencesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetStagedProfilePreferencesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetStagedProfilePreferencesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetStagedProfilePreferencesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetStagedProfilePreferencesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetStagedProfilePreferencesLOVExecute(r)
}

/*
GetStagedProfilePreferencesLOV Fetch List Of Values for Staged Profile Preferences

 <p><strong>OperationId:</strong>getStagedProfilePreferencesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resortNameId Value of the parameter 'resortNameId' which is required to fetch StagedProfilePreferences LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch StagedProfilePreferences LOV
 @return ApiGetStagedProfilePreferencesLOVRequest
*/
func (a *LOVApiService) GetStagedProfilePreferencesLOV(ctx context.Context, resortNameId string, hotelId string) ApiGetStagedProfilePreferencesLOVRequest {
	return ApiGetStagedProfilePreferencesLOVRequest{
		ApiService: a,
		ctx: ctx,
		resortNameId: resortNameId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetStagedProfilePreferencesLOVExecute(r ApiGetStagedProfilePreferencesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetStagedProfilePreferencesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortNameId/{resortNameId}/stagedProfilePreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"resortNameId"+"}", url.PathEscape(parameterValueToString(r.resortNameId, "resortNameId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.resortNameId) < 1 {
		return localVarReturnValue, nil, reportError("resortNameId must have at least 1 elements")
	}
	if strlen(r.resortNameId) > 2000 {
		return localVarReturnValue, nil, reportError("resortNameId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatisticsYearsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	year string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetStatisticsYearsLOVRequest) Authorization(authorization string) ApiGetStatisticsYearsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetStatisticsYearsLOVRequest) XAppKey(xAppKey string) ApiGetStatisticsYearsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetStatisticsYearsLOVRequest) XHotelid(xHotelid string) ApiGetStatisticsYearsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetStatisticsYearsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetStatisticsYearsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetStatisticsYearsLOVRequest) ParameterName(parameterName []string) ApiGetStatisticsYearsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetStatisticsYearsLOVRequest) ParameterValue(parameterValue []string) ApiGetStatisticsYearsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetStatisticsYearsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetStatisticsYearsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetStatisticsYearsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetStatisticsYearsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetStatisticsYearsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetStatisticsYearsLOVExecute(r)
}

/*
GetStatisticsYearsLOV Fetch List Of Values for Statistics Years

 <p><strong>OperationId:</strong>getStatisticsYearsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param year Value of the parameter 'year' which is required to fetch StatisticsYears LOV
 @return ApiGetStatisticsYearsLOVRequest
*/
func (a *LOVApiService) GetStatisticsYearsLOV(ctx context.Context, year string) ApiGetStatisticsYearsLOVRequest {
	return ApiGetStatisticsYearsLOVRequest{
		ApiService: a,
		ctx: ctx,
		year: year,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetStatisticsYearsLOVExecute(r ApiGetStatisticsYearsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetStatisticsYearsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/year/{year}/statisticsYears"
	localVarPath = strings.Replace(localVarPath, "{"+"year"+"}", url.PathEscape(parameterValueToString(r.year, "year")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.year) < 1 {
		return localVarReturnValue, nil, reportError("year must have at least 1 elements")
	}
	if strlen(r.year) > 2000 {
		return localVarReturnValue, nil, reportError("year must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStoredValueRedeemTrxLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetStoredValueRedeemTrxLOVRequest) Authorization(authorization string) ApiGetStoredValueRedeemTrxLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetStoredValueRedeemTrxLOVRequest) XAppKey(xAppKey string) ApiGetStoredValueRedeemTrxLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetStoredValueRedeemTrxLOVRequest) XHotelid(xHotelid string) ApiGetStoredValueRedeemTrxLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetStoredValueRedeemTrxLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetStoredValueRedeemTrxLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetStoredValueRedeemTrxLOVRequest) ParameterName(parameterName []string) ApiGetStoredValueRedeemTrxLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetStoredValueRedeemTrxLOVRequest) ParameterValue(parameterValue []string) ApiGetStoredValueRedeemTrxLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetStoredValueRedeemTrxLOVRequest) XExternalsystem(xExternalsystem string) ApiGetStoredValueRedeemTrxLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetStoredValueRedeemTrxLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetStoredValueRedeemTrxLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetStoredValueRedeemTrxLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetStoredValueRedeemTrxLOVExecute(r)
}

/*
GetStoredValueRedeemTrxLOV Fetch List Of Values for Stored Value Redeem Trx

 <p><strong>OperationId:</strong>getStoredValueRedeemTrxLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch StoredValueRedeemTrx LOV
 @return ApiGetStoredValueRedeemTrxLOVRequest
*/
func (a *LOVApiService) GetStoredValueRedeemTrxLOV(ctx context.Context, hotelId string) ApiGetStoredValueRedeemTrxLOVRequest {
	return ApiGetStoredValueRedeemTrxLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetStoredValueRedeemTrxLOVExecute(r ApiGetStoredValueRedeemTrxLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetStoredValueRedeemTrxLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/storedValueRedeemTrx"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubBlockLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	superBlock string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetSubBlockLOVRequest) Authorization(authorization string) ApiGetSubBlockLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetSubBlockLOVRequest) XAppKey(xAppKey string) ApiGetSubBlockLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetSubBlockLOVRequest) XHotelid(xHotelid string) ApiGetSubBlockLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetSubBlockLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetSubBlockLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetSubBlockLOVRequest) ParameterName(parameterName []string) ApiGetSubBlockLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetSubBlockLOVRequest) ParameterValue(parameterValue []string) ApiGetSubBlockLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetSubBlockLOVRequest) XExternalsystem(xExternalsystem string) ApiGetSubBlockLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetSubBlockLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetSubBlockLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetSubBlockLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSubBlockLOVExecute(r)
}

/*
GetSubBlockLOV Fetch List Of Values for Sub Block

 <p><strong>OperationId:</strong>getSubBlockLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param superBlock Value of the parameter 'superBlock' which is required to fetch SubBlock LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SubBlock LOV
 @return ApiGetSubBlockLOVRequest
*/
func (a *LOVApiService) GetSubBlockLOV(ctx context.Context, superBlock string, hotelId string) ApiGetSubBlockLOVRequest {
	return ApiGetSubBlockLOVRequest{
		ApiService: a,
		ctx: ctx,
		superBlock: superBlock,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSubBlockLOVExecute(r ApiGetSubBlockLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSubBlockLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/superBlock/{superBlock}/subBlock"
	localVarPath = strings.Replace(localVarPath, "{"+"superBlock"+"}", url.PathEscape(parameterValueToString(r.superBlock, "superBlock")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.superBlock) < 1 {
		return localVarReturnValue, nil, reportError("superBlock must have at least 1 elements")
	}
	if strlen(r.superBlock) > 2000 {
		return localVarReturnValue, nil, reportError("superBlock must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSummaryRefreshLogLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetSummaryRefreshLogLOVRequest) Authorization(authorization string) ApiGetSummaryRefreshLogLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetSummaryRefreshLogLOVRequest) XAppKey(xAppKey string) ApiGetSummaryRefreshLogLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetSummaryRefreshLogLOVRequest) XHotelid(xHotelid string) ApiGetSummaryRefreshLogLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetSummaryRefreshLogLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetSummaryRefreshLogLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetSummaryRefreshLogLOVRequest) ParameterName(parameterName []string) ApiGetSummaryRefreshLogLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetSummaryRefreshLogLOVRequest) ParameterValue(parameterValue []string) ApiGetSummaryRefreshLogLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetSummaryRefreshLogLOVRequest) XExternalsystem(xExternalsystem string) ApiGetSummaryRefreshLogLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetSummaryRefreshLogLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetSummaryRefreshLogLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetSummaryRefreshLogLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSummaryRefreshLogLOVExecute(r)
}

/*
GetSummaryRefreshLogLOV Fetch List Of Values for Summary Refresh Log

 <p><strong>OperationId:</strong>getSummaryRefreshLogLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SummaryRefreshLog LOV
 @return ApiGetSummaryRefreshLogLOVRequest
*/
func (a *LOVApiService) GetSummaryRefreshLogLOV(ctx context.Context, hotelId string) ApiGetSummaryRefreshLogLOVRequest {
	return ApiGetSummaryRefreshLogLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSummaryRefreshLogLOVExecute(r ApiGetSummaryRefreshLogLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSummaryRefreshLogLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/summaryRefreshLog"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSynchronizeRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetSynchronizeRateCodesLOVRequest) Authorization(authorization string) ApiGetSynchronizeRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetSynchronizeRateCodesLOVRequest) XAppKey(xAppKey string) ApiGetSynchronizeRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetSynchronizeRateCodesLOVRequest) XHotelid(xHotelid string) ApiGetSynchronizeRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetSynchronizeRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetSynchronizeRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetSynchronizeRateCodesLOVRequest) ParameterName(parameterName []string) ApiGetSynchronizeRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetSynchronizeRateCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetSynchronizeRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetSynchronizeRateCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetSynchronizeRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetSynchronizeRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetSynchronizeRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetSynchronizeRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSynchronizeRateCodesLOVExecute(r)
}

/*
GetSynchronizeRateCodesLOV Fetch List Of Values for Synchronize Rate Codes

 <p><strong>OperationId:</strong>getSynchronizeRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SynchronizeRateCodes LOV
 @return ApiGetSynchronizeRateCodesLOVRequest
*/
func (a *LOVApiService) GetSynchronizeRateCodesLOV(ctx context.Context, hotelId string) ApiGetSynchronizeRateCodesLOVRequest {
	return ApiGetSynchronizeRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSynchronizeRateCodesLOVExecute(r ApiGetSynchronizeRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSynchronizeRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/synchronizeRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaskBreakOutLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fromDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTaskBreakOutLOVRequest) Authorization(authorization string) ApiGetTaskBreakOutLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTaskBreakOutLOVRequest) XAppKey(xAppKey string) ApiGetTaskBreakOutLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTaskBreakOutLOVRequest) XHotelid(xHotelid string) ApiGetTaskBreakOutLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTaskBreakOutLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTaskBreakOutLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTaskBreakOutLOVRequest) ParameterName(parameterName []string) ApiGetTaskBreakOutLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTaskBreakOutLOVRequest) ParameterValue(parameterValue []string) ApiGetTaskBreakOutLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTaskBreakOutLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTaskBreakOutLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTaskBreakOutLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTaskBreakOutLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTaskBreakOutLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTaskBreakOutLOVExecute(r)
}

/*
GetTaskBreakOutLOV Fetch List Of Values for Task Break Out

 <p><strong>OperationId:</strong>getTaskBreakOutLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fromDate Value of the parameter 'fromDate' which is required to fetch TaskBreakOut LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TaskBreakOut LOV
 @return ApiGetTaskBreakOutLOVRequest
*/
func (a *LOVApiService) GetTaskBreakOutLOV(ctx context.Context, fromDate string, hotelId string) ApiGetTaskBreakOutLOVRequest {
	return ApiGetTaskBreakOutLOVRequest{
		ApiService: a,
		ctx: ctx,
		fromDate: fromDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTaskBreakOutLOVExecute(r ApiGetTaskBreakOutLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTaskBreakOutLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fromDate/{fromDate}/taskBreakOut"
	localVarPath = strings.Replace(localVarPath, "{"+"fromDate"+"}", url.PathEscape(parameterValueToString(r.fromDate, "fromDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fromDate) < 1 {
		return localVarReturnValue, nil, reportError("fromDate must have at least 1 elements")
	}
	if strlen(r.fromDate) > 2000 {
		return localVarReturnValue, nil, reportError("fromDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaskSheetDeptLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	levelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTaskSheetDeptLOVRequest) Authorization(authorization string) ApiGetTaskSheetDeptLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTaskSheetDeptLOVRequest) XAppKey(xAppKey string) ApiGetTaskSheetDeptLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTaskSheetDeptLOVRequest) XHotelid(xHotelid string) ApiGetTaskSheetDeptLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTaskSheetDeptLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTaskSheetDeptLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTaskSheetDeptLOVRequest) ParameterName(parameterName []string) ApiGetTaskSheetDeptLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTaskSheetDeptLOVRequest) ParameterValue(parameterValue []string) ApiGetTaskSheetDeptLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTaskSheetDeptLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTaskSheetDeptLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTaskSheetDeptLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTaskSheetDeptLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTaskSheetDeptLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTaskSheetDeptLOVExecute(r)
}

/*
GetTaskSheetDeptLOV Fetch List Of Values for Task Sheet Dept

 <p><strong>OperationId:</strong>getTaskSheetDeptLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelCode Value of the parameter 'levelCode' which is required to fetch TaskSheetDept LOV
 @return ApiGetTaskSheetDeptLOVRequest
*/
func (a *LOVApiService) GetTaskSheetDeptLOV(ctx context.Context, levelCode string) ApiGetTaskSheetDeptLOVRequest {
	return ApiGetTaskSheetDeptLOVRequest{
		ApiService: a,
		ctx: ctx,
		levelCode: levelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTaskSheetDeptLOVExecute(r ApiGetTaskSheetDeptLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTaskSheetDeptLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/levelCode/{levelCode}/taskSheetDept"
	localVarPath = strings.Replace(localVarPath, "{"+"levelCode"+"}", url.PathEscape(parameterValueToString(r.levelCode, "levelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.levelCode) < 1 {
		return localVarReturnValue, nil, reportError("levelCode must have at least 1 elements")
	}
	if strlen(r.levelCode) > 2000 {
		return localVarReturnValue, nil, reportError("levelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaskSheetLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	breakOutId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTaskSheetLOVRequest) Authorization(authorization string) ApiGetTaskSheetLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTaskSheetLOVRequest) XAppKey(xAppKey string) ApiGetTaskSheetLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTaskSheetLOVRequest) XHotelid(xHotelid string) ApiGetTaskSheetLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTaskSheetLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTaskSheetLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTaskSheetLOVRequest) ParameterName(parameterName []string) ApiGetTaskSheetLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTaskSheetLOVRequest) ParameterValue(parameterValue []string) ApiGetTaskSheetLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTaskSheetLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTaskSheetLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTaskSheetLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTaskSheetLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTaskSheetLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTaskSheetLOVExecute(r)
}

/*
GetTaskSheetLOV Fetch List Of Values for Task Sheet

 <p><strong>OperationId:</strong>getTaskSheetLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param breakOutId Value of the parameter 'breakOutId' which is required to fetch TaskSheet LOV
 @return ApiGetTaskSheetLOVRequest
*/
func (a *LOVApiService) GetTaskSheetLOV(ctx context.Context, breakOutId string) ApiGetTaskSheetLOVRequest {
	return ApiGetTaskSheetLOVRequest{
		ApiService: a,
		ctx: ctx,
		breakOutId: breakOutId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTaskSheetLOVExecute(r ApiGetTaskSheetLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTaskSheetLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/breakOutId/{breakOutId}/taskSheet"
	localVarPath = strings.Replace(localVarPath, "{"+"breakOutId"+"}", url.PathEscape(parameterValueToString(r.breakOutId, "breakOutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.breakOutId) < 1 {
		return localVarReturnValue, nil, reportError("breakOutId must have at least 1 elements")
	}
	if strlen(r.breakOutId) > 2000 {
		return localVarReturnValue, nil, reportError("breakOutId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaskSheetRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	taskSheetNo string
	taskCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTaskSheetRoomsLOVRequest) Authorization(authorization string) ApiGetTaskSheetRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTaskSheetRoomsLOVRequest) XAppKey(xAppKey string) ApiGetTaskSheetRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTaskSheetRoomsLOVRequest) XHotelid(xHotelid string) ApiGetTaskSheetRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTaskSheetRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTaskSheetRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTaskSheetRoomsLOVRequest) ParameterName(parameterName []string) ApiGetTaskSheetRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTaskSheetRoomsLOVRequest) ParameterValue(parameterValue []string) ApiGetTaskSheetRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTaskSheetRoomsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTaskSheetRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTaskSheetRoomsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTaskSheetRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTaskSheetRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTaskSheetRoomsLOVExecute(r)
}

/*
GetTaskSheetRoomsLOV Fetch List Of Values for Task Sheet Rooms

 <p><strong>OperationId:</strong>getTaskSheetRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskSheetNo Value of the parameter 'taskSheetNo' which is required to fetch TaskSheetRooms LOV
 @param taskCode Value of the parameter 'taskCode' which is required to fetch TaskSheetRooms LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TaskSheetRooms LOV
 @return ApiGetTaskSheetRoomsLOVRequest
*/
func (a *LOVApiService) GetTaskSheetRoomsLOV(ctx context.Context, taskSheetNo string, taskCode string, hotelId string) ApiGetTaskSheetRoomsLOVRequest {
	return ApiGetTaskSheetRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		taskSheetNo: taskSheetNo,
		taskCode: taskCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTaskSheetRoomsLOVExecute(r ApiGetTaskSheetRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTaskSheetRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/taskCode/{taskCode}/taskSheetNo/{taskSheetNo}/taskSheetRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"taskSheetNo"+"}", url.PathEscape(parameterValueToString(r.taskSheetNo, "taskSheetNo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskCode"+"}", url.PathEscape(parameterValueToString(r.taskCode, "taskCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taskSheetNo) < 1 {
		return localVarReturnValue, nil, reportError("taskSheetNo must have at least 1 elements")
	}
	if strlen(r.taskSheetNo) > 2000 {
		return localVarReturnValue, nil, reportError("taskSheetNo must have less than 2000 elements")
	}
	if strlen(r.taskCode) < 1 {
		return localVarReturnValue, nil, reportError("taskCode must have at least 1 elements")
	}
	if strlen(r.taskCode) > 2000 {
		return localVarReturnValue, nil, reportError("taskCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaxTransactionCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	taxCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTaxTransactionCodeLOVRequest) Authorization(authorization string) ApiGetTaxTransactionCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTaxTransactionCodeLOVRequest) XAppKey(xAppKey string) ApiGetTaxTransactionCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTaxTransactionCodeLOVRequest) XHotelid(xHotelid string) ApiGetTaxTransactionCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTaxTransactionCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTaxTransactionCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTaxTransactionCodeLOVRequest) ParameterName(parameterName []string) ApiGetTaxTransactionCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTaxTransactionCodeLOVRequest) ParameterValue(parameterValue []string) ApiGetTaxTransactionCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTaxTransactionCodeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTaxTransactionCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTaxTransactionCodeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTaxTransactionCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTaxTransactionCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTaxTransactionCodeLOVExecute(r)
}

/*
GetTaxTransactionCodeLOV Fetch List Of Values for Tax Transaction Code

 <p><strong>OperationId:</strong>getTaxTransactionCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxCode Value of the parameter 'taxCode' which is required to fetch TaxTransactionCode LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TaxTransactionCode LOV
 @return ApiGetTaxTransactionCodeLOVRequest
*/
func (a *LOVApiService) GetTaxTransactionCodeLOV(ctx context.Context, taxCode string, hotelId string) ApiGetTaxTransactionCodeLOVRequest {
	return ApiGetTaxTransactionCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		taxCode: taxCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTaxTransactionCodeLOVExecute(r ApiGetTaxTransactionCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTaxTransactionCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/taxCode/{taxCode}/taxTransactionCode"
	localVarPath = strings.Replace(localVarPath, "{"+"taxCode"+"}", url.PathEscape(parameterValueToString(r.taxCode, "taxCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxCode) < 1 {
		return localVarReturnValue, nil, reportError("taxCode must have at least 1 elements")
	}
	if strlen(r.taxCode) > 2000 {
		return localVarReturnValue, nil, reportError("taxCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaxTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTaxTypesLOVRequest) Authorization(authorization string) ApiGetTaxTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTaxTypesLOVRequest) XAppKey(xAppKey string) ApiGetTaxTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTaxTypesLOVRequest) XHotelid(xHotelid string) ApiGetTaxTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTaxTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTaxTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTaxTypesLOVRequest) ParameterName(parameterName []string) ApiGetTaxTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTaxTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetTaxTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTaxTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTaxTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTaxTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTaxTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTaxTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTaxTypesLOVExecute(r)
}

/*
GetTaxTypesLOV Fetch List Of Values for Tax Types

 <p><strong>OperationId:</strong>getTaxTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TaxTypes LOV
 @return ApiGetTaxTypesLOVRequest
*/
func (a *LOVApiService) GetTaxTypesLOV(ctx context.Context, hotelId string) ApiGetTaxTypesLOVRequest {
	return ApiGetTaxTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTaxTypesLOVExecute(r ApiGetTaxTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTaxTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/taxTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTelephoneCategoryLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTelephoneCategoryLOVRequest) Authorization(authorization string) ApiGetTelephoneCategoryLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTelephoneCategoryLOVRequest) XAppKey(xAppKey string) ApiGetTelephoneCategoryLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTelephoneCategoryLOVRequest) XHotelid(xHotelid string) ApiGetTelephoneCategoryLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTelephoneCategoryLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTelephoneCategoryLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTelephoneCategoryLOVRequest) ParameterName(parameterName []string) ApiGetTelephoneCategoryLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTelephoneCategoryLOVRequest) ParameterValue(parameterValue []string) ApiGetTelephoneCategoryLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTelephoneCategoryLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTelephoneCategoryLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTelephoneCategoryLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTelephoneCategoryLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTelephoneCategoryLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTelephoneCategoryLOVExecute(r)
}

/*
GetTelephoneCategoryLOV Fetch List Of Values for Telephone Category

 <p><strong>OperationId:</strong>getTelephoneCategoryLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TelephoneCategory LOV
 @return ApiGetTelephoneCategoryLOVRequest
*/
func (a *LOVApiService) GetTelephoneCategoryLOV(ctx context.Context, hotelId string) ApiGetTelephoneCategoryLOVRequest {
	return ApiGetTelephoneCategoryLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTelephoneCategoryLOVExecute(r ApiGetTelephoneCategoryLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTelephoneCategoryLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/telephoneCategory"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTemplateBookingChannelRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingChannelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTemplateBookingChannelRoomTypesLOVRequest) Authorization(authorization string) ApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTemplateBookingChannelRoomTypesLOVRequest) XAppKey(xAppKey string) ApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTemplateBookingChannelRoomTypesLOVRequest) XHotelid(xHotelid string) ApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTemplateBookingChannelRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTemplateBookingChannelRoomTypesLOVRequest) ParameterName(parameterName []string) ApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTemplateBookingChannelRoomTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTemplateBookingChannelRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTemplateBookingChannelRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTemplateBookingChannelRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateBookingChannelRoomTypesLOVExecute(r)
}

/*
GetTemplateBookingChannelRoomTypesLOV Fetch List Of Values for Template Booking Channel Room Types

 <p><strong>OperationId:</strong>getTemplateBookingChannelRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingChannelCode Value of the parameter 'bookingChannelCode' which is required to fetch TemplateBookingChannelRoomTypes LOV
 @return ApiGetTemplateBookingChannelRoomTypesLOVRequest
*/
func (a *LOVApiService) GetTemplateBookingChannelRoomTypesLOV(ctx context.Context, bookingChannelCode string) ApiGetTemplateBookingChannelRoomTypesLOVRequest {
	return ApiGetTemplateBookingChannelRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingChannelCode: bookingChannelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateBookingChannelRoomTypesLOVExecute(r ApiGetTemplateBookingChannelRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateBookingChannelRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingChannels/{bookingChannelCode}/templateBookingChannelRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCode"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCode, "bookingChannelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingChannelCode) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have at least 1 elements")
	}
	if strlen(r.bookingChannelCode) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTemplateFiscalFolioParametersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	templateCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTemplateFiscalFolioParametersLOVRequest) Authorization(authorization string) ApiGetTemplateFiscalFolioParametersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTemplateFiscalFolioParametersLOVRequest) XAppKey(xAppKey string) ApiGetTemplateFiscalFolioParametersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTemplateFiscalFolioParametersLOVRequest) XHotelid(xHotelid string) ApiGetTemplateFiscalFolioParametersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTemplateFiscalFolioParametersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTemplateFiscalFolioParametersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTemplateFiscalFolioParametersLOVRequest) ParameterName(parameterName []string) ApiGetTemplateFiscalFolioParametersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTemplateFiscalFolioParametersLOVRequest) ParameterValue(parameterValue []string) ApiGetTemplateFiscalFolioParametersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTemplateFiscalFolioParametersLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTemplateFiscalFolioParametersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTemplateFiscalFolioParametersLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTemplateFiscalFolioParametersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTemplateFiscalFolioParametersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateFiscalFolioParametersLOVExecute(r)
}

/*
GetTemplateFiscalFolioParametersLOV Fetch List Of Values for Template Fiscal Folio Parameters

 <p><strong>OperationId:</strong>getTemplateFiscalFolioParametersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateCode Value of the parameter 'templateCode' which is required to fetch TemplateFiscalFolioParameters LOV
 @return ApiGetTemplateFiscalFolioParametersLOVRequest
*/
func (a *LOVApiService) GetTemplateFiscalFolioParametersLOV(ctx context.Context, templateCode string) ApiGetTemplateFiscalFolioParametersLOVRequest {
	return ApiGetTemplateFiscalFolioParametersLOVRequest{
		ApiService: a,
		ctx: ctx,
		templateCode: templateCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateFiscalFolioParametersLOVExecute(r ApiGetTemplateFiscalFolioParametersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateFiscalFolioParametersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/templateCode/{templateCode}/templateFiscalFolioParameters"
	localVarPath = strings.Replace(localVarPath, "{"+"templateCode"+"}", url.PathEscape(parameterValueToString(r.templateCode, "templateCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.templateCode) < 1 {
		return localVarReturnValue, nil, reportError("templateCode must have at least 1 elements")
	}
	if strlen(r.templateCode) > 2000 {
		return localVarReturnValue, nil, reportError("templateCode must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTemplateMarketCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeInactive string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTemplateMarketCodesLOVRequest) Authorization(authorization string) ApiGetTemplateMarketCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTemplateMarketCodesLOVRequest) XAppKey(xAppKey string) ApiGetTemplateMarketCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTemplateMarketCodesLOVRequest) XHotelid(xHotelid string) ApiGetTemplateMarketCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTemplateMarketCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTemplateMarketCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTemplateMarketCodesLOVRequest) ParameterName(parameterName []string) ApiGetTemplateMarketCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTemplateMarketCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetTemplateMarketCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTemplateMarketCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTemplateMarketCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTemplateMarketCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTemplateMarketCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTemplateMarketCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateMarketCodesLOVExecute(r)
}

/*
GetTemplateMarketCodesLOV Fetch List Of Values for Template Market Codes

 <p><strong>OperationId:</strong>getTemplateMarketCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeInactive Value of the parameter 'includeInactive' which is required to fetch TemplateMarketCodes LOV
 @return ApiGetTemplateMarketCodesLOVRequest
*/
func (a *LOVApiService) GetTemplateMarketCodesLOV(ctx context.Context, includeInactive string) ApiGetTemplateMarketCodesLOVRequest {
	return ApiGetTemplateMarketCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeInactive: includeInactive,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateMarketCodesLOVExecute(r ApiGetTemplateMarketCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateMarketCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeInactive/{includeInactive}/templateMarketCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"includeInactive"+"}", url.PathEscape(parameterValueToString(r.includeInactive, "includeInactive")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeInactive) < 1 {
		return localVarReturnValue, nil, reportError("includeInactive must have at least 1 elements")
	}
	if strlen(r.includeInactive) > 2000 {
		return localVarReturnValue, nil, reportError("includeInactive must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTemplateMarketGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeInactive string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTemplateMarketGroupsLOVRequest) Authorization(authorization string) ApiGetTemplateMarketGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTemplateMarketGroupsLOVRequest) XAppKey(xAppKey string) ApiGetTemplateMarketGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTemplateMarketGroupsLOVRequest) XHotelid(xHotelid string) ApiGetTemplateMarketGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTemplateMarketGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTemplateMarketGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTemplateMarketGroupsLOVRequest) ParameterName(parameterName []string) ApiGetTemplateMarketGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTemplateMarketGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetTemplateMarketGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTemplateMarketGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTemplateMarketGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTemplateMarketGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTemplateMarketGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTemplateMarketGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateMarketGroupsLOVExecute(r)
}

/*
GetTemplateMarketGroupsLOV Fetch List Of Values for Template Market Groups

 <p><strong>OperationId:</strong>getTemplateMarketGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeInactive Value of the parameter 'includeInactive' which is required to fetch TemplateMarketGroups LOV
 @return ApiGetTemplateMarketGroupsLOVRequest
*/
func (a *LOVApiService) GetTemplateMarketGroupsLOV(ctx context.Context, includeInactive string) ApiGetTemplateMarketGroupsLOVRequest {
	return ApiGetTemplateMarketGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeInactive: includeInactive,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateMarketGroupsLOVExecute(r ApiGetTemplateMarketGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateMarketGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeInactive/{includeInactive}/templateMarketGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"includeInactive"+"}", url.PathEscape(parameterValueToString(r.includeInactive, "includeInactive")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeInactive) < 1 {
		return localVarReturnValue, nil, reportError("includeInactive must have at least 1 elements")
	}
	if strlen(r.includeInactive) > 2000 {
		return localVarReturnValue, nil, reportError("includeInactive must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTemplatePolicyCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	policyType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTemplatePolicyCodesLOVRequest) Authorization(authorization string) ApiGetTemplatePolicyCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTemplatePolicyCodesLOVRequest) XAppKey(xAppKey string) ApiGetTemplatePolicyCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTemplatePolicyCodesLOVRequest) XHotelid(xHotelid string) ApiGetTemplatePolicyCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTemplatePolicyCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTemplatePolicyCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTemplatePolicyCodesLOVRequest) ParameterName(parameterName []string) ApiGetTemplatePolicyCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTemplatePolicyCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetTemplatePolicyCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTemplatePolicyCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTemplatePolicyCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTemplatePolicyCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTemplatePolicyCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTemplatePolicyCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplatePolicyCodesLOVExecute(r)
}

/*
GetTemplatePolicyCodesLOV Fetch List Of Values for Template Policy Codes

 <p><strong>OperationId:</strong>getTemplatePolicyCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyType Value of the parameter 'policyType' which is required to fetch TemplatePolicyCodes LOV
 @return ApiGetTemplatePolicyCodesLOVRequest
*/
func (a *LOVApiService) GetTemplatePolicyCodesLOV(ctx context.Context, policyType string) ApiGetTemplatePolicyCodesLOVRequest {
	return ApiGetTemplatePolicyCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		policyType: policyType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplatePolicyCodesLOVExecute(r ApiGetTemplatePolicyCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplatePolicyCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/policyType/{policyType}/templatePolicyCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"policyType"+"}", url.PathEscape(parameterValueToString(r.policyType, "policyType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.policyType) < 1 {
		return localVarReturnValue, nil, reportError("policyType must have at least 1 elements")
	}
	if strlen(r.policyType) > 2000 {
		return localVarReturnValue, nil, reportError("policyType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTemplatePreferencesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeGlobals string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTemplatePreferencesLOVRequest) Authorization(authorization string) ApiGetTemplatePreferencesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTemplatePreferencesLOVRequest) XAppKey(xAppKey string) ApiGetTemplatePreferencesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTemplatePreferencesLOVRequest) XHotelid(xHotelid string) ApiGetTemplatePreferencesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTemplatePreferencesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTemplatePreferencesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTemplatePreferencesLOVRequest) ParameterName(parameterName []string) ApiGetTemplatePreferencesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTemplatePreferencesLOVRequest) ParameterValue(parameterValue []string) ApiGetTemplatePreferencesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTemplatePreferencesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTemplatePreferencesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTemplatePreferencesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTemplatePreferencesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTemplatePreferencesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplatePreferencesLOVExecute(r)
}

/*
GetTemplatePreferencesLOV Fetch List Of Values for Template Preferences

 <p><strong>OperationId:</strong>getTemplatePreferencesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeGlobals Value of the parameter 'includeGlobals' which is required to fetch TemplatePreferences LOV
 @return ApiGetTemplatePreferencesLOVRequest
*/
func (a *LOVApiService) GetTemplatePreferencesLOV(ctx context.Context, includeGlobals string) ApiGetTemplatePreferencesLOVRequest {
	return ApiGetTemplatePreferencesLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeGlobals: includeGlobals,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplatePreferencesLOVExecute(r ApiGetTemplatePreferencesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplatePreferencesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeGlobals/{includeGlobals}/templatePreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"includeGlobals"+"}", url.PathEscape(parameterValueToString(r.includeGlobals, "includeGlobals")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeGlobals) < 1 {
		return localVarReturnValue, nil, reportError("includeGlobals must have at least 1 elements")
	}
	if strlen(r.includeGlobals) > 2000 {
		return localVarReturnValue, nil, reportError("includeGlobals must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTemplateRoomClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeInactive string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTemplateRoomClassesLOVRequest) Authorization(authorization string) ApiGetTemplateRoomClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTemplateRoomClassesLOVRequest) XAppKey(xAppKey string) ApiGetTemplateRoomClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTemplateRoomClassesLOVRequest) XHotelid(xHotelid string) ApiGetTemplateRoomClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTemplateRoomClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTemplateRoomClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTemplateRoomClassesLOVRequest) ParameterName(parameterName []string) ApiGetTemplateRoomClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTemplateRoomClassesLOVRequest) ParameterValue(parameterValue []string) ApiGetTemplateRoomClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTemplateRoomClassesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTemplateRoomClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTemplateRoomClassesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTemplateRoomClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTemplateRoomClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateRoomClassesLOVExecute(r)
}

/*
GetTemplateRoomClassesLOV Fetch List Of Values for Template Room Classes

 <p><strong>OperationId:</strong>getTemplateRoomClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeInactive Value of the parameter 'includeInactive' which is required to fetch TemplateRoomClasses LOV
 @return ApiGetTemplateRoomClassesLOVRequest
*/
func (a *LOVApiService) GetTemplateRoomClassesLOV(ctx context.Context, includeInactive string) ApiGetTemplateRoomClassesLOVRequest {
	return ApiGetTemplateRoomClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeInactive: includeInactive,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateRoomClassesLOVExecute(r ApiGetTemplateRoomClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateRoomClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeInactive/{includeInactive}/templateRoomClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"includeInactive"+"}", url.PathEscape(parameterValueToString(r.includeInactive, "includeInactive")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeInactive) < 1 {
		return localVarReturnValue, nil, reportError("includeInactive must have at least 1 elements")
	}
	if strlen(r.includeInactive) > 2000 {
		return localVarReturnValue, nil, reportError("includeInactive must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTemplateSourceCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeInactive string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTemplateSourceCodesLOVRequest) Authorization(authorization string) ApiGetTemplateSourceCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTemplateSourceCodesLOVRequest) XAppKey(xAppKey string) ApiGetTemplateSourceCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTemplateSourceCodesLOVRequest) XHotelid(xHotelid string) ApiGetTemplateSourceCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTemplateSourceCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTemplateSourceCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTemplateSourceCodesLOVRequest) ParameterName(parameterName []string) ApiGetTemplateSourceCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTemplateSourceCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetTemplateSourceCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTemplateSourceCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTemplateSourceCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTemplateSourceCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTemplateSourceCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTemplateSourceCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateSourceCodesLOVExecute(r)
}

/*
GetTemplateSourceCodesLOV Fetch List Of Values for Template Source Codes

 <p><strong>OperationId:</strong>getTemplateSourceCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeInactive Value of the parameter 'includeInactive' which is required to fetch TemplateSourceCodes LOV
 @return ApiGetTemplateSourceCodesLOVRequest
*/
func (a *LOVApiService) GetTemplateSourceCodesLOV(ctx context.Context, includeInactive string) ApiGetTemplateSourceCodesLOVRequest {
	return ApiGetTemplateSourceCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeInactive: includeInactive,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateSourceCodesLOVExecute(r ApiGetTemplateSourceCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateSourceCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeInactive/{includeInactive}/templateSourceCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"includeInactive"+"}", url.PathEscape(parameterValueToString(r.includeInactive, "includeInactive")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeInactive) < 1 {
		return localVarReturnValue, nil, reportError("includeInactive must have at least 1 elements")
	}
	if strlen(r.includeInactive) > 2000 {
		return localVarReturnValue, nil, reportError("includeInactive must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTemplateSourceGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeInactive string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTemplateSourceGroupsLOVRequest) Authorization(authorization string) ApiGetTemplateSourceGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTemplateSourceGroupsLOVRequest) XAppKey(xAppKey string) ApiGetTemplateSourceGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTemplateSourceGroupsLOVRequest) XHotelid(xHotelid string) ApiGetTemplateSourceGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTemplateSourceGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTemplateSourceGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTemplateSourceGroupsLOVRequest) ParameterName(parameterName []string) ApiGetTemplateSourceGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTemplateSourceGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetTemplateSourceGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTemplateSourceGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTemplateSourceGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTemplateSourceGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTemplateSourceGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTemplateSourceGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateSourceGroupsLOVExecute(r)
}

/*
GetTemplateSourceGroupsLOV Fetch List Of Values for Template Source Groups

 <p><strong>OperationId:</strong>getTemplateSourceGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeInactive Value of the parameter 'includeInactive' which is required to fetch TemplateSourceGroups LOV
 @return ApiGetTemplateSourceGroupsLOVRequest
*/
func (a *LOVApiService) GetTemplateSourceGroupsLOV(ctx context.Context, includeInactive string) ApiGetTemplateSourceGroupsLOVRequest {
	return ApiGetTemplateSourceGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeInactive: includeInactive,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateSourceGroupsLOVExecute(r ApiGetTemplateSourceGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateSourceGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeInactive/{includeInactive}/templateSourceGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"includeInactive"+"}", url.PathEscape(parameterValueToString(r.includeInactive, "includeInactive")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeInactive) < 1 {
		return localVarReturnValue, nil, reportError("includeInactive must have at least 1 elements")
	}
	if strlen(r.includeInactive) > 2000 {
		return localVarReturnValue, nil, reportError("includeInactive must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTemplateTransactionSubgroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fetchOnlyUniqueValues string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTemplateTransactionSubgroupsLOVRequest) Authorization(authorization string) ApiGetTemplateTransactionSubgroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTemplateTransactionSubgroupsLOVRequest) XAppKey(xAppKey string) ApiGetTemplateTransactionSubgroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTemplateTransactionSubgroupsLOVRequest) XHotelid(xHotelid string) ApiGetTemplateTransactionSubgroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTemplateTransactionSubgroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTemplateTransactionSubgroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTemplateTransactionSubgroupsLOVRequest) ParameterName(parameterName []string) ApiGetTemplateTransactionSubgroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTemplateTransactionSubgroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetTemplateTransactionSubgroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTemplateTransactionSubgroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTemplateTransactionSubgroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTemplateTransactionSubgroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTemplateTransactionSubgroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTemplateTransactionSubgroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateTransactionSubgroupsLOVExecute(r)
}

/*
GetTemplateTransactionSubgroupsLOV Fetch List Of Values for Template Transaction Subgroups

 <p><strong>OperationId:</strong>getTemplateTransactionSubgroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fetchOnlyUniqueValues Value of the parameter 'fetchOnlyUniqueValues' which is required to fetch TemplateTransactionSubgroups LOV
 @return ApiGetTemplateTransactionSubgroupsLOVRequest
*/
func (a *LOVApiService) GetTemplateTransactionSubgroupsLOV(ctx context.Context, fetchOnlyUniqueValues string) ApiGetTemplateTransactionSubgroupsLOVRequest {
	return ApiGetTemplateTransactionSubgroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		fetchOnlyUniqueValues: fetchOnlyUniqueValues,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateTransactionSubgroupsLOVExecute(r ApiGetTemplateTransactionSubgroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateTransactionSubgroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/fetchOnlyUniqueValues/{fetchOnlyUniqueValues}/templateTransactionSubgroups"
	localVarPath = strings.Replace(localVarPath, "{"+"fetchOnlyUniqueValues"+"}", url.PathEscape(parameterValueToString(r.fetchOnlyUniqueValues, "fetchOnlyUniqueValues")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fetchOnlyUniqueValues) < 1 {
		return localVarReturnValue, nil, reportError("fetchOnlyUniqueValues must have at least 1 elements")
	}
	if strlen(r.fetchOnlyUniqueValues) > 2000 {
		return localVarReturnValue, nil, reportError("fetchOnlyUniqueValues must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTestUpsellRulesRateCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomCategory string
	arrivalDate string
	nights string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTestUpsellRulesRateCodeLOVRequest) Authorization(authorization string) ApiGetTestUpsellRulesRateCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTestUpsellRulesRateCodeLOVRequest) XAppKey(xAppKey string) ApiGetTestUpsellRulesRateCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTestUpsellRulesRateCodeLOVRequest) XHotelid(xHotelid string) ApiGetTestUpsellRulesRateCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTestUpsellRulesRateCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTestUpsellRulesRateCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTestUpsellRulesRateCodeLOVRequest) ParameterName(parameterName []string) ApiGetTestUpsellRulesRateCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTestUpsellRulesRateCodeLOVRequest) ParameterValue(parameterValue []string) ApiGetTestUpsellRulesRateCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTestUpsellRulesRateCodeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTestUpsellRulesRateCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTestUpsellRulesRateCodeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTestUpsellRulesRateCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTestUpsellRulesRateCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTestUpsellRulesRateCodeLOVExecute(r)
}

/*
GetTestUpsellRulesRateCodeLOV Fetch List Of Values for Test Upsell Rules Rate Code

 <p><strong>OperationId:</strong>getTestUpsellRulesRateCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomCategory Value of the parameter 'roomCategory' which is required to fetch TestUpsellRulesRateCode LOV
 @param arrivalDate Value of the parameter 'arrivalDate' which is required to fetch TestUpsellRulesRateCode LOV
 @param nights Value of the parameter 'nights' which is required to fetch TestUpsellRulesRateCode LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TestUpsellRulesRateCode LOV
 @return ApiGetTestUpsellRulesRateCodeLOVRequest
*/
func (a *LOVApiService) GetTestUpsellRulesRateCodeLOV(ctx context.Context, roomCategory string, arrivalDate string, nights string, hotelId string) ApiGetTestUpsellRulesRateCodeLOVRequest {
	return ApiGetTestUpsellRulesRateCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomCategory: roomCategory,
		arrivalDate: arrivalDate,
		nights: nights,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTestUpsellRulesRateCodeLOVExecute(r ApiGetTestUpsellRulesRateCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTestUpsellRulesRateCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/nights/{nights}/arrivalDate/{arrivalDate}/roomCategory/{roomCategory}/testUpsellRulesRateCode"
	localVarPath = strings.Replace(localVarPath, "{"+"roomCategory"+"}", url.PathEscape(parameterValueToString(r.roomCategory, "roomCategory")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"arrivalDate"+"}", url.PathEscape(parameterValueToString(r.arrivalDate, "arrivalDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nights"+"}", url.PathEscape(parameterValueToString(r.nights, "nights")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomCategory) < 1 {
		return localVarReturnValue, nil, reportError("roomCategory must have at least 1 elements")
	}
	if strlen(r.roomCategory) > 2000 {
		return localVarReturnValue, nil, reportError("roomCategory must have less than 2000 elements")
	}
	if strlen(r.arrivalDate) < 1 {
		return localVarReturnValue, nil, reportError("arrivalDate must have at least 1 elements")
	}
	if strlen(r.arrivalDate) > 2000 {
		return localVarReturnValue, nil, reportError("arrivalDate must have less than 2000 elements")
	}
	if strlen(r.nights) < 1 {
		return localVarReturnValue, nil, reportError("nights must have at least 1 elements")
	}
	if strlen(r.nights) > 2000 {
		return localVarReturnValue, nil, reportError("nights must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetToPostalCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	country string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetToPostalCodesLOVRequest) Authorization(authorization string) ApiGetToPostalCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetToPostalCodesLOVRequest) XAppKey(xAppKey string) ApiGetToPostalCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetToPostalCodesLOVRequest) XHotelid(xHotelid string) ApiGetToPostalCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetToPostalCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetToPostalCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetToPostalCodesLOVRequest) ParameterName(parameterName []string) ApiGetToPostalCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetToPostalCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetToPostalCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetToPostalCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetToPostalCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetToPostalCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetToPostalCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetToPostalCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetToPostalCodesLOVExecute(r)
}

/*
GetToPostalCodesLOV Fetch List Of Values for To Postal Codes

 <p><strong>OperationId:</strong>getToPostalCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param country Value of the parameter 'country' which is required to fetch ToPostalCodes LOV
 @return ApiGetToPostalCodesLOVRequest
*/
func (a *LOVApiService) GetToPostalCodesLOV(ctx context.Context, country string) ApiGetToPostalCodesLOVRequest {
	return ApiGetToPostalCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		country: country,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetToPostalCodesLOVExecute(r ApiGetToPostalCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetToPostalCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/country/{country}/toPostalCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", url.PathEscape(parameterValueToString(r.country, "country")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.country) < 1 {
		return localVarReturnValue, nil, reportError("country must have at least 1 elements")
	}
	if strlen(r.country) > 2000 {
		return localVarReturnValue, nil, reportError("country must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTraceDateCalcLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	view string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTraceDateCalcLOVRequest) Authorization(authorization string) ApiGetTraceDateCalcLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTraceDateCalcLOVRequest) XAppKey(xAppKey string) ApiGetTraceDateCalcLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTraceDateCalcLOVRequest) XHotelid(xHotelid string) ApiGetTraceDateCalcLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTraceDateCalcLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTraceDateCalcLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTraceDateCalcLOVRequest) ParameterName(parameterName []string) ApiGetTraceDateCalcLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTraceDateCalcLOVRequest) ParameterValue(parameterValue []string) ApiGetTraceDateCalcLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTraceDateCalcLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTraceDateCalcLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTraceDateCalcLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTraceDateCalcLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTraceDateCalcLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTraceDateCalcLOVExecute(r)
}

/*
GetTraceDateCalcLOV Fetch List Of Values for Trace Date Calc

 <p><strong>OperationId:</strong>getTraceDateCalcLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param view Value of the parameter 'view' which is required to fetch TraceDateCalc LOV
 @return ApiGetTraceDateCalcLOVRequest
*/
func (a *LOVApiService) GetTraceDateCalcLOV(ctx context.Context, view string) ApiGetTraceDateCalcLOVRequest {
	return ApiGetTraceDateCalcLOVRequest{
		ApiService: a,
		ctx: ctx,
		view: view,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTraceDateCalcLOVExecute(r ApiGetTraceDateCalcLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTraceDateCalcLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/view/{view}/traceDateCalc"
	localVarPath = strings.Replace(localVarPath, "{"+"view"+"}", url.PathEscape(parameterValueToString(r.view, "view")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.view) < 1 {
		return localVarReturnValue, nil, reportError("view must have at least 1 elements")
	}
	if strlen(r.view) > 2000 {
		return localVarReturnValue, nil, reportError("view must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTraceFieldLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	view string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTraceFieldLOVRequest) Authorization(authorization string) ApiGetTraceFieldLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTraceFieldLOVRequest) XAppKey(xAppKey string) ApiGetTraceFieldLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTraceFieldLOVRequest) XHotelid(xHotelid string) ApiGetTraceFieldLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTraceFieldLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTraceFieldLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTraceFieldLOVRequest) ParameterName(parameterName []string) ApiGetTraceFieldLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTraceFieldLOVRequest) ParameterValue(parameterValue []string) ApiGetTraceFieldLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTraceFieldLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTraceFieldLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTraceFieldLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTraceFieldLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTraceFieldLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTraceFieldLOVExecute(r)
}

/*
GetTraceFieldLOV Fetch List Of Values for Trace Field

 <p><strong>OperationId:</strong>getTraceFieldLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param view Value of the parameter 'view' which is required to fetch TraceField LOV
 @return ApiGetTraceFieldLOVRequest
*/
func (a *LOVApiService) GetTraceFieldLOV(ctx context.Context, view string) ApiGetTraceFieldLOVRequest {
	return ApiGetTraceFieldLOVRequest{
		ApiService: a,
		ctx: ctx,
		view: view,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTraceFieldLOVExecute(r ApiGetTraceFieldLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTraceFieldLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/view/{view}/traceField"
	localVarPath = strings.Replace(localVarPath, "{"+"view"+"}", url.PathEscape(parameterValueToString(r.view, "view")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.view) < 1 {
		return localVarReturnValue, nil, reportError("view must have at least 1 elements")
	}
	if strlen(r.view) > 2000 {
		return localVarReturnValue, nil, reportError("view must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionAdjustmentReasonCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTransactionAdjustmentReasonCodesLOVRequest) Authorization(authorization string) ApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTransactionAdjustmentReasonCodesLOVRequest) XAppKey(xAppKey string) ApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTransactionAdjustmentReasonCodesLOVRequest) XHotelid(xHotelid string) ApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTransactionAdjustmentReasonCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTransactionAdjustmentReasonCodesLOVRequest) ParameterName(parameterName []string) ApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTransactionAdjustmentReasonCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTransactionAdjustmentReasonCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTransactionAdjustmentReasonCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTransactionAdjustmentReasonCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionAdjustmentReasonCodesLOVExecute(r)
}

/*
GetTransactionAdjustmentReasonCodesLOV Fetch List Of Values for Transaction Adjustment Reason Codes

 <p><strong>OperationId:</strong>getTransactionAdjustmentReasonCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionAdjustmentReasonCodes LOV
 @return ApiGetTransactionAdjustmentReasonCodesLOVRequest
*/
func (a *LOVApiService) GetTransactionAdjustmentReasonCodesLOV(ctx context.Context, hotelId string) ApiGetTransactionAdjustmentReasonCodesLOVRequest {
	return ApiGetTransactionAdjustmentReasonCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionAdjustmentReasonCodesLOVExecute(r ApiGetTransactionAdjustmentReasonCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionAdjustmentReasonCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionAdjustmentReasonCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionCodesConsumptionLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTransactionCodesConsumptionLOVRequest) Authorization(authorization string) ApiGetTransactionCodesConsumptionLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTransactionCodesConsumptionLOVRequest) XAppKey(xAppKey string) ApiGetTransactionCodesConsumptionLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTransactionCodesConsumptionLOVRequest) XHotelid(xHotelid string) ApiGetTransactionCodesConsumptionLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTransactionCodesConsumptionLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTransactionCodesConsumptionLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTransactionCodesConsumptionLOVRequest) ParameterName(parameterName []string) ApiGetTransactionCodesConsumptionLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTransactionCodesConsumptionLOVRequest) ParameterValue(parameterValue []string) ApiGetTransactionCodesConsumptionLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTransactionCodesConsumptionLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTransactionCodesConsumptionLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTransactionCodesConsumptionLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTransactionCodesConsumptionLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTransactionCodesConsumptionLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionCodesConsumptionLOVExecute(r)
}

/*
GetTransactionCodesConsumptionLOV Fetch List Of Values for Transaction Codes Consumption

 <p><strong>OperationId:</strong>getTransactionCodesConsumptionLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionCodesConsumption LOV
 @return ApiGetTransactionCodesConsumptionLOVRequest
*/
func (a *LOVApiService) GetTransactionCodesConsumptionLOV(ctx context.Context, hotelId string) ApiGetTransactionCodesConsumptionLOVRequest {
	return ApiGetTransactionCodesConsumptionLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionCodesConsumptionLOVExecute(r ApiGetTransactionCodesConsumptionLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionCodesConsumptionLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionCodesConsumption"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTransactionCodesLOVRequest) Authorization(authorization string) ApiGetTransactionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTransactionCodesLOVRequest) XAppKey(xAppKey string) ApiGetTransactionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTransactionCodesLOVRequest) XHotelid(xHotelid string) ApiGetTransactionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTransactionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTransactionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTransactionCodesLOVRequest) ParameterName(parameterName []string) ApiGetTransactionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTransactionCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetTransactionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTransactionCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTransactionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTransactionCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTransactionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTransactionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionCodesLOVExecute(r)
}

/*
GetTransactionCodesLOV Fetch List Of Values for Transaction Codes

 <p><strong>OperationId:</strong>getTransactionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionCodes LOV
 @return ApiGetTransactionCodesLOVRequest
*/
func (a *LOVApiService) GetTransactionCodesLOV(ctx context.Context, hotelId string) ApiGetTransactionCodesLOVRequest {
	return ApiGetTransactionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionCodesLOVExecute(r ApiGetTransactionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionCodesPaymentLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTransactionCodesPaymentLOVRequest) Authorization(authorization string) ApiGetTransactionCodesPaymentLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTransactionCodesPaymentLOVRequest) XAppKey(xAppKey string) ApiGetTransactionCodesPaymentLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTransactionCodesPaymentLOVRequest) XHotelid(xHotelid string) ApiGetTransactionCodesPaymentLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTransactionCodesPaymentLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTransactionCodesPaymentLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTransactionCodesPaymentLOVRequest) ParameterName(parameterName []string) ApiGetTransactionCodesPaymentLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTransactionCodesPaymentLOVRequest) ParameterValue(parameterValue []string) ApiGetTransactionCodesPaymentLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTransactionCodesPaymentLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTransactionCodesPaymentLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTransactionCodesPaymentLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTransactionCodesPaymentLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTransactionCodesPaymentLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionCodesPaymentLOVExecute(r)
}

/*
GetTransactionCodesPaymentLOV Fetch List Of Values for Transaction Codes Payment

 <p><strong>OperationId:</strong>getTransactionCodesPaymentLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionCodesPayment LOV
 @return ApiGetTransactionCodesPaymentLOVRequest
*/
func (a *LOVApiService) GetTransactionCodesPaymentLOV(ctx context.Context, hotelId string) ApiGetTransactionCodesPaymentLOVRequest {
	return ApiGetTransactionCodesPaymentLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionCodesPaymentLOVExecute(r ApiGetTransactionCodesPaymentLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionCodesPaymentLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionCodesPayment"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionDeleteReasonCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTransactionDeleteReasonCodesLOVRequest) Authorization(authorization string) ApiGetTransactionDeleteReasonCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTransactionDeleteReasonCodesLOVRequest) XAppKey(xAppKey string) ApiGetTransactionDeleteReasonCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTransactionDeleteReasonCodesLOVRequest) XHotelid(xHotelid string) ApiGetTransactionDeleteReasonCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTransactionDeleteReasonCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTransactionDeleteReasonCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTransactionDeleteReasonCodesLOVRequest) ParameterName(parameterName []string) ApiGetTransactionDeleteReasonCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTransactionDeleteReasonCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetTransactionDeleteReasonCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTransactionDeleteReasonCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTransactionDeleteReasonCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTransactionDeleteReasonCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTransactionDeleteReasonCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTransactionDeleteReasonCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionDeleteReasonCodesLOVExecute(r)
}

/*
GetTransactionDeleteReasonCodesLOV Fetch List Of Values for Transaction Delete Reason Codes

 <p><strong>OperationId:</strong>getTransactionDeleteReasonCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionDeleteReasonCodes LOV
 @return ApiGetTransactionDeleteReasonCodesLOVRequest
*/
func (a *LOVApiService) GetTransactionDeleteReasonCodesLOV(ctx context.Context, hotelId string) ApiGetTransactionDeleteReasonCodesLOVRequest {
	return ApiGetTransactionDeleteReasonCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionDeleteReasonCodesLOVExecute(r ApiGetTransactionDeleteReasonCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionDeleteReasonCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionDeleteReasonCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionDiversionRuleRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTransactionDiversionRuleRoomsLOVRequest) Authorization(authorization string) ApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTransactionDiversionRuleRoomsLOVRequest) XAppKey(xAppKey string) ApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTransactionDiversionRuleRoomsLOVRequest) XHotelid(xHotelid string) ApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTransactionDiversionRuleRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTransactionDiversionRuleRoomsLOVRequest) ParameterName(parameterName []string) ApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTransactionDiversionRuleRoomsLOVRequest) ParameterValue(parameterValue []string) ApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTransactionDiversionRuleRoomsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTransactionDiversionRuleRoomsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTransactionDiversionRuleRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionDiversionRuleRoomsLOVExecute(r)
}

/*
GetTransactionDiversionRuleRoomsLOV Fetch List Of Values for Transaction Diversion Rule Rooms

 <p><strong>OperationId:</strong>getTransactionDiversionRuleRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionDiversionRuleRooms LOV
 @return ApiGetTransactionDiversionRuleRoomsLOVRequest
*/
func (a *LOVApiService) GetTransactionDiversionRuleRoomsLOV(ctx context.Context, hotelId string) ApiGetTransactionDiversionRuleRoomsLOVRequest {
	return ApiGetTransactionDiversionRuleRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionDiversionRuleRoomsLOVExecute(r ApiGetTransactionDiversionRuleRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionDiversionRuleRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionDiversionRuleRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTransactionGroupsLOVRequest) Authorization(authorization string) ApiGetTransactionGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTransactionGroupsLOVRequest) XAppKey(xAppKey string) ApiGetTransactionGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTransactionGroupsLOVRequest) XHotelid(xHotelid string) ApiGetTransactionGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTransactionGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTransactionGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTransactionGroupsLOVRequest) ParameterName(parameterName []string) ApiGetTransactionGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTransactionGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetTransactionGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTransactionGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTransactionGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTransactionGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTransactionGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTransactionGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionGroupsLOVExecute(r)
}

/*
GetTransactionGroupsLOV Fetch List Of Values for Transaction Groups

 <p><strong>OperationId:</strong>getTransactionGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionGroups LOV
 @return ApiGetTransactionGroupsLOVRequest
*/
func (a *LOVApiService) GetTransactionGroupsLOV(ctx context.Context, hotelId string) ApiGetTransactionGroupsLOVRequest {
	return ApiGetTransactionGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionGroupsLOVExecute(r ApiGetTransactionGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionSubgroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTransactionSubgroupsLOVRequest) Authorization(authorization string) ApiGetTransactionSubgroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTransactionSubgroupsLOVRequest) XAppKey(xAppKey string) ApiGetTransactionSubgroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTransactionSubgroupsLOVRequest) XHotelid(xHotelid string) ApiGetTransactionSubgroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTransactionSubgroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTransactionSubgroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTransactionSubgroupsLOVRequest) ParameterName(parameterName []string) ApiGetTransactionSubgroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTransactionSubgroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetTransactionSubgroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTransactionSubgroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTransactionSubgroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTransactionSubgroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTransactionSubgroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTransactionSubgroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionSubgroupsLOVExecute(r)
}

/*
GetTransactionSubgroupsLOV Fetch List Of Values for Transaction Subgroups

 <p><strong>OperationId:</strong>getTransactionSubgroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionSubgroups LOV
 @return ApiGetTransactionSubgroupsLOVRequest
*/
func (a *LOVApiService) GetTransactionSubgroupsLOV(ctx context.Context, hotelId string) ApiGetTransactionSubgroupsLOVRequest {
	return ApiGetTransactionSubgroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionSubgroupsLOVExecute(r ApiGetTransactionSubgroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionSubgroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionSubgroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransportTypesHotelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTransportTypesHotelLOVRequest) Authorization(authorization string) ApiGetTransportTypesHotelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTransportTypesHotelLOVRequest) XAppKey(xAppKey string) ApiGetTransportTypesHotelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTransportTypesHotelLOVRequest) XHotelid(xHotelid string) ApiGetTransportTypesHotelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTransportTypesHotelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTransportTypesHotelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTransportTypesHotelLOVRequest) ParameterName(parameterName []string) ApiGetTransportTypesHotelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTransportTypesHotelLOVRequest) ParameterValue(parameterValue []string) ApiGetTransportTypesHotelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTransportTypesHotelLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTransportTypesHotelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTransportTypesHotelLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTransportTypesHotelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTransportTypesHotelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransportTypesHotelLOVExecute(r)
}

/*
GetTransportTypesHotelLOV Fetch List Of Values for Transport Types Hotel

 <p><strong>OperationId:</strong>getTransportTypesHotelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransportTypesHotel LOV
 @return ApiGetTransportTypesHotelLOVRequest
*/
func (a *LOVApiService) GetTransportTypesHotelLOV(ctx context.Context, hotelId string) ApiGetTransportTypesHotelLOVRequest {
	return ApiGetTransportTypesHotelLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransportTypesHotelLOVExecute(r ApiGetTransportTypesHotelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransportTypesHotelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transportTypesHotel"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransportTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTransportTypesLOVRequest) Authorization(authorization string) ApiGetTransportTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTransportTypesLOVRequest) XAppKey(xAppKey string) ApiGetTransportTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTransportTypesLOVRequest) XHotelid(xHotelid string) ApiGetTransportTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTransportTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTransportTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTransportTypesLOVRequest) ParameterName(parameterName []string) ApiGetTransportTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTransportTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetTransportTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTransportTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTransportTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTransportTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTransportTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTransportTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransportTypesLOVExecute(r)
}

/*
GetTransportTypesLOV Fetch List Of Values for Transport Types

 <p><strong>OperationId:</strong>getTransportTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransportTypes LOV
 @return ApiGetTransportTypesLOVRequest
*/
func (a *LOVApiService) GetTransportTypesLOV(ctx context.Context, hotelId string) ApiGetTransportTypesLOVRequest {
	return ApiGetTransportTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransportTypesLOVExecute(r ApiGetTransportTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransportTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transportTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTravelAgentSourceLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTravelAgentSourceLOVRequest) Authorization(authorization string) ApiGetTravelAgentSourceLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTravelAgentSourceLOVRequest) XAppKey(xAppKey string) ApiGetTravelAgentSourceLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTravelAgentSourceLOVRequest) XHotelid(xHotelid string) ApiGetTravelAgentSourceLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTravelAgentSourceLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTravelAgentSourceLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTravelAgentSourceLOVRequest) ParameterName(parameterName []string) ApiGetTravelAgentSourceLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTravelAgentSourceLOVRequest) ParameterValue(parameterValue []string) ApiGetTravelAgentSourceLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTravelAgentSourceLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTravelAgentSourceLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTravelAgentSourceLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTravelAgentSourceLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTravelAgentSourceLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTravelAgentSourceLOVExecute(r)
}

/*
GetTravelAgentSourceLOV Fetch List Of Values for Travel Agent Source

 <p><strong>OperationId:</strong>getTravelAgentSourceLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TravelAgentSource LOV
 @return ApiGetTravelAgentSourceLOVRequest
*/
func (a *LOVApiService) GetTravelAgentSourceLOV(ctx context.Context, hotelId string) ApiGetTravelAgentSourceLOVRequest {
	return ApiGetTravelAgentSourceLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTravelAgentSourceLOVExecute(r ApiGetTravelAgentSourceLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTravelAgentSourceLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/travelAgentSource"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTravelAgentSourceResvLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTravelAgentSourceResvLOVRequest) Authorization(authorization string) ApiGetTravelAgentSourceResvLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTravelAgentSourceResvLOVRequest) XAppKey(xAppKey string) ApiGetTravelAgentSourceResvLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTravelAgentSourceResvLOVRequest) XHotelid(xHotelid string) ApiGetTravelAgentSourceResvLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTravelAgentSourceResvLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTravelAgentSourceResvLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTravelAgentSourceResvLOVRequest) ParameterName(parameterName []string) ApiGetTravelAgentSourceResvLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTravelAgentSourceResvLOVRequest) ParameterValue(parameterValue []string) ApiGetTravelAgentSourceResvLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTravelAgentSourceResvLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTravelAgentSourceResvLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTravelAgentSourceResvLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTravelAgentSourceResvLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTravelAgentSourceResvLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTravelAgentSourceResvLOVExecute(r)
}

/*
GetTravelAgentSourceResvLOV Fetch List Of Values for Travel Agent Source Resv

 <p><strong>OperationId:</strong>getTravelAgentSourceResvLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TravelAgentSourceResv LOV
 @return ApiGetTravelAgentSourceResvLOVRequest
*/
func (a *LOVApiService) GetTravelAgentSourceResvLOV(ctx context.Context, hotelId string) ApiGetTravelAgentSourceResvLOVRequest {
	return ApiGetTravelAgentSourceResvLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTravelAgentSourceResvLOVExecute(r ApiGetTravelAgentSourceResvLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTravelAgentSourceResvLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/travelAgentSourceResv"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTrxCodeArrangementLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	type_ string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTrxCodeArrangementLOVRequest) Authorization(authorization string) ApiGetTrxCodeArrangementLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTrxCodeArrangementLOVRequest) XAppKey(xAppKey string) ApiGetTrxCodeArrangementLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTrxCodeArrangementLOVRequest) XHotelid(xHotelid string) ApiGetTrxCodeArrangementLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTrxCodeArrangementLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTrxCodeArrangementLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTrxCodeArrangementLOVRequest) ParameterName(parameterName []string) ApiGetTrxCodeArrangementLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTrxCodeArrangementLOVRequest) ParameterValue(parameterValue []string) ApiGetTrxCodeArrangementLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTrxCodeArrangementLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTrxCodeArrangementLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTrxCodeArrangementLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTrxCodeArrangementLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTrxCodeArrangementLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTrxCodeArrangementLOVExecute(r)
}

/*
GetTrxCodeArrangementLOV Fetch List Of Values for Trx Code Arrangement

 <p><strong>OperationId:</strong>getTrxCodeArrangementLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Value of the parameter 'type' which is required to fetch TrxCodeArrangement LOV
 @return ApiGetTrxCodeArrangementLOVRequest
*/
func (a *LOVApiService) GetTrxCodeArrangementLOV(ctx context.Context, type_ string) ApiGetTrxCodeArrangementLOVRequest {
	return ApiGetTrxCodeArrangementLOVRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTrxCodeArrangementLOVExecute(r ApiGetTrxCodeArrangementLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTrxCodeArrangementLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/type/{type}/trxCodeArrangement"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.type_) < 1 {
		return localVarReturnValue, nil, reportError("type_ must have at least 1 elements")
	}
	if strlen(r.type_) > 2000 {
		return localVarReturnValue, nil, reportError("type_ must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTurnawayCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetTurnawayCodesLOVRequest) Authorization(authorization string) ApiGetTurnawayCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetTurnawayCodesLOVRequest) XAppKey(xAppKey string) ApiGetTurnawayCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetTurnawayCodesLOVRequest) XHotelid(xHotelid string) ApiGetTurnawayCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetTurnawayCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetTurnawayCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetTurnawayCodesLOVRequest) ParameterName(parameterName []string) ApiGetTurnawayCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetTurnawayCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetTurnawayCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetTurnawayCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetTurnawayCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetTurnawayCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetTurnawayCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetTurnawayCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTurnawayCodesLOVExecute(r)
}

/*
GetTurnawayCodesLOV Fetch List Of Values for Turnaway Codes

 <p><strong>OperationId:</strong>getTurnawayCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TurnawayCodes LOV
 @return ApiGetTurnawayCodesLOVRequest
*/
func (a *LOVApiService) GetTurnawayCodesLOV(ctx context.Context, hotelId string) ApiGetTurnawayCodesLOVRequest {
	return ApiGetTurnawayCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTurnawayCodesLOVExecute(r ApiGetTurnawayCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTurnawayCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/turnawayCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUDFMappingsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	moduleName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUDFMappingsLOVRequest) Authorization(authorization string) ApiGetUDFMappingsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUDFMappingsLOVRequest) XAppKey(xAppKey string) ApiGetUDFMappingsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUDFMappingsLOVRequest) XHotelid(xHotelid string) ApiGetUDFMappingsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUDFMappingsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUDFMappingsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUDFMappingsLOVRequest) ParameterName(parameterName []string) ApiGetUDFMappingsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUDFMappingsLOVRequest) ParameterValue(parameterValue []string) ApiGetUDFMappingsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUDFMappingsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUDFMappingsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUDFMappingsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUDFMappingsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUDFMappingsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUDFMappingsLOVExecute(r)
}

/*
GetUDFMappingsLOV Fetch List Of Values for UDFMappings

 <p><strong>OperationId:</strong>getUDFMappingsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param moduleName Value of the parameter 'moduleName' which is required to fetch UDFMappings LOV
 @return ApiGetUDFMappingsLOVRequest
*/
func (a *LOVApiService) GetUDFMappingsLOV(ctx context.Context, moduleName string) ApiGetUDFMappingsLOVRequest {
	return ApiGetUDFMappingsLOVRequest{
		ApiService: a,
		ctx: ctx,
		moduleName: moduleName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUDFMappingsLOVExecute(r ApiGetUDFMappingsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUDFMappingsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/moduleName/{moduleName}/udfMappings"
	localVarPath = strings.Replace(localVarPath, "{"+"moduleName"+"}", url.PathEscape(parameterValueToString(r.moduleName, "moduleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.moduleName) < 1 {
		return localVarReturnValue, nil, reportError("moduleName must have at least 1 elements")
	}
	if strlen(r.moduleName) > 2000 {
		return localVarReturnValue, nil, reportError("moduleName must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUdfAttributesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	udfCategory string
	udfType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUdfAttributesLOVRequest) Authorization(authorization string) ApiGetUdfAttributesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUdfAttributesLOVRequest) XAppKey(xAppKey string) ApiGetUdfAttributesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUdfAttributesLOVRequest) XHotelid(xHotelid string) ApiGetUdfAttributesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUdfAttributesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUdfAttributesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUdfAttributesLOVRequest) ParameterName(parameterName []string) ApiGetUdfAttributesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUdfAttributesLOVRequest) ParameterValue(parameterValue []string) ApiGetUdfAttributesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUdfAttributesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUdfAttributesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUdfAttributesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUdfAttributesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUdfAttributesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUdfAttributesLOVExecute(r)
}

/*
GetUdfAttributesLOV Fetch List Of Values for Udf Attributes

 <p><strong>OperationId:</strong>getUdfAttributesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param udfCategory Value of the parameter 'udfCategory' which is required to fetch UdfAttributes LOV
 @param udfType Value of the parameter 'udfType' which is required to fetch UdfAttributes LOV
 @return ApiGetUdfAttributesLOVRequest
*/
func (a *LOVApiService) GetUdfAttributesLOV(ctx context.Context, udfCategory string, udfType string) ApiGetUdfAttributesLOVRequest {
	return ApiGetUdfAttributesLOVRequest{
		ApiService: a,
		ctx: ctx,
		udfCategory: udfCategory,
		udfType: udfType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUdfAttributesLOVExecute(r ApiGetUdfAttributesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUdfAttributesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/udfType/{udfType}/udfCategory/{udfCategory}/udfAttributes"
	localVarPath = strings.Replace(localVarPath, "{"+"udfCategory"+"}", url.PathEscape(parameterValueToString(r.udfCategory, "udfCategory")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"udfType"+"}", url.PathEscape(parameterValueToString(r.udfType, "udfType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.udfCategory) < 1 {
		return localVarReturnValue, nil, reportError("udfCategory must have at least 1 elements")
	}
	if strlen(r.udfCategory) > 2000 {
		return localVarReturnValue, nil, reportError("udfCategory must have less than 2000 elements")
	}
	if strlen(r.udfType) < 1 {
		return localVarReturnValue, nil, reportError("udfType must have at least 1 elements")
	}
	if strlen(r.udfType) > 2000 {
		return localVarReturnValue, nil, reportError("udfType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellDefaultTrxCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellDefaultTrxCodeLOVRequest) Authorization(authorization string) ApiGetUpsellDefaultTrxCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellDefaultTrxCodeLOVRequest) XAppKey(xAppKey string) ApiGetUpsellDefaultTrxCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellDefaultTrxCodeLOVRequest) XHotelid(xHotelid string) ApiGetUpsellDefaultTrxCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellDefaultTrxCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellDefaultTrxCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellDefaultTrxCodeLOVRequest) ParameterName(parameterName []string) ApiGetUpsellDefaultTrxCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellDefaultTrxCodeLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellDefaultTrxCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellDefaultTrxCodeLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellDefaultTrxCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellDefaultTrxCodeLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellDefaultTrxCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellDefaultTrxCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellDefaultTrxCodeLOVExecute(r)
}

/*
GetUpsellDefaultTrxCodeLOV Fetch List Of Values for Upsell Default Trx Code

 <p><strong>OperationId:</strong>getUpsellDefaultTrxCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellDefaultTrxCode LOV
 @return ApiGetUpsellDefaultTrxCodeLOVRequest
*/
func (a *LOVApiService) GetUpsellDefaultTrxCodeLOV(ctx context.Context, hotelId string) ApiGetUpsellDefaultTrxCodeLOVRequest {
	return ApiGetUpsellDefaultTrxCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellDefaultTrxCodeLOVExecute(r ApiGetUpsellDefaultTrxCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellDefaultTrxCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellDefaultTrxCode"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellFromRoomClassEditLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellFromRoomClassEditLOVRequest) Authorization(authorization string) ApiGetUpsellFromRoomClassEditLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellFromRoomClassEditLOVRequest) XAppKey(xAppKey string) ApiGetUpsellFromRoomClassEditLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellFromRoomClassEditLOVRequest) XHotelid(xHotelid string) ApiGetUpsellFromRoomClassEditLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellFromRoomClassEditLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellFromRoomClassEditLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellFromRoomClassEditLOVRequest) ParameterName(parameterName []string) ApiGetUpsellFromRoomClassEditLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellFromRoomClassEditLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellFromRoomClassEditLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellFromRoomClassEditLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellFromRoomClassEditLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellFromRoomClassEditLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellFromRoomClassEditLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellFromRoomClassEditLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellFromRoomClassEditLOVExecute(r)
}

/*
GetUpsellFromRoomClassEditLOV Fetch List Of Values for Upsell From Room Class Edit

 <p><strong>OperationId:</strong>getUpsellFromRoomClassEditLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellFromRoomClassEdit LOV
 @return ApiGetUpsellFromRoomClassEditLOVRequest
*/
func (a *LOVApiService) GetUpsellFromRoomClassEditLOV(ctx context.Context, hotelId string) ApiGetUpsellFromRoomClassEditLOVRequest {
	return ApiGetUpsellFromRoomClassEditLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellFromRoomClassEditLOVExecute(r ApiGetUpsellFromRoomClassEditLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellFromRoomClassEditLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellFromRoomClassEdit"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellFromRoomTypeEditLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellFromRoomTypeEditLOVRequest) Authorization(authorization string) ApiGetUpsellFromRoomTypeEditLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellFromRoomTypeEditLOVRequest) XAppKey(xAppKey string) ApiGetUpsellFromRoomTypeEditLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellFromRoomTypeEditLOVRequest) XHotelid(xHotelid string) ApiGetUpsellFromRoomTypeEditLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellFromRoomTypeEditLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellFromRoomTypeEditLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellFromRoomTypeEditLOVRequest) ParameterName(parameterName []string) ApiGetUpsellFromRoomTypeEditLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellFromRoomTypeEditLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellFromRoomTypeEditLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellFromRoomTypeEditLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellFromRoomTypeEditLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellFromRoomTypeEditLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellFromRoomTypeEditLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellFromRoomTypeEditLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellFromRoomTypeEditLOVExecute(r)
}

/*
GetUpsellFromRoomTypeEditLOV Fetch List Of Values for Upsell From Room Type Edit

 <p><strong>OperationId:</strong>getUpsellFromRoomTypeEditLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellFromRoomTypeEdit LOV
 @return ApiGetUpsellFromRoomTypeEditLOVRequest
*/
func (a *LOVApiService) GetUpsellFromRoomTypeEditLOV(ctx context.Context, hotelId string) ApiGetUpsellFromRoomTypeEditLOVRequest {
	return ApiGetUpsellFromRoomTypeEditLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellFromRoomTypeEditLOVExecute(r ApiGetUpsellFromRoomTypeEditLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellFromRoomTypeEditLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellFromRoomTypeEdit"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellHierarchyLevelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellHierarchyLevelsLOVRequest) Authorization(authorization string) ApiGetUpsellHierarchyLevelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellHierarchyLevelsLOVRequest) XAppKey(xAppKey string) ApiGetUpsellHierarchyLevelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellHierarchyLevelsLOVRequest) XHotelid(xHotelid string) ApiGetUpsellHierarchyLevelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellHierarchyLevelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellHierarchyLevelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellHierarchyLevelsLOVRequest) ParameterName(parameterName []string) ApiGetUpsellHierarchyLevelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellHierarchyLevelsLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellHierarchyLevelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellHierarchyLevelsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellHierarchyLevelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellHierarchyLevelsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellHierarchyLevelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellHierarchyLevelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellHierarchyLevelsLOVExecute(r)
}

/*
GetUpsellHierarchyLevelsLOV Fetch List Of Values for Upsell Hierarchy Levels

 <p><strong>OperationId:</strong>getUpsellHierarchyLevelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellHierarchyLevels LOV
 @return ApiGetUpsellHierarchyLevelsLOVRequest
*/
func (a *LOVApiService) GetUpsellHierarchyLevelsLOV(ctx context.Context, hotelId string) ApiGetUpsellHierarchyLevelsLOVRequest {
	return ApiGetUpsellHierarchyLevelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellHierarchyLevelsLOVExecute(r ApiGetUpsellHierarchyLevelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellHierarchyLevelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellHierarchyLevels"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellMembershipLevelsOnlyLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellMembershipLevelsOnlyLOVRequest) Authorization(authorization string) ApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellMembershipLevelsOnlyLOVRequest) XAppKey(xAppKey string) ApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellMembershipLevelsOnlyLOVRequest) XHotelid(xHotelid string) ApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellMembershipLevelsOnlyLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellMembershipLevelsOnlyLOVRequest) ParameterName(parameterName []string) ApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellMembershipLevelsOnlyLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellMembershipLevelsOnlyLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellMembershipLevelsOnlyLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellMembershipLevelsOnlyLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellMembershipLevelsOnlyLOVExecute(r)
}

/*
GetUpsellMembershipLevelsOnlyLOV Fetch List Of Values for Upsell Membership Levels Only

 <p><strong>OperationId:</strong>getUpsellMembershipLevelsOnlyLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipType Value of the parameter 'membershipType' which is required to fetch UpsellMembershipLevelsOnly LOV
 @return ApiGetUpsellMembershipLevelsOnlyLOVRequest
*/
func (a *LOVApiService) GetUpsellMembershipLevelsOnlyLOV(ctx context.Context, membershipType string) ApiGetUpsellMembershipLevelsOnlyLOVRequest {
	return ApiGetUpsellMembershipLevelsOnlyLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipType: membershipType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellMembershipLevelsOnlyLOVExecute(r ApiGetUpsellMembershipLevelsOnlyLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellMembershipLevelsOnlyLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipType/{membershipType}/upsellMembershipLevelsOnly"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellOccupancyLevelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeBlank string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellOccupancyLevelsLOVRequest) Authorization(authorization string) ApiGetUpsellOccupancyLevelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellOccupancyLevelsLOVRequest) XAppKey(xAppKey string) ApiGetUpsellOccupancyLevelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellOccupancyLevelsLOVRequest) XHotelid(xHotelid string) ApiGetUpsellOccupancyLevelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellOccupancyLevelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellOccupancyLevelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellOccupancyLevelsLOVRequest) ParameterName(parameterName []string) ApiGetUpsellOccupancyLevelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellOccupancyLevelsLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellOccupancyLevelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellOccupancyLevelsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellOccupancyLevelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellOccupancyLevelsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellOccupancyLevelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellOccupancyLevelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellOccupancyLevelsLOVExecute(r)
}

/*
GetUpsellOccupancyLevelsLOV Fetch List Of Values for Upsell Occupancy Levels

 <p><strong>OperationId:</strong>getUpsellOccupancyLevelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeBlank Value of the parameter 'includeBlank' which is required to fetch UpsellOccupancyLevels LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellOccupancyLevels LOV
 @return ApiGetUpsellOccupancyLevelsLOVRequest
*/
func (a *LOVApiService) GetUpsellOccupancyLevelsLOV(ctx context.Context, includeBlank string, hotelId string) ApiGetUpsellOccupancyLevelsLOVRequest {
	return ApiGetUpsellOccupancyLevelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeBlank: includeBlank,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellOccupancyLevelsLOVExecute(r ApiGetUpsellOccupancyLevelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellOccupancyLevelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/includeBlank/{includeBlank}/upsellOccupancyLevels"
	localVarPath = strings.Replace(localVarPath, "{"+"includeBlank"+"}", url.PathEscape(parameterValueToString(r.includeBlank, "includeBlank")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeBlank) < 1 {
		return localVarReturnValue, nil, reportError("includeBlank must have at least 1 elements")
	}
	if strlen(r.includeBlank) > 2000 {
		return localVarReturnValue, nil, reportError("includeBlank must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellRateCategoriesEditLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellRateCategoriesEditLOVRequest) Authorization(authorization string) ApiGetUpsellRateCategoriesEditLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellRateCategoriesEditLOVRequest) XAppKey(xAppKey string) ApiGetUpsellRateCategoriesEditLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellRateCategoriesEditLOVRequest) XHotelid(xHotelid string) ApiGetUpsellRateCategoriesEditLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellRateCategoriesEditLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellRateCategoriesEditLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellRateCategoriesEditLOVRequest) ParameterName(parameterName []string) ApiGetUpsellRateCategoriesEditLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellRateCategoriesEditLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellRateCategoriesEditLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellRateCategoriesEditLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellRateCategoriesEditLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellRateCategoriesEditLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellRateCategoriesEditLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellRateCategoriesEditLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellRateCategoriesEditLOVExecute(r)
}

/*
GetUpsellRateCategoriesEditLOV Fetch List Of Values for Upsell Rate Categories Edit

 <p><strong>OperationId:</strong>getUpsellRateCategoriesEditLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellRateCategoriesEdit LOV
 @return ApiGetUpsellRateCategoriesEditLOVRequest
*/
func (a *LOVApiService) GetUpsellRateCategoriesEditLOV(ctx context.Context, hotelId string) ApiGetUpsellRateCategoriesEditLOVRequest {
	return ApiGetUpsellRateCategoriesEditLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellRateCategoriesEditLOVExecute(r ApiGetUpsellRateCategoriesEditLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellRateCategoriesEditLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellRateCategoriesEdit"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellRateCodesLOVRequest) Authorization(authorization string) ApiGetUpsellRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellRateCodesLOVRequest) XAppKey(xAppKey string) ApiGetUpsellRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellRateCodesLOVRequest) XHotelid(xHotelid string) ApiGetUpsellRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellRateCodesLOVRequest) ParameterName(parameterName []string) ApiGetUpsellRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellRateCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellRateCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellRateCodesLOVExecute(r)
}

/*
GetUpsellRateCodesLOV Fetch List Of Values for Upsell Rate Codes

 <p><strong>OperationId:</strong>getUpsellRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellRateCodes LOV
 @return ApiGetUpsellRateCodesLOVRequest
*/
func (a *LOVApiService) GetUpsellRateCodesLOV(ctx context.Context, hotelId string) ApiGetUpsellRateCodesLOVRequest {
	return ApiGetUpsellRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellRateCodesLOVExecute(r ApiGetUpsellRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellRoomClassViewLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellRoomClassViewLOVRequest) Authorization(authorization string) ApiGetUpsellRoomClassViewLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellRoomClassViewLOVRequest) XAppKey(xAppKey string) ApiGetUpsellRoomClassViewLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellRoomClassViewLOVRequest) XHotelid(xHotelid string) ApiGetUpsellRoomClassViewLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellRoomClassViewLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellRoomClassViewLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellRoomClassViewLOVRequest) ParameterName(parameterName []string) ApiGetUpsellRoomClassViewLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellRoomClassViewLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellRoomClassViewLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellRoomClassViewLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellRoomClassViewLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellRoomClassViewLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellRoomClassViewLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellRoomClassViewLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellRoomClassViewLOVExecute(r)
}

/*
GetUpsellRoomClassViewLOV Fetch List Of Values for Upsell Room Class View

 <p><strong>OperationId:</strong>getUpsellRoomClassViewLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellRoomClassView LOV
 @return ApiGetUpsellRoomClassViewLOVRequest
*/
func (a *LOVApiService) GetUpsellRoomClassViewLOV(ctx context.Context, hotelId string) ApiGetUpsellRoomClassViewLOVRequest {
	return ApiGetUpsellRoomClassViewLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellRoomClassViewLOVExecute(r ApiGetUpsellRoomClassViewLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellRoomClassViewLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellRoomClassView"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellRoomTypeViewLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellRoomTypeViewLOVRequest) Authorization(authorization string) ApiGetUpsellRoomTypeViewLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellRoomTypeViewLOVRequest) XAppKey(xAppKey string) ApiGetUpsellRoomTypeViewLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellRoomTypeViewLOVRequest) XHotelid(xHotelid string) ApiGetUpsellRoomTypeViewLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellRoomTypeViewLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellRoomTypeViewLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellRoomTypeViewLOVRequest) ParameterName(parameterName []string) ApiGetUpsellRoomTypeViewLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellRoomTypeViewLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellRoomTypeViewLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellRoomTypeViewLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellRoomTypeViewLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellRoomTypeViewLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellRoomTypeViewLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellRoomTypeViewLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellRoomTypeViewLOVExecute(r)
}

/*
GetUpsellRoomTypeViewLOV Fetch List Of Values for Upsell Room Type View

 <p><strong>OperationId:</strong>getUpsellRoomTypeViewLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellRoomTypeView LOV
 @return ApiGetUpsellRoomTypeViewLOVRequest
*/
func (a *LOVApiService) GetUpsellRoomTypeViewLOV(ctx context.Context, hotelId string) ApiGetUpsellRoomTypeViewLOVRequest {
	return ApiGetUpsellRoomTypeViewLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellRoomTypeViewLOVExecute(r ApiGetUpsellRoomTypeViewLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellRoomTypeViewLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellRoomTypeView"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellRuleLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellRuleLOVRequest) Authorization(authorization string) ApiGetUpsellRuleLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellRuleLOVRequest) XAppKey(xAppKey string) ApiGetUpsellRuleLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellRuleLOVRequest) XHotelid(xHotelid string) ApiGetUpsellRuleLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellRuleLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellRuleLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellRuleLOVRequest) ParameterName(parameterName []string) ApiGetUpsellRuleLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellRuleLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellRuleLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellRuleLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellRuleLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellRuleLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellRuleLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellRuleLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellRuleLOVExecute(r)
}

/*
GetUpsellRuleLOV Fetch List Of Values for Upsell Rule

 <p><strong>OperationId:</strong>getUpsellRuleLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellRule LOV
 @return ApiGetUpsellRuleLOVRequest
*/
func (a *LOVApiService) GetUpsellRuleLOV(ctx context.Context, hotelId string) ApiGetUpsellRuleLOVRequest {
	return ApiGetUpsellRuleLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellRuleLOVExecute(r ApiGetUpsellRuleLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellRuleLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellRule"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellToRoomClassEditLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fromRoomClass string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellToRoomClassEditLOVRequest) Authorization(authorization string) ApiGetUpsellToRoomClassEditLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellToRoomClassEditLOVRequest) XAppKey(xAppKey string) ApiGetUpsellToRoomClassEditLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellToRoomClassEditLOVRequest) XHotelid(xHotelid string) ApiGetUpsellToRoomClassEditLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellToRoomClassEditLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellToRoomClassEditLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellToRoomClassEditLOVRequest) ParameterName(parameterName []string) ApiGetUpsellToRoomClassEditLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellToRoomClassEditLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellToRoomClassEditLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellToRoomClassEditLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellToRoomClassEditLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellToRoomClassEditLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellToRoomClassEditLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellToRoomClassEditLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellToRoomClassEditLOVExecute(r)
}

/*
GetUpsellToRoomClassEditLOV Fetch List Of Values for Upsell To Room Class Edit

 <p><strong>OperationId:</strong>getUpsellToRoomClassEditLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fromRoomClass Value of the parameter 'fromRoomClass' which is required to fetch UpsellToRoomClassEdit LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellToRoomClassEdit LOV
 @return ApiGetUpsellToRoomClassEditLOVRequest
*/
func (a *LOVApiService) GetUpsellToRoomClassEditLOV(ctx context.Context, fromRoomClass string, hotelId string) ApiGetUpsellToRoomClassEditLOVRequest {
	return ApiGetUpsellToRoomClassEditLOVRequest{
		ApiService: a,
		ctx: ctx,
		fromRoomClass: fromRoomClass,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellToRoomClassEditLOVExecute(r ApiGetUpsellToRoomClassEditLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellToRoomClassEditLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fromRoomClass/{fromRoomClass}/upsellToRoomClassEdit"
	localVarPath = strings.Replace(localVarPath, "{"+"fromRoomClass"+"}", url.PathEscape(parameterValueToString(r.fromRoomClass, "fromRoomClass")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fromRoomClass) < 1 {
		return localVarReturnValue, nil, reportError("fromRoomClass must have at least 1 elements")
	}
	if strlen(r.fromRoomClass) > 2000 {
		return localVarReturnValue, nil, reportError("fromRoomClass must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellToRoomTypeEditLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fromRoomTypeLabel string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellToRoomTypeEditLOVRequest) Authorization(authorization string) ApiGetUpsellToRoomTypeEditLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellToRoomTypeEditLOVRequest) XAppKey(xAppKey string) ApiGetUpsellToRoomTypeEditLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellToRoomTypeEditLOVRequest) XHotelid(xHotelid string) ApiGetUpsellToRoomTypeEditLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellToRoomTypeEditLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellToRoomTypeEditLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellToRoomTypeEditLOVRequest) ParameterName(parameterName []string) ApiGetUpsellToRoomTypeEditLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellToRoomTypeEditLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellToRoomTypeEditLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellToRoomTypeEditLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellToRoomTypeEditLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellToRoomTypeEditLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellToRoomTypeEditLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellToRoomTypeEditLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellToRoomTypeEditLOVExecute(r)
}

/*
GetUpsellToRoomTypeEditLOV Fetch List Of Values for Upsell To Room Type Edit

 <p><strong>OperationId:</strong>getUpsellToRoomTypeEditLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fromRoomTypeLabel Value of the parameter 'fromRoomTypeLabel' which is required to fetch UpsellToRoomTypeEdit LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellToRoomTypeEdit LOV
 @return ApiGetUpsellToRoomTypeEditLOVRequest
*/
func (a *LOVApiService) GetUpsellToRoomTypeEditLOV(ctx context.Context, fromRoomTypeLabel string, hotelId string) ApiGetUpsellToRoomTypeEditLOVRequest {
	return ApiGetUpsellToRoomTypeEditLOVRequest{
		ApiService: a,
		ctx: ctx,
		fromRoomTypeLabel: fromRoomTypeLabel,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellToRoomTypeEditLOVExecute(r ApiGetUpsellToRoomTypeEditLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellToRoomTypeEditLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fromRoomTypeLabel/{fromRoomTypeLabel}/upsellToRoomTypeEdit"
	localVarPath = strings.Replace(localVarPath, "{"+"fromRoomTypeLabel"+"}", url.PathEscape(parameterValueToString(r.fromRoomTypeLabel, "fromRoomTypeLabel")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fromRoomTypeLabel) < 1 {
		return localVarReturnValue, nil, reportError("fromRoomTypeLabel must have at least 1 elements")
	}
	if strlen(r.fromRoomTypeLabel) > 2000 {
		return localVarReturnValue, nil, reportError("fromRoomTypeLabel must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpsellTrxCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUpsellTrxCodesLOVRequest) Authorization(authorization string) ApiGetUpsellTrxCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUpsellTrxCodesLOVRequest) XAppKey(xAppKey string) ApiGetUpsellTrxCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUpsellTrxCodesLOVRequest) XHotelid(xHotelid string) ApiGetUpsellTrxCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUpsellTrxCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUpsellTrxCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUpsellTrxCodesLOVRequest) ParameterName(parameterName []string) ApiGetUpsellTrxCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUpsellTrxCodesLOVRequest) ParameterValue(parameterValue []string) ApiGetUpsellTrxCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUpsellTrxCodesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUpsellTrxCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUpsellTrxCodesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUpsellTrxCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUpsellTrxCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellTrxCodesLOVExecute(r)
}

/*
GetUpsellTrxCodesLOV Fetch List Of Values for Upsell Trx Codes

 <p><strong>OperationId:</strong>getUpsellTrxCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellTrxCodes LOV
 @return ApiGetUpsellTrxCodesLOVRequest
*/
func (a *LOVApiService) GetUpsellTrxCodesLOV(ctx context.Context, hotelId string) ApiGetUpsellTrxCodesLOVRequest {
	return ApiGetUpsellTrxCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellTrxCodesLOVExecute(r ApiGetUpsellTrxCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellTrxCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellTrxCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserDbFunctionArgsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	category string
	functionName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUserDbFunctionArgsLOVRequest) Authorization(authorization string) ApiGetUserDbFunctionArgsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUserDbFunctionArgsLOVRequest) XAppKey(xAppKey string) ApiGetUserDbFunctionArgsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUserDbFunctionArgsLOVRequest) XHotelid(xHotelid string) ApiGetUserDbFunctionArgsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUserDbFunctionArgsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUserDbFunctionArgsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUserDbFunctionArgsLOVRequest) ParameterName(parameterName []string) ApiGetUserDbFunctionArgsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUserDbFunctionArgsLOVRequest) ParameterValue(parameterValue []string) ApiGetUserDbFunctionArgsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUserDbFunctionArgsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUserDbFunctionArgsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUserDbFunctionArgsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUserDbFunctionArgsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUserDbFunctionArgsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUserDbFunctionArgsLOVExecute(r)
}

/*
GetUserDbFunctionArgsLOV Fetch List Of Values for User Db Function Args

 <p><strong>OperationId:</strong>getUserDbFunctionArgsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param category Value of the parameter 'category' which is required to fetch UserDbFunctionArgs LOV
 @param functionName Value of the parameter 'functionName' which is required to fetch UserDbFunctionArgs LOV
 @return ApiGetUserDbFunctionArgsLOVRequest
*/
func (a *LOVApiService) GetUserDbFunctionArgsLOV(ctx context.Context, category string, functionName string) ApiGetUserDbFunctionArgsLOVRequest {
	return ApiGetUserDbFunctionArgsLOVRequest{
		ApiService: a,
		ctx: ctx,
		category: category,
		functionName: functionName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUserDbFunctionArgsLOVExecute(r ApiGetUserDbFunctionArgsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUserDbFunctionArgsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/functionName/{functionName}/category/{category}/userDbFunctionArgs"
	localVarPath = strings.Replace(localVarPath, "{"+"category"+"}", url.PathEscape(parameterValueToString(r.category, "category")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"functionName"+"}", url.PathEscape(parameterValueToString(r.functionName, "functionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.category) < 1 {
		return localVarReturnValue, nil, reportError("category must have at least 1 elements")
	}
	if strlen(r.category) > 2000 {
		return localVarReturnValue, nil, reportError("category must have less than 2000 elements")
	}
	if strlen(r.functionName) < 1 {
		return localVarReturnValue, nil, reportError("functionName must have at least 1 elements")
	}
	if strlen(r.functionName) > 2000 {
		return localVarReturnValue, nil, reportError("functionName must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserDbFunctionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	category string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUserDbFunctionsLOVRequest) Authorization(authorization string) ApiGetUserDbFunctionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUserDbFunctionsLOVRequest) XAppKey(xAppKey string) ApiGetUserDbFunctionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUserDbFunctionsLOVRequest) XHotelid(xHotelid string) ApiGetUserDbFunctionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUserDbFunctionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUserDbFunctionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUserDbFunctionsLOVRequest) ParameterName(parameterName []string) ApiGetUserDbFunctionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUserDbFunctionsLOVRequest) ParameterValue(parameterValue []string) ApiGetUserDbFunctionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUserDbFunctionsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUserDbFunctionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUserDbFunctionsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUserDbFunctionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUserDbFunctionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUserDbFunctionsLOVExecute(r)
}

/*
GetUserDbFunctionsLOV Fetch List Of Values for User Db Functions

 <p><strong>OperationId:</strong>getUserDbFunctionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param category Value of the parameter 'category' which is required to fetch UserDbFunctions LOV
 @return ApiGetUserDbFunctionsLOVRequest
*/
func (a *LOVApiService) GetUserDbFunctionsLOV(ctx context.Context, category string) ApiGetUserDbFunctionsLOVRequest {
	return ApiGetUserDbFunctionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		category: category,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUserDbFunctionsLOVExecute(r ApiGetUserDbFunctionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUserDbFunctionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/category/{category}/userDbFunctions"
	localVarPath = strings.Replace(localVarPath, "{"+"category"+"}", url.PathEscape(parameterValueToString(r.category, "category")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.category) < 1 {
		return localVarReturnValue, nil, reportError("category must have at least 1 elements")
	}
	if strlen(r.category) > 2000 {
		return localVarReturnValue, nil, reportError("category must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserLogActivityGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUserLogActivityGroupsLOVRequest) Authorization(authorization string) ApiGetUserLogActivityGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUserLogActivityGroupsLOVRequest) XAppKey(xAppKey string) ApiGetUserLogActivityGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUserLogActivityGroupsLOVRequest) XHotelid(xHotelid string) ApiGetUserLogActivityGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUserLogActivityGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUserLogActivityGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUserLogActivityGroupsLOVRequest) ParameterName(parameterName []string) ApiGetUserLogActivityGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUserLogActivityGroupsLOVRequest) ParameterValue(parameterValue []string) ApiGetUserLogActivityGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUserLogActivityGroupsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUserLogActivityGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUserLogActivityGroupsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUserLogActivityGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUserLogActivityGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUserLogActivityGroupsLOVExecute(r)
}

/*
GetUserLogActivityGroupsLOV Fetch List Of Values for User Log Activity Groups

 <p><strong>OperationId:</strong>getUserLogActivityGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UserLogActivityGroups LOV
 @return ApiGetUserLogActivityGroupsLOVRequest
*/
func (a *LOVApiService) GetUserLogActivityGroupsLOV(ctx context.Context, hotelId string) ApiGetUserLogActivityGroupsLOVRequest {
	return ApiGetUserLogActivityGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUserLogActivityGroupsLOVExecute(r ApiGetUserLogActivityGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUserLogActivityGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/userLogActivityGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserLogActivityTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	activityGroup string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUserLogActivityTypesLOVRequest) Authorization(authorization string) ApiGetUserLogActivityTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUserLogActivityTypesLOVRequest) XAppKey(xAppKey string) ApiGetUserLogActivityTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUserLogActivityTypesLOVRequest) XHotelid(xHotelid string) ApiGetUserLogActivityTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUserLogActivityTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUserLogActivityTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUserLogActivityTypesLOVRequest) ParameterName(parameterName []string) ApiGetUserLogActivityTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUserLogActivityTypesLOVRequest) ParameterValue(parameterValue []string) ApiGetUserLogActivityTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUserLogActivityTypesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUserLogActivityTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUserLogActivityTypesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUserLogActivityTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUserLogActivityTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUserLogActivityTypesLOVExecute(r)
}

/*
GetUserLogActivityTypesLOV Fetch List Of Values for User Log Activity Types

 <p><strong>OperationId:</strong>getUserLogActivityTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityGroup Value of the parameter 'activityGroup' which is required to fetch UserLogActivityTypes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UserLogActivityTypes LOV
 @return ApiGetUserLogActivityTypesLOVRequest
*/
func (a *LOVApiService) GetUserLogActivityTypesLOV(ctx context.Context, activityGroup string, hotelId string) ApiGetUserLogActivityTypesLOVRequest {
	return ApiGetUserLogActivityTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		activityGroup: activityGroup,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUserLogActivityTypesLOVExecute(r ApiGetUserLogActivityTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUserLogActivityTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/activityGroup/{activityGroup}/userLogActivityTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"activityGroup"+"}", url.PathEscape(parameterValueToString(r.activityGroup, "activityGroup")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityGroup) < 1 {
		return localVarReturnValue, nil, reportError("activityGroup must have at least 1 elements")
	}
	if strlen(r.activityGroup) > 2000 {
		return localVarReturnValue, nil, reportError("activityGroup must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserRolesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roleWithDepartment string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetUserRolesLOVRequest) Authorization(authorization string) ApiGetUserRolesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetUserRolesLOVRequest) XAppKey(xAppKey string) ApiGetUserRolesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetUserRolesLOVRequest) XHotelid(xHotelid string) ApiGetUserRolesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetUserRolesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetUserRolesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetUserRolesLOVRequest) ParameterName(parameterName []string) ApiGetUserRolesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetUserRolesLOVRequest) ParameterValue(parameterValue []string) ApiGetUserRolesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetUserRolesLOVRequest) XExternalsystem(xExternalsystem string) ApiGetUserRolesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetUserRolesLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetUserRolesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetUserRolesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUserRolesLOVExecute(r)
}

/*
GetUserRolesLOV Fetch List Of Values for User Roles

 <p><strong>OperationId:</strong>getUserRolesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleWithDepartment Value of the parameter 'roleWithDepartment' which is required to fetch UserRoles LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UserRoles LOV
 @return ApiGetUserRolesLOVRequest
*/
func (a *LOVApiService) GetUserRolesLOV(ctx context.Context, roleWithDepartment string, hotelId string) ApiGetUserRolesLOVRequest {
	return ApiGetUserRolesLOVRequest{
		ApiService: a,
		ctx: ctx,
		roleWithDepartment: roleWithDepartment,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUserRolesLOVExecute(r ApiGetUserRolesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUserRolesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roleWithDepartment/{roleWithDepartment}/userRoles"
	localVarPath = strings.Replace(localVarPath, "{"+"roleWithDepartment"+"}", url.PathEscape(parameterValueToString(r.roleWithDepartment, "roleWithDepartment")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roleWithDepartment) < 1 {
		return localVarReturnValue, nil, reportError("roleWithDepartment must have at least 1 elements")
	}
	if strlen(r.roleWithDepartment) > 2000 {
		return localVarReturnValue, nil, reportError("roleWithDepartment must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetYearSetupLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetYearSetupLOVRequest) Authorization(authorization string) ApiGetYearSetupLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetYearSetupLOVRequest) XAppKey(xAppKey string) ApiGetYearSetupLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetYearSetupLOVRequest) XHotelid(xHotelid string) ApiGetYearSetupLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetYearSetupLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetYearSetupLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetYearSetupLOVRequest) ParameterName(parameterName []string) ApiGetYearSetupLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetYearSetupLOVRequest) ParameterValue(parameterValue []string) ApiGetYearSetupLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetYearSetupLOVRequest) XExternalsystem(xExternalsystem string) ApiGetYearSetupLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetYearSetupLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetYearSetupLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetYearSetupLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetYearSetupLOVExecute(r)
}

/*
GetYearSetupLOV Fetch List Of Values for Year Setup

 <p><strong>OperationId:</strong>getYearSetupLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch YearSetup LOV
 @return ApiGetYearSetupLOVRequest
*/
func (a *LOVApiService) GetYearSetupLOV(ctx context.Context, hotelId string) ApiGetYearSetupLOVRequest {
	return ApiGetYearSetupLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetYearSetupLOVExecute(r ApiGetYearSetupLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetYearSetupLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/yearSetup"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetYieldMarketsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetYieldMarketsLOVRequest) Authorization(authorization string) ApiGetYieldMarketsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetYieldMarketsLOVRequest) XAppKey(xAppKey string) ApiGetYieldMarketsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetYieldMarketsLOVRequest) XHotelid(xHotelid string) ApiGetYieldMarketsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r ApiGetYieldMarketsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) ApiGetYieldMarketsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r ApiGetYieldMarketsLOVRequest) ParameterName(parameterName []string) ApiGetYieldMarketsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ApiGetYieldMarketsLOVRequest) ParameterValue(parameterValue []string) ApiGetYieldMarketsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r ApiGetYieldMarketsLOVRequest) XExternalsystem(xExternalsystem string) ApiGetYieldMarketsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetYieldMarketsLOVRequest) AcceptLanguage(acceptLanguage string) ApiGetYieldMarketsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetYieldMarketsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetYieldMarketsLOVExecute(r)
}

/*
GetYieldMarketsLOV Fetch List Of Values for Yield Markets

 <p><strong>OperationId:</strong>getYieldMarketsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch YieldMarkets LOV
 @return ApiGetYieldMarketsLOVRequest
*/
func (a *LOVApiService) GetYieldMarketsLOV(ctx context.Context, hotelId string) ApiGetYieldMarketsLOVRequest {
	return ApiGetYieldMarketsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetYieldMarketsLOVExecute(r ApiGetYieldMarketsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetYieldMarketsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/yieldMarkets"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPingLOVServiceRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiPingLOVServiceRequest) Authorization(authorization string) ApiPingLOVServiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiPingLOVServiceRequest) XAppKey(xAppKey string) ApiPingLOVServiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiPingLOVServiceRequest) XHotelid(xHotelid string) ApiPingLOVServiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ApiPingLOVServiceRequest) XExternalsystem(xExternalsystem string) ApiPingLOVServiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiPingLOVServiceRequest) AcceptLanguage(acceptLanguage string) ApiPingLOVServiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiPingLOVServiceRequest) Execute() (*OperaVersion, *http.Response, error) {
	return r.ApiService.PingLOVServiceExecute(r)
}

/*
PingLOVService Retrieve List of Values Service Version

 <p><strong>OperationId:</strong>pingLOVService</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPingLOVServiceRequest
*/
func (a *LOVApiService) PingLOVService(ctx context.Context) ApiPingLOVServiceRequest {
	return ApiPingLOVServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperaVersion
func (a *LOVApiService) PingLOVServiceExecute(r ApiPingLOVServiceRequest) (*OperaVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperaVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.PingLOVService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/listOfValues/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateListOfValuesRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	validateListOfValues *ValidateListOfValuesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiValidateListOfValuesRequest) Authorization(authorization string) ApiValidateListOfValuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiValidateListOfValuesRequest) XAppKey(xAppKey string) ApiValidateListOfValuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiValidateListOfValuesRequest) XHotelid(xHotelid string) ApiValidateListOfValuesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ApiValidateListOfValuesRequest) ValidateListOfValues(validateListOfValues ValidateListOfValuesRequest) ApiValidateListOfValuesRequest {
	r.validateListOfValues = &validateListOfValues
	return r
}

// External system code.
func (r ApiValidateListOfValuesRequest) XExternalsystem(xExternalsystem string) ApiValidateListOfValuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiValidateListOfValuesRequest) AcceptLanguage(acceptLanguage string) ApiValidateListOfValuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiValidateListOfValuesRequest) Execute() (*ValidateListOfValuesDetails, *http.Response, error) {
	return r.ApiService.ValidateListOfValuesExecute(r)
}

/*
ValidateListOfValues Validate List Of Values

 <p><strong>OperationId:</strong>validateListOfValues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateListOfValuesRequest
*/
func (a *LOVApiService) ValidateListOfValues(ctx context.Context) ApiValidateListOfValuesRequest {
	return ApiValidateListOfValuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ValidateListOfValuesDetails
func (a *LOVApiService) ValidateListOfValuesExecute(r ApiValidateListOfValuesRequest) (*ValidateListOfValuesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateListOfValuesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.ValidateListOfValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}
	if r.validateListOfValues == nil {
		return localVarReturnValue, nil, reportError("validateListOfValues is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.validateListOfValues
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
