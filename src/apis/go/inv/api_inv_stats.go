/*
OPERA Cloud Inventory API

APIs to cater for Inventory functionality in OPERA Cloud. This includes sell limits for date ranges, viewing and updating the property&apos;s inventory, as well as item inventory (such as rollaways, microwaves etc.).<br /><br /> Compatible with OPERA Cloud release 22.3.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 22.3.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package inv

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// INVStatsApiService INVStatsApi service
type INVStatsApiService service

type INVStatsApiDeleteinvStatsServiceRequest struct {
	ctx context.Context
	ApiService *INVStatsApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r INVStatsApiDeleteinvStatsServiceRequest) Authorization(authorization string) INVStatsApiDeleteinvStatsServiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r INVStatsApiDeleteinvStatsServiceRequest) XAppKey(xAppKey string) INVStatsApiDeleteinvStatsServiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r INVStatsApiDeleteinvStatsServiceRequest) XHotelid(xHotelid string) INVStatsApiDeleteinvStatsServiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r INVStatsApiDeleteinvStatsServiceRequest) XExternalsystem(xExternalsystem string) INVStatsApiDeleteinvStatsServiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r INVStatsApiDeleteinvStatsServiceRequest) AcceptLanguage(acceptLanguage string) INVStatsApiDeleteinvStatsServiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r INVStatsApiDeleteinvStatsServiceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteinvStatsServiceExecute(r)
}

/*
DeleteinvStatsService Clear Cache

Clearing of cache in inventory statistics service <p><strong>OperationId:</strong>deleteinvStatsService</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return INVStatsApiDeleteinvStatsServiceRequest
*/
func (a *INVStatsApiService) DeleteinvStatsService(ctx context.Context) INVStatsApiDeleteinvStatsServiceRequest {
	return INVStatsApiDeleteinvStatsServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *INVStatsApiService) DeleteinvStatsServiceExecute(r INVStatsApiDeleteinvStatsServiceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "INVStatsApiService.DeleteinvStatsService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/invStatsService/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type INVStatsApiGetBlockInventoryStatisticsRequest struct {
	ctx context.Context
	ApiService *INVStatsApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeBlocksWithNoRoom *bool
	includeOverbooking *bool
	includeOpportunities *bool
	includeTentativeInventory *bool
	limit *int32
	offset *int32
	endDateRange *string
	startDateRange *string
	blockStatusCodes *[]string
	originCodes *[]string
	roomOwnerCodes *[]string
	blockOwners *[]string
	summarySortByCode *string
	detailSortByCode *string
	friday *bool
	monday *bool
	saturday *bool
	sunday *bool
	thursday *bool
	tuesday *bool
	wednesday *bool
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r INVStatsApiGetBlockInventoryStatisticsRequest) Authorization(authorization string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r INVStatsApiGetBlockInventoryStatisticsRequest) XAppKey(xAppKey string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r INVStatsApiGetBlockInventoryStatisticsRequest) XHotelid(xHotelid string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// If set to true, includes business blocks without rooms.
func (r INVStatsApiGetBlockInventoryStatisticsRequest) IncludeBlocksWithNoRoom(includeBlocksWithNoRoom bool) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.includeBlocksWithNoRoom = &includeBlocksWithNoRoom
	return r
}

// If set to true, the house overbooking limit for each day is added to the total number of physical rooms.
func (r INVStatsApiGetBlockInventoryStatisticsRequest) IncludeOverbooking(includeOverbooking bool) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.includeOverbooking = &includeOverbooking
	return r
}

// If set to true, the results will include opportunities. If this flag is not provided it will be considered false and exclude opportunities.
func (r INVStatsApiGetBlockInventoryStatisticsRequest) IncludeOpportunities(includeOpportunities bool) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.includeOpportunities = &includeOpportunities
	return r
}

// If set to true, includes non-deduct business blocks and group reservations in the Sales Allowance Available Rooms and House Availability statistics.
func (r INVStatsApiGetBlockInventoryStatisticsRequest) IncludeTentativeInventory(includeTentativeInventory bool) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.includeTentativeInventory = &includeTentativeInventory
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r INVStatsApiGetBlockInventoryStatisticsRequest) Limit(limit int32) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r INVStatsApiGetBlockInventoryStatisticsRequest) Offset(offset int32) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.offset = &offset
	return r
}

// The ending value of the date range.
func (r INVStatsApiGetBlockInventoryStatisticsRequest) EndDateRange(endDateRange string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.endDateRange = &endDateRange
	return r
}

// The starting value of the date range.
func (r INVStatsApiGetBlockInventoryStatisticsRequest) StartDateRange(startDateRange string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.startDateRange = &startDateRange
	return r
}

func (r INVStatsApiGetBlockInventoryStatisticsRequest) BlockStatusCodes(blockStatusCodes []string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.blockStatusCodes = &blockStatusCodes
	return r
}

func (r INVStatsApiGetBlockInventoryStatisticsRequest) OriginCodes(originCodes []string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.originCodes = &originCodes
	return r
}

func (r INVStatsApiGetBlockInventoryStatisticsRequest) RoomOwnerCodes(roomOwnerCodes []string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.roomOwnerCodes = &roomOwnerCodes
	return r
}

func (r INVStatsApiGetBlockInventoryStatisticsRequest) BlockOwners(blockOwners []string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.blockOwners = &blockOwners
	return r
}

// Supported block inventory statistical sorting.
func (r INVStatsApiGetBlockInventoryStatisticsRequest) SummarySortByCode(summarySortByCode string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.summarySortByCode = &summarySortByCode
	return r
}

// Supported block inventory statistical sorting.
func (r INVStatsApiGetBlockInventoryStatisticsRequest) DetailSortByCode(detailSortByCode string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.detailSortByCode = &detailSortByCode
	return r
}

func (r INVStatsApiGetBlockInventoryStatisticsRequest) Friday(friday bool) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.friday = &friday
	return r
}

func (r INVStatsApiGetBlockInventoryStatisticsRequest) Monday(monday bool) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.monday = &monday
	return r
}

func (r INVStatsApiGetBlockInventoryStatisticsRequest) Saturday(saturday bool) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.saturday = &saturday
	return r
}

func (r INVStatsApiGetBlockInventoryStatisticsRequest) Sunday(sunday bool) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.sunday = &sunday
	return r
}

func (r INVStatsApiGetBlockInventoryStatisticsRequest) Thursday(thursday bool) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.thursday = &thursday
	return r
}

func (r INVStatsApiGetBlockInventoryStatisticsRequest) Tuesday(tuesday bool) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.tuesday = &tuesday
	return r
}

func (r INVStatsApiGetBlockInventoryStatisticsRequest) Wednesday(wednesday bool) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.wednesday = &wednesday
	return r
}

// Type for block inventory statistics instructions that can be used in requests for partial operations.
func (r INVStatsApiGetBlockInventoryStatisticsRequest) FetchInstructions(fetchInstructions []string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r INVStatsApiGetBlockInventoryStatisticsRequest) XExternalsystem(xExternalsystem string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r INVStatsApiGetBlockInventoryStatisticsRequest) AcceptLanguage(acceptLanguage string) INVStatsApiGetBlockInventoryStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r INVStatsApiGetBlockInventoryStatisticsRequest) Execute() (*BlockInventoryStatistic, *http.Response, error) {
	return r.ApiService.GetBlockInventoryStatisticsExecute(r)
}

/*
GetBlockInventoryStatistics Get block inventory statistics

Use this API to get block statistics on a per-day basis across a specified date range. The result includes a summary section of rooms booked by status by date, details on deduct and non-deduct rooms booked per day, and Sales Allowance and House Availability figures per day. The details section of the results include block details such as name, block, code, start and end date, owner, and more. It also shows a breakdown of blocked picked-up and available rooms per day per block. The result set is used to feed the GRC (Group Rooms Control) page in the OPERA UI. <p><strong>OperationId:</strong>getBlockInventoryStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where block inventory statistics are searched.
 @return INVStatsApiGetBlockInventoryStatisticsRequest
*/
func (a *INVStatsApiService) GetBlockInventoryStatistics(ctx context.Context, hotelId string) INVStatsApiGetBlockInventoryStatisticsRequest {
	return INVStatsApiGetBlockInventoryStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockInventoryStatistic
func (a *INVStatsApiService) GetBlockInventoryStatisticsExecute(r INVStatsApiGetBlockInventoryStatisticsRequest) (*BlockInventoryStatistic, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockInventoryStatistic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "INVStatsApiService.GetBlockInventoryStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blockInventoryStatistics"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeBlocksWithNoRoom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeBlocksWithNoRoom", r.includeBlocksWithNoRoom, "")
	}
	if r.includeOverbooking != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOverbooking", r.includeOverbooking, "")
	}
	if r.includeOpportunities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOpportunities", r.includeOpportunities, "")
	}
	if r.includeTentativeInventory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTentativeInventory", r.includeTentativeInventory, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.endDateRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDateRange", r.endDateRange, "")
	}
	if r.startDateRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDateRange", r.startDateRange, "")
	}
	if r.blockStatusCodes != nil {
		t := *r.blockStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockStatusCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockStatusCodes", t, "multi")
		}
	}
	if r.originCodes != nil {
		t := *r.originCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "originCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "originCodes", t, "multi")
		}
	}
	if r.roomOwnerCodes != nil {
		t := *r.roomOwnerCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomOwnerCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomOwnerCodes", t, "multi")
		}
	}
	if r.blockOwners != nil {
		t := *r.blockOwners
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockOwners", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockOwners", t, "multi")
		}
	}
	if r.summarySortByCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarySortByCode", r.summarySortByCode, "")
	}
	if r.detailSortByCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailSortByCode", r.detailSortByCode, "")
	}
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
	}
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
	}
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
	}
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
	}
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
	}
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
	}
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type INVStatsApiGetInventoryStatisticsRequest struct {
	ctx context.Context
	ApiService *INVStatsApiService
	hotelId string
	dateRangeEnd *string
	reportCode *string
	dateRangeStart *string
	authorization *string
	xAppKey *string
	xHotelid *string
	parameterName *[]string
	parameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The ending value of the date range.
func (r INVStatsApiGetInventoryStatisticsRequest) DateRangeEnd(dateRangeEnd string) INVStatsApiGetInventoryStatisticsRequest {
	r.dateRangeEnd = &dateRangeEnd
	return r
}

// Identifies the type of statistics collected. Each ReportCode corresponds to a set of category summaries based upon a predetermined agreement.
func (r INVStatsApiGetInventoryStatisticsRequest) ReportCode(reportCode string) INVStatsApiGetInventoryStatisticsRequest {
	r.reportCode = &reportCode
	return r
}

// The starting value of the date range.
func (r INVStatsApiGetInventoryStatisticsRequest) DateRangeStart(dateRangeStart string) INVStatsApiGetInventoryStatisticsRequest {
	r.dateRangeStart = &dateRangeStart
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r INVStatsApiGetInventoryStatisticsRequest) Authorization(authorization string) INVStatsApiGetInventoryStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r INVStatsApiGetInventoryStatisticsRequest) XAppKey(xAppKey string) INVStatsApiGetInventoryStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r INVStatsApiGetInventoryStatisticsRequest) XHotelid(xHotelid string) INVStatsApiGetInventoryStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Name of the parameter.
func (r INVStatsApiGetInventoryStatisticsRequest) ParameterName(parameterName []string) INVStatsApiGetInventoryStatisticsRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r INVStatsApiGetInventoryStatisticsRequest) ParameterValue(parameterValue []string) INVStatsApiGetInventoryStatisticsRequest {
	r.parameterValue = &parameterValue
	return r
}

// External system code.
func (r INVStatsApiGetInventoryStatisticsRequest) XExternalsystem(xExternalsystem string) INVStatsApiGetInventoryStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r INVStatsApiGetInventoryStatisticsRequest) AcceptLanguage(acceptLanguage string) INVStatsApiGetInventoryStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r INVStatsApiGetInventoryStatisticsRequest) Execute() ([]StatisticType, *http.Response, error) {
	return r.ApiService.GetInventoryStatisticsExecute(r)
}

/*
GetInventoryStatistics Get hotel inventory

Use this API to retrieve the inventory data for a specified hotel. Narrow down your results using the query parameters such as a date range, room type, room class, and/or tentative inventory included. Maximum days limit with a single request is 30 days.<p><strong>OperationId:</strong>getInventoryStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where inventory statistics are searched.
 @return INVStatsApiGetInventoryStatisticsRequest
*/
func (a *INVStatsApiService) GetInventoryStatistics(ctx context.Context, hotelId string) INVStatsApiGetInventoryStatisticsRequest {
	return INVStatsApiGetInventoryStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return []StatisticType
func (a *INVStatsApiService) GetInventoryStatisticsExecute(r INVStatsApiGetInventoryStatisticsRequest) ([]StatisticType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []StatisticType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "INVStatsApiService.GetInventoryStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/inventoryStatistics"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeEnd", r.dateRangeEnd, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "reportCode", r.reportCode, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeStart", r.dateRangeStart, "")
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type INVStatsApiPinginvStatsServiceRequest struct {
	ctx context.Context
	ApiService *INVStatsApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r INVStatsApiPinginvStatsServiceRequest) Authorization(authorization string) INVStatsApiPinginvStatsServiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r INVStatsApiPinginvStatsServiceRequest) XAppKey(xAppKey string) INVStatsApiPinginvStatsServiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r INVStatsApiPinginvStatsServiceRequest) XHotelid(xHotelid string) INVStatsApiPinginvStatsServiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r INVStatsApiPinginvStatsServiceRequest) XExternalsystem(xExternalsystem string) INVStatsApiPinginvStatsServiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r INVStatsApiPinginvStatsServiceRequest) AcceptLanguage(acceptLanguage string) INVStatsApiPinginvStatsServiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r INVStatsApiPinginvStatsServiceRequest) Execute() (*PingDetail, *http.Response, error) {
	return r.ApiService.PinginvStatsServiceExecute(r)
}

/*
PinginvStatsService Ping

Check inventory statistics service <p><strong>OperationId:</strong>pinginvStatsService</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return INVStatsApiPinginvStatsServiceRequest
*/
func (a *INVStatsApiService) PinginvStatsService(ctx context.Context) INVStatsApiPinginvStatsServiceRequest {
	return INVStatsApiPinginvStatsServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PingDetail
func (a *INVStatsApiService) PinginvStatsServiceExecute(r INVStatsApiPinginvStatsServiceRequest) (*PingDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PingDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "INVStatsApiService.PinginvStatsService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/invStatsService/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
