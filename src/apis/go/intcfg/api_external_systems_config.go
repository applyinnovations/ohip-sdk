/*
OPERA Cloud Integration Configuration API

APIs catering to Integration Configuration in OPERA Cloud.  Operations such as get Hotel Interface Types, or get UDF mappings can be found in this module.<br /><br /> Compatible with OPERA Cloud release 22.3.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 22.3.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package intcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ExternalSystemsConfigApiService ExternalSystemsConfigApi service
type ExternalSystemsConfigApiService service

type ExternalSystemsConfigApiClearCacheRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiClearCacheRequest) Authorization(authorization string) ExternalSystemsConfigApiClearCacheRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiClearCacheRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiClearCacheRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiClearCacheRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiClearCacheRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ExternalSystemsConfigApiClearCacheRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiClearCacheRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiClearCacheRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiClearCacheRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiClearCacheRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ClearCacheExecute(r)
}

/*
ClearCache Operation to clear cache.

 <p><strong>OperationId:</strong>clearCache</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiClearCacheRequest
*/
func (a *ExternalSystemsConfigApiService) ClearCache(ctx context.Context) ExternalSystemsConfigApiClearCacheRequest {
	return ExternalSystemsConfigApiClearCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) ClearCacheExecute(r ExternalSystemsConfigApiClearCacheRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.ClearCache")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/config/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiDeleteDeliveryMethodsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	type_ *string
	options *[]string
	configurationId *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiDeleteDeliveryMethodsRequest) Authorization(authorization string) ExternalSystemsConfigApiDeleteDeliveryMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiDeleteDeliveryMethodsRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiDeleteDeliveryMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiDeleteDeliveryMethodsRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiDeleteDeliveryMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ExternalSystemsConfigApiDeleteDeliveryMethodsRequest) HotelId(hotelId string) ExternalSystemsConfigApiDeleteDeliveryMethodsRequest {
	r.hotelId = &hotelId
	return r
}

// Settings for Text Message Delivery of Queue Reservation status
func (r ExternalSystemsConfigApiDeleteDeliveryMethodsRequest) Type_(type_ string) ExternalSystemsConfigApiDeleteDeliveryMethodsRequest {
	r.type_ = &type_
	return r
}

// SFTP delivery configurations
func (r ExternalSystemsConfigApiDeleteDeliveryMethodsRequest) Options(options []string) ExternalSystemsConfigApiDeleteDeliveryMethodsRequest {
	r.options = &options
	return r
}

// Unique id associated with this configuration
func (r ExternalSystemsConfigApiDeleteDeliveryMethodsRequest) ConfigurationId(configurationId []int32) ExternalSystemsConfigApiDeleteDeliveryMethodsRequest {
	r.configurationId = &configurationId
	return r
}

// External system code.
func (r ExternalSystemsConfigApiDeleteDeliveryMethodsRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiDeleteDeliveryMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiDeleteDeliveryMethodsRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiDeleteDeliveryMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiDeleteDeliveryMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteDeliveryMethodsExecute(r)
}

/*
DeleteDeliveryMethods Operation to remove delivery methods.

 <p><strong>OperationId:</strong>deleteDeliveryMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiDeleteDeliveryMethodsRequest
*/
func (a *ExternalSystemsConfigApiService) DeleteDeliveryMethods(ctx context.Context) ExternalSystemsConfigApiDeleteDeliveryMethodsRequest {
	return ExternalSystemsConfigApiDeleteDeliveryMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) DeleteDeliveryMethodsExecute(r ExternalSystemsConfigApiDeleteDeliveryMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.DeleteDeliveryMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deliveryMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.options != nil {
		t := *r.options
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "options", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "options", t, "multi")
		}
	}
	if r.configurationId != nil {
		t := *r.configurationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiDeleteHotelInterfaceRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	logo *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiDeleteHotelInterfaceRequest) Authorization(authorization string) ExternalSystemsConfigApiDeleteHotelInterfaceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiDeleteHotelInterfaceRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiDeleteHotelInterfaceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiDeleteHotelInterfaceRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiDeleteHotelInterfaceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Interface Logo. On the database, this is also referred as DBF Logo. This is a three letter code followed by an underscore(_). This tells us which DBF files and log files with the prefix that IFC7 is going to create.
func (r ExternalSystemsConfigApiDeleteHotelInterfaceRequest) Logo(logo string) ExternalSystemsConfigApiDeleteHotelInterfaceRequest {
	r.logo = &logo
	return r
}

// External system code.
func (r ExternalSystemsConfigApiDeleteHotelInterfaceRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiDeleteHotelInterfaceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiDeleteHotelInterfaceRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiDeleteHotelInterfaceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiDeleteHotelInterfaceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteHotelInterfaceExecute(r)
}

/*
DeleteHotelInterface Operation to remove hotel interface.

 <p><strong>OperationId:</strong>deleteHotelInterface</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return ExternalSystemsConfigApiDeleteHotelInterfaceRequest
*/
func (a *ExternalSystemsConfigApiService) DeleteHotelInterface(ctx context.Context, hotelId string) ExternalSystemsConfigApiDeleteHotelInterfaceRequest {
	return ExternalSystemsConfigApiDeleteHotelInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) DeleteHotelInterfaceExecute(r ExternalSystemsConfigApiDeleteHotelInterfaceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.DeleteHotelInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/hotelInerface"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.logo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logo", r.logo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiDeleteInterfaceRightRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	right *int32
	code *string
	description *string
	interfaceRightDescription *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) Authorization(authorization string) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code to which the Interface Right belongs to.
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) HotelId(hotelId string) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) Id(id string) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) IdExtension(idExtension int32) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) IdContext(idContext string) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) Type_(type_ string) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.type_ = &type_
	return r
}

// Internal code for each allowed right of a Hotel Interface record.
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) Right(right int32) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.right = &right
	return r
}

// User defined code for an Interface Right.
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) Code(code string) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.code = &code
	return r
}

// User defined description for an Interface Right.
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) Description(description string) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.description = &description
	return r
}

// System Description of an allowed Interface Right.
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) InterfaceRightDescription(interfaceRightDescription string) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.interfaceRightDescription = &interfaceRightDescription
	return r
}

// External system code.
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiDeleteInterfaceRightRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteInterfaceRightExecute(r)
}

/*
DeleteInterfaceRight Operation to remove interface right.

 <p><strong>OperationId:</strong>deleteInterfaceRight</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiDeleteInterfaceRightRequest
*/
func (a *ExternalSystemsConfigApiService) DeleteInterfaceRight(ctx context.Context) ExternalSystemsConfigApiDeleteInterfaceRightRequest {
	return ExternalSystemsConfigApiDeleteInterfaceRightRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) DeleteInterfaceRightExecute(r ExternalSystemsConfigApiDeleteInterfaceRightRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.DeleteInterfaceRight")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceRights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.right != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "right", r.right, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.interfaceRightDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceRightDescription", r.interfaceRightDescription, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiDeletePublisherRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	hotelId string
	externalSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	subscriberHotelId *string
	code *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiDeletePublisherRequest) Authorization(authorization string) ExternalSystemsConfigApiDeletePublisherRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiDeletePublisherRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiDeletePublisherRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiDeletePublisherRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiDeletePublisherRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ExternalSystemsConfigApiDeletePublisherRequest) SubscriberHotelId(subscriberHotelId string) ExternalSystemsConfigApiDeletePublisherRequest {
	r.subscriberHotelId = &subscriberHotelId
	return r
}

func (r ExternalSystemsConfigApiDeletePublisherRequest) Code(code string) ExternalSystemsConfigApiDeletePublisherRequest {
	r.code = &code
	return r
}

// External system code.
func (r ExternalSystemsConfigApiDeletePublisherRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiDeletePublisherRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiDeletePublisherRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiDeletePublisherRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiDeletePublisherRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePublisherExecute(r)
}

/*
DeletePublisher Operation to remove publisher.

 <p><strong>OperationId:</strong>deletePublisher</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Id used to find a property in OPERA.
 @param externalSystemCode Unique OPERA Code used to find External System in OPERA.
 @return ExternalSystemsConfigApiDeletePublisherRequest
*/
func (a *ExternalSystemsConfigApiService) DeletePublisher(ctx context.Context, hotelId string, externalSystemCode string) ExternalSystemsConfigApiDeletePublisherRequest {
	return ExternalSystemsConfigApiDeletePublisherRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		externalSystemCode: externalSystemCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) DeletePublisherExecute(r ExternalSystemsConfigApiDeletePublisherRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.DeletePublisher")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{externalSystemCode}/hotels/{hotelId}/publishers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}

	if r.subscriberHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subscriberHotelId", r.subscriberHotelId, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiGetDeliveryMethodsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	croCode *string
	usages *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiGetDeliveryMethodsRequest) Authorization(authorization string) ExternalSystemsConfigApiGetDeliveryMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiGetDeliveryMethodsRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiGetDeliveryMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiGetDeliveryMethodsRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiGetDeliveryMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property code.
func (r ExternalSystemsConfigApiGetDeliveryMethodsRequest) HotelId(hotelId string) ExternalSystemsConfigApiGetDeliveryMethodsRequest {
	r.hotelId = &hotelId
	return r
}

// CRO code.
func (r ExternalSystemsConfigApiGetDeliveryMethodsRequest) CroCode(croCode string) ExternalSystemsConfigApiGetDeliveryMethodsRequest {
	r.croCode = &croCode
	return r
}

// Settings for Text Message Delivery of Queue Reservation status
func (r ExternalSystemsConfigApiGetDeliveryMethodsRequest) Usages(usages []string) ExternalSystemsConfigApiGetDeliveryMethodsRequest {
	r.usages = &usages
	return r
}

// If true this will include inactive records(This is only applicable for general SMTP delivery method ).
func (r ExternalSystemsConfigApiGetDeliveryMethodsRequest) IncludeInactive(includeInactive bool) ExternalSystemsConfigApiGetDeliveryMethodsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ExternalSystemsConfigApiGetDeliveryMethodsRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiGetDeliveryMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiGetDeliveryMethodsRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiGetDeliveryMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiGetDeliveryMethodsRequest) Execute() (*FetchedDeliveryMethods, *http.Response, error) {
	return r.ApiService.GetDeliveryMethodsExecute(r)
}

/*
GetDeliveryMethods Operation to fetch delivery methods.

 <p><strong>OperationId:</strong>getDeliveryMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiGetDeliveryMethodsRequest
*/
func (a *ExternalSystemsConfigApiService) GetDeliveryMethods(ctx context.Context) ExternalSystemsConfigApiGetDeliveryMethodsRequest {
	return ExternalSystemsConfigApiGetDeliveryMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedDeliveryMethods
func (a *ExternalSystemsConfigApiService) GetDeliveryMethodsExecute(r ExternalSystemsConfigApiGetDeliveryMethodsRequest) (*FetchedDeliveryMethods, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedDeliveryMethods
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetDeliveryMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deliveryMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.croCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "croCode", r.croCode, "")
	}
	if r.usages != nil {
		t := *r.usages
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "usages", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "usages", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	databaseId string
	interfaceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	interfaceCodes *[]string
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest) Authorization(authorization string) ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag that indicates to include inactive records.
func (r ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest) IncludeInactive(includeInactive bool) ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest {
	r.includeInactive = &includeInactive
	return r
}

func (r ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest) InterfaceCodes(interfaceCodes []string) ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest {
	r.interfaceCodes = &interfaceCodes
	return r
}

func (r ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest) HotelIds(hotelIds []string) ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest) Execute() (*FetchedExternalDatabaseAvailableProperties, *http.Response, error) {
	return r.ApiService.GetExternalDatabaseAvailablePropertiesExecute(r)
}

/*
GetExternalDatabaseAvailableProperties Operation to fetch external database available properties.

 <p><strong>OperationId:</strong>getExternalDatabaseAvailableProperties</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId OPERA Id for Databsase
 @param interfaceId OPERA Id for interface
 @return ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest
*/
func (a *ExternalSystemsConfigApiService) GetExternalDatabaseAvailableProperties(ctx context.Context, databaseId string, interfaceId string) ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest {
	return ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return FetchedExternalDatabaseAvailableProperties
func (a *ExternalSystemsConfigApiService) GetExternalDatabaseAvailablePropertiesExecute(r ExternalSystemsConfigApiGetExternalDatabaseAvailablePropertiesRequest) (*FetchedExternalDatabaseAvailableProperties, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedExternalDatabaseAvailableProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetExternalDatabaseAvailableProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaces/{interfaceId}/databases/{databaseId}/availableResorts"
	localVarPath = strings.Replace(localVarPath, "{"+"databaseId"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.databaseId) < 1 {
		return localVarReturnValue, nil, reportError("databaseId must have at least 1 elements")
	}
	if strlen(r.databaseId) > 2000 {
		return localVarReturnValue, nil, reportError("databaseId must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}

	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.interfaceCodes != nil {
		t := *r.interfaceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceCodes", t, "multi")
		}
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	machine *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest) Authorization(authorization string) ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for Character Strings, length 0 to 40.
func (r ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest) Machine(machine string) ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest {
	r.machine = &machine
	return r
}

// External system code.
func (r ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest) Execute() (*FetchedHotelInterfaceControllerRegistry, *http.Response, error) {
	return r.ApiService.GetHotelInterfaceControllerRegistryExecute(r)
}

/*
GetHotelInterfaceControllerRegistry Operation to fetch hotel interface controller registry.

 <p><strong>OperationId:</strong>getHotelInterfaceControllerRegistry</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest
*/
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceControllerRegistry(ctx context.Context) ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest {
	return ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedHotelInterfaceControllerRegistry
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceControllerRegistryExecute(r ExternalSystemsConfigApiGetHotelInterfaceControllerRegistryRequest) (*FetchedHotelInterfaceControllerRegistry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedHotelInterfaceControllerRegistry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetHotelInterfaceControllerRegistry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceControllerRegistry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.machine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "machine", r.machine, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelIds *[]string
	interfaceTypes *[]string
	logoCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) Authorization(authorization string) ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) Limit(limit int32) ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) Offset(offset int32) ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest {
	r.offset = &offset
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) HotelIds(hotelIds []string) ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest {
	r.hotelIds = &hotelIds
	return r
}

// XML Posting Interface
func (r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) InterfaceTypes(interfaceTypes []string) ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest {
	r.interfaceTypes = &interfaceTypes
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) LogoCodes(logoCodes []string) ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest {
	r.logoCodes = &logoCodes
	return r
}

// If true this will set the criteria to include inactive records.
func (r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) IncludeInactive(includeInactive bool) ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) Execute() (*FetchedHotelInterfaceErrors, *http.Response, error) {
	return r.ApiService.GetHotelInterfaceErrorsExecute(r)
}

/*
GetHotelInterfaceErrors Operation to fetch hotel interface errors.

 <p><strong>OperationId:</strong>getHotelInterfaceErrors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest
*/
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceErrors(ctx context.Context) ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest {
	return ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedHotelInterfaceErrors
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceErrorsExecute(r ExternalSystemsConfigApiGetHotelInterfaceErrorsRequest) (*FetchedHotelInterfaceErrors, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedHotelInterfaceErrors
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetHotelInterfaceErrors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceErrors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.interfaceTypes != nil {
		t := *r.interfaceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", t, "multi")
		}
	}
	if r.logoCodes != nil {
		t := *r.logoCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "logoCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "logoCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelIds *[]string
	interfaceTypes *[]string
	logoCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) Authorization(authorization string) ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) Limit(limit int32) ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) Offset(offset int32) ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest {
	r.offset = &offset
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) HotelIds(hotelIds []string) ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest {
	r.hotelIds = &hotelIds
	return r
}

// XML Posting Interface
func (r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) InterfaceTypes(interfaceTypes []string) ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest {
	r.interfaceTypes = &interfaceTypes
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) LogoCodes(logoCodes []string) ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest {
	r.logoCodes = &logoCodes
	return r
}

// If true this will set the criteria to include inactive records.
func (r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) IncludeInactive(includeInactive bool) ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) Execute() (*FetchedHotelInterfaceFailedMessages, *http.Response, error) {
	return r.ApiService.GetHotelInterfaceFailedMessagesExecute(r)
}

/*
GetHotelInterfaceFailedMessages Operation to fetch hotel interface failed messages.

 <p><strong>OperationId:</strong>getHotelInterfaceFailedMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest
*/
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceFailedMessages(ctx context.Context) ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest {
	return ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedHotelInterfaceFailedMessages
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceFailedMessagesExecute(r ExternalSystemsConfigApiGetHotelInterfaceFailedMessagesRequest) (*FetchedHotelInterfaceFailedMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedHotelInterfaceFailedMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetHotelInterfaceFailedMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceFailedMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.interfaceTypes != nil {
		t := *r.interfaceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", t, "multi")
		}
	}
	if r.logoCodes != nil {
		t := *r.logoCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "logoCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "logoCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelIds *[]string
	interfaceTypes *[]string
	logoCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) Authorization(authorization string) ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) Limit(limit int32) ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) Offset(offset int32) ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest {
	r.offset = &offset
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) HotelIds(hotelIds []string) ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest {
	r.hotelIds = &hotelIds
	return r
}

// XML Posting Interface
func (r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) InterfaceTypes(interfaceTypes []string) ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest {
	r.interfaceTypes = &interfaceTypes
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) LogoCodes(logoCodes []string) ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest {
	r.logoCodes = &logoCodes
	return r
}

// If true this will set the criteria to include inactive records.
func (r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) IncludeInactive(includeInactive bool) ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) Execute() (*FetchedHotelInterfaceSchemas, *http.Response, error) {
	return r.ApiService.GetHotelInterfaceSchemasExecute(r)
}

/*
GetHotelInterfaceSchemas Operation to fetch hotel interface schemas.

 <p><strong>OperationId:</strong>getHotelInterfaceSchemas</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest
*/
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceSchemas(ctx context.Context) ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest {
	return ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedHotelInterfaceSchemas
func (a *ExternalSystemsConfigApiService) GetHotelInterfaceSchemasExecute(r ExternalSystemsConfigApiGetHotelInterfaceSchemasRequest) (*FetchedHotelInterfaceSchemas, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedHotelInterfaceSchemas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetHotelInterfaceSchemas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceSchemas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.interfaceTypes != nil {
		t := *r.interfaceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", t, "multi")
		}
	}
	if r.logoCodes != nil {
		t := *r.logoCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "logoCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "logoCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiGetHotelInterfacesRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	interfaceTypes *[]string
	logosCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiGetHotelInterfacesRequest) Authorization(authorization string) ExternalSystemsConfigApiGetHotelInterfacesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiGetHotelInterfacesRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiGetHotelInterfacesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiGetHotelInterfacesRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiGetHotelInterfacesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfacesRequest) HotelIds(hotelIds []string) ExternalSystemsConfigApiGetHotelInterfacesRequest {
	r.hotelIds = &hotelIds
	return r
}

// XML Posting Interface
func (r ExternalSystemsConfigApiGetHotelInterfacesRequest) InterfaceTypes(interfaceTypes []string) ExternalSystemsConfigApiGetHotelInterfacesRequest {
	r.interfaceTypes = &interfaceTypes
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfacesRequest) LogosCodes(logosCodes []string) ExternalSystemsConfigApiGetHotelInterfacesRequest {
	r.logosCodes = &logosCodes
	return r
}

// If true this will set the criteria to include inactive records.
func (r ExternalSystemsConfigApiGetHotelInterfacesRequest) IncludeInactive(includeInactive bool) ExternalSystemsConfigApiGetHotelInterfacesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ExternalSystemsConfigApiGetHotelInterfacesRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiGetHotelInterfacesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiGetHotelInterfacesRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiGetHotelInterfacesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiGetHotelInterfacesRequest) Execute() (*FetchedHotelInterfaces, *http.Response, error) {
	return r.ApiService.GetHotelInterfacesExecute(r)
}

/*
GetHotelInterfaces Operation to fetch hotel interfaces.

 <p><strong>OperationId:</strong>getHotelInterfaces</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiGetHotelInterfacesRequest
*/
func (a *ExternalSystemsConfigApiService) GetHotelInterfaces(ctx context.Context) ExternalSystemsConfigApiGetHotelInterfacesRequest {
	return ExternalSystemsConfigApiGetHotelInterfacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedHotelInterfaces
func (a *ExternalSystemsConfigApiService) GetHotelInterfacesExecute(r ExternalSystemsConfigApiGetHotelInterfacesRequest) (*FetchedHotelInterfaces, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedHotelInterfaces
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetHotelInterfaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelInterfaceTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.interfaceTypes != nil {
		t := *r.interfaceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceTypes", t, "multi")
		}
	}
	if r.logosCodes != nil {
		t := *r.logosCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "logosCodes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "logosCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiGetInterfaceRightsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiGetInterfaceRightsRequest) Authorization(authorization string) ExternalSystemsConfigApiGetInterfaceRightsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiGetInterfaceRightsRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiGetInterfaceRightsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiGetInterfaceRightsRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiGetInterfaceRightsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ExternalSystemsConfigApiGetInterfaceRightsRequest) HotelId(hotelId string) ExternalSystemsConfigApiGetInterfaceRightsRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ExternalSystemsConfigApiGetInterfaceRightsRequest) Id(id string) ExternalSystemsConfigApiGetInterfaceRightsRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ExternalSystemsConfigApiGetInterfaceRightsRequest) IdExtension(idExtension int32) ExternalSystemsConfigApiGetInterfaceRightsRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ExternalSystemsConfigApiGetInterfaceRightsRequest) IdContext(idContext string) ExternalSystemsConfigApiGetInterfaceRightsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ExternalSystemsConfigApiGetInterfaceRightsRequest) Type_(type_ string) ExternalSystemsConfigApiGetInterfaceRightsRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r ExternalSystemsConfigApiGetInterfaceRightsRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiGetInterfaceRightsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiGetInterfaceRightsRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiGetInterfaceRightsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiGetInterfaceRightsRequest) Execute() ([]InterfaceRightType, *http.Response, error) {
	return r.ApiService.GetInterfaceRightsExecute(r)
}

/*
GetInterfaceRights Operation to fetch interface rights.

 <p><strong>OperationId:</strong>getInterfaceRights</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiGetInterfaceRightsRequest
*/
func (a *ExternalSystemsConfigApiService) GetInterfaceRights(ctx context.Context) ExternalSystemsConfigApiGetInterfaceRightsRequest {
	return ExternalSystemsConfigApiGetInterfaceRightsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InterfaceRightType
func (a *ExternalSystemsConfigApiService) GetInterfaceRightsExecute(r ExternalSystemsConfigApiGetInterfaceRightsRequest) ([]InterfaceRightType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InterfaceRightType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetInterfaceRights")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceRights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiGetPublishersRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	externalSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiGetPublishersRequest) Authorization(authorization string) ExternalSystemsConfigApiGetPublishersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiGetPublishersRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiGetPublishersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiGetPublishersRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiGetPublishersRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ExternalSystemsConfigApiGetPublishersRequest) HotelId(hotelId string) ExternalSystemsConfigApiGetPublishersRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r ExternalSystemsConfigApiGetPublishersRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiGetPublishersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiGetPublishersRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiGetPublishersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiGetPublishersRequest) Execute() (*FetchedPublishers, *http.Response, error) {
	return r.ApiService.GetPublishersExecute(r)
}

/*
GetPublishers Operation to fetch publishers.

 <p><strong>OperationId:</strong>getPublishers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalSystemCode Unique OPERA Code used to find External System in OPERA.
 @return ExternalSystemsConfigApiGetPublishersRequest
*/
func (a *ExternalSystemsConfigApiService) GetPublishers(ctx context.Context, externalSystemCode string) ExternalSystemsConfigApiGetPublishersRequest {
	return ExternalSystemsConfigApiGetPublishersRequest{
		ApiService: a,
		ctx: ctx,
		externalSystemCode: externalSystemCode,
	}
}

// Execute executes the request
//  @return FetchedPublishers
func (a *ExternalSystemsConfigApiService) GetPublishersExecute(r ExternalSystemsConfigApiGetPublishersRequest) (*FetchedPublishers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedPublishers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetPublishers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{externalSystemCode}/publishers"
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiGetUDFMappingsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	type_ *string
	uDFName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiGetUDFMappingsRequest) Authorization(authorization string) ExternalSystemsConfigApiGetUDFMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiGetUDFMappingsRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiGetUDFMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiGetUDFMappingsRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiGetUDFMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A reference to the type of object defined by the Type for Reservation and Profile Type.
func (r ExternalSystemsConfigApiGetUDFMappingsRequest) Type_(type_ string) ExternalSystemsConfigApiGetUDFMappingsRequest {
	r.type_ = &type_
	return r
}

// Name of the user-defined function (UDF) field.
func (r ExternalSystemsConfigApiGetUDFMappingsRequest) UDFName(uDFName string) ExternalSystemsConfigApiGetUDFMappingsRequest {
	r.uDFName = &uDFName
	return r
}

// External system code.
func (r ExternalSystemsConfigApiGetUDFMappingsRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiGetUDFMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiGetUDFMappingsRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiGetUDFMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiGetUDFMappingsRequest) Execute() (*FetchedUDFMappings, *http.Response, error) {
	return r.ApiService.GetUDFMappingsExecute(r)
}

/*
GetUDFMappings Operation to send a response to the Look up of UDFs.

Operation to send a response to the Look-up of UDFs. <p><strong>OperationId:</strong>getUDFMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiGetUDFMappingsRequest
*/
func (a *ExternalSystemsConfigApiService) GetUDFMappings(ctx context.Context) ExternalSystemsConfigApiGetUDFMappingsRequest {
	return ExternalSystemsConfigApiGetUDFMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedUDFMappings
func (a *ExternalSystemsConfigApiService) GetUDFMappingsExecute(r ExternalSystemsConfigApiGetUDFMappingsRequest) (*FetchedUDFMappings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedUDFMappings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.GetUDFMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/udfMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.uDFName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uDFName", r.uDFName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiPingRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiPingRequest) Authorization(authorization string) ExternalSystemsConfigApiPingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiPingRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiPingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiPingRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiPingRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ExternalSystemsConfigApiPingRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiPingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiPingRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiPingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiPingRequest) Execute() (*OperaVersion, *http.Response, error) {
	return r.ApiService.PingExecute(r)
}

/*
Ping Operation to ping.

 <p><strong>OperationId:</strong>ping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiPingRequest
*/
func (a *ExternalSystemsConfigApiService) Ping(ctx context.Context) ExternalSystemsConfigApiPingRequest {
	return ExternalSystemsConfigApiPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperaVersion
func (a *ExternalSystemsConfigApiService) PingExecute(r ExternalSystemsConfigApiPingRequest) (*OperaVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperaVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.Ping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/config/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiPostDeliveryMethodsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	createDeliveryMethods *PostDeliveryMethodsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiPostDeliveryMethodsRequest) Authorization(authorization string) ExternalSystemsConfigApiPostDeliveryMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiPostDeliveryMethodsRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiPostDeliveryMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiPostDeliveryMethodsRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiPostDeliveryMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create the delivery method for a property/HUB/Chain and its configurations.
func (r ExternalSystemsConfigApiPostDeliveryMethodsRequest) CreateDeliveryMethods(createDeliveryMethods PostDeliveryMethodsRequest) ExternalSystemsConfigApiPostDeliveryMethodsRequest {
	r.createDeliveryMethods = &createDeliveryMethods
	return r
}

// External system code.
func (r ExternalSystemsConfigApiPostDeliveryMethodsRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiPostDeliveryMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiPostDeliveryMethodsRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiPostDeliveryMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiPostDeliveryMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostDeliveryMethodsExecute(r)
}

/*
PostDeliveryMethods Operation to create delivery methods.

 <p><strong>OperationId:</strong>postDeliveryMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiPostDeliveryMethodsRequest
*/
func (a *ExternalSystemsConfigApiService) PostDeliveryMethods(ctx context.Context) ExternalSystemsConfigApiPostDeliveryMethodsRequest {
	return ExternalSystemsConfigApiPostDeliveryMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) PostDeliveryMethodsExecute(r ExternalSystemsConfigApiPostDeliveryMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.PostDeliveryMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deliveryMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createDeliveryMethods
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiPostPublishersRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	hotelId string
	externalSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	createPublishers *PostPublishersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiPostPublishersRequest) Authorization(authorization string) ExternalSystemsConfigApiPostPublishersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiPostPublishersRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiPostPublishersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiPostPublishersRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiPostPublishersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create publishers.
func (r ExternalSystemsConfigApiPostPublishersRequest) CreatePublishers(createPublishers PostPublishersRequest) ExternalSystemsConfigApiPostPublishersRequest {
	r.createPublishers = &createPublishers
	return r
}

// External system code.
func (r ExternalSystemsConfigApiPostPublishersRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiPostPublishersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiPostPublishersRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiPostPublishersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiPostPublishersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPublishersExecute(r)
}

/*
PostPublishers Operation to create publishers.

 <p><strong>OperationId:</strong>postPublishers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Id used to find a property in OPERA.
 @param externalSystemCode Unique OPERA Code used to find External System in OPERA.
 @return ExternalSystemsConfigApiPostPublishersRequest
*/
func (a *ExternalSystemsConfigApiService) PostPublishers(ctx context.Context, hotelId string, externalSystemCode string) ExternalSystemsConfigApiPostPublishersRequest {
	return ExternalSystemsConfigApiPostPublishersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		externalSystemCode: externalSystemCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ExternalSystemsConfigApiService) PostPublishersExecute(r ExternalSystemsConfigApiPostPublishersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.PostPublishers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{externalSystemCode}/hotels/{hotelId}/publishers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createPublishers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiPutDeliveryMethodsRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	changeDeliveryMethods *PutDeliveryMethodsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiPutDeliveryMethodsRequest) Authorization(authorization string) ExternalSystemsConfigApiPutDeliveryMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiPutDeliveryMethodsRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiPutDeliveryMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiPutDeliveryMethodsRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiPutDeliveryMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change the delivery method for a property/HUB/Chain and its configurations.
func (r ExternalSystemsConfigApiPutDeliveryMethodsRequest) ChangeDeliveryMethods(changeDeliveryMethods PutDeliveryMethodsRequest) ExternalSystemsConfigApiPutDeliveryMethodsRequest {
	r.changeDeliveryMethods = &changeDeliveryMethods
	return r
}

// External system code.
func (r ExternalSystemsConfigApiPutDeliveryMethodsRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiPutDeliveryMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiPutDeliveryMethodsRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiPutDeliveryMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiPutDeliveryMethodsRequest) Execute() (*ChangedDeliveryMethods, *http.Response, error) {
	return r.ApiService.PutDeliveryMethodsExecute(r)
}

/*
PutDeliveryMethods Operation to change delivery methods.

 <p><strong>OperationId:</strong>putDeliveryMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiPutDeliveryMethodsRequest
*/
func (a *ExternalSystemsConfigApiService) PutDeliveryMethods(ctx context.Context) ExternalSystemsConfigApiPutDeliveryMethodsRequest {
	return ExternalSystemsConfigApiPutDeliveryMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedDeliveryMethods
func (a *ExternalSystemsConfigApiService) PutDeliveryMethodsExecute(r ExternalSystemsConfigApiPutDeliveryMethodsRequest) (*ChangedDeliveryMethods, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedDeliveryMethods
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.PutDeliveryMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deliveryMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeDeliveryMethods
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiPutInterfaceRightRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	changeInterfaceRight *PutInterfaceRightRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiPutInterfaceRightRequest) Authorization(authorization string) ExternalSystemsConfigApiPutInterfaceRightRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiPutInterfaceRightRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiPutInterfaceRightRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiPutInterfaceRightRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiPutInterfaceRightRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for updating a Hotel Interface Right. It will create the Hotel Interface Right if it does not exist on the database.
func (r ExternalSystemsConfigApiPutInterfaceRightRequest) ChangeInterfaceRight(changeInterfaceRight PutInterfaceRightRequest) ExternalSystemsConfigApiPutInterfaceRightRequest {
	r.changeInterfaceRight = &changeInterfaceRight
	return r
}

// External system code.
func (r ExternalSystemsConfigApiPutInterfaceRightRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiPutInterfaceRightRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiPutInterfaceRightRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiPutInterfaceRightRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiPutInterfaceRightRequest) Execute() (*ChangedInterfaceRight, *http.Response, error) {
	return r.ApiService.PutInterfaceRightExecute(r)
}

/*
PutInterfaceRight Operation to change interface right.

 <p><strong>OperationId:</strong>putInterfaceRight</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiPutInterfaceRightRequest
*/
func (a *ExternalSystemsConfigApiService) PutInterfaceRight(ctx context.Context) ExternalSystemsConfigApiPutInterfaceRightRequest {
	return ExternalSystemsConfigApiPutInterfaceRightRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedInterfaceRight
func (a *ExternalSystemsConfigApiService) PutInterfaceRightExecute(r ExternalSystemsConfigApiPutInterfaceRightRequest) (*ChangedInterfaceRight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedInterfaceRight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.PutInterfaceRight")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaceRights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeInterfaceRight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalSystemsConfigApiPutUDFMappingRequest struct {
	ctx context.Context
	ApiService *ExternalSystemsConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	changeUDFMapping *PutUDFMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ExternalSystemsConfigApiPutUDFMappingRequest) Authorization(authorization string) ExternalSystemsConfigApiPutUDFMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ExternalSystemsConfigApiPutUDFMappingRequest) XAppKey(xAppKey string) ExternalSystemsConfigApiPutUDFMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ExternalSystemsConfigApiPutUDFMappingRequest) XHotelid(xHotelid string) ExternalSystemsConfigApiPutUDFMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Self-contained Request object that is used when Updating UDFMapping.
func (r ExternalSystemsConfigApiPutUDFMappingRequest) ChangeUDFMapping(changeUDFMapping PutUDFMappingRequest) ExternalSystemsConfigApiPutUDFMappingRequest {
	r.changeUDFMapping = &changeUDFMapping
	return r
}

// External system code.
func (r ExternalSystemsConfigApiPutUDFMappingRequest) XExternalsystem(xExternalsystem string) ExternalSystemsConfigApiPutUDFMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ExternalSystemsConfigApiPutUDFMappingRequest) AcceptLanguage(acceptLanguage string) ExternalSystemsConfigApiPutUDFMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ExternalSystemsConfigApiPutUDFMappingRequest) Execute() (*ChangedUDFMapping, *http.Response, error) {
	return r.ApiService.PutUDFMappingExecute(r)
}

/*
PutUDFMapping Operation to send a response to the Change in UDF.

Operation to send a response to the Change in UDF. <p><strong>OperationId:</strong>putUDFMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalSystemsConfigApiPutUDFMappingRequest
*/
func (a *ExternalSystemsConfigApiService) PutUDFMapping(ctx context.Context) ExternalSystemsConfigApiPutUDFMappingRequest {
	return ExternalSystemsConfigApiPutUDFMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChangedUDFMapping
func (a *ExternalSystemsConfigApiService) PutUDFMappingExecute(r ExternalSystemsConfigApiPutUDFMappingRequest) (*ChangedUDFMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedUDFMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalSystemsConfigApiService.PutUDFMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/udfMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeUDFMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
