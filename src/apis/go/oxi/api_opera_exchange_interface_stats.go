/*
OPERA Cloud Xchange Interface OXI API

APIs to create and manage OPERA Xchange Interface (OXI) configurations for OPERA Cloud Exchange module functionality.<br /><br /> Compatible with OPERA Cloud release 23.0.0.0.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2022 Oracle and/or its affiliates.</p>

API version: 23.0.0.0
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// OperaExchangeInterfaceStatsApiService OperaExchangeInterfaceStatsApi service
type OperaExchangeInterfaceStatsApiService service

type ApiDequeueOXIMessagesRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceStatsApiService
	queueName string
	hotelId string
	interfaceId string
	messageStatus *string
	authorization *string
	xAppKey *string
	xHotelid *string
	endDate *time.Time
	startDate *time.Time
	module *string
	actionType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Supported Message Status.
func (r ApiDequeueOXIMessagesRequest) MessageStatus(messageStatus string) ApiDequeueOXIMessagesRequest {
	r.messageStatus = &messageStatus
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiDequeueOXIMessagesRequest) Authorization(authorization string) ApiDequeueOXIMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiDequeueOXIMessagesRequest) XAppKey(xAppKey string) ApiDequeueOXIMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiDequeueOXIMessagesRequest) XHotelid(xHotelid string) ApiDequeueOXIMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// The ending value of the time span.
func (r ApiDequeueOXIMessagesRequest) EndDate(endDate time.Time) ApiDequeueOXIMessagesRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the time span.
func (r ApiDequeueOXIMessagesRequest) StartDate(startDate time.Time) ApiDequeueOXIMessagesRequest {
	r.startDate = &startDate
	return r
}

// Module of the messages.
func (r ApiDequeueOXIMessagesRequest) Module(module string) ApiDequeueOXIMessagesRequest {
	r.module = &module
	return r
}

// Action Type of the messages.
func (r ApiDequeueOXIMessagesRequest) ActionType(actionType string) ApiDequeueOXIMessagesRequest {
	r.actionType = &actionType
	return r
}

// External system code.
func (r ApiDequeueOXIMessagesRequest) XExternalsystem(xExternalsystem string) ApiDequeueOXIMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiDequeueOXIMessagesRequest) AcceptLanguage(acceptLanguage string) ApiDequeueOXIMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiDequeueOXIMessagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DequeueOXIMessagesExecute(r)
}

/*
DequeueOXIMessages Purge the messages from OXI inbound and outbound queues.

API to purge messages from inbound and outbound queues. <p><strong>OperationId:</strong>dequeueOXIMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param queueName Queue name from which messages has to be Dequeued.
 @param hotelId Unique OPERA internal ID used to find hotel in OPERA.
 @param interfaceId Unique OPERA internal ID used to identify an Interface in OPERA..
 @return ApiDequeueOXIMessagesRequest
*/
func (a *OperaExchangeInterfaceStatsApiService) DequeueOXIMessages(ctx context.Context, queueName string, hotelId string, interfaceId string) ApiDequeueOXIMessagesRequest {
	return ApiDequeueOXIMessagesRequest{
		ApiService: a,
		ctx: ctx,
		queueName: queueName,
		hotelId: hotelId,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaExchangeInterfaceStatsApiService) DequeueOXIMessagesExecute(r ApiDequeueOXIMessagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceStatsApiService.DequeueOXIMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interfaces/{interfaceId}/hotels/{hotelId}/queues/{queueName}/dequeueOXIMessages"
	localVarPath = strings.Replace(localVarPath, "{"+"queueName"+"}", url.PathEscape(parameterValueToString(r.queueName, "queueName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.queueName) < 1 {
		return localVarReturnValue, nil, reportError("queueName must have at least 1 elements")
	}
	if strlen(r.queueName) > 2000 {
		return localVarReturnValue, nil, reportError("queueName must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if r.messageStatus == nil {
		return localVarReturnValue, nil, reportError("messageStatus is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "messageStatus", r.messageStatus, "")
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.module != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "module", r.module, "")
	}
	if r.actionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionType", r.actionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMessageStatisticsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceStatsApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	endDate *[]string
	startDate *[]string
	statCode *[]string
	interfaceId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetMessageStatisticsRequest) Authorization(authorization string) ApiGetMessageStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetMessageStatisticsRequest) XAppKey(xAppKey string) ApiGetMessageStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetMessageStatisticsRequest) XHotelid(xHotelid string) ApiGetMessageStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Supported Exchange Interface report codes.
func (r ApiGetMessageStatisticsRequest) Code(code []string) ApiGetMessageStatisticsRequest {
	r.code = &code
	return r
}

// End date of the report.
func (r ApiGetMessageStatisticsRequest) EndDate(endDate []string) ApiGetMessageStatisticsRequest {
	r.endDate = &endDate
	return r
}

// Start date of the report.
func (r ApiGetMessageStatisticsRequest) StartDate(startDate []string) ApiGetMessageStatisticsRequest {
	r.startDate = &startDate
	return r
}

// Supported Exchange Interface statistical codes.
func (r ApiGetMessageStatisticsRequest) StatCode(statCode []string) ApiGetMessageStatisticsRequest {
	r.statCode = &statCode
	return r
}

// ID of the Interface Setup
func (r ApiGetMessageStatisticsRequest) InterfaceId(interfaceId string) ApiGetMessageStatisticsRequest {
	r.interfaceId = &interfaceId
	return r
}

// External system code.
func (r ApiGetMessageStatisticsRequest) XExternalsystem(xExternalsystem string) ApiGetMessageStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetMessageStatisticsRequest) AcceptLanguage(acceptLanguage string) ApiGetMessageStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetMessageStatisticsRequest) Execute() (*MessageStatistics, *http.Response, error) {
	return r.ApiService.GetMessageStatisticsExecute(r)
}

/*
GetMessageStatistics Retrieves the statistics of Messages for Opera Exchange Interface.

API to Fetch OXI Dashboard Tile Statistics (Upload and Download message counts by Success, Fail and Warning Status codes) by Hotel Id and Interface Id. <p><strong>OperationId:</strong>getMessageStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA internal ID used to find hotel in OPERA.
 @return ApiGetMessageStatisticsRequest
*/
func (a *OperaExchangeInterfaceStatsApiService) GetMessageStatistics(ctx context.Context, hotelId string) ApiGetMessageStatisticsRequest {
	return ApiGetMessageStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return MessageStatistics
func (a *OperaExchangeInterfaceStatsApiService) GetMessageStatisticsExecute(r ApiGetMessageStatisticsRequest) (*MessageStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceStatsApiService.GetMessageStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/messageStatistics"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.endDate != nil {
		t := *r.endDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", t, "multi")
		}
	}
	if r.startDate != nil {
		t := *r.startDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", t, "multi")
		}
	}
	if r.statCode != nil {
		t := *r.statCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statCode", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statCode", t, "multi")
		}
	}
	if r.interfaceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceId", r.interfaceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOXIMessageStatisticsRequest struct {
	ctx context.Context
	ApiService *OperaExchangeInterfaceStatsApiService
	queueName string
	hotelId string
	messageStatus *string
	authorization *string
	xAppKey *string
	xHotelid *string
	interfaceId *string
	enqueueEndDate *time.Time
	enqueueStartDate *time.Time
	groupByModuleAndActionType *bool
	limit *int32
	offset *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Supported Message Status.
func (r ApiGetOXIMessageStatisticsRequest) MessageStatus(messageStatus string) ApiGetOXIMessageStatisticsRequest {
	r.messageStatus = &messageStatus
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ApiGetOXIMessageStatisticsRequest) Authorization(authorization string) ApiGetOXIMessageStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ApiGetOXIMessageStatisticsRequest) XAppKey(xAppKey string) ApiGetOXIMessageStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ApiGetOXIMessageStatisticsRequest) XHotelid(xHotelid string) ApiGetOXIMessageStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// InterfaceID for which Message statistics has to be fetched.
func (r ApiGetOXIMessageStatisticsRequest) InterfaceId(interfaceId string) ApiGetOXIMessageStatisticsRequest {
	r.interfaceId = &interfaceId
	return r
}

// The ending value of the time span.
func (r ApiGetOXIMessageStatisticsRequest) EnqueueEndDate(enqueueEndDate time.Time) ApiGetOXIMessageStatisticsRequest {
	r.enqueueEndDate = &enqueueEndDate
	return r
}

// The starting value of the time span.
func (r ApiGetOXIMessageStatisticsRequest) EnqueueStartDate(enqueueStartDate time.Time) ApiGetOXIMessageStatisticsRequest {
	r.enqueueStartDate = &enqueueStartDate
	return r
}

// Attribute that decides whether the results must be grouped additionally by Module and Action type of the messages.
func (r ApiGetOXIMessageStatisticsRequest) GroupByModuleAndActionType(groupByModuleAndActionType bool) ApiGetOXIMessageStatisticsRequest {
	r.groupByModuleAndActionType = &groupByModuleAndActionType
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ApiGetOXIMessageStatisticsRequest) Limit(limit int32) ApiGetOXIMessageStatisticsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ApiGetOXIMessageStatisticsRequest) Offset(offset int32) ApiGetOXIMessageStatisticsRequest {
	r.offset = &offset
	return r
}

// External system code.
func (r ApiGetOXIMessageStatisticsRequest) XExternalsystem(xExternalsystem string) ApiGetOXIMessageStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ApiGetOXIMessageStatisticsRequest) AcceptLanguage(acceptLanguage string) ApiGetOXIMessageStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetOXIMessageStatisticsRequest) Execute() (*OXIMessageStatistics, *http.Response, error) {
	return r.ApiService.GetOXIMessageStatisticsExecute(r)
}

/*
GetOXIMessageStatistics Retrieves the statistics of Messages in inbound,outbound and BE queues.

API to retrieve message statistics for inbound , outbound and business event queues. <p><strong>OperationId:</strong>getOXIMessageStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param queueName Queue name from which Message statistics has to be fetched.
 @param hotelId Unique OPERA internal ID used to find hotel in OPERA.
 @return ApiGetOXIMessageStatisticsRequest
*/
func (a *OperaExchangeInterfaceStatsApiService) GetOXIMessageStatistics(ctx context.Context, queueName string, hotelId string) ApiGetOXIMessageStatisticsRequest {
	return ApiGetOXIMessageStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		queueName: queueName,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return OXIMessageStatistics
func (a *OperaExchangeInterfaceStatsApiService) GetOXIMessageStatisticsExecute(r ApiGetOXIMessageStatisticsRequest) (*OXIMessageStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OXIMessageStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaExchangeInterfaceStatsApiService.GetOXIMessageStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/queues/{queueName}/messageStatistics"
	localVarPath = strings.Replace(localVarPath, "{"+"queueName"+"}", url.PathEscape(parameterValueToString(r.queueName, "queueName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.queueName) < 1 {
		return localVarReturnValue, nil, reportError("queueName must have at least 1 elements")
	}
	if strlen(r.queueName) > 2000 {
		return localVarReturnValue, nil, reportError("queueName must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if r.messageStatus == nil {
		return localVarReturnValue, nil, reportError("messageStatus is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.xAppKey == nil {
		return localVarReturnValue, nil, reportError("xAppKey is required and must be specified")
	}
	if r.xHotelid == nil {
		return localVarReturnValue, nil, reportError("xHotelid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "messageStatus", r.messageStatus, "")
	if r.interfaceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "InterfaceId", r.interfaceId, "")
	}
	if r.enqueueEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enqueueEndDate", r.enqueueEndDate, "")
	}
	if r.enqueueStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enqueueStartDate", r.enqueueStartDate, "")
	}
	if r.groupByModuleAndActionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupByModuleAndActionType", r.groupByModuleAndActionType, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
