/* tslint:disable */
/* eslint-disable */
/**
 * OPERA Cloud Export Configuration API
 * APIs catering to the managing export master data configuration. The exports feature in OPERA Cloud provides the ability to create and export data files, such as back office data, to third-party interfaces and receiving systems.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>
 *
 * The version of the OpenAPI document: 23.2
 * Contact: hospitality_apis_ww_grp@oracle.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * Details of processing data for export being setup.
 * @export
 * @interface ExportDataSetupType
 */
export interface ExportDataSetupType {
    /**
     * A flag to add new line character after every row of data generated.
     * @type {boolean}
     * @memberof ExportDataSetupType
     */
    addNewLine?: boolean;
    /**
     * A flag to indicate if the data should be appended to an existing file.
     * @type {boolean}
     * @memberof ExportDataSetupType
     */
    appendToFile?: boolean;
    /**
     * Column separator of the export file.
     * @type {string}
     * @memberof ExportDataSetupType
     */
    columnSeparator?: string;
    /**
     * A flag to indicate if this export contains export components.
     * @type {boolean}
     * @memberof ExportDataSetupType
     */
    componentExport?: boolean;
    /**
     * A flag to indicate if the export is compressed.
     * @type {boolean}
     * @memberof ExportDataSetupType
     */
    compressData?: boolean;
    /**
     * A flag to indicate if Export header and footer should always be created even if no data is generated.
     * @type {boolean}
     * @memberof ExportDataSetupType
     */
    createHeaderFooter?: boolean;
    /**
     * The source view code.
     * @type {string}
     * @memberof ExportDataSetupType
     */
    dataSourceName?: string;
    /**
     * Where clause for the file to select data form the Source View.
     * @type {string}
     * @memberof ExportDataSetupType
     */
    filterCondition?: string;
    /**
     * The code to execute after running the export, usually to clean up data.
     * @type {string}
     * @memberof ExportDataSetupType
     */
    postExportProcedure?: string;
    /**
     * The code to execute prior to running the export in order to prepare the data.
     * @type {string}
     * @memberof ExportDataSetupType
     */
    preExportProcedure?: string;
    /**
     * For XML exports this defines the optional document type name
     * @type {string}
     * @memberof ExportDataSetupType
     */
    xMLDocumentTypeName?: string;
    /**
     * For XML exports this defines the optional public id in doc type tag
     * @type {string}
     * @memberof ExportDataSetupType
     */
    xMLDocumentTypePublicId?: string;
    /**
     * For XML exports this defines the optional system id in doc type tag
     * @type {string}
     * @memberof ExportDataSetupType
     */
    xMLDocumentTypeSystemId?: string;
    /**
     * For XML exports this allows to add the encoding attribute to the xml file header.
     * @type {string}
     * @memberof ExportDataSetupType
     */
    xMLEncoding?: string;
    /**
     * For XML exports this allows to add the additional processing instructions to the XML file header if needed.
     * @type {string}
     * @memberof ExportDataSetupType
     */
    xMLProcessingInstructions?: string;
    /**
     * Main tag for the xml document
     * @type {string}
     * @memberof ExportDataSetupType
     */
    xMLRootTag?: string;
}

/**
 * Check if a given object implements the ExportDataSetupType interface.
 */
export function instanceOfExportDataSetupType(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function ExportDataSetupTypeFromJSON(json: any): ExportDataSetupType {
    return ExportDataSetupTypeFromJSONTyped(json, false);
}

export function ExportDataSetupTypeFromJSONTyped(json: any, ignoreDiscriminator: boolean): ExportDataSetupType {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'addNewLine': !exists(json, 'addNewLine') ? undefined : json['addNewLine'],
        'appendToFile': !exists(json, 'appendToFile') ? undefined : json['appendToFile'],
        'columnSeparator': !exists(json, 'columnSeparator') ? undefined : json['columnSeparator'],
        'componentExport': !exists(json, 'componentExport') ? undefined : json['componentExport'],
        'compressData': !exists(json, 'compressData') ? undefined : json['compressData'],
        'createHeaderFooter': !exists(json, 'createHeaderFooter') ? undefined : json['createHeaderFooter'],
        'dataSourceName': !exists(json, 'dataSourceName') ? undefined : json['dataSourceName'],
        'filterCondition': !exists(json, 'filterCondition') ? undefined : json['filterCondition'],
        'postExportProcedure': !exists(json, 'postExportProcedure') ? undefined : json['postExportProcedure'],
        'preExportProcedure': !exists(json, 'preExportProcedure') ? undefined : json['preExportProcedure'],
        'xMLDocumentTypeName': !exists(json, 'xMLDocumentTypeName') ? undefined : json['xMLDocumentTypeName'],
        'xMLDocumentTypePublicId': !exists(json, 'xMLDocumentTypePublicId') ? undefined : json['xMLDocumentTypePublicId'],
        'xMLDocumentTypeSystemId': !exists(json, 'xMLDocumentTypeSystemId') ? undefined : json['xMLDocumentTypeSystemId'],
        'xMLEncoding': !exists(json, 'xMLEncoding') ? undefined : json['xMLEncoding'],
        'xMLProcessingInstructions': !exists(json, 'xMLProcessingInstructions') ? undefined : json['xMLProcessingInstructions'],
        'xMLRootTag': !exists(json, 'xMLRootTag') ? undefined : json['xMLRootTag'],
    };
}

export function ExportDataSetupTypeToJSON(value?: ExportDataSetupType | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'addNewLine': value.addNewLine,
        'appendToFile': value.appendToFile,
        'columnSeparator': value.columnSeparator,
        'componentExport': value.componentExport,
        'compressData': value.compressData,
        'createHeaderFooter': value.createHeaderFooter,
        'dataSourceName': value.dataSourceName,
        'filterCondition': value.filterCondition,
        'postExportProcedure': value.postExportProcedure,
        'preExportProcedure': value.preExportProcedure,
        'xMLDocumentTypeName': value.xMLDocumentTypeName,
        'xMLDocumentTypePublicId': value.xMLDocumentTypePublicId,
        'xMLDocumentTypeSystemId': value.xMLDocumentTypeSystemId,
        'xMLEncoding': value.xMLEncoding,
        'xMLProcessingInstructions': value.xMLProcessingInstructions,
        'xMLRootTag': value.xMLRootTag,
    };
}

