/* tslint:disable */
/* eslint-disable */
/**
 * OPERA Cloud Export Configuration API
 * APIs catering to the managing export master data configuration. The exports feature in OPERA Cloud provides the ability to create and export data files, such as back office data, to third-party interfaces and receiving systems.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>
 *
 * The version of the OpenAPI document: 23.2
 * Contact: hospitality_apis_ww_grp@oracle.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ChangeExportSchedulesByChainRequest,
  ExceptionDetailType,
  ExportActivityLog,
  ExportColumnsAndFunctionsDetails,
  ExportMappingCodesDetails,
  ExportMappingCodesToLink,
  ExportMappingLinkedCodes,
  ExportMappingLinkedTypesDetails,
  ExportMappingsDetails,
  ExportSchedulesDetails,
  ExportSchedulesStatus,
  ExportsAvailable,
  FetchExportMappingCodes,
  FetchExportMappings,
  GeneratedExports,
  PostExportSchedulesRequest,
  PutExportMappingCodesRequest,
  PutExportMappingLinkedTypesRequest,
  PutExportMappingsRequest,
  Status,
} from '../models';
import {
    ChangeExportSchedulesByChainRequestFromJSON,
    ChangeExportSchedulesByChainRequestToJSON,
    ExceptionDetailTypeFromJSON,
    ExceptionDetailTypeToJSON,
    ExportActivityLogFromJSON,
    ExportActivityLogToJSON,
    ExportColumnsAndFunctionsDetailsFromJSON,
    ExportColumnsAndFunctionsDetailsToJSON,
    ExportMappingCodesDetailsFromJSON,
    ExportMappingCodesDetailsToJSON,
    ExportMappingCodesToLinkFromJSON,
    ExportMappingCodesToLinkToJSON,
    ExportMappingLinkedCodesFromJSON,
    ExportMappingLinkedCodesToJSON,
    ExportMappingLinkedTypesDetailsFromJSON,
    ExportMappingLinkedTypesDetailsToJSON,
    ExportMappingsDetailsFromJSON,
    ExportMappingsDetailsToJSON,
    ExportSchedulesDetailsFromJSON,
    ExportSchedulesDetailsToJSON,
    ExportSchedulesStatusFromJSON,
    ExportSchedulesStatusToJSON,
    ExportsAvailableFromJSON,
    ExportsAvailableToJSON,
    FetchExportMappingCodesFromJSON,
    FetchExportMappingCodesToJSON,
    FetchExportMappingsFromJSON,
    FetchExportMappingsToJSON,
    GeneratedExportsFromJSON,
    GeneratedExportsToJSON,
    PostExportSchedulesRequestFromJSON,
    PostExportSchedulesRequestToJSON,
    PutExportMappingCodesRequestFromJSON,
    PutExportMappingCodesRequestToJSON,
    PutExportMappingLinkedTypesRequestFromJSON,
    PutExportMappingLinkedTypesRequestToJSON,
    PutExportMappingsRequestFromJSON,
    PutExportMappingsRequestToJSON,
    StatusFromJSON,
    StatusToJSON,
} from '../models';

export interface ChangeExportSchedulesRequest {
    hotelId?: string;
    exportFileId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportSchedulesToBeChanged?: ChangeExportSchedulesByChainRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface ChangeExportSchedulesByChainOperationRequest {
    exportFileId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportSchedulesToBeChanged?: ChangeExportSchedulesByChainRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteExistingExportMappingsRequest {
    exportMappingId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface DeleteExportMappingCodesRequest {
    mappingTypeCode?: string;
    exportMappingId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportActivityLogRequest {
    hotelId?: string;
    activityType?: string;
    fromDate?: Date;
    toDate?: Date;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    limit?: number;
    offset?: number;
    module?: GetExportActivityLogModuleEnum;
    parameterName?: Array<string>;
    parameterValue?: Array<string>;
    activityGroup?: string;
    searchText?: string;
    userByIds?: Array<number>;
    userForIds?: Array<number>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportColumnsAndFunctionsRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    fetchDbColumns?: boolean;
    fetchOperaApis?: boolean;
    fetchPrePostProcedures?: boolean;
    dataSource?: string;
    exportFileId?: string;
    category?: GetExportColumnsAndFunctionsCategoryEnum;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportMappingCodesRequest {
    exportMappingTypeId?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportMappingCodesToLinkRequest {
    configType?: string;
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    code?: string;
    description?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportMappingLinkedCodesRequest {
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    id?: string;
    idExtension?: number;
    idContext?: string;
    type?: string;
    codeToLink?: string;
    configType?: GetExportMappingLinkedCodesConfigTypeEnum;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportMappingsRequest {
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportMappingConfigs?: Set<GetExportMappingsExportMappingConfigsEnum>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportMappingsByChainRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    hotelId?: string;
    exportMappingConfigs?: Set<GetExportMappingsByChainExportMappingConfigsEnum>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportSchedulesRequest {
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    timeZone?: string;
    exportFileId?: string;
    idExtension?: number;
    idContext?: string;
    type?: string;
    exportGroup?: GetExportSchedulesExportGroupEnum;
    exportName?: string;
    startDate?: Date;
    endDate?: Date;
    frequency?: GetExportSchedulesFrequencyEnum;
    includeInactive?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportsAvailableRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    fetchColumns?: boolean;
    fetchDataSetup?: boolean;
    fetchDestinationSetup?: boolean;
    fetchGenerateConfiguration?: boolean;
    limit?: number;
    exportFileId?: string;
    idExtension?: number;
    idContext?: string;
    type?: string;
    hotelIds?: Array<string>;
    fileGroup?: GetExportsAvailableFileGroupEnum;
    includeInactive?: boolean;
    match?: string;
    includeComponents?: boolean;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface GetExportsGeneratedRequest {
    exportFileId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportDataId?: string;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostExportMappingCodesRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportMappingCodes?: PutExportMappingCodesRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostExportMappingsRequest {
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportMappings?: PutExportMappingsRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PostExportSchedulesOperationRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportSchedulesCriteria?: PostExportSchedulesRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutExportMappingCodesOperationRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportMappingCodes?: PutExportMappingCodesRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutExportMappingLinkedTypesOperationRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportMappingLinkedTypes?: PutExportMappingLinkedTypesRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface PutExportMappingsOperationRequest {
    hotelId?: string;
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    exportMappings?: PutExportMappingsRequest;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

export interface RemoveExportSchedulesRequest {
    authorization?: string;
    xAppKey?: string;
    xHotelid?: string;
    jobNames?: Array<string>;
    xExternalsystem?: string;
    acceptLanguage?: string;
}

/**
 * 
 */
export class ExportApi extends runtime.BaseAPI {

    /**
     * Use this API to update export schedules for a specific property based on the hotelId, exportFileId, exportSchedulesToBeChanged. <p><strong>OperationId:</strong>changeExportSchedules</p>
     * Operation to change export schedules.
     */
    async changeExportSchedulesRaw(requestParameters: ChangeExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportSchedulesStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportSchedules/{exportFileId}`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))).replace(`{${"exportFileId"}}`, encodeURIComponent(String(requestParameters.exportFileId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ChangeExportSchedulesByChainRequestToJSON(requestParameters.exportSchedulesToBeChanged),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportSchedulesStatusFromJSON(jsonValue));
    }

    /**
     * Use this API to update export schedules for a specific property based on the hotelId, exportFileId, exportSchedulesToBeChanged. <p><strong>OperationId:</strong>changeExportSchedules</p>
     * Operation to change export schedules.
     */
    async changeExportSchedules(requestParameters: ChangeExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportSchedulesStatus> {
        const response = await this.changeExportSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to update export schedules for all hotels in a chain based on the exportFileIdId and exportSchedulesToBeChanged. <p><strong>OperationId:</strong>changeExportSchedulesByChain</p>
     * Operation to change export schedules.
     */
    async changeExportSchedulesByChainRaw(requestParameters: ChangeExportSchedulesByChainOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportSchedulesStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportSchedules/{exportFileId}`.replace(`{${"exportFileId"}}`, encodeURIComponent(String(requestParameters.exportFileId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ChangeExportSchedulesByChainRequestToJSON(requestParameters.exportSchedulesToBeChanged),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportSchedulesStatusFromJSON(jsonValue));
    }

    /**
     * Use this API to update export schedules for all hotels in a chain based on the exportFileIdId and exportSchedulesToBeChanged. <p><strong>OperationId:</strong>changeExportSchedulesByChain</p>
     * Operation to change export schedules.
     */
    async changeExportSchedulesByChain(requestParameters: ChangeExportSchedulesByChainOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportSchedulesStatus> {
        const response = await this.changeExportSchedulesByChainRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete export mappings for a specific property based on the exportMappingId and the hotelId. <p><strong>OperationId:</strong>deleteExistingExportMappings</p>
     * Operation to remove export mappings.
     */
    async deleteExistingExportMappingsRaw(requestParameters: DeleteExistingExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappingId/{exportMappingId}/exportMappings`.replace(`{${"exportMappingId"}}`, encodeURIComponent(String(requestParameters.exportMappingId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete export mappings for a specific property based on the exportMappingId and the hotelId. <p><strong>OperationId:</strong>deleteExistingExportMappings</p>
     * Operation to remove export mappings.
     */
    async deleteExistingExportMappings(requestParameters: DeleteExistingExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteExistingExportMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>deleteExportMappingCodes</p>
     * Operation to remove export mapping codes.
     */
    async deleteExportMappingCodesRaw(requestParameters: DeleteExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappings/{exportMappingId}/mappingTypes/{mappingTypeCode}/exportMappingCodes`.replace(`{${"mappingTypeCode"}}`, encodeURIComponent(String(requestParameters.mappingTypeCode))).replace(`{${"exportMappingId"}}`, encodeURIComponent(String(requestParameters.exportMappingId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>deleteExportMappingCodes</p>
     * Operation to remove export mapping codes.
     */
    async deleteExportMappingCodes(requestParameters: DeleteExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.deleteExportMappingCodesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to return activity logs for export data for a specific property based on search criteria such as hotelId, activityType, fromDate, toDate, limit, offset, module, parameterName, parameterValue, activityGroup, searchText, userByIds, userForIds.  <p><strong>OperationId:</strong>getExportActivityLog</p>
     * Operation to fetch activity logs for Export Data.
     */
    async getExportActivityLogRaw(requestParameters: GetExportActivityLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportActivityLog>> {
        const queryParameters: any = {};

        if (requestParameters.activityType !== undefined) {
            queryParameters['activityType'] = requestParameters.activityType;
        }

        if (requestParameters.fromDate !== undefined) {
            queryParameters['fromDate'] = (requestParameters.fromDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.toDate !== undefined) {
            queryParameters['toDate'] = (requestParameters.toDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.module !== undefined) {
            queryParameters['module'] = requestParameters.module;
        }

        if (requestParameters.parameterName) {
            queryParameters['parameterName'] = requestParameters.parameterName;
        }

        if (requestParameters.parameterValue) {
            queryParameters['parameterValue'] = requestParameters.parameterValue;
        }

        if (requestParameters.activityGroup !== undefined) {
            queryParameters['activityGroup'] = requestParameters.activityGroup;
        }

        if (requestParameters.searchText !== undefined) {
            queryParameters['searchText'] = requestParameters.searchText;
        }

        if (requestParameters.userByIds) {
            queryParameters['userByIds'] = requestParameters.userByIds;
        }

        if (requestParameters.userForIds) {
            queryParameters['userForIds'] = requestParameters.userForIds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportActivityLog`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportActivityLogFromJSON(jsonValue));
    }

    /**
     * Use this API to return activity logs for export data for a specific property based on search criteria such as hotelId, activityType, fromDate, toDate, limit, offset, module, parameterName, parameterValue, activityGroup, searchText, userByIds, userForIds.  <p><strong>OperationId:</strong>getExportActivityLog</p>
     * Operation to fetch activity logs for Export Data.
     */
    async getExportActivityLog(requestParameters: GetExportActivityLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportActivityLog> {
        const response = await this.getExportActivityLogRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to return export columns and functions based on search criteria such as fetchDbColumns, fetchOperaApis, fetchPrePostProcedures, dataSource, exportFileId, category. <p><strong>OperationId:</strong>getExportColumnsAndFunctions</p>
     * Operation to fetch export columns and functions.
     */
    async getExportColumnsAndFunctionsRaw(requestParameters: GetExportColumnsAndFunctionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportColumnsAndFunctionsDetails>> {
        const queryParameters: any = {};

        if (requestParameters.fetchDbColumns !== undefined) {
            queryParameters['fetchDbColumns'] = requestParameters.fetchDbColumns;
        }

        if (requestParameters.fetchOperaApis !== undefined) {
            queryParameters['fetchOperaApis'] = requestParameters.fetchOperaApis;
        }

        if (requestParameters.fetchPrePostProcedures !== undefined) {
            queryParameters['fetchPrePostProcedures'] = requestParameters.fetchPrePostProcedures;
        }

        if (requestParameters.dataSource !== undefined) {
            queryParameters['dataSource'] = requestParameters.dataSource;
        }

        if (requestParameters.exportFileId !== undefined) {
            queryParameters['exportFileId'] = requestParameters.exportFileId;
        }

        if (requestParameters.category !== undefined) {
            queryParameters['category'] = requestParameters.category;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/columnsAndFunctions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportColumnsAndFunctionsDetailsFromJSON(jsonValue));
    }

    /**
     * Use this API to return export columns and functions based on search criteria such as fetchDbColumns, fetchOperaApis, fetchPrePostProcedures, dataSource, exportFileId, category. <p><strong>OperationId:</strong>getExportColumnsAndFunctions</p>
     * Operation to fetch export columns and functions.
     */
    async getExportColumnsAndFunctions(requestParameters: GetExportColumnsAndFunctionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportColumnsAndFunctionsDetails> {
        const response = await this.getExportColumnsAndFunctionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingCodes</p>
     * Operation to fetch export mapping codes.
     */
    async getExportMappingCodesRaw(requestParameters: GetExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchExportMappingCodes>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappingTypes/{exportMappingTypeId}/exportMappingCodes`.replace(`{${"exportMappingTypeId"}}`, encodeURIComponent(String(requestParameters.exportMappingTypeId))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchExportMappingCodesFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingCodes</p>
     * Operation to fetch export mapping codes.
     */
    async getExportMappingCodes(requestParameters: GetExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchExportMappingCodes> {
        const response = await this.getExportMappingCodesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingCodesToLink</p>
     * Operation to fetch export mapping codes to link.
     */
    async getExportMappingCodesToLinkRaw(requestParameters: GetExportMappingCodesToLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportMappingCodesToLink>> {
        const queryParameters: any = {};

        if (requestParameters.code !== undefined) {
            queryParameters['code'] = requestParameters.code;
        }

        if (requestParameters.description !== undefined) {
            queryParameters['description'] = requestParameters.description;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/configTypes/{configType}/exportMappingCodesToLink`.replace(`{${"configType"}}`, encodeURIComponent(String(requestParameters.configType))).replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportMappingCodesToLinkFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingCodesToLink</p>
     * Operation to fetch export mapping codes to link.
     */
    async getExportMappingCodesToLink(requestParameters: GetExportMappingCodesToLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportMappingCodesToLink> {
        const response = await this.getExportMappingCodesToLinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingLinkedCodes</p>
     * Operation to fetch export mapping linked codes.
     */
    async getExportMappingLinkedCodesRaw(requestParameters: GetExportMappingLinkedCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportMappingLinkedCodes>> {
        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.idExtension !== undefined) {
            queryParameters['idExtension'] = requestParameters.idExtension;
        }

        if (requestParameters.idContext !== undefined) {
            queryParameters['idContext'] = requestParameters.idContext;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.codeToLink !== undefined) {
            queryParameters['codeToLink'] = requestParameters.codeToLink;
        }

        if (requestParameters.configType !== undefined) {
            queryParameters['configType'] = requestParameters.configType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappings/linkedCodes`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportMappingLinkedCodesFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingLinkedCodes</p>
     * Operation to fetch export mapping linked codes.
     */
    async getExportMappingLinkedCodes(requestParameters: GetExportMappingLinkedCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportMappingLinkedCodes> {
        const response = await this.getExportMappingLinkedCodesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappings</p>
     * Operation to fetch export mappings.
     */
    async getExportMappingsRaw(requestParameters: GetExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchExportMappings>> {
        const queryParameters: any = {};

        if (requestParameters.exportMappingConfigs) {
            queryParameters['exportMappingConfigs'] = requestParameters.exportMappingConfigs;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappings`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchExportMappingsFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappings</p>
     * Operation to fetch export mappings.
     */
    async getExportMappings(requestParameters: GetExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchExportMappings> {
        const response = await this.getExportMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingsByChain</p>
     * Operation to fetch export mappings by chain.
     */
    async getExportMappingsByChainRaw(requestParameters: GetExportMappingsByChainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchExportMappings>> {
        const queryParameters: any = {};

        if (requestParameters.hotelId !== undefined) {
            queryParameters['hotelId'] = requestParameters.hotelId;
        }

        if (requestParameters.exportMappingConfigs) {
            queryParameters['exportMappingConfigs'] = requestParameters.exportMappingConfigs;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportMappings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchExportMappingsFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>getExportMappingsByChain</p>
     * Operation to fetch export mappings by chain.
     */
    async getExportMappingsByChain(requestParameters: GetExportMappingsByChainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchExportMappings> {
        const response = await this.getExportMappingsByChainRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to return export schedules for a specific property based on search criteria such as hotelId, timeZone, exportFileId, idExtension, idContext, type, exportGroup, exportName, startDate, endDate, frequency, includeInactive.  <p><strong>OperationId:</strong>getExportSchedules</p>
     * Operation to fetch export schedules.
     */
    async getExportSchedulesRaw(requestParameters: GetExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportSchedulesDetails>> {
        const queryParameters: any = {};

        if (requestParameters.timeZone !== undefined) {
            queryParameters['timeZone'] = requestParameters.timeZone;
        }

        if (requestParameters.exportFileId !== undefined) {
            queryParameters['exportFileId'] = requestParameters.exportFileId;
        }

        if (requestParameters.idExtension !== undefined) {
            queryParameters['idExtension'] = requestParameters.idExtension;
        }

        if (requestParameters.idContext !== undefined) {
            queryParameters['idContext'] = requestParameters.idContext;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.exportGroup !== undefined) {
            queryParameters['exportGroup'] = requestParameters.exportGroup;
        }

        if (requestParameters.exportName !== undefined) {
            queryParameters['exportName'] = requestParameters.exportName;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = (requestParameters.startDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = (requestParameters.endDate as any).toISOString().substr(0,10);
        }

        if (requestParameters.frequency !== undefined) {
            queryParameters['frequency'] = requestParameters.frequency;
        }

        if (requestParameters.includeInactive !== undefined) {
            queryParameters['includeInactive'] = requestParameters.includeInactive;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportSchedules`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportSchedulesDetailsFromJSON(jsonValue));
    }

    /**
     * Use this API to return export schedules for a specific property based on search criteria such as hotelId, timeZone, exportFileId, idExtension, idContext, type, exportGroup, exportName, startDate, endDate, frequency, includeInactive.  <p><strong>OperationId:</strong>getExportSchedules</p>
     * Operation to fetch export schedules.
     */
    async getExportSchedules(requestParameters: GetExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportSchedulesDetails> {
        const response = await this.getExportSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to return available exports based on search criteria such as fetchColumns, fetchDataSetup, fetchDestinationSetup, fetchGenerateConfiguration, limit, exportFileId, idExtension, idContext, type, hotelIds, fileGroup, includeInactive, includeComponents. <p><strong>OperationId:</strong>getExportsAvailable</p>
     * Return available exports
     */
    async getExportsAvailableRaw(requestParameters: GetExportsAvailableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportsAvailable>> {
        const queryParameters: any = {};

        if (requestParameters.fetchColumns !== undefined) {
            queryParameters['fetchColumns'] = requestParameters.fetchColumns;
        }

        if (requestParameters.fetchDataSetup !== undefined) {
            queryParameters['fetchDataSetup'] = requestParameters.fetchDataSetup;
        }

        if (requestParameters.fetchDestinationSetup !== undefined) {
            queryParameters['fetchDestinationSetup'] = requestParameters.fetchDestinationSetup;
        }

        if (requestParameters.fetchGenerateConfiguration !== undefined) {
            queryParameters['fetchGenerateConfiguration'] = requestParameters.fetchGenerateConfiguration;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.exportFileId !== undefined) {
            queryParameters['exportFileId'] = requestParameters.exportFileId;
        }

        if (requestParameters.idExtension !== undefined) {
            queryParameters['idExtension'] = requestParameters.idExtension;
        }

        if (requestParameters.idContext !== undefined) {
            queryParameters['idContext'] = requestParameters.idContext;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.hotelIds) {
            queryParameters['hotelIds'] = requestParameters.hotelIds;
        }

        if (requestParameters.fileGroup !== undefined) {
            queryParameters['fileGroup'] = requestParameters.fileGroup;
        }

        if (requestParameters.includeInactive !== undefined) {
            queryParameters['includeInactive'] = requestParameters.includeInactive;
        }

        if (requestParameters.match !== undefined) {
            queryParameters['match'] = requestParameters.match;
        }

        if (requestParameters.includeComponents !== undefined) {
            queryParameters['includeComponents'] = requestParameters.includeComponents;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/availableExports`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportsAvailableFromJSON(jsonValue));
    }

    /**
     * Use this API to return available exports based on search criteria such as fetchColumns, fetchDataSetup, fetchDestinationSetup, fetchGenerateConfiguration, limit, exportFileId, idExtension, idContext, type, hotelIds, fileGroup, includeInactive, includeComponents. <p><strong>OperationId:</strong>getExportsAvailable</p>
     * Return available exports
     */
    async getExportsAvailable(requestParameters: GetExportsAvailableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportsAvailable> {
        const response = await this.getExportsAvailableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>getExportsGenerated</p>
     * Operation to fetch exports generated.
     */
    async getExportsGeneratedRaw(requestParameters: GetExportsGeneratedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GeneratedExports>> {
        const queryParameters: any = {};

        if (requestParameters.exportDataId !== undefined) {
            queryParameters['exportDataId'] = requestParameters.exportDataId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/{exportFileId}/generatedExports`.replace(`{${"exportFileId"}}`, encodeURIComponent(String(requestParameters.exportFileId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GeneratedExportsFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>getExportsGenerated</p>
     * Operation to fetch exports generated.
     */
    async getExportsGenerated(requestParameters: GetExportsGeneratedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GeneratedExports> {
        const response = await this.getExportsGeneratedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>postExportMappingCodes</p>
     * Operation to create export mapping codes.
     */
    async postExportMappingCodesRaw(requestParameters: PostExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportMappingCodes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PutExportMappingCodesRequestToJSON(requestParameters.exportMappingCodes),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>postExportMappingCodes</p>
     * Operation to create export mapping codes.
     */
    async postExportMappingCodes(requestParameters: PostExportMappingCodesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postExportMappingCodesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>postExportMappings</p>
     * Operation to create export mappings.
     */
    async postExportMappingsRaw(requestParameters: PostExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappings`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PutExportMappingsRequestToJSON(requestParameters.exportMappings),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>postExportMappings</p>
     * Operation to create export mappings.
     */
    async postExportMappings(requestParameters: PostExportMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postExportMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to create export schedules. <p><strong>OperationId:</strong>postExportSchedules</p>
     * Operation to create export schedules.
     */
    async postExportSchedulesRaw(requestParameters: PostExportSchedulesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportSchedules`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostExportSchedulesRequestToJSON(requestParameters.exportSchedulesCriteria),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to create export schedules. <p><strong>OperationId:</strong>postExportSchedules</p>
     * Operation to create export schedules.
     */
    async postExportSchedules(requestParameters: PostExportSchedulesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.postExportSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>putExportMappingCodes</p>
     * Operation to update export mapping codes.
     */
    async putExportMappingCodesRaw(requestParameters: PutExportMappingCodesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportMappingCodesDetails>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportMappingCodes`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutExportMappingCodesRequestToJSON(requestParameters.exportMappingCodes),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportMappingCodesDetailsFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>putExportMappingCodes</p>
     * Operation to update export mapping codes.
     */
    async putExportMappingCodes(requestParameters: PutExportMappingCodesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportMappingCodesDetails> {
        const response = await this.putExportMappingCodesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>putExportMappingLinkedTypes</p>
     * Operation to update export mapping linked types.
     */
    async putExportMappingLinkedTypesRaw(requestParameters: PutExportMappingLinkedTypesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportMappingLinkedTypesDetails>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportMappingLinkedTypes`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutExportMappingLinkedTypesRequestToJSON(requestParameters.exportMappingLinkedTypes),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportMappingLinkedTypesDetailsFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>putExportMappingLinkedTypes</p>
     * Operation to update export mapping linked types.
     */
    async putExportMappingLinkedTypes(requestParameters: PutExportMappingLinkedTypesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportMappingLinkedTypesDetails> {
        const response = await this.putExportMappingLinkedTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  <p><strong>OperationId:</strong>putExportMappings</p>
     * Operation to update export mappings.
     */
    async putExportMappingsRaw(requestParameters: PutExportMappingsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportMappingsDetails>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/hotels/{hotelId}/exportMappings`.replace(`{${"hotelId"}}`, encodeURIComponent(String(requestParameters.hotelId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PutExportMappingsRequestToJSON(requestParameters.exportMappings),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportMappingsDetailsFromJSON(jsonValue));
    }

    /**
     *  <p><strong>OperationId:</strong>putExportMappings</p>
     * Operation to update export mappings.
     */
    async putExportMappings(requestParameters: PutExportMappingsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportMappingsDetails> {
        const response = await this.putExportMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this API to delete export schedules based on the jobNames. <p><strong>OperationId:</strong>removeExportSchedules</p>
     * Operation to remove export schedules.
     */
    async removeExportSchedulesRaw(requestParameters: RemoveExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Status>> {
        const queryParameters: any = {};

        if (requestParameters.jobNames) {
            queryParameters['jobNames'] = requestParameters.jobNames;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.xAppKey !== undefined && requestParameters.xAppKey !== null) {
            headerParameters['x-app-key'] = String(requestParameters.xAppKey);
        }

        if (requestParameters.xHotelid !== undefined && requestParameters.xHotelid !== null) {
            headerParameters['x-hotelid'] = String(requestParameters.xHotelid);
        }

        if (requestParameters.xExternalsystem !== undefined && requestParameters.xExternalsystem !== null) {
            headerParameters['x-externalsystem'] = String(requestParameters.xExternalsystem);
        }

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/exportSchedules`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusFromJSON(jsonValue));
    }

    /**
     * Use this API to delete export schedules based on the jobNames. <p><strong>OperationId:</strong>removeExportSchedules</p>
     * Operation to remove export schedules.
     */
    async removeExportSchedules(requestParameters: RemoveExportSchedulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Status> {
        const response = await this.removeExportSchedulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetExportActivityLogModuleEnum = {
    Reservation: 'Reservation',
    Contract: 'Contract',
    Allotment: 'Allotment',
    Outlookview: 'Outlookview',
    Profile: 'Profile',
    Accountreceivables: 'Accountreceivables',
    GdsConvRateCodes: 'GdsConvRateCodes',
    RateCode: 'RateCode',
    Billing: 'Billing',
    Activity: 'Activity'
} as const;
export type GetExportActivityLogModuleEnum = typeof GetExportActivityLogModuleEnum[keyof typeof GetExportActivityLogModuleEnum];
/**
 * @export
 */
export const GetExportColumnsAndFunctionsCategoryEnum = {
    Exports: 'Exports',
    CustomNumbers: 'CustomNumbers'
} as const;
export type GetExportColumnsAndFunctionsCategoryEnum = typeof GetExportColumnsAndFunctionsCategoryEnum[keyof typeof GetExportColumnsAndFunctionsCategoryEnum];
/**
 * @export
 */
export const GetExportMappingLinkedCodesConfigTypeEnum = {
    TransactionCodes: 'TransactionCodes',
    MarketCodes: 'MarketCodes',
    PackageCodes: 'PackageCodes',
    PaymentMethods: 'PaymentMethods',
    ProfileIdTypes: 'ProfileIdTypes',
    StatisticCodes: 'StatisticCodes',
    PropertyCodes: 'PropertyCodes',
    CountryCodes: 'CountryCodes',
    NationalityCodes: 'NationalityCodes',
    StateCodes: 'StateCodes',
    DistrictCodes: 'DistrictCodes',
    CityCodes: 'CityCodes',
    CountryCities: 'CountryCities',
    PurposeOfStayCodes: 'PurposeOfStayCodes',
    TransportationCodes: 'TransportationCodes',
    CancelReasons: 'CancelReasons',
    Gender: 'Gender',
    RoomTypes: 'RoomTypes',
    IdCountryCodes: 'IdCountryCodes'
} as const;
export type GetExportMappingLinkedCodesConfigTypeEnum = typeof GetExportMappingLinkedCodesConfigTypeEnum[keyof typeof GetExportMappingLinkedCodesConfigTypeEnum];
/**
 * @export
 */
export const GetExportMappingsExportMappingConfigsEnum = {
    TransactionCodes: 'TransactionCodes',
    MarketCodes: 'MarketCodes',
    PackageCodes: 'PackageCodes',
    PaymentMethods: 'PaymentMethods',
    ProfileIdTypes: 'ProfileIdTypes',
    StatisticCodes: 'StatisticCodes',
    PropertyCodes: 'PropertyCodes',
    CountryCodes: 'CountryCodes',
    NationalityCodes: 'NationalityCodes',
    StateCodes: 'StateCodes',
    DistrictCodes: 'DistrictCodes',
    CityCodes: 'CityCodes',
    CountryCities: 'CountryCities',
    PurposeOfStayCodes: 'PurposeOfStayCodes',
    TransportationCodes: 'TransportationCodes',
    CancelReasons: 'CancelReasons',
    Gender: 'Gender',
    RoomTypes: 'RoomTypes',
    IdCountryCodes: 'IdCountryCodes'
} as const;
export type GetExportMappingsExportMappingConfigsEnum = typeof GetExportMappingsExportMappingConfigsEnum[keyof typeof GetExportMappingsExportMappingConfigsEnum];
/**
 * @export
 */
export const GetExportMappingsByChainExportMappingConfigsEnum = {
    TransactionCodes: 'TransactionCodes',
    MarketCodes: 'MarketCodes',
    PackageCodes: 'PackageCodes',
    PaymentMethods: 'PaymentMethods',
    ProfileIdTypes: 'ProfileIdTypes',
    StatisticCodes: 'StatisticCodes',
    PropertyCodes: 'PropertyCodes',
    CountryCodes: 'CountryCodes',
    NationalityCodes: 'NationalityCodes',
    StateCodes: 'StateCodes',
    DistrictCodes: 'DistrictCodes',
    CityCodes: 'CityCodes',
    CountryCities: 'CountryCities',
    PurposeOfStayCodes: 'PurposeOfStayCodes',
    TransportationCodes: 'TransportationCodes',
    CancelReasons: 'CancelReasons',
    Gender: 'Gender',
    RoomTypes: 'RoomTypes',
    IdCountryCodes: 'IdCountryCodes'
} as const;
export type GetExportMappingsByChainExportMappingConfigsEnum = typeof GetExportMappingsByChainExportMappingConfigsEnum[keyof typeof GetExportMappingsByChainExportMappingConfigsEnum];
/**
 * @export
 */
export const GetExportSchedulesExportGroupEnum = {
    Miscellaneous: 'Miscellaneous',
    Memberships: 'Memberships',
    Country: 'Country',
    BackOffice: 'BackOffice'
} as const;
export type GetExportSchedulesExportGroupEnum = typeof GetExportSchedulesExportGroupEnum[keyof typeof GetExportSchedulesExportGroupEnum];
/**
 * @export
 */
export const GetExportSchedulesFrequencyEnum = {
    Once: 'Once',
    Hourly: 'Hourly',
    Daily: 'Daily',
    Weekly: 'Weekly',
    Monthly: 'Monthly',
    EndOfDay: 'EndOfDay'
} as const;
export type GetExportSchedulesFrequencyEnum = typeof GetExportSchedulesFrequencyEnum[keyof typeof GetExportSchedulesFrequencyEnum];
/**
 * @export
 */
export const GetExportsAvailableFileGroupEnum = {
    Miscellaneous: 'Miscellaneous',
    Memberships: 'Memberships',
    Country: 'Country',
    Delphi: 'Delphi',
    BackOffice: 'BackOffice',
    BackOfficeRevenue: 'BackOfficeRevenue',
    BackOfficeCityLedger: 'BackOfficeCityLedger',
    BackOfficeMarketStatistics: 'BackOfficeMarketStatistics',
    BackOfficeDailyStatistics: 'BackOfficeDailyStatistics',
    CommissionEft: 'CommissionEft'
} as const;
export type GetExportsAvailableFileGroupEnum = typeof GetExportsAvailableFileGroupEnum[keyof typeof GetExportsAvailableFileGroupEnum];
