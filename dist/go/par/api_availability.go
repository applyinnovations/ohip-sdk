/*
OPERA Cloud Price Availability Rate API

APIs to cater for Price and Rate Availability functionality in OPERA Cloud. <br /><br />Availability enables you to manage your room inventory by providing a detailed view of all available and sold rooms at a property. Some of the tasks you can perform include defining conditions for stay restrictions, setting room sell limits, and searching for and viewing room availability.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package par

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// AvailabilityApiService AvailabilityApi service
type AvailabilityApiService service

type AvailabilityApiAnalyzeRateAvailabilityRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanCode *string
	roomType *string
	startDate *string
	endDate *string
	duration *string
	numberOfRooms *int32
	adults *int32
	children *int32
	childAge *[]int32
	bucket1Count *int32
	bucket2Count *int32
	bucket3Count *int32
	bucket4Count *int32
	bucket5Count *int32
	blockId *string
	blockIdType *string
	reservationId *[]string
	reservationIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) Authorization(authorization string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) XAppKey(xAppKey string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) XHotelid(xHotelid string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Rate Code for which the Analysis is requested.
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) RatePlanCode(ratePlanCode string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// The Room Type for which the Analysis is requested. Analysis is done to determine whether the Rate Code is available for this Room Type.
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) RoomType(roomType string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.roomType = &roomType
	return r
}

func (r AvailabilityApiAnalyzeRateAvailabilityRequest) StartDate(startDate string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.startDate = &startDate
	return r
}

func (r AvailabilityApiAnalyzeRateAvailabilityRequest) EndDate(endDate string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.endDate = &endDate
	return r
}

func (r AvailabilityApiAnalyzeRateAvailabilityRequest) Duration(duration string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.duration = &duration
	return r
}

// The number of rooms requested. The Analysis to check if this Rate Code is available for this number of rooms.
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) NumberOfRooms(numberOfRooms int32) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.numberOfRooms = &numberOfRooms
	return r
}

// Defines the number of Adults.
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) Adults(adults int32) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.adults = &adults
	return r
}

// Defines the number of Children.
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) Children(children int32) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.children = &children
	return r
}

// Age of a child in years.
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) ChildAge(childAge []int32) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.childAge = &childAge
	return r
}

// Number of children classified under the first Age Qualifying Group(Child Bucket#1).
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) Bucket1Count(bucket1Count int32) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.bucket1Count = &bucket1Count
	return r
}

// Number of children classified under the second Age Qualifying Group(Child Bucket#2).
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) Bucket2Count(bucket2Count int32) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.bucket2Count = &bucket2Count
	return r
}

// Number of children classified under the third Age Qualifying Group(Child Bucket#3).
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) Bucket3Count(bucket3Count int32) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.bucket3Count = &bucket3Count
	return r
}

// Number of children classified under the fourth Age Qualifying Group(Child Bucket#4).
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) Bucket4Count(bucket4Count int32) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.bucket4Count = &bucket4Count
	return r
}

// Number of children classified under the fifth Age Qualifying Group(Child Bucket#5).
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) Bucket5Count(bucket5Count int32) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.bucket5Count = &bucket5Count
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) BlockId(blockId string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.blockId = &blockId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) BlockIdType(blockIdType string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.blockIdType = &blockIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) ReservationId(reservationId []string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.reservationId = &reservationId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) ReservationIdType(reservationIdType []string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// External system code.
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) XExternalsystem(xExternalsystem string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiAnalyzeRateAvailabilityRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiAnalyzeRateAvailabilityRequest) Execute() (*RateAnalysisDetails, *http.Response, error) {
	return r.ApiService.AnalyzeRateAvailabilityExecute(r)
}

/*
AnalyzeRateAvailability Analyze Rate Availability 

This API allows to Analyze Rate Availability. Rate analysis request to include the rate code, room type and room span to analyze whether a rate is closed and the reasons. <p><strong>OperationId:</strong>analyzeRateAvailability</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiAnalyzeRateAvailabilityRequest
*/
func (a *AvailabilityApiService) AnalyzeRateAvailability(ctx context.Context, hotelId string) AvailabilityApiAnalyzeRateAvailabilityRequest {
	return AvailabilityApiAnalyzeRateAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RateAnalysisDetails
func (a *AvailabilityApiService) AnalyzeRateAvailabilityExecute(r AvailabilityApiAnalyzeRateAvailabilityRequest) (*RateAnalysisDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RateAnalysisDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.AnalyzeRateAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/analyzeRateAvailability"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.numberOfRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfRooms", r.numberOfRooms, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.childAge != nil {
		t := *r.childAge
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", t, "multi")
		}
	}
	if r.bucket1Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket1Count", r.bucket1Count, "")
	}
	if r.bucket2Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket2Count", r.bucket2Count, "")
	}
	if r.bucket3Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket3Count", r.bucket3Count, "")
	}
	if r.bucket4Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket4Count", r.bucket4Count, "")
	}
	if r.bucket5Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket5Count", r.bucket5Count, "")
	}
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
	}
	if r.reservationId != nil {
		t := *r.reservationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", t, "multi")
		}
	}
	if r.reservationIdType != nil {
		t := *r.reservationIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiClearAllRestrictionsRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	clearAllRestrictions *ClearAllRestrictionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiClearAllRestrictionsRequest) Authorization(authorization string) AvailabilityApiClearAllRestrictionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiClearAllRestrictionsRequest) XAppKey(xAppKey string) AvailabilityApiClearAllRestrictionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiClearAllRestrictionsRequest) XHotelid(xHotelid string) AvailabilityApiClearAllRestrictionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for clearing all restrictions based on date.
func (r AvailabilityApiClearAllRestrictionsRequest) ClearAllRestrictions(clearAllRestrictions ClearAllRestrictionsRequest) AvailabilityApiClearAllRestrictionsRequest {
	r.clearAllRestrictions = &clearAllRestrictions
	return r
}

// External system code.
func (r AvailabilityApiClearAllRestrictionsRequest) XExternalsystem(xExternalsystem string) AvailabilityApiClearAllRestrictionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiClearAllRestrictionsRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiClearAllRestrictionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiClearAllRestrictionsRequest) Execute() (*ClearAllRestrictions, *http.Response, error) {
	return r.ApiService.ClearAllRestrictionsExecute(r)
}

/*
ClearAllRestrictions Clear all restrictions

Use this API to clear all Restrictions for a hotel on given date. The hotel code and the date will need to be passed as part of the request.<p><strong>OperationId:</strong>clearAllRestrictions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiClearAllRestrictionsRequest
*/
func (a *AvailabilityApiService) ClearAllRestrictions(ctx context.Context, hotelId string) AvailabilityApiClearAllRestrictionsRequest {
	return AvailabilityApiClearAllRestrictionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ClearAllRestrictions
func (a *AvailabilityApiService) ClearAllRestrictionsExecute(r AvailabilityApiClearAllRestrictionsRequest) (*ClearAllRestrictions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClearAllRestrictions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.ClearAllRestrictions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/restrictions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.clearAllRestrictions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiDeleteHurdleRatesRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hurdleDate *[]string
	roomType *[]string
	roomCategory *[]string
	yieldCategory *[]string
	lengthOfStay *[]float32
	yieldMarketCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiDeleteHurdleRatesRequest) Authorization(authorization string) AvailabilityApiDeleteHurdleRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiDeleteHurdleRatesRequest) XAppKey(xAppKey string) AvailabilityApiDeleteHurdleRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiDeleteHurdleRatesRequest) XHotelid(xHotelid string) AvailabilityApiDeleteHurdleRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hurdle date for which the hurdle rate is scheduled.
func (r AvailabilityApiDeleteHurdleRatesRequest) HurdleDate(hurdleDate []string) AvailabilityApiDeleteHurdleRatesRequest {
	r.hurdleDate = &hurdleDate
	return r
}

// Room type for which the hurdle rate applies to.
func (r AvailabilityApiDeleteHurdleRatesRequest) RoomType(roomType []string) AvailabilityApiDeleteHurdleRatesRequest {
	r.roomType = &roomType
	return r
}

// Internal room category of the room type for which the hurdle rate applies to.
func (r AvailabilityApiDeleteHurdleRatesRequest) RoomCategory(roomCategory []string) AvailabilityApiDeleteHurdleRatesRequest {
	r.roomCategory = &roomCategory
	return r
}

// Yield category for which the hurdle rate applies to.
func (r AvailabilityApiDeleteHurdleRatesRequest) YieldCategory(yieldCategory []string) AvailabilityApiDeleteHurdleRatesRequest {
	r.yieldCategory = &yieldCategory
	return r
}

// Length of stay for which the hurdle rate applies to.
func (r AvailabilityApiDeleteHurdleRatesRequest) LengthOfStay(lengthOfStay []float32) AvailabilityApiDeleteHurdleRatesRequest {
	r.lengthOfStay = &lengthOfStay
	return r
}

// Yield market code for which the hurdle rate applies to.
func (r AvailabilityApiDeleteHurdleRatesRequest) YieldMarketCode(yieldMarketCode []string) AvailabilityApiDeleteHurdleRatesRequest {
	r.yieldMarketCode = &yieldMarketCode
	return r
}

// External system code.
func (r AvailabilityApiDeleteHurdleRatesRequest) XExternalsystem(xExternalsystem string) AvailabilityApiDeleteHurdleRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiDeleteHurdleRatesRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiDeleteHurdleRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiDeleteHurdleRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteHurdleRatesExecute(r)
}

/*
DeleteHurdleRates Delete Hurdle Rates

This API allows to delete hurdles rates. <p><strong>OperationId:</strong>deleteHurdleRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiDeleteHurdleRatesRequest
*/
func (a *AvailabilityApiService) DeleteHurdleRates(ctx context.Context, hotelId string) AvailabilityApiDeleteHurdleRatesRequest {
	return AvailabilityApiDeleteHurdleRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AvailabilityApiService) DeleteHurdleRatesExecute(r AvailabilityApiDeleteHurdleRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.DeleteHurdleRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/hurdles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hurdleDate != nil {
		t := *r.hurdleDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hurdleDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hurdleDate", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomCategory != nil {
		t := *r.roomCategory
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomCategory", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomCategory", t, "multi")
		}
	}
	if r.yieldCategory != nil {
		t := *r.yieldCategory
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "yieldCategory", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "yieldCategory", t, "multi")
		}
	}
	if r.lengthOfStay != nil {
		t := *r.lengthOfStay
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "lengthOfStay", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "lengthOfStay", t, "multi")
		}
	}
	if r.yieldMarketCode != nil {
		t := *r.yieldMarketCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "yieldMarketCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "yieldMarketCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiDeleteRestrictionRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	restrictionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	restrictionEndDate *string
	restrictionStartDate *string
	bookingChannelCode *string
	ratePlanCategory *string
	ratePlanCode *string
	roomClass *string
	roomType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiDeleteRestrictionRequest) Authorization(authorization string) AvailabilityApiDeleteRestrictionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiDeleteRestrictionRequest) XAppKey(xAppKey string) AvailabilityApiDeleteRestrictionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiDeleteRestrictionRequest) XHotelid(xHotelid string) AvailabilityApiDeleteRestrictionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates the End date of the restriction and mandatory to delete the restriction.
func (r AvailabilityApiDeleteRestrictionRequest) RestrictionEndDate(restrictionEndDate string) AvailabilityApiDeleteRestrictionRequest {
	r.restrictionEndDate = &restrictionEndDate
	return r
}

// Indicates the start date of the restriction and mandatory to delete the restriction.
func (r AvailabilityApiDeleteRestrictionRequest) RestrictionStartDate(restrictionStartDate string) AvailabilityApiDeleteRestrictionRequest {
	r.restrictionStartDate = &restrictionStartDate
	return r
}

// Indicates restriction is applicable to specified Booking Channel Code in conjunction with other codes, if specified.
func (r AvailabilityApiDeleteRestrictionRequest) BookingChannelCode(bookingChannelCode string) AvailabilityApiDeleteRestrictionRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

// Indicates restriction is applicable to specified Rate Plan Category in conjunction with other codes, if specified.
func (r AvailabilityApiDeleteRestrictionRequest) RatePlanCategory(ratePlanCategory string) AvailabilityApiDeleteRestrictionRequest {
	r.ratePlanCategory = &ratePlanCategory
	return r
}

// Indicates restriction is applicable to specified Rate Plan Code in conjunction with other codes, if specified.
func (r AvailabilityApiDeleteRestrictionRequest) RatePlanCode(ratePlanCode string) AvailabilityApiDeleteRestrictionRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Indicates restriction is applicable to specified Room Category in conjunction with other codes, if specified.
func (r AvailabilityApiDeleteRestrictionRequest) RoomClass(roomClass string) AvailabilityApiDeleteRestrictionRequest {
	r.roomClass = &roomClass
	return r
}

// Indicates restriction is applicable to specified Room Type in conjunction with other codes, if specified.
func (r AvailabilityApiDeleteRestrictionRequest) RoomType(roomType string) AvailabilityApiDeleteRestrictionRequest {
	r.roomType = &roomType
	return r
}

// External system code.
func (r AvailabilityApiDeleteRestrictionRequest) XExternalsystem(xExternalsystem string) AvailabilityApiDeleteRestrictionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiDeleteRestrictionRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiDeleteRestrictionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiDeleteRestrictionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRestrictionExecute(r)
}

/*
DeleteRestriction Delete a Restriction 

This API allows to Delete a given restriction. The date range is passed along with the restriction control type details which can include house, room type, room class or rate plan information. The unique criteria has been defined with one of these combinations: restrictionType, restrictionStartDate, restrictionEndDate, bookingChannelCode, ratePlanCategory, ratePlanCode, roomClass, roomType.<p><strong>OperationId:</strong>deleteRestriction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param restrictionId Indicates the Restriction Type of the restriction and mandatory to delete the restriction.
 @param hotelId Indicates restriction is applicable to specified property and mandatory to delete the restriction.
 @return AvailabilityApiDeleteRestrictionRequest
*/
func (a *AvailabilityApiService) DeleteRestriction(ctx context.Context, restrictionId string, hotelId string) AvailabilityApiDeleteRestrictionRequest {
	return AvailabilityApiDeleteRestrictionRequest{
		ApiService: a,
		ctx: ctx,
		restrictionId: restrictionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AvailabilityApiService) DeleteRestrictionExecute(r AvailabilityApiDeleteRestrictionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.DeleteRestriction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/restrictions/{restrictionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"restrictionId"+"}", url.PathEscape(parameterValueToString(r.restrictionId, "restrictionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.restrictionId) < 1 {
		return localVarReturnValue, nil, reportError("restrictionId must have at least 1 elements")
	}
	if strlen(r.restrictionId) > 2000 {
		return localVarReturnValue, nil, reportError("restrictionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.restrictionEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "restrictionEndDate", r.restrictionEndDate, "")
	}
	if r.restrictionStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "restrictionStartDate", r.restrictionStartDate, "")
	}
	if r.bookingChannelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", r.bookingChannelCode, "")
	}
	if r.ratePlanCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCategory", r.ratePlanCategory, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.roomClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", r.roomClass, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiGetAlternateAvailabilityRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanCode *string
	redemption *bool
	roomType *string
	roomNumber *string
	startDate *string
	endDate *string
	duration *string
	quantity *int32
	adults *int32
	children *int32
	childAge *[]int32
	bucket1Count *int32
	bucket2Count *int32
	bucket3Count *int32
	bucket4Count *int32
	bucket5Count *int32
	reservationGuestId *string
	reservationGuestIdType *string
	reservationProfileType *[]string
	blockCode *string
	blockName *string
	blockId *string
	blockIdType *string
	membershipLevel *string
	membershipType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiGetAlternateAvailabilityRequest) Authorization(authorization string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiGetAlternateAvailabilityRequest) XAppKey(xAppKey string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiGetAlternateAvailabilityRequest) XHotelid(xHotelid string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Requested Rate code
func (r AvailabilityApiGetAlternateAvailabilityRequest) RatePlanCode(ratePlanCode string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Used to indicate if award redemption flag is to be set.
func (r AvailabilityApiGetAlternateAvailabilityRequest) Redemption(redemption bool) AvailabilityApiGetAlternateAvailabilityRequest {
	r.redemption = &redemption
	return r
}

// Requested Room type.
func (r AvailabilityApiGetAlternateAvailabilityRequest) RoomType(roomType string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.roomType = &roomType
	return r
}

// Requested Room Number.
func (r AvailabilityApiGetAlternateAvailabilityRequest) RoomNumber(roomNumber string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.roomNumber = &roomNumber
	return r
}

func (r AvailabilityApiGetAlternateAvailabilityRequest) StartDate(startDate string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.startDate = &startDate
	return r
}

func (r AvailabilityApiGetAlternateAvailabilityRequest) EndDate(endDate string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.endDate = &endDate
	return r
}

func (r AvailabilityApiGetAlternateAvailabilityRequest) Duration(duration string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.duration = &duration
	return r
}

func (r AvailabilityApiGetAlternateAvailabilityRequest) Quantity(quantity int32) AvailabilityApiGetAlternateAvailabilityRequest {
	r.quantity = &quantity
	return r
}

// Defines the number of Adults.
func (r AvailabilityApiGetAlternateAvailabilityRequest) Adults(adults int32) AvailabilityApiGetAlternateAvailabilityRequest {
	r.adults = &adults
	return r
}

// Defines the number of Children.
func (r AvailabilityApiGetAlternateAvailabilityRequest) Children(children int32) AvailabilityApiGetAlternateAvailabilityRequest {
	r.children = &children
	return r
}

// Age of a child in years.
func (r AvailabilityApiGetAlternateAvailabilityRequest) ChildAge(childAge []int32) AvailabilityApiGetAlternateAvailabilityRequest {
	r.childAge = &childAge
	return r
}

// Number of children classified under the first Age Qualifying Group(Child Bucket#1).
func (r AvailabilityApiGetAlternateAvailabilityRequest) Bucket1Count(bucket1Count int32) AvailabilityApiGetAlternateAvailabilityRequest {
	r.bucket1Count = &bucket1Count
	return r
}

// Number of children classified under the second Age Qualifying Group(Child Bucket#2).
func (r AvailabilityApiGetAlternateAvailabilityRequest) Bucket2Count(bucket2Count int32) AvailabilityApiGetAlternateAvailabilityRequest {
	r.bucket2Count = &bucket2Count
	return r
}

// Number of children classified under the third Age Qualifying Group(Child Bucket#3).
func (r AvailabilityApiGetAlternateAvailabilityRequest) Bucket3Count(bucket3Count int32) AvailabilityApiGetAlternateAvailabilityRequest {
	r.bucket3Count = &bucket3Count
	return r
}

// Number of children classified under the fourth Age Qualifying Group(Child Bucket#4).
func (r AvailabilityApiGetAlternateAvailabilityRequest) Bucket4Count(bucket4Count int32) AvailabilityApiGetAlternateAvailabilityRequest {
	r.bucket4Count = &bucket4Count
	return r
}

// Number of children classified under the fifth Age Qualifying Group(Child Bucket#5).
func (r AvailabilityApiGetAlternateAvailabilityRequest) Bucket5Count(bucket5Count int32) AvailabilityApiGetAlternateAvailabilityRequest {
	r.bucket5Count = &bucket5Count
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetAlternateAvailabilityRequest) ReservationGuestId(reservationGuestId string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.reservationGuestId = &reservationGuestId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AvailabilityApiGetAlternateAvailabilityRequest) ReservationGuestIdType(reservationGuestIdType string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.reservationGuestIdType = &reservationGuestIdType
	return r
}

func (r AvailabilityApiGetAlternateAvailabilityRequest) ReservationProfileType(reservationProfileType []string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.reservationProfileType = &reservationProfileType
	return r
}

func (r AvailabilityApiGetAlternateAvailabilityRequest) BlockCode(blockCode string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.blockCode = &blockCode
	return r
}

func (r AvailabilityApiGetAlternateAvailabilityRequest) BlockName(blockName string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.blockName = &blockName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetAlternateAvailabilityRequest) BlockId(blockId string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.blockId = &blockId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AvailabilityApiGetAlternateAvailabilityRequest) BlockIdType(blockIdType string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.blockIdType = &blockIdType
	return r
}

// Membership id Number of the guest.
func (r AvailabilityApiGetAlternateAvailabilityRequest) MembershipLevel(membershipLevel string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.membershipLevel = &membershipLevel
	return r
}

// Membership id Number of the guest.
func (r AvailabilityApiGetAlternateAvailabilityRequest) MembershipType(membershipType string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.membershipType = &membershipType
	return r
}

// External system code.
func (r AvailabilityApiGetAlternateAvailabilityRequest) XExternalsystem(xExternalsystem string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiGetAlternateAvailabilityRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiGetAlternateAvailabilityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiGetAlternateAvailabilityRequest) Execute() (*AlternateAvailability, *http.Response, error) {
	return r.ApiService.GetAlternateAvailabilityExecute(r)
}

/*
GetAlternateAvailability Get alternate availability

Use this API to get alternate dates for closed rates. Filter criteria include dates, room stay information, profile, block or guest information.<p><strong>OperationId:</strong>getAlternateAvailability</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiGetAlternateAvailabilityRequest
*/
func (a *AvailabilityApiService) GetAlternateAvailability(ctx context.Context, hotelId string) AvailabilityApiGetAlternateAvailabilityRequest {
	return AvailabilityApiGetAlternateAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AlternateAvailability
func (a *AvailabilityApiService) GetAlternateAvailabilityExecute(r AvailabilityApiGetAlternateAvailabilityRequest) (*AlternateAvailability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlternateAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.GetAlternateAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/availability/alternate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.redemption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redemption", r.redemption, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	if r.roomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumber", r.roomNumber, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quantity", r.quantity, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.childAge != nil {
		t := *r.childAge
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", t, "multi")
		}
	}
	if r.bucket1Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket1Count", r.bucket1Count, "")
	}
	if r.bucket2Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket2Count", r.bucket2Count, "")
	}
	if r.bucket3Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket3Count", r.bucket3Count, "")
	}
	if r.bucket4Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket4Count", r.bucket4Count, "")
	}
	if r.bucket5Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket5Count", r.bucket5Count, "")
	}
	if r.reservationGuestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestId", r.reservationGuestId, "")
	}
	if r.reservationGuestIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestIdType", r.reservationGuestIdType, "")
	}
	if r.reservationProfileType != nil {
		t := *r.reservationProfileType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProfileType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProfileType", t, "multi")
		}
	}
	if r.blockCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCode", r.blockCode, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
	}
	if r.membershipLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevel", r.membershipLevel, "")
	}
	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiGetAvailabilityRatePlanInfoRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanCodeList *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiGetAvailabilityRatePlanInfoRequest) Authorization(authorization string) AvailabilityApiGetAvailabilityRatePlanInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiGetAvailabilityRatePlanInfoRequest) XAppKey(xAppKey string) AvailabilityApiGetAvailabilityRatePlanInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiGetAvailabilityRatePlanInfoRequest) XHotelid(xHotelid string) AvailabilityApiGetAvailabilityRatePlanInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Rate Plan code.
func (r AvailabilityApiGetAvailabilityRatePlanInfoRequest) RatePlanCodeList(ratePlanCodeList []string) AvailabilityApiGetAvailabilityRatePlanInfoRequest {
	r.ratePlanCodeList = &ratePlanCodeList
	return r
}

// External system code.
func (r AvailabilityApiGetAvailabilityRatePlanInfoRequest) XExternalsystem(xExternalsystem string) AvailabilityApiGetAvailabilityRatePlanInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiGetAvailabilityRatePlanInfoRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiGetAvailabilityRatePlanInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiGetAvailabilityRatePlanInfoRequest) Execute() (*AvailabilityRatePlanInfo, *http.Response, error) {
	return r.ApiService.GetAvailabilityRatePlanInfoExecute(r)
}

/*
GetAvailabilityRatePlanInfo Get Rate Plan Information 

This API fetches the ratePlan information like description, short information, long information, Web URL for the ratePlan and Commission Code. The rate plan code list can be passed as part of the criteria in the request. <p><strong>OperationId:</strong>getAvailabilityRatePlanInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiGetAvailabilityRatePlanInfoRequest
*/
func (a *AvailabilityApiService) GetAvailabilityRatePlanInfo(ctx context.Context, ratePlanCode string, hotelId string) AvailabilityApiGetAvailabilityRatePlanInfoRequest {
	return AvailabilityApiGetAvailabilityRatePlanInfoRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AvailabilityRatePlanInfo
func (a *AvailabilityApiService) GetAvailabilityRatePlanInfoExecute(r AvailabilityApiGetAvailabilityRatePlanInfoRequest) (*AvailabilityRatePlanInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AvailabilityRatePlanInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.GetAvailabilityRatePlanInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rates/{ratePlanCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.ratePlanCodeList != nil {
		t := *r.ratePlanCodeList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodeList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodeList", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanCodeList *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest) Authorization(authorization string) AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest) XAppKey(xAppKey string) AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest) XHotelid(xHotelid string) AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest {
	r.xHotelid = &xHotelid
	return r
}

// Rate Plan code.
func (r AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest) RatePlanCodeList(ratePlanCodeList []string) AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest {
	r.ratePlanCodeList = &ratePlanCodeList
	return r
}

// External system code.
func (r AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest) XExternalsystem(xExternalsystem string) AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest) Execute() (*AvailabilityRatePlanInfo, *http.Response, error) {
	return r.ApiService.GetAvailabilityRatePlanInfoByMultipleRatePlansExecute(r)
}

/*
GetAvailabilityRatePlanInfoByMultipleRatePlans Use this API to get Rate Plan information such as commission codes, market codes, and rate category. 

Operation description<p><strong>OperationId:</strong>getAvailabilityRatePlanInfoByMultipleRatePlans</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest
*/
func (a *AvailabilityApiService) GetAvailabilityRatePlanInfoByMultipleRatePlans(ctx context.Context, hotelId string) AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest {
	return AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AvailabilityRatePlanInfo
func (a *AvailabilityApiService) GetAvailabilityRatePlanInfoByMultipleRatePlansExecute(r AvailabilityApiGetAvailabilityRatePlanInfoByMultipleRatePlansRequest) (*AvailabilityRatePlanInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AvailabilityRatePlanInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.GetAvailabilityRatePlanInfoByMultipleRatePlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.ratePlanCodeList != nil {
		t := *r.ratePlanCodeList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodeList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodeList", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiGetAvailableUpsellsRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationId *string
	profileId *string
	reservationStatus *string
	startDate *string
	endDate *string
	ratePlanCode *string
	roomType *string
	adults *int32
	children *int32
	rateAmount *float32
	guaranteeCode *string
	marketCode *string
	fixedRate *bool
	rateDate *[]string
	requiredAmount *[]float32
	numberOfRooms *int32
	bucket1Count *int32
	bucket2Count *int32
	bucket3Count *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiGetAvailableUpsellsRequest) Authorization(authorization string) AvailabilityApiGetAvailableUpsellsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiGetAvailableUpsellsRequest) XAppKey(xAppKey string) AvailabilityApiGetAvailableUpsellsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiGetAvailableUpsellsRequest) XHotelid(xHotelid string) AvailabilityApiGetAvailableUpsellsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetAvailableUpsellsRequest) ReservationId(reservationId string) AvailabilityApiGetAvailableUpsellsRequest {
	r.reservationId = &reservationId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetAvailableUpsellsRequest) ProfileId(profileId string) AvailabilityApiGetAvailableUpsellsRequest {
	r.profileId = &profileId
	return r
}

// This reservation is in checked in status and the business date is past departure date. This could occur when ORS and PMS are in same environment.
func (r AvailabilityApiGetAvailableUpsellsRequest) ReservationStatus(reservationStatus string) AvailabilityApiGetAvailableUpsellsRequest {
	r.reservationStatus = &reservationStatus
	return r
}

func (r AvailabilityApiGetAvailableUpsellsRequest) StartDate(startDate string) AvailabilityApiGetAvailableUpsellsRequest {
	r.startDate = &startDate
	return r
}

func (r AvailabilityApiGetAvailableUpsellsRequest) EndDate(endDate string) AvailabilityApiGetAvailableUpsellsRequest {
	r.endDate = &endDate
	return r
}

// Rate plan code
func (r AvailabilityApiGetAvailableUpsellsRequest) RatePlanCode(ratePlanCode string) AvailabilityApiGetAvailableUpsellsRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Room type
func (r AvailabilityApiGetAvailableUpsellsRequest) RoomType(roomType string) AvailabilityApiGetAvailableUpsellsRequest {
	r.roomType = &roomType
	return r
}

// Defines the number of Adults.
func (r AvailabilityApiGetAvailableUpsellsRequest) Adults(adults int32) AvailabilityApiGetAvailableUpsellsRequest {
	r.adults = &adults
	return r
}

// Defines the number of Children.
func (r AvailabilityApiGetAvailableUpsellsRequest) Children(children int32) AvailabilityApiGetAvailableUpsellsRequest {
	r.children = &children
	return r
}

// A monetary amount.
func (r AvailabilityApiGetAvailableUpsellsRequest) RateAmount(rateAmount float32) AvailabilityApiGetAvailableUpsellsRequest {
	r.rateAmount = &rateAmount
	return r
}

// Guarantee code
func (r AvailabilityApiGetAvailableUpsellsRequest) GuaranteeCode(guaranteeCode string) AvailabilityApiGetAvailableUpsellsRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// Market code
func (r AvailabilityApiGetAvailableUpsellsRequest) MarketCode(marketCode string) AvailabilityApiGetAvailableUpsellsRequest {
	r.marketCode = &marketCode
	return r
}

// Fixed Rate flag
func (r AvailabilityApiGetAvailableUpsellsRequest) FixedRate(fixedRate bool) AvailabilityApiGetAvailableUpsellsRequest {
	r.fixedRate = &fixedRate
	return r
}

// Reservation date
func (r AvailabilityApiGetAvailableUpsellsRequest) RateDate(rateDate []string) AvailabilityApiGetAvailableUpsellsRequest {
	r.rateDate = &rateDate
	return r
}

// A monetary amount.
func (r AvailabilityApiGetAvailableUpsellsRequest) RequiredAmount(requiredAmount []float32) AvailabilityApiGetAvailableUpsellsRequest {
	r.requiredAmount = &requiredAmount
	return r
}

// Number of Rooms
func (r AvailabilityApiGetAvailableUpsellsRequest) NumberOfRooms(numberOfRooms int32) AvailabilityApiGetAvailableUpsellsRequest {
	r.numberOfRooms = &numberOfRooms
	return r
}

// Number of children classified under the first Age Qualifying Group(Child Bucket#1).
func (r AvailabilityApiGetAvailableUpsellsRequest) Bucket1Count(bucket1Count int32) AvailabilityApiGetAvailableUpsellsRequest {
	r.bucket1Count = &bucket1Count
	return r
}

// Number of children classified under the second Age Qualifying Group(Child Bucket#2).
func (r AvailabilityApiGetAvailableUpsellsRequest) Bucket2Count(bucket2Count int32) AvailabilityApiGetAvailableUpsellsRequest {
	r.bucket2Count = &bucket2Count
	return r
}

// Number of children classified under the third Age Qualifying Group(Child Bucket#3).
func (r AvailabilityApiGetAvailableUpsellsRequest) Bucket3Count(bucket3Count int32) AvailabilityApiGetAvailableUpsellsRequest {
	r.bucket3Count = &bucket3Count
	return r
}

// External system code.
func (r AvailabilityApiGetAvailableUpsellsRequest) XExternalsystem(xExternalsystem string) AvailabilityApiGetAvailableUpsellsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiGetAvailableUpsellsRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiGetAvailableUpsellsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiGetAvailableUpsellsRequest) Execute() (*AvailableUpsells, *http.Response, error) {
	return r.ApiService.GetAvailableUpsellsExecute(r)
}

/*
GetAvailableUpsells Get for Available Up-sells

This API allows to fetch for Available Up-sells for specific hotel and date range. <p><strong>OperationId:</strong>getAvailableUpsells</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiGetAvailableUpsellsRequest
*/
func (a *AvailabilityApiService) GetAvailableUpsells(ctx context.Context, hotelId string) AvailabilityApiGetAvailableUpsellsRequest {
	return AvailabilityApiGetAvailableUpsellsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AvailableUpsells
func (a *AvailabilityApiService) GetAvailableUpsellsExecute(r AvailabilityApiGetAvailableUpsellsRequest) (*AvailableUpsells, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AvailableUpsells
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.GetAvailableUpsells")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/availableUpsells"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.reservationStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", r.reservationStatus, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.rateAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateAmount", r.rateAmount, "")
	}
	if r.guaranteeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", r.guaranteeCode, "")
	}
	if r.marketCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketCode", r.marketCode, "")
	}
	if r.fixedRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fixedRate", r.fixedRate, "")
	}
	if r.rateDate != nil {
		t := *r.rateDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateDate", t, "multi")
		}
	}
	if r.requiredAmount != nil {
		t := *r.requiredAmount
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "requiredAmount", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "requiredAmount", t, "multi")
		}
	}
	if r.numberOfRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfRooms", r.numberOfRooms, "")
	}
	if r.bucket1Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket1Count", r.bucket1Count, "")
	}
	if r.bucket2Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket2Count", r.bucket2Count, "")
	}
	if r.bucket3Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket3Count", r.bucket3Count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiGetGuaranteeablePreferencesRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	startDate *string
	endDate *string
	roomType *string
	availableCode *[]string
	requestedCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiGetGuaranteeablePreferencesRequest) Authorization(authorization string) AvailabilityApiGetGuaranteeablePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiGetGuaranteeablePreferencesRequest) XAppKey(xAppKey string) AvailabilityApiGetGuaranteeablePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiGetGuaranteeablePreferencesRequest) XHotelid(xHotelid string) AvailabilityApiGetGuaranteeablePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r AvailabilityApiGetGuaranteeablePreferencesRequest) StartDate(startDate string) AvailabilityApiGetGuaranteeablePreferencesRequest {
	r.startDate = &startDate
	return r
}

func (r AvailabilityApiGetGuaranteeablePreferencesRequest) EndDate(endDate string) AvailabilityApiGetGuaranteeablePreferencesRequest {
	r.endDate = &endDate
	return r
}

// Room Type for which the Guaranteeable Preference Code Mapping is requested.
func (r AvailabilityApiGetGuaranteeablePreferencesRequest) RoomType(roomType string) AvailabilityApiGetGuaranteeablePreferencesRequest {
	r.roomType = &roomType
	return r
}

func (r AvailabilityApiGetGuaranteeablePreferencesRequest) AvailableCode(availableCode []string) AvailabilityApiGetGuaranteeablePreferencesRequest {
	r.availableCode = &availableCode
	return r
}

func (r AvailabilityApiGetGuaranteeablePreferencesRequest) RequestedCode(requestedCode []string) AvailabilityApiGetGuaranteeablePreferencesRequest {
	r.requestedCode = &requestedCode
	return r
}

// External system code.
func (r AvailabilityApiGetGuaranteeablePreferencesRequest) XExternalsystem(xExternalsystem string) AvailabilityApiGetGuaranteeablePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiGetGuaranteeablePreferencesRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiGetGuaranteeablePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiGetGuaranteeablePreferencesRequest) Execute() (*GuaranteeablePreferences, *http.Response, error) {
	return r.ApiService.GetGuaranteeablePreferencesExecute(r)
}

/*
GetGuaranteeablePreferences Get Guarantee-able Preference Codes

Get Guarantee-able Preference Codes for a specified property. <p><strong>OperationId:</strong>getGuaranteeablePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiGetGuaranteeablePreferencesRequest
*/
func (a *AvailabilityApiService) GetGuaranteeablePreferences(ctx context.Context, hotelId string) AvailabilityApiGetGuaranteeablePreferencesRequest {
	return AvailabilityApiGetGuaranteeablePreferencesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GuaranteeablePreferences
func (a *AvailabilityApiService) GetGuaranteeablePreferencesExecute(r AvailabilityApiGetGuaranteeablePreferencesRequest) (*GuaranteeablePreferences, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuaranteeablePreferences
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.GetGuaranteeablePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/guaranteeablePreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	if r.availableCode != nil {
		t := *r.availableCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "availableCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "availableCode", t, "multi")
		}
	}
	if r.requestedCode != nil {
		t := *r.requestedCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "requestedCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "requestedCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiGetHotelAvailabilityRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cro *[]string
	includeClosedRates *[]bool
	includeDefaultRatePlanSet *[]bool
	initialRatePlanSet *[]bool
	limit *[]int32
	pagePointerKey *[]string
	ratePlanSet *[]string
	redeemAwards *[]bool
	roomStayStartDate *string
	roomStayEndDate *string
	roomStayQuantity *int32
	adults *int32
	children *int32
	childAge *[]int32
	bucket1Count *int32
	bucket2Count *int32
	bucket3Count *int32
	bucket4Count *int32
	bucket5Count *int32
	fullStayTimeSpanStartDate *string
	fullStayTimeSpanEndDate *string
	prevailingRate *bool
	rateCategory *string
	rateClass *string
	rateGroup *string
	ratePlanCode *[]string
	promotionCode *[]string
	roomType *[]string
	feature *[]string
	reservationGuestId *string
	reservationGuestIdType *string
	reservationProfileType *[]string
	attachedProfileId *[]string
	hotelReservationId *string
	hotelReservationIdType *string
	ratePlanInfo *bool
	returnOnlyAvailableRateCodes *bool
	resGuaranteeInfo *bool
	roomTypeInfo *bool
	membershipIdNumber *[]int32
	membershipLevel *[]string
	membershipType *[]string
	pointsAvailable *[]int32
	smokingPreference *[]string
	hotelPackage *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiGetHotelAvailabilityRequest) Authorization(authorization string) AvailabilityApiGetHotelAvailabilityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiGetHotelAvailabilityRequest) XAppKey(xAppKey string) AvailabilityApiGetHotelAvailabilityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiGetHotelAvailabilityRequest) XHotelid(xHotelid string) AvailabilityApiGetHotelAvailabilityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Central reservation office Code who is requesting Rate Availability.
func (r AvailabilityApiGetHotelAvailabilityRequest) Cro(cro []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.cro = &cro
	return r
}

// Used to indicate if closed rates are to be included in the Rate Plan set.
func (r AvailabilityApiGetHotelAvailabilityRequest) IncludeClosedRates(includeClosedRates []bool) AvailabilityApiGetHotelAvailabilityRequest {
	r.includeClosedRates = &includeClosedRates
	return r
}

// Used to indicate if the configured default rate plan set will be included.
func (r AvailabilityApiGetHotelAvailabilityRequest) IncludeDefaultRatePlanSet(includeDefaultRatePlanSet []bool) AvailabilityApiGetHotelAvailabilityRequest {
	r.includeDefaultRatePlanSet = &includeDefaultRatePlanSet
	return r
}

// If InitialRatePlanSet is set to true response will return most relevant Rate Plan Set(e.g. NEGOTIATED if profiles has Negotiated Rates) depending on the request. if request does not requires special Rate Plan Set, it will return default Rate Plan Set if RatePlanSet value is not set.
func (r AvailabilityApiGetHotelAvailabilityRequest) InitialRatePlanSet(initialRatePlanSet []bool) AvailabilityApiGetHotelAvailabilityRequest {
	r.initialRatePlanSet = &initialRatePlanSet
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r AvailabilityApiGetHotelAvailabilityRequest) Limit(limit []int32) AvailabilityApiGetHotelAvailabilityRequest {
	r.limit = &limit
	return r
}

// Specifies fetched record&#39;s key as pointer to fetch additional records from. If key is composite use comma separated string.
func (r AvailabilityApiGetHotelAvailabilityRequest) PagePointerKey(pagePointerKey []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.pagePointerKey = &pagePointerKey
	return r
}

// Rate Plan Set code to filter Rate Plans based on the predefined set. if not specified it will not filter any Rate Plans by Rate Plan Set. When InitialRatePlanSet is true response may not always return Rate Plans for the supplied Rate Plan Set(See InitialRatePlanSet documentation).
func (r AvailabilityApiGetHotelAvailabilityRequest) RatePlanSet(ratePlanSet []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.ratePlanSet = &ratePlanSet
	return r
}

// Used to indicate if the awards are to be redeemed.
func (r AvailabilityApiGetHotelAvailabilityRequest) RedeemAwards(redeemAwards []bool) AvailabilityApiGetHotelAvailabilityRequest {
	r.redeemAwards = &redeemAwards
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) RoomStayStartDate(roomStayStartDate string) AvailabilityApiGetHotelAvailabilityRequest {
	r.roomStayStartDate = &roomStayStartDate
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) RoomStayEndDate(roomStayEndDate string) AvailabilityApiGetHotelAvailabilityRequest {
	r.roomStayEndDate = &roomStayEndDate
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) RoomStayQuantity(roomStayQuantity int32) AvailabilityApiGetHotelAvailabilityRequest {
	r.roomStayQuantity = &roomStayQuantity
	return r
}

// Defines the number of Adults.
func (r AvailabilityApiGetHotelAvailabilityRequest) Adults(adults int32) AvailabilityApiGetHotelAvailabilityRequest {
	r.adults = &adults
	return r
}

// Defines the number of Children.
func (r AvailabilityApiGetHotelAvailabilityRequest) Children(children int32) AvailabilityApiGetHotelAvailabilityRequest {
	r.children = &children
	return r
}

// Age of a child in years.
func (r AvailabilityApiGetHotelAvailabilityRequest) ChildAge(childAge []int32) AvailabilityApiGetHotelAvailabilityRequest {
	r.childAge = &childAge
	return r
}

// Number of children classified under the first Age Qualifying Group(Child Bucket#1).
func (r AvailabilityApiGetHotelAvailabilityRequest) Bucket1Count(bucket1Count int32) AvailabilityApiGetHotelAvailabilityRequest {
	r.bucket1Count = &bucket1Count
	return r
}

// Number of children classified under the second Age Qualifying Group(Child Bucket#2).
func (r AvailabilityApiGetHotelAvailabilityRequest) Bucket2Count(bucket2Count int32) AvailabilityApiGetHotelAvailabilityRequest {
	r.bucket2Count = &bucket2Count
	return r
}

// Number of children classified under the third Age Qualifying Group(Child Bucket#3).
func (r AvailabilityApiGetHotelAvailabilityRequest) Bucket3Count(bucket3Count int32) AvailabilityApiGetHotelAvailabilityRequest {
	r.bucket3Count = &bucket3Count
	return r
}

// Number of children classified under the fourth Age Qualifying Group(Child Bucket#4).
func (r AvailabilityApiGetHotelAvailabilityRequest) Bucket4Count(bucket4Count int32) AvailabilityApiGetHotelAvailabilityRequest {
	r.bucket4Count = &bucket4Count
	return r
}

// Number of children classified under the fifth Age Qualifying Group(Child Bucket#5).
func (r AvailabilityApiGetHotelAvailabilityRequest) Bucket5Count(bucket5Count int32) AvailabilityApiGetHotelAvailabilityRequest {
	r.bucket5Count = &bucket5Count
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) FullStayTimeSpanStartDate(fullStayTimeSpanStartDate string) AvailabilityApiGetHotelAvailabilityRequest {
	r.fullStayTimeSpanStartDate = &fullStayTimeSpanStartDate
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) FullStayTimeSpanEndDate(fullStayTimeSpanEndDate string) AvailabilityApiGetHotelAvailabilityRequest {
	r.fullStayTimeSpanEndDate = &fullStayTimeSpanEndDate
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) PrevailingRate(prevailingRate bool) AvailabilityApiGetHotelAvailabilityRequest {
	r.prevailingRate = &prevailingRate
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) RateCategory(rateCategory string) AvailabilityApiGetHotelAvailabilityRequest {
	r.rateCategory = &rateCategory
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) RateClass(rateClass string) AvailabilityApiGetHotelAvailabilityRequest {
	r.rateClass = &rateClass
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) RateGroup(rateGroup string) AvailabilityApiGetHotelAvailabilityRequest {
	r.rateGroup = &rateGroup
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) RatePlanCode(ratePlanCode []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Promotion code associated with the rate plan.
func (r AvailabilityApiGetHotelAvailabilityRequest) PromotionCode(promotionCode []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.promotionCode = &promotionCode
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) RoomType(roomType []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.roomType = &roomType
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) Feature(feature []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.feature = &feature
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetHotelAvailabilityRequest) ReservationGuestId(reservationGuestId string) AvailabilityApiGetHotelAvailabilityRequest {
	r.reservationGuestId = &reservationGuestId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AvailabilityApiGetHotelAvailabilityRequest) ReservationGuestIdType(reservationGuestIdType string) AvailabilityApiGetHotelAvailabilityRequest {
	r.reservationGuestIdType = &reservationGuestIdType
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) ReservationProfileType(reservationProfileType []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.reservationProfileType = &reservationProfileType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetHotelAvailabilityRequest) AttachedProfileId(attachedProfileId []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.attachedProfileId = &attachedProfileId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetHotelAvailabilityRequest) HotelReservationId(hotelReservationId string) AvailabilityApiGetHotelAvailabilityRequest {
	r.hotelReservationId = &hotelReservationId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AvailabilityApiGetHotelAvailabilityRequest) HotelReservationIdType(hotelReservationIdType string) AvailabilityApiGetHotelAvailabilityRequest {
	r.hotelReservationIdType = &hotelReservationIdType
	return r
}

// If true Rate Plan Code Master information will be included in the response.
func (r AvailabilityApiGetHotelAvailabilityRequest) RatePlanInfo(ratePlanInfo bool) AvailabilityApiGetHotelAvailabilityRequest {
	r.ratePlanInfo = &ratePlanInfo
	return r
}

// If true Only availability check will be done and it will return available rate codes.
func (r AvailabilityApiGetHotelAvailabilityRequest) ReturnOnlyAvailableRateCodes(returnOnlyAvailableRateCodes bool) AvailabilityApiGetHotelAvailabilityRequest {
	r.returnOnlyAvailableRateCodes = &returnOnlyAvailableRateCodes
	return r
}

// If true Guarantee Code information will be fetched with Rate Code Information. This attribute is only effective when RatePlanInfo is true.
func (r AvailabilityApiGetHotelAvailabilityRequest) ResGuaranteeInfo(resGuaranteeInfo bool) AvailabilityApiGetHotelAvailabilityRequest {
	r.resGuaranteeInfo = &resGuaranteeInfo
	return r
}

// If true Room Type Master information will be included in the response.
func (r AvailabilityApiGetHotelAvailabilityRequest) RoomTypeInfo(roomTypeInfo bool) AvailabilityApiGetHotelAvailabilityRequest {
	r.roomTypeInfo = &roomTypeInfo
	return r
}

// Membership id Number of the guest.
func (r AvailabilityApiGetHotelAvailabilityRequest) MembershipIdNumber(membershipIdNumber []int32) AvailabilityApiGetHotelAvailabilityRequest {
	r.membershipIdNumber = &membershipIdNumber
	return r
}

// Membership id Number of the guest.
func (r AvailabilityApiGetHotelAvailabilityRequest) MembershipLevel(membershipLevel []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.membershipLevel = &membershipLevel
	return r
}

// Membership id Number of the guest.
func (r AvailabilityApiGetHotelAvailabilityRequest) MembershipType(membershipType []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.membershipType = &membershipType
	return r
}

// Used to indicate Points Available for Profile Primary Membership Type.
func (r AvailabilityApiGetHotelAvailabilityRequest) PointsAvailable(pointsAvailable []int32) AvailabilityApiGetHotelAvailabilityRequest {
	r.pointsAvailable = &pointsAvailable
	return r
}

// Smoking preference to search a reservation. This is compared to the preference on the guest profile of the reservation.
func (r AvailabilityApiGetHotelAvailabilityRequest) SmokingPreference(smokingPreference []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.smokingPreference = &smokingPreference
	return r
}

// Hotel Package Code to filter the search result.
func (r AvailabilityApiGetHotelAvailabilityRequest) HotelPackage(hotelPackage []string) AvailabilityApiGetHotelAvailabilityRequest {
	r.hotelPackage = &hotelPackage
	return r
}

// External system code.
func (r AvailabilityApiGetHotelAvailabilityRequest) XExternalsystem(xExternalsystem string) AvailabilityApiGetHotelAvailabilityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiGetHotelAvailabilityRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiGetHotelAvailabilityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiGetHotelAvailabilityRequest) Execute() (*HotelAvailability, *http.Response, error) {
	return r.ApiService.GetHotelAvailabilityExecute(r)
}

/*
GetHotelAvailability Get hotel availability

Use this API to get hotel availability for multiple hotels, given dates, Rate Plans, Rate Category, Rate Group, Membership Rates, and number of people. By default five records are returned unless a higher number is specified in the limit query parameter.<p><strong>OperationId:</strong>getHotelAvailability</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiGetHotelAvailabilityRequest
*/
func (a *AvailabilityApiService) GetHotelAvailability(ctx context.Context, hotelId string) AvailabilityApiGetHotelAvailabilityRequest {
	return AvailabilityApiGetHotelAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelAvailability
func (a *AvailabilityApiService) GetHotelAvailabilityExecute(r AvailabilityApiGetHotelAvailabilityRequest) (*HotelAvailability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.GetHotelAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/availability"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.cro != nil {
		t := *r.cro
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cro", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cro", t, "multi")
		}
	}
	if r.includeClosedRates != nil {
		t := *r.includeClosedRates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includeClosedRates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includeClosedRates", t, "multi")
		}
	}
	if r.includeDefaultRatePlanSet != nil {
		t := *r.includeDefaultRatePlanSet
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includeDefaultRatePlanSet", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includeDefaultRatePlanSet", t, "multi")
		}
	}
	if r.initialRatePlanSet != nil {
		t := *r.initialRatePlanSet
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "initialRatePlanSet", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "initialRatePlanSet", t, "multi")
		}
	}
	if r.limit != nil {
		t := *r.limit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "limit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "limit", t, "multi")
		}
	}
	if r.pagePointerKey != nil {
		t := *r.pagePointerKey
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pagePointerKey", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pagePointerKey", t, "multi")
		}
	}
	if r.ratePlanSet != nil {
		t := *r.ratePlanSet
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanSet", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanSet", t, "multi")
		}
	}
	if r.redeemAwards != nil {
		t := *r.redeemAwards
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "redeemAwards", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "redeemAwards", t, "multi")
		}
	}
	if r.roomStayStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomStayStartDate", r.roomStayStartDate, "")
	}
	if r.roomStayEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomStayEndDate", r.roomStayEndDate, "")
	}
	if r.roomStayQuantity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomStayQuantity", r.roomStayQuantity, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.childAge != nil {
		t := *r.childAge
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", t, "multi")
		}
	}
	if r.bucket1Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket1Count", r.bucket1Count, "")
	}
	if r.bucket2Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket2Count", r.bucket2Count, "")
	}
	if r.bucket3Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket3Count", r.bucket3Count, "")
	}
	if r.bucket4Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket4Count", r.bucket4Count, "")
	}
	if r.bucket5Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket5Count", r.bucket5Count, "")
	}
	if r.fullStayTimeSpanStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fullStayTimeSpanStartDate", r.fullStayTimeSpanStartDate, "")
	}
	if r.fullStayTimeSpanEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fullStayTimeSpanEndDate", r.fullStayTimeSpanEndDate, "")
	}
	if r.prevailingRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prevailingRate", r.prevailingRate, "")
	}
	if r.rateCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", r.rateCategory, "")
	}
	if r.rateClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateClass", r.rateClass, "")
	}
	if r.rateGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateGroup", r.rateGroup, "")
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	if r.promotionCode != nil {
		t := *r.promotionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.feature != nil {
		t := *r.feature
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feature", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feature", t, "multi")
		}
	}
	if r.reservationGuestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestId", r.reservationGuestId, "")
	}
	if r.reservationGuestIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestIdType", r.reservationGuestIdType, "")
	}
	if r.reservationProfileType != nil {
		t := *r.reservationProfileType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProfileType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProfileType", t, "multi")
		}
	}
	if r.attachedProfileId != nil {
		t := *r.attachedProfileId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", t, "multi")
		}
	}
	if r.hotelReservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelReservationId", r.hotelReservationId, "")
	}
	if r.hotelReservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelReservationIdType", r.hotelReservationIdType, "")
	}
	if r.ratePlanInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanInfo", r.ratePlanInfo, "")
	}
	if r.returnOnlyAvailableRateCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnOnlyAvailableRateCodes", r.returnOnlyAvailableRateCodes, "")
	}
	if r.resGuaranteeInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resGuaranteeInfo", r.resGuaranteeInfo, "")
	}
	if r.roomTypeInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeInfo", r.roomTypeInfo, "")
	}
	if r.membershipIdNumber != nil {
		t := *r.membershipIdNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipIdNumber", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipIdNumber", t, "multi")
		}
	}
	if r.membershipLevel != nil {
		t := *r.membershipLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevel", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevel", t, "multi")
		}
	}
	if r.membershipType != nil {
		t := *r.membershipType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", t, "multi")
		}
	}
	if r.pointsAvailable != nil {
		t := *r.pointsAvailable
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pointsAvailable", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pointsAvailable", t, "multi")
		}
	}
	if r.smokingPreference != nil {
		t := *r.smokingPreference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "smokingPreference", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "smokingPreference", t, "multi")
		}
	}
	if r.hotelPackage != nil {
		t := *r.hotelPackage
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelPackage", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelPackage", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiGetHotelAvailabilityCRORequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	cro *[]string
	hotelIds *[]string
	includeClosedRates *[]bool
	includeDefaultRatePlanSet *[]bool
	initialRatePlanSet *[]bool
	limit *[]int32
	pagePointerKey *[]string
	ratePlanSet *[]string
	redeemAwards *[]bool
	roomStayStartDate *string
	roomStayEndDate *string
	roomStayQuantity *int32
	adults *int32
	children *int32
	childAge *[]int32
	bucket1Count *int32
	bucket2Count *int32
	bucket3Count *int32
	bucket4Count *int32
	bucket5Count *int32
	fullStayTimeSpanStartDate *string
	fullStayTimeSpanEndDate *string
	prevailingRate *bool
	rateCategory *string
	rateClass *string
	rateGroup *string
	ratePlanCode *[]string
	promotionCode *[]string
	roomType *[]string
	roomClass *[]string
	feature *[]string
	reservationGuestId *string
	reservationGuestIdType *string
	reservationProfileType *[]string
	attachedProfileId *[]string
	hotelReservationId *string
	hotelReservationIdType *string
	ratePlanInfo *bool
	returnOnlyAvailableRateCodes *bool
	resGuaranteeInfo *bool
	roomTypeInfo *bool
	membershipIdNumber *[]int32
	membershipLevel *[]string
	membershipType *[]string
	pointsAvailable *[]int32
	smokingPreference *[]string
	hotelPackage *[]string
	yieldMarketCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiGetHotelAvailabilityCRORequest) Authorization(authorization string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiGetHotelAvailabilityCRORequest) XAppKey(xAppKey string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiGetHotelAvailabilityCRORequest) XHotelid(xHotelid string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.xHotelid = &xHotelid
	return r
}

// Central reservation office Code who is requesting Rate Availability.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) Cro(cro []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.cro = &cro
	return r
}

// Hotel code of the Hotel whose Rate Availability is requested.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) HotelIds(hotelIds []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.hotelIds = &hotelIds
	return r
}

// Used to indicate if closed rates are to be included in the Rate Plan set.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) IncludeClosedRates(includeClosedRates []bool) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.includeClosedRates = &includeClosedRates
	return r
}

// Used to indicate if the configured default rate plan set will be included.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) IncludeDefaultRatePlanSet(includeDefaultRatePlanSet []bool) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.includeDefaultRatePlanSet = &includeDefaultRatePlanSet
	return r
}

// If InitialRatePlanSet is set to true response will return most relevant Rate Plan Set(e.g. NEGOTIATED if profiles has Negotiated Rates) depending on the request. if request does not requires special Rate Plan Set, it will return default Rate Plan Set if RatePlanSet value is not set.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) InitialRatePlanSet(initialRatePlanSet []bool) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.initialRatePlanSet = &initialRatePlanSet
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) Limit(limit []int32) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.limit = &limit
	return r
}

// Specifies fetched record&#39;s key as pointer to fetch additional records from. If key is composite use comma separated string.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) PagePointerKey(pagePointerKey []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.pagePointerKey = &pagePointerKey
	return r
}

// Rate Plan Set code to filter Rate Plans based on the predefined set. if not specified it will not filter any Rate Plans by Rate Plan Set. When InitialRatePlanSet is true response may not always return Rate Plans for the supplied Rate Plan Set(See InitialRatePlanSet documentation).
func (r AvailabilityApiGetHotelAvailabilityCRORequest) RatePlanSet(ratePlanSet []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.ratePlanSet = &ratePlanSet
	return r
}

// Used to indicate if the awards are to be redeemed.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) RedeemAwards(redeemAwards []bool) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.redeemAwards = &redeemAwards
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) RoomStayStartDate(roomStayStartDate string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.roomStayStartDate = &roomStayStartDate
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) RoomStayEndDate(roomStayEndDate string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.roomStayEndDate = &roomStayEndDate
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) RoomStayQuantity(roomStayQuantity int32) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.roomStayQuantity = &roomStayQuantity
	return r
}

// Defines the number of Adults.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) Adults(adults int32) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.adults = &adults
	return r
}

// Defines the number of Children.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) Children(children int32) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.children = &children
	return r
}

// Age of a child in years.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) ChildAge(childAge []int32) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.childAge = &childAge
	return r
}

// Number of children classified under the first Age Qualifying Group(Child Bucket#1).
func (r AvailabilityApiGetHotelAvailabilityCRORequest) Bucket1Count(bucket1Count int32) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.bucket1Count = &bucket1Count
	return r
}

// Number of children classified under the second Age Qualifying Group(Child Bucket#2).
func (r AvailabilityApiGetHotelAvailabilityCRORequest) Bucket2Count(bucket2Count int32) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.bucket2Count = &bucket2Count
	return r
}

// Number of children classified under the third Age Qualifying Group(Child Bucket#3).
func (r AvailabilityApiGetHotelAvailabilityCRORequest) Bucket3Count(bucket3Count int32) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.bucket3Count = &bucket3Count
	return r
}

// Number of children classified under the fourth Age Qualifying Group(Child Bucket#4).
func (r AvailabilityApiGetHotelAvailabilityCRORequest) Bucket4Count(bucket4Count int32) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.bucket4Count = &bucket4Count
	return r
}

// Number of children classified under the fifth Age Qualifying Group(Child Bucket#5).
func (r AvailabilityApiGetHotelAvailabilityCRORequest) Bucket5Count(bucket5Count int32) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.bucket5Count = &bucket5Count
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) FullStayTimeSpanStartDate(fullStayTimeSpanStartDate string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.fullStayTimeSpanStartDate = &fullStayTimeSpanStartDate
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) FullStayTimeSpanEndDate(fullStayTimeSpanEndDate string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.fullStayTimeSpanEndDate = &fullStayTimeSpanEndDate
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) PrevailingRate(prevailingRate bool) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.prevailingRate = &prevailingRate
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) RateCategory(rateCategory string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.rateCategory = &rateCategory
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) RateClass(rateClass string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.rateClass = &rateClass
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) RateGroup(rateGroup string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.rateGroup = &rateGroup
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) RatePlanCode(ratePlanCode []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Promotion code associated with the rate plan.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) PromotionCode(promotionCode []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.promotionCode = &promotionCode
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) RoomType(roomType []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.roomType = &roomType
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) RoomClass(roomClass []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.roomClass = &roomClass
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) Feature(feature []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.feature = &feature
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) ReservationGuestId(reservationGuestId string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.reservationGuestId = &reservationGuestId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) ReservationGuestIdType(reservationGuestIdType string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.reservationGuestIdType = &reservationGuestIdType
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) ReservationProfileType(reservationProfileType []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.reservationProfileType = &reservationProfileType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) AttachedProfileId(attachedProfileId []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.attachedProfileId = &attachedProfileId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) HotelReservationId(hotelReservationId string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.hotelReservationId = &hotelReservationId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) HotelReservationIdType(hotelReservationIdType string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.hotelReservationIdType = &hotelReservationIdType
	return r
}

// If true Rate Plan Code Master information will be included in the response.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) RatePlanInfo(ratePlanInfo bool) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.ratePlanInfo = &ratePlanInfo
	return r
}

// If true Only availability check will be done and it will return available rate codes.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) ReturnOnlyAvailableRateCodes(returnOnlyAvailableRateCodes bool) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.returnOnlyAvailableRateCodes = &returnOnlyAvailableRateCodes
	return r
}

// If true Guarantee Code information will be fetched with Rate Code Information. This attribute is only effective when RatePlanInfo is true.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) ResGuaranteeInfo(resGuaranteeInfo bool) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.resGuaranteeInfo = &resGuaranteeInfo
	return r
}

// If true Room Type Master information will be included in the response.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) RoomTypeInfo(roomTypeInfo bool) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.roomTypeInfo = &roomTypeInfo
	return r
}

// Membership id Number of the guest.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) MembershipIdNumber(membershipIdNumber []int32) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.membershipIdNumber = &membershipIdNumber
	return r
}

// Membership id Number of the guest.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) MembershipLevel(membershipLevel []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.membershipLevel = &membershipLevel
	return r
}

// Membership id Number of the guest.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) MembershipType(membershipType []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.membershipType = &membershipType
	return r
}

// Used to indicate Points Available for Profile Primary Membership Type.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) PointsAvailable(pointsAvailable []int32) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.pointsAvailable = &pointsAvailable
	return r
}

// Smoking preference to search a reservation. This is compared to the preference on the guest profile of the reservation.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) SmokingPreference(smokingPreference []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.smokingPreference = &smokingPreference
	return r
}

// Hotel Package Code to filter the search result.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) HotelPackage(hotelPackage []string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.hotelPackage = &hotelPackage
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) YieldMarketCode(yieldMarketCode string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.yieldMarketCode = &yieldMarketCode
	return r
}

// External system code.
func (r AvailabilityApiGetHotelAvailabilityCRORequest) XExternalsystem(xExternalsystem string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiGetHotelAvailabilityCRORequest) AcceptLanguage(acceptLanguage string) AvailabilityApiGetHotelAvailabilityCRORequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiGetHotelAvailabilityCRORequest) Execute() (*HotelAvailability, *http.Response, error) {
	return r.ApiService.GetHotelAvailabilityCROExecute(r)
}

/*
GetHotelAvailabilityCRO Get Hotel Availability

 This API fetches hotel availablity for multiple hotels, given dates, RatePlans, Rate Category, Rate Group, Membership Rates, Number of People. <p><strong>OperationId:</strong>getHotelAvailabilityCRO</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AvailabilityApiGetHotelAvailabilityCRORequest
*/
func (a *AvailabilityApiService) GetHotelAvailabilityCRO(ctx context.Context) AvailabilityApiGetHotelAvailabilityCRORequest {
	return AvailabilityApiGetHotelAvailabilityCRORequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HotelAvailability
func (a *AvailabilityApiService) GetHotelAvailabilityCROExecute(r AvailabilityApiGetHotelAvailabilityCRORequest) (*HotelAvailability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.GetHotelAvailabilityCRO")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/availability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cro != nil {
		t := *r.cro
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cro", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cro", t, "multi")
		}
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeClosedRates != nil {
		t := *r.includeClosedRates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includeClosedRates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includeClosedRates", t, "multi")
		}
	}
	if r.includeDefaultRatePlanSet != nil {
		t := *r.includeDefaultRatePlanSet
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includeDefaultRatePlanSet", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includeDefaultRatePlanSet", t, "multi")
		}
	}
	if r.initialRatePlanSet != nil {
		t := *r.initialRatePlanSet
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "initialRatePlanSet", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "initialRatePlanSet", t, "multi")
		}
	}
	if r.limit != nil {
		t := *r.limit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "limit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "limit", t, "multi")
		}
	}
	if r.pagePointerKey != nil {
		t := *r.pagePointerKey
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pagePointerKey", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pagePointerKey", t, "multi")
		}
	}
	if r.ratePlanSet != nil {
		t := *r.ratePlanSet
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanSet", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanSet", t, "multi")
		}
	}
	if r.redeemAwards != nil {
		t := *r.redeemAwards
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "redeemAwards", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "redeemAwards", t, "multi")
		}
	}
	if r.roomStayStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomStayStartDate", r.roomStayStartDate, "")
	}
	if r.roomStayEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomStayEndDate", r.roomStayEndDate, "")
	}
	if r.roomStayQuantity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomStayQuantity", r.roomStayQuantity, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.childAge != nil {
		t := *r.childAge
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", t, "multi")
		}
	}
	if r.bucket1Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket1Count", r.bucket1Count, "")
	}
	if r.bucket2Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket2Count", r.bucket2Count, "")
	}
	if r.bucket3Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket3Count", r.bucket3Count, "")
	}
	if r.bucket4Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket4Count", r.bucket4Count, "")
	}
	if r.bucket5Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket5Count", r.bucket5Count, "")
	}
	if r.fullStayTimeSpanStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fullStayTimeSpanStartDate", r.fullStayTimeSpanStartDate, "")
	}
	if r.fullStayTimeSpanEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fullStayTimeSpanEndDate", r.fullStayTimeSpanEndDate, "")
	}
	if r.prevailingRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prevailingRate", r.prevailingRate, "")
	}
	if r.rateCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", r.rateCategory, "")
	}
	if r.rateClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateClass", r.rateClass, "")
	}
	if r.rateGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateGroup", r.rateGroup, "")
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	if r.promotionCode != nil {
		t := *r.promotionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.feature != nil {
		t := *r.feature
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feature", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feature", t, "multi")
		}
	}
	if r.reservationGuestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestId", r.reservationGuestId, "")
	}
	if r.reservationGuestIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestIdType", r.reservationGuestIdType, "")
	}
	if r.reservationProfileType != nil {
		t := *r.reservationProfileType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProfileType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProfileType", t, "multi")
		}
	}
	if r.attachedProfileId != nil {
		t := *r.attachedProfileId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", t, "multi")
		}
	}
	if r.hotelReservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelReservationId", r.hotelReservationId, "")
	}
	if r.hotelReservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelReservationIdType", r.hotelReservationIdType, "")
	}
	if r.ratePlanInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanInfo", r.ratePlanInfo, "")
	}
	if r.returnOnlyAvailableRateCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnOnlyAvailableRateCodes", r.returnOnlyAvailableRateCodes, "")
	}
	if r.resGuaranteeInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resGuaranteeInfo", r.resGuaranteeInfo, "")
	}
	if r.roomTypeInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeInfo", r.roomTypeInfo, "")
	}
	if r.membershipIdNumber != nil {
		t := *r.membershipIdNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipIdNumber", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipIdNumber", t, "multi")
		}
	}
	if r.membershipLevel != nil {
		t := *r.membershipLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevel", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevel", t, "multi")
		}
	}
	if r.membershipType != nil {
		t := *r.membershipType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", t, "multi")
		}
	}
	if r.pointsAvailable != nil {
		t := *r.pointsAvailable
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pointsAvailable", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pointsAvailable", t, "multi")
		}
	}
	if r.smokingPreference != nil {
		t := *r.smokingPreference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "smokingPreference", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "smokingPreference", t, "multi")
		}
	}
	if r.hotelPackage != nil {
		t := *r.hotelPackage
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelPackage", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelPackage", t, "multi")
		}
	}
	if r.yieldMarketCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "yieldMarketCode", r.yieldMarketCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiGetHotelsRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	cro *string
	limit *int32
	startDate *string
	endDate *string
	quantity *int32
	adults *int32
	children *int32
	alternateHotels *bool
	hotelId *[]string
	regionCode *string
	city *[]string
	hotelType *[]string
	hotelAmenity *[]string
	attraction *[]string
	hotelPackage *[]string
	prevailingRate *bool
	rateCategory *string
	rateClass *string
	rateGroup *string
	ratePlanCode *[]string
	ratePlanId *[]string
	promotionCode *[]string
	roomType *[]string
	roomClass *[]string
	bedType *[]string
	feature *[]string
	reservationGuestId *string
	reservationGuestIdType *string
	reservationProfileType *[]string
	id *[]string
	currencyExchangeRates *bool
	ratePlanInfo *bool
	resGuaranteeInfo *bool
	returnAllRates *bool
	roomTypeInfo *bool
	sellMessages *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiGetHotelsRequest) Authorization(authorization string) AvailabilityApiGetHotelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiGetHotelsRequest) XAppKey(xAppKey string) AvailabilityApiGetHotelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiGetHotelsRequest) XHotelid(xHotelid string) AvailabilityApiGetHotelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Central Reservation Office Code who is conducting the search. This will search only hotels handled by the CRO.
func (r AvailabilityApiGetHotelsRequest) Cro(cro string) AvailabilityApiGetHotelsRequest {
	r.cro = &cro
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r AvailabilityApiGetHotelsRequest) Limit(limit int32) AvailabilityApiGetHotelsRequest {
	r.limit = &limit
	return r
}

func (r AvailabilityApiGetHotelsRequest) StartDate(startDate string) AvailabilityApiGetHotelsRequest {
	r.startDate = &startDate
	return r
}

func (r AvailabilityApiGetHotelsRequest) EndDate(endDate string) AvailabilityApiGetHotelsRequest {
	r.endDate = &endDate
	return r
}

func (r AvailabilityApiGetHotelsRequest) Quantity(quantity int32) AvailabilityApiGetHotelsRequest {
	r.quantity = &quantity
	return r
}

// Defines the number of Adults.
func (r AvailabilityApiGetHotelsRequest) Adults(adults int32) AvailabilityApiGetHotelsRequest {
	r.adults = &adults
	return r
}

// Defines the number of Children.
func (r AvailabilityApiGetHotelsRequest) Children(children int32) AvailabilityApiGetHotelsRequest {
	r.children = &children
	return r
}

// If true or not specified Alternate Hotels will be returned in the result. To search specific hotels send it false.
func (r AvailabilityApiGetHotelsRequest) AlternateHotels(alternateHotels bool) AvailabilityApiGetHotelsRequest {
	r.alternateHotels = &alternateHotels
	return r
}

// Hotel Code to be searched.
func (r AvailabilityApiGetHotelsRequest) HotelId(hotelId []string) AvailabilityApiGetHotelsRequest {
	r.hotelId = &hotelId
	return r
}

// Region Code where the given cities are located.
func (r AvailabilityApiGetHotelsRequest) RegionCode(regionCode string) AvailabilityApiGetHotelsRequest {
	r.regionCode = &regionCode
	return r
}

// City Code to filter the search result.
func (r AvailabilityApiGetHotelsRequest) City(city []string) AvailabilityApiGetHotelsRequest {
	r.city = &city
	return r
}

// Hotel Type to filter the search result.
func (r AvailabilityApiGetHotelsRequest) HotelType(hotelType []string) AvailabilityApiGetHotelsRequest {
	r.hotelType = &hotelType
	return r
}

// Hotel Amenity Code to filter the search result.
func (r AvailabilityApiGetHotelsRequest) HotelAmenity(hotelAmenity []string) AvailabilityApiGetHotelsRequest {
	r.hotelAmenity = &hotelAmenity
	return r
}

// Attaction Code to filter the search result.
func (r AvailabilityApiGetHotelsRequest) Attraction(attraction []string) AvailabilityApiGetHotelsRequest {
	r.attraction = &attraction
	return r
}

// Hotel Package Code to filter the search result.
func (r AvailabilityApiGetHotelsRequest) HotelPackage(hotelPackage []string) AvailabilityApiGetHotelsRequest {
	r.hotelPackage = &hotelPackage
	return r
}

func (r AvailabilityApiGetHotelsRequest) PrevailingRate(prevailingRate bool) AvailabilityApiGetHotelsRequest {
	r.prevailingRate = &prevailingRate
	return r
}

func (r AvailabilityApiGetHotelsRequest) RateCategory(rateCategory string) AvailabilityApiGetHotelsRequest {
	r.rateCategory = &rateCategory
	return r
}

func (r AvailabilityApiGetHotelsRequest) RateClass(rateClass string) AvailabilityApiGetHotelsRequest {
	r.rateClass = &rateClass
	return r
}

func (r AvailabilityApiGetHotelsRequest) RateGroup(rateGroup string) AvailabilityApiGetHotelsRequest {
	r.rateGroup = &rateGroup
	return r
}

func (r AvailabilityApiGetHotelsRequest) RatePlanCode(ratePlanCode []string) AvailabilityApiGetHotelsRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

func (r AvailabilityApiGetHotelsRequest) RatePlanId(ratePlanId []string) AvailabilityApiGetHotelsRequest {
	r.ratePlanId = &ratePlanId
	return r
}

// Promotion code associated with the rate plan.
func (r AvailabilityApiGetHotelsRequest) PromotionCode(promotionCode []string) AvailabilityApiGetHotelsRequest {
	r.promotionCode = &promotionCode
	return r
}

func (r AvailabilityApiGetHotelsRequest) RoomType(roomType []string) AvailabilityApiGetHotelsRequest {
	r.roomType = &roomType
	return r
}

func (r AvailabilityApiGetHotelsRequest) RoomClass(roomClass []string) AvailabilityApiGetHotelsRequest {
	r.roomClass = &roomClass
	return r
}

func (r AvailabilityApiGetHotelsRequest) BedType(bedType []string) AvailabilityApiGetHotelsRequest {
	r.bedType = &bedType
	return r
}

func (r AvailabilityApiGetHotelsRequest) Feature(feature []string) AvailabilityApiGetHotelsRequest {
	r.feature = &feature
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetHotelsRequest) ReservationGuestId(reservationGuestId string) AvailabilityApiGetHotelsRequest {
	r.reservationGuestId = &reservationGuestId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AvailabilityApiGetHotelsRequest) ReservationGuestIdType(reservationGuestIdType string) AvailabilityApiGetHotelsRequest {
	r.reservationGuestIdType = &reservationGuestIdType
	return r
}

func (r AvailabilityApiGetHotelsRequest) ReservationProfileType(reservationProfileType []string) AvailabilityApiGetHotelsRequest {
	r.reservationProfileType = &reservationProfileType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetHotelsRequest) Id(id []string) AvailabilityApiGetHotelsRequest {
	r.id = &id
	return r
}

// If true Currency Exchange Rates information will be included in the response.
func (r AvailabilityApiGetHotelsRequest) CurrencyExchangeRates(currencyExchangeRates bool) AvailabilityApiGetHotelsRequest {
	r.currencyExchangeRates = &currencyExchangeRates
	return r
}

// If true Rate Plan Code Master information will be included in the response.
func (r AvailabilityApiGetHotelsRequest) RatePlanInfo(ratePlanInfo bool) AvailabilityApiGetHotelsRequest {
	r.ratePlanInfo = &ratePlanInfo
	return r
}

// If true Guarantee Code information will be fetched with Rate Code Information. This attribute is only effective when RatePlanInfo is true.
func (r AvailabilityApiGetHotelsRequest) ResGuaranteeInfo(resGuaranteeInfo bool) AvailabilityApiGetHotelsRequest {
	r.resGuaranteeInfo = &resGuaranteeInfo
	return r
}

// Indicates whether to return only &#39;Requested&#39; rate codes or &#39;All&#39; rate codes. The default value is true which means all available ratecodes will be returned.
func (r AvailabilityApiGetHotelsRequest) ReturnAllRates(returnAllRates bool) AvailabilityApiGetHotelsRequest {
	r.returnAllRates = &returnAllRates
	return r
}

// If true Room Type Master information will be included in the response.
func (r AvailabilityApiGetHotelsRequest) RoomTypeInfo(roomTypeInfo bool) AvailabilityApiGetHotelsRequest {
	r.roomTypeInfo = &roomTypeInfo
	return r
}

// If true Sell Messages information will be included in the response.
func (r AvailabilityApiGetHotelsRequest) SellMessages(sellMessages bool) AvailabilityApiGetHotelsRequest {
	r.sellMessages = &sellMessages
	return r
}

// External system code.
func (r AvailabilityApiGetHotelsRequest) XExternalsystem(xExternalsystem string) AvailabilityApiGetHotelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiGetHotelsRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiGetHotelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiGetHotelsRequest) Execute() (*SearchHotelsDetails, *http.Response, error) {
	return r.ApiService.GetHotelsExecute(r)
}

/*
GetHotels Search hotels for the sales process

This API is to search hotels for the sales process. <p><strong>OperationId:</strong>getHotels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AvailabilityApiGetHotelsRequest
*/
func (a *AvailabilityApiService) GetHotels(ctx context.Context) AvailabilityApiGetHotelsRequest {
	return AvailabilityApiGetHotelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchHotelsDetails
func (a *AvailabilityApiService) GetHotelsExecute(r AvailabilityApiGetHotelsRequest) (*SearchHotelsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchHotelsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.GetHotels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cro != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cro", r.cro, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quantity", r.quantity, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.alternateHotels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alternateHotels", r.alternateHotels, "")
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.regionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regionCode", r.regionCode, "")
	}
	if r.city != nil {
		t := *r.city
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "city", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "city", t, "multi")
		}
	}
	if r.hotelType != nil {
		t := *r.hotelType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelType", t, "multi")
		}
	}
	if r.hotelAmenity != nil {
		t := *r.hotelAmenity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelAmenity", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelAmenity", t, "multi")
		}
	}
	if r.attraction != nil {
		t := *r.attraction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attraction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attraction", t, "multi")
		}
	}
	if r.hotelPackage != nil {
		t := *r.hotelPackage
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelPackage", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelPackage", t, "multi")
		}
	}
	if r.prevailingRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prevailingRate", r.prevailingRate, "")
	}
	if r.rateCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", r.rateCategory, "")
	}
	if r.rateClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateClass", r.rateClass, "")
	}
	if r.rateGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateGroup", r.rateGroup, "")
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	if r.ratePlanId != nil {
		t := *r.ratePlanId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanId", t, "multi")
		}
	}
	if r.promotionCode != nil {
		t := *r.promotionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.bedType != nil {
		t := *r.bedType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bedType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bedType", t, "multi")
		}
	}
	if r.feature != nil {
		t := *r.feature
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "feature", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "feature", t, "multi")
		}
	}
	if r.reservationGuestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestId", r.reservationGuestId, "")
	}
	if r.reservationGuestIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestIdType", r.reservationGuestIdType, "")
	}
	if r.reservationProfileType != nil {
		t := *r.reservationProfileType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProfileType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProfileType", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.currencyExchangeRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyExchangeRates", r.currencyExchangeRates, "")
	}
	if r.ratePlanInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanInfo", r.ratePlanInfo, "")
	}
	if r.resGuaranteeInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resGuaranteeInfo", r.resGuaranteeInfo, "")
	}
	if r.returnAllRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnAllRates", r.returnAllRates, "")
	}
	if r.roomTypeInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeInfo", r.roomTypeInfo, "")
	}
	if r.sellMessages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellMessages", r.sellMessages, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiGetHurdleRatesRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	hurdleDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	limit *int32
	roomTypesCode *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Date criteria for which the hurdle rate is scheduled.
func (r AvailabilityApiGetHurdleRatesRequest) HurdleDate(hurdleDate string) AvailabilityApiGetHurdleRatesRequest {
	r.hurdleDate = &hurdleDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiGetHurdleRatesRequest) Authorization(authorization string) AvailabilityApiGetHurdleRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiGetHurdleRatesRequest) XAppKey(xAppKey string) AvailabilityApiGetHurdleRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiGetHurdleRatesRequest) XHotelid(xHotelid string) AvailabilityApiGetHurdleRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r AvailabilityApiGetHurdleRatesRequest) HotelIds(hotelIds []string) AvailabilityApiGetHurdleRatesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r AvailabilityApiGetHurdleRatesRequest) Limit(limit int32) AvailabilityApiGetHurdleRatesRequest {
	r.limit = &limit
	return r
}

// Codes to be searched.
func (r AvailabilityApiGetHurdleRatesRequest) RoomTypesCode(roomTypesCode []string) AvailabilityApiGetHurdleRatesRequest {
	r.roomTypesCode = &roomTypesCode
	return r
}

// Wildcard search on the code.
func (r AvailabilityApiGetHurdleRatesRequest) WildCard(wildCard string) AvailabilityApiGetHurdleRatesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r AvailabilityApiGetHurdleRatesRequest) XExternalsystem(xExternalsystem string) AvailabilityApiGetHurdleRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiGetHurdleRatesRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiGetHurdleRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiGetHurdleRatesRequest) Execute() (*HurdleRates, *http.Response, error) {
	return r.ApiService.GetHurdleRatesExecute(r)
}

/*
GetHurdleRates Get Hurdle Rates

This API allows to fetch existing Hurdle Rates. <p><strong>OperationId:</strong>getHurdleRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiGetHurdleRatesRequest
*/
func (a *AvailabilityApiService) GetHurdleRates(ctx context.Context, hotelId string) AvailabilityApiGetHurdleRatesRequest {
	return AvailabilityApiGetHurdleRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HurdleRates
func (a *AvailabilityApiService) GetHurdleRatesExecute(r AvailabilityApiGetHurdleRatesRequest) (*HurdleRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HurdleRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.GetHurdleRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/hurdles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "hurdleDate", r.hurdleDate, "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.roomTypesCode != nil {
		t := *r.roomTypesCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypesCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypesCode", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiGetReservationGuaranteesRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	arrivalDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanCode *string
	blockId *string
	reservationGuestId *string
	companyId *string
	travelAgentId *string
	sourceId *string
	groupId *string
	guaranteeCode *string
	calculateEstimateAmount *bool
	startDate *string
	endDate *string
	numberOfRooms *int32
	numberOfAdults *int32
	numberOfChildren *int32
	roomType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Arrival Date of the guest.
func (r AvailabilityApiGetReservationGuaranteesRequest) ArrivalDate(arrivalDate string) AvailabilityApiGetReservationGuaranteesRequest {
	r.arrivalDate = &arrivalDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiGetReservationGuaranteesRequest) Authorization(authorization string) AvailabilityApiGetReservationGuaranteesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiGetReservationGuaranteesRequest) XAppKey(xAppKey string) AvailabilityApiGetReservationGuaranteesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiGetReservationGuaranteesRequest) XHotelid(xHotelid string) AvailabilityApiGetReservationGuaranteesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Rate Plan Code to find associated Guarantee Codes.
func (r AvailabilityApiGetReservationGuaranteesRequest) RatePlanCode(ratePlanCode string) AvailabilityApiGetReservationGuaranteesRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetReservationGuaranteesRequest) BlockId(blockId string) AvailabilityApiGetReservationGuaranteesRequest {
	r.blockId = &blockId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetReservationGuaranteesRequest) ReservationGuestId(reservationGuestId string) AvailabilityApiGetReservationGuaranteesRequest {
	r.reservationGuestId = &reservationGuestId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetReservationGuaranteesRequest) CompanyId(companyId string) AvailabilityApiGetReservationGuaranteesRequest {
	r.companyId = &companyId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetReservationGuaranteesRequest) TravelAgentId(travelAgentId string) AvailabilityApiGetReservationGuaranteesRequest {
	r.travelAgentId = &travelAgentId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetReservationGuaranteesRequest) SourceId(sourceId string) AvailabilityApiGetReservationGuaranteesRequest {
	r.sourceId = &sourceId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AvailabilityApiGetReservationGuaranteesRequest) GroupId(groupId string) AvailabilityApiGetReservationGuaranteesRequest {
	r.groupId = &groupId
	return r
}

// Guarantee Code should be supplied only for the code verification purpose, if the supplied code is valid for the rest of the criteria it will return the response with the Guarantee Code information.
func (r AvailabilityApiGetReservationGuaranteesRequest) GuaranteeCode(guaranteeCode string) AvailabilityApiGetReservationGuaranteesRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// Determines whether estimated amount to be calculated or not
func (r AvailabilityApiGetReservationGuaranteesRequest) CalculateEstimateAmount(calculateEstimateAmount bool) AvailabilityApiGetReservationGuaranteesRequest {
	r.calculateEstimateAmount = &calculateEstimateAmount
	return r
}

func (r AvailabilityApiGetReservationGuaranteesRequest) StartDate(startDate string) AvailabilityApiGetReservationGuaranteesRequest {
	r.startDate = &startDate
	return r
}

func (r AvailabilityApiGetReservationGuaranteesRequest) EndDate(endDate string) AvailabilityApiGetReservationGuaranteesRequest {
	r.endDate = &endDate
	return r
}

func (r AvailabilityApiGetReservationGuaranteesRequest) NumberOfRooms(numberOfRooms int32) AvailabilityApiGetReservationGuaranteesRequest {
	r.numberOfRooms = &numberOfRooms
	return r
}

// Defines the number of Adults.
func (r AvailabilityApiGetReservationGuaranteesRequest) NumberOfAdults(numberOfAdults int32) AvailabilityApiGetReservationGuaranteesRequest {
	r.numberOfAdults = &numberOfAdults
	return r
}

// Defines the number of Children.
func (r AvailabilityApiGetReservationGuaranteesRequest) NumberOfChildren(numberOfChildren int32) AvailabilityApiGetReservationGuaranteesRequest {
	r.numberOfChildren = &numberOfChildren
	return r
}

// Room Type for the reservation
func (r AvailabilityApiGetReservationGuaranteesRequest) RoomType(roomType string) AvailabilityApiGetReservationGuaranteesRequest {
	r.roomType = &roomType
	return r
}

// External system code.
func (r AvailabilityApiGetReservationGuaranteesRequest) XExternalsystem(xExternalsystem string) AvailabilityApiGetReservationGuaranteesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiGetReservationGuaranteesRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiGetReservationGuaranteesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiGetReservationGuaranteesRequest) Execute() (*ReservationGuaranteesPolicies, *http.Response, error) {
	return r.ApiService.GetReservationGuaranteesExecute(r)
}

/*
GetReservationGuarantees Get reservation guarantees

Use this API to get the required guarantee types in order to complete a booking. The criteria can include the rate plan code, arrival date, guarantee code and the profile information.<p><strong>OperationId:</strong>getReservationGuarantees</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiGetReservationGuaranteesRequest
*/
func (a *AvailabilityApiService) GetReservationGuarantees(ctx context.Context, hotelId string) AvailabilityApiGetReservationGuaranteesRequest {
	return AvailabilityApiGetReservationGuaranteesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationGuaranteesPolicies
func (a *AvailabilityApiService) GetReservationGuaranteesExecute(r AvailabilityApiGetReservationGuaranteesRequest) (*ReservationGuaranteesPolicies, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationGuaranteesPolicies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.GetReservationGuarantees")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/guarantees"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalDate", r.arrivalDate, "")
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	if r.reservationGuestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationGuestId", r.reservationGuestId, "")
	}
	if r.companyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	}
	if r.travelAgentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentId", r.travelAgentId, "")
	}
	if r.sourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceId", r.sourceId, "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "")
	}
	if r.guaranteeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", r.guaranteeCode, "")
	}
	if r.calculateEstimateAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "calculateEstimateAmount", r.calculateEstimateAmount, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.numberOfRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfRooms", r.numberOfRooms, "")
	}
	if r.numberOfAdults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfAdults", r.numberOfAdults, "")
	}
	if r.numberOfChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfChildren", r.numberOfChildren, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiGetRestrictionsByDateRangeRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	chainName *string
	end *string
	fetchSizeByDay *int32
	limit *int32
	restrictionInfo *string
	restrictionSearchCriteriaStartDate *string
	bookingChannelCode *string
	ratePlanCategory *string
	ratePlanCode *string
	roomClass *string
	roomType *string
	filterCodeCategory *string
	filterCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) Authorization(authorization string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) XAppKey(xAppKey string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) XHotelid(xHotelid string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.xHotelid = &xHotelid
	return r
}

// The name of the hotel chain (e.g., Hilton, Marriott, Hyatt).
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) ChainName(chainName string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.chainName = &chainName
	return r
}

// The ending value of the date range.
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) End(end string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.end = &end
	return r
}

// Defines the maximum amount of restrictions by day.
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) FetchSizeByDay(fetchSizeByDay int32) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.fetchSizeByDay = &fetchSizeByDay
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) Limit(limit int32) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.limit = &limit
	return r
}

func (r AvailabilityApiGetRestrictionsByDateRangeRequest) RestrictionInfo(restrictionInfo string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.restrictionInfo = &restrictionInfo
	return r
}

// The starting value of the date range.
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) RestrictionSearchCriteriaStartDate(restrictionSearchCriteriaStartDate string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.restrictionSearchCriteriaStartDate = &restrictionSearchCriteriaStartDate
	return r
}

// Indicates restriction is applicable to specified Booking Channel Code in conjunction with other codes, if specified.
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) BookingChannelCode(bookingChannelCode string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

// Indicates restriction is applicable to specified Rate Plan Category in conjunction with other codes, if specified.
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) RatePlanCategory(ratePlanCategory string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.ratePlanCategory = &ratePlanCategory
	return r
}

// Indicates restriction is applicable to specified Rate Plan Code in conjunction with other codes, if specified.
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) RatePlanCode(ratePlanCode string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Indicates restriction is applicable to specified Room Category in conjunction with other codes, if specified.
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) RoomClass(roomClass string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.roomClass = &roomClass
	return r
}

// Indicates restriction is applicable to specified Room Type in conjunction with other codes, if specified.
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) RoomType(roomType string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.roomType = &roomType
	return r
}

// An enumerated type defining the Filter Code Categort or Type. Values: BookingChannelCode, RoomClass, RoomType, RatePlanCategory, RatePlanCode.
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) FilterCodeCategory(filterCodeCategory string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.filterCodeCategory = &filterCodeCategory
	return r
}

// Defines BookingChannelCode, RoomClass, RoomType, RatePlanCategory or RatePlanCode to filter the Restriction.
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) FilterCode(filterCode []string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.filterCode = &filterCode
	return r
}

// External system code.
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) XExternalsystem(xExternalsystem string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiGetRestrictionsByDateRangeRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiGetRestrictionsByDateRangeRequest) Execute() (*RestrictionsByDateRange, *http.Response, error) {
	return r.ApiService.GetRestrictionsByDateRangeExecute(r)
}

/*
GetRestrictionsByDateRange Get hotel restrictions

Use this API to get the Restrictions for a hotel in given date range. The search criteria can include filter codes or restriction control types, date range and the hotel information.<p><strong>OperationId:</strong>getRestrictionsByDateRange</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiGetRestrictionsByDateRangeRequest
*/
func (a *AvailabilityApiService) GetRestrictionsByDateRange(ctx context.Context, hotelId string) AvailabilityApiGetRestrictionsByDateRangeRequest {
	return AvailabilityApiGetRestrictionsByDateRangeRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RestrictionsByDateRange
func (a *AvailabilityApiService) GetRestrictionsByDateRangeExecute(r AvailabilityApiGetRestrictionsByDateRangeRequest) (*RestrictionsByDateRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestrictionsByDateRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.GetRestrictionsByDateRange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/restrictions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.chainName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainName", r.chainName, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.fetchSizeByDay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchSizeByDay", r.fetchSizeByDay, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.restrictionInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "restrictionInfo", r.restrictionInfo, "")
	}
	if r.restrictionSearchCriteriaStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "restrictionSearchCriteriaStartDate", r.restrictionSearchCriteriaStartDate, "")
	}
	if r.bookingChannelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", r.bookingChannelCode, "")
	}
	if r.ratePlanCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCategory", r.ratePlanCategory, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.roomClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", r.roomClass, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	if r.filterCodeCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterCodeCategory", r.filterCodeCategory, "")
	}
	if r.filterCode != nil {
		t := *r.filterCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiGetRestrictionsHistoryRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	chainName *string
	date *string
	bookingChannelCode *string
	ratePlanCategory *string
	ratePlanCode *string
	roomClass *string
	roomType *string
	filterCodeCategory *string
	filterCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiGetRestrictionsHistoryRequest) Authorization(authorization string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiGetRestrictionsHistoryRequest) XAppKey(xAppKey string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiGetRestrictionsHistoryRequest) XHotelid(xHotelid string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// The name of the hotel chain (e.g., Hilton, Marriott, Hyatt).
func (r AvailabilityApiGetRestrictionsHistoryRequest) ChainName(chainName string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.chainName = &chainName
	return r
}

func (r AvailabilityApiGetRestrictionsHistoryRequest) Date(date string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.date = &date
	return r
}

// Indicates restriction is applicable to specified Booking Channel Code in conjunction with other codes, if specified.
func (r AvailabilityApiGetRestrictionsHistoryRequest) BookingChannelCode(bookingChannelCode string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

// Indicates restriction is applicable to specified Rate Plan Category in conjunction with other codes, if specified.
func (r AvailabilityApiGetRestrictionsHistoryRequest) RatePlanCategory(ratePlanCategory string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.ratePlanCategory = &ratePlanCategory
	return r
}

// Indicates restriction is applicable to specified Rate Plan Code in conjunction with other codes, if specified.
func (r AvailabilityApiGetRestrictionsHistoryRequest) RatePlanCode(ratePlanCode string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Indicates restriction is applicable to specified Room Category in conjunction with other codes, if specified.
func (r AvailabilityApiGetRestrictionsHistoryRequest) RoomClass(roomClass string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.roomClass = &roomClass
	return r
}

// Indicates restriction is applicable to specified Room Type in conjunction with other codes, if specified.
func (r AvailabilityApiGetRestrictionsHistoryRequest) RoomType(roomType string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.roomType = &roomType
	return r
}

// An enumerated type defining the Filter Code Categort or Type. Values: BookingChannelCode, RoomClass, RoomType, RatePlanCategory, RatePlanCode.
func (r AvailabilityApiGetRestrictionsHistoryRequest) FilterCodeCategory(filterCodeCategory string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.filterCodeCategory = &filterCodeCategory
	return r
}

// Defines BookingChannelCode, RoomClass, RoomType, RatePlanCategory or RatePlanCode to filter the Restriction.
func (r AvailabilityApiGetRestrictionsHistoryRequest) FilterCode(filterCode []string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.filterCode = &filterCode
	return r
}

// External system code.
func (r AvailabilityApiGetRestrictionsHistoryRequest) XExternalsystem(xExternalsystem string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiGetRestrictionsHistoryRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiGetRestrictionsHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiGetRestrictionsHistoryRequest) Execute() (*RestrictionsHistory, *http.Response, error) {
	return r.ApiService.GetRestrictionsHistoryExecute(r)
}

/*
GetRestrictionsHistory Get the Restriction history 

This API allows to fetch the Restriction history. Specify filter codes or restriction control types. The date range can be passed as part of the request. <p><strong>OperationId:</strong>getRestrictionsHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiGetRestrictionsHistoryRequest
*/
func (a *AvailabilityApiService) GetRestrictionsHistory(ctx context.Context, hotelId string) AvailabilityApiGetRestrictionsHistoryRequest {
	return AvailabilityApiGetRestrictionsHistoryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RestrictionsHistory
func (a *AvailabilityApiService) GetRestrictionsHistoryExecute(r AvailabilityApiGetRestrictionsHistoryRequest) (*RestrictionsHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestrictionsHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.GetRestrictionsHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/restrictionsHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.chainName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainName", r.chainName, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.bookingChannelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", r.bookingChannelCode, "")
	}
	if r.ratePlanCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCategory", r.ratePlanCategory, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.roomClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", r.roomClass, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	if r.filterCodeCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterCodeCategory", r.filterCodeCategory, "")
	}
	if r.filterCode != nil {
		t := *r.filterCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiPostHurdleRatesRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createHurdleRates *PostHurdleRatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiPostHurdleRatesRequest) Authorization(authorization string) AvailabilityApiPostHurdleRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiPostHurdleRatesRequest) XAppKey(xAppKey string) AvailabilityApiPostHurdleRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiPostHurdleRatesRequest) XHotelid(xHotelid string) AvailabilityApiPostHurdleRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Hurdle Rates.
func (r AvailabilityApiPostHurdleRatesRequest) CreateHurdleRates(createHurdleRates PostHurdleRatesRequest) AvailabilityApiPostHurdleRatesRequest {
	r.createHurdleRates = &createHurdleRates
	return r
}

// External system code.
func (r AvailabilityApiPostHurdleRatesRequest) XExternalsystem(xExternalsystem string) AvailabilityApiPostHurdleRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiPostHurdleRatesRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiPostHurdleRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiPostHurdleRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHurdleRatesExecute(r)
}

/*
PostHurdleRates Create Hurdle Rates

This API allows to create hurdle rates. <p><strong>OperationId:</strong>postHurdleRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiPostHurdleRatesRequest
*/
func (a *AvailabilityApiService) PostHurdleRates(ctx context.Context, hotelId string) AvailabilityApiPostHurdleRatesRequest {
	return AvailabilityApiPostHurdleRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AvailabilityApiService) PostHurdleRatesExecute(r AvailabilityApiPostHurdleRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.PostHurdleRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/hurdles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createHurdleRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiPostRestrictionRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createRestriction *PostRestrictionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiPostRestrictionRequest) Authorization(authorization string) AvailabilityApiPostRestrictionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiPostRestrictionRequest) XAppKey(xAppKey string) AvailabilityApiPostRestrictionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiPostRestrictionRequest) XHotelid(xHotelid string) AvailabilityApiPostRestrictionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new restriction.
func (r AvailabilityApiPostRestrictionRequest) CreateRestriction(createRestriction PostRestrictionRequest) AvailabilityApiPostRestrictionRequest {
	r.createRestriction = &createRestriction
	return r
}

// External system code.
func (r AvailabilityApiPostRestrictionRequest) XExternalsystem(xExternalsystem string) AvailabilityApiPostRestrictionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiPostRestrictionRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiPostRestrictionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiPostRestrictionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRestrictionExecute(r)
}

/*
PostRestriction Create a restriction

Use this API to create restrictions on various levels such as house level, rate class, rate category, rate plan, room class, room type, and booking channel code.<p><strong>OperationId:</strong>postRestriction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiPostRestrictionRequest
*/
func (a *AvailabilityApiService) PostRestriction(ctx context.Context, hotelId string) AvailabilityApiPostRestrictionRequest {
	return AvailabilityApiPostRestrictionRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AvailabilityApiService) PostRestrictionExecute(r AvailabilityApiPostRestrictionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.PostRestriction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/restrictions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createRestriction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiPutHurdleRatesRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeHurdleRates *PutHurdleRatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiPutHurdleRatesRequest) Authorization(authorization string) AvailabilityApiPutHurdleRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiPutHurdleRatesRequest) XAppKey(xAppKey string) AvailabilityApiPutHurdleRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiPutHurdleRatesRequest) XHotelid(xHotelid string) AvailabilityApiPutHurdleRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Hurdle Rates.
func (r AvailabilityApiPutHurdleRatesRequest) ChangeHurdleRates(changeHurdleRates PutHurdleRatesRequest) AvailabilityApiPutHurdleRatesRequest {
	r.changeHurdleRates = &changeHurdleRates
	return r
}

// External system code.
func (r AvailabilityApiPutHurdleRatesRequest) XExternalsystem(xExternalsystem string) AvailabilityApiPutHurdleRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiPutHurdleRatesRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiPutHurdleRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiPutHurdleRatesRequest) Execute() (*ChangeHurdleRatesDetails, *http.Response, error) {
	return r.ApiService.PutHurdleRatesExecute(r)
}

/*
PutHurdleRates Change Hurdle Rates

This API allows to update an existing Hurdle Rate. <p><strong>OperationId:</strong>putHurdleRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiPutHurdleRatesRequest
*/
func (a *AvailabilityApiService) PutHurdleRates(ctx context.Context, hotelId string) AvailabilityApiPutHurdleRatesRequest {
	return AvailabilityApiPutHurdleRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangeHurdleRatesDetails
func (a *AvailabilityApiService) PutHurdleRatesExecute(r AvailabilityApiPutHurdleRatesRequest) (*ChangeHurdleRatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeHurdleRatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.PutHurdleRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/hurdles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeHurdleRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AvailabilityApiValidateReservationGuaranteesRequest struct {
	ctx context.Context
	ApiService *AvailabilityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	validateReservationGuarantees *ValidateReservationGuaranteesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AvailabilityApiValidateReservationGuaranteesRequest) Authorization(authorization string) AvailabilityApiValidateReservationGuaranteesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AvailabilityApiValidateReservationGuaranteesRequest) XAppKey(xAppKey string) AvailabilityApiValidateReservationGuaranteesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AvailabilityApiValidateReservationGuaranteesRequest) XHotelid(xHotelid string) AvailabilityApiValidateReservationGuaranteesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to fetch reservation guarantees.
func (r AvailabilityApiValidateReservationGuaranteesRequest) ValidateReservationGuarantees(validateReservationGuarantees ValidateReservationGuaranteesRequest) AvailabilityApiValidateReservationGuaranteesRequest {
	r.validateReservationGuarantees = &validateReservationGuarantees
	return r
}

// External system code.
func (r AvailabilityApiValidateReservationGuaranteesRequest) XExternalsystem(xExternalsystem string) AvailabilityApiValidateReservationGuaranteesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AvailabilityApiValidateReservationGuaranteesRequest) AcceptLanguage(acceptLanguage string) AvailabilityApiValidateReservationGuaranteesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AvailabilityApiValidateReservationGuaranteesRequest) Execute() (*ReservationGuaranteesPolicies, *http.Response, error) {
	return r.ApiService.ValidateReservationGuaranteesExecute(r)
}

/*
ValidateReservationGuarantees Get Reservation Guarantee 

This API allows to Fetch Reservation Guarantee. The criteria can include the rate plan code, arrival date, guarantee code and the profile information.  <p><strong>OperationId:</strong>validateReservationGuarantees</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return AvailabilityApiValidateReservationGuaranteesRequest
*/
func (a *AvailabilityApiService) ValidateReservationGuarantees(ctx context.Context, hotelId string) AvailabilityApiValidateReservationGuaranteesRequest {
	return AvailabilityApiValidateReservationGuaranteesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationGuaranteesPolicies
func (a *AvailabilityApiService) ValidateReservationGuaranteesExecute(r AvailabilityApiValidateReservationGuaranteesRequest) (*ReservationGuaranteesPolicies, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationGuaranteesPolicies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailabilityApiService.ValidateReservationGuarantees")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/validateGuarantees"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.validateReservationGuarantees
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
