/*
OPERA Cloud Channel Configuration API

APIs to cater for Channel Management functionality in OPERA Cloud. <br /><br /> Channel Management allows a property to configure and administer channels such as OTAs, and web channels, covering functionality such as channel configuration, availability, inventory and restrictions.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package chl

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ChannelApiService ChannelApi service
type ChannelApiService service

type ChannelApiCopyChannelAccountContractsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelAccountContractsCopy *CopyChannelAccountContractsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiCopyChannelAccountContractsRequest) Authorization(authorization string) ChannelApiCopyChannelAccountContractsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiCopyChannelAccountContractsRequest) XAppKey(xAppKey string) ChannelApiCopyChannelAccountContractsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiCopyChannelAccountContractsRequest) XHotelid(xHotelid string) ChannelApiCopyChannelAccountContractsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to copy the channel account contract and create a new contract.
func (r ChannelApiCopyChannelAccountContractsRequest) ChannelAccountContractsCopy(channelAccountContractsCopy CopyChannelAccountContractsRequest) ChannelApiCopyChannelAccountContractsRequest {
	r.channelAccountContractsCopy = &channelAccountContractsCopy
	return r
}

// External system code.
func (r ChannelApiCopyChannelAccountContractsRequest) XExternalsystem(xExternalsystem string) ChannelApiCopyChannelAccountContractsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiCopyChannelAccountContractsRequest) AcceptLanguage(acceptLanguage string) ChannelApiCopyChannelAccountContractsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiCopyChannelAccountContractsRequest) Execute() (*ChannelAccountContractsDetailsCopy, *http.Response, error) {
	return r.ApiService.CopyChannelAccountContractsExecute(r)
}

/*
CopyChannelAccountContracts Creates copy of channel account contracts

This API creates copy of channel account contracts. <p><strong>OperationId:</strong>copyChannelAccountContracts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiCopyChannelAccountContractsRequest
*/
func (a *ChannelApiService) CopyChannelAccountContracts(ctx context.Context) ChannelApiCopyChannelAccountContractsRequest {
	return ChannelApiCopyChannelAccountContractsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelAccountContractsDetailsCopy
func (a *ChannelApiService) CopyChannelAccountContractsExecute(r ChannelApiCopyChannelAccountContractsRequest) (*ChannelAccountContractsDetailsCopy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelAccountContractsDetailsCopy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.CopyChannelAccountContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/account/contracts/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelAccountContractsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiCopyChannelMarketingTextRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelMarketingTextCopy *CopyChannelMarketingTextRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiCopyChannelMarketingTextRequest) Authorization(authorization string) ChannelApiCopyChannelMarketingTextRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiCopyChannelMarketingTextRequest) XAppKey(xAppKey string) ChannelApiCopyChannelMarketingTextRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiCopyChannelMarketingTextRequest) XHotelid(xHotelid string) ChannelApiCopyChannelMarketingTextRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to copy channel marketing texts.
func (r ChannelApiCopyChannelMarketingTextRequest) ChannelMarketingTextCopy(channelMarketingTextCopy CopyChannelMarketingTextRequest) ChannelApiCopyChannelMarketingTextRequest {
	r.channelMarketingTextCopy = &channelMarketingTextCopy
	return r
}

// External system code.
func (r ChannelApiCopyChannelMarketingTextRequest) XExternalsystem(xExternalsystem string) ChannelApiCopyChannelMarketingTextRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiCopyChannelMarketingTextRequest) AcceptLanguage(acceptLanguage string) ChannelApiCopyChannelMarketingTextRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiCopyChannelMarketingTextRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyChannelMarketingTextExecute(r)
}

/*
CopyChannelMarketingText Allows to copy marketing message to another channel and hotel

Use this API to copy one channel's mapping for marketing messages to another channel and hotel mapping. <p><strong>OperationId:</strong>copyChannelMarketingText</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiCopyChannelMarketingTextRequest
*/
func (a *ChannelApiService) CopyChannelMarketingText(ctx context.Context) ChannelApiCopyChannelMarketingTextRequest {
	return ChannelApiCopyChannelMarketingTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) CopyChannelMarketingTextExecute(r ChannelApiCopyChannelMarketingTextRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.CopyChannelMarketingText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/marketingText/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelMarketingTextCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiCopyTotalPricingElementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	totalPricingElementsCopy *CopyTotalPricingElementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiCopyTotalPricingElementsRequest) Authorization(authorization string) ChannelApiCopyTotalPricingElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiCopyTotalPricingElementsRequest) XAppKey(xAppKey string) ChannelApiCopyTotalPricingElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiCopyTotalPricingElementsRequest) XHotelid(xHotelid string) ChannelApiCopyTotalPricingElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to copy the total pricing elements into the target properties.
func (r ChannelApiCopyTotalPricingElementsRequest) TotalPricingElementsCopy(totalPricingElementsCopy CopyTotalPricingElementsRequest) ChannelApiCopyTotalPricingElementsRequest {
	r.totalPricingElementsCopy = &totalPricingElementsCopy
	return r
}

// External system code.
func (r ChannelApiCopyTotalPricingElementsRequest) XExternalsystem(xExternalsystem string) ChannelApiCopyTotalPricingElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiCopyTotalPricingElementsRequest) AcceptLanguage(acceptLanguage string) ChannelApiCopyTotalPricingElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiCopyTotalPricingElementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyTotalPricingElementsExecute(r)
}

/*
CopyTotalPricingElements Allows to copy total pricing tax and fees to another hotel id

Use this API to copy global distribution system's fee and tax configurations from one hotel to another hotel within same chain/tenant <p><strong>OperationId:</strong>copyTotalPricingElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiCopyTotalPricingElementsRequest
*/
func (a *ChannelApiService) CopyTotalPricingElements(ctx context.Context) ChannelApiCopyTotalPricingElementsRequest {
	return ChannelApiCopyTotalPricingElementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) CopyTotalPricingElementsExecute(r ChannelApiCopyTotalPricingElementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.CopyTotalPricingElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/totalPricing/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.totalPricingElementsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteAmenitiesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	systemCode *string
	systemSubType *string
	systemType *string
	systemName *string
	websiteURL *string
	iconURL *string
	localSystemCode *[]string
	externalSystemCode *[]string
	description *[]string
	startDate *string
	endDate *string
	duration *string
	amenityGroup *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteAmenitiesMappingRequest) Authorization(authorization string) ChannelApiDeleteAmenitiesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteAmenitiesMappingRequest) XAppKey(xAppKey string) ChannelApiDeleteAmenitiesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteAmenitiesMappingRequest) XHotelid(xHotelid string) ChannelApiDeleteAmenitiesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether code is inactive or not.
func (r ChannelApiDeleteAmenitiesMappingRequest) Inactive(inactive bool) ChannelApiDeleteAmenitiesMappingRequest {
	r.inactive = &inactive
	return r
}

// External system code such as TRAVELOCITY, EXPEDIA, etc.
func (r ChannelApiDeleteAmenitiesMappingRequest) SystemCode(systemCode string) ChannelApiDeleteAmenitiesMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system subtype such as GDS, WEB, etc.
func (r ChannelApiDeleteAmenitiesMappingRequest) SystemSubType(systemSubType string) ChannelApiDeleteAmenitiesMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system type such as CHANNEL, OXI, etc.
func (r ChannelApiDeleteAmenitiesMappingRequest) SystemType(systemType string) ChannelApiDeleteAmenitiesMappingRequest {
	r.systemType = &systemType
	return r
}

// External system name.
func (r ChannelApiDeleteAmenitiesMappingRequest) SystemName(systemName string) ChannelApiDeleteAmenitiesMappingRequest {
	r.systemName = &systemName
	return r
}

// Cannel Website URL
func (r ChannelApiDeleteAmenitiesMappingRequest) WebsiteURL(websiteURL string) ChannelApiDeleteAmenitiesMappingRequest {
	r.websiteURL = &websiteURL
	return r
}

// Channel Icon URL
func (r ChannelApiDeleteAmenitiesMappingRequest) IconURL(iconURL string) ChannelApiDeleteAmenitiesMappingRequest {
	r.iconURL = &iconURL
	return r
}

// Code used inside the OPERA System
func (r ChannelApiDeleteAmenitiesMappingRequest) LocalSystemCode(localSystemCode []string) ChannelApiDeleteAmenitiesMappingRequest {
	r.localSystemCode = &localSystemCode
	return r
}

// Code used in the External System
func (r ChannelApiDeleteAmenitiesMappingRequest) ExternalSystemCode(externalSystemCode []string) ChannelApiDeleteAmenitiesMappingRequest {
	r.externalSystemCode = &externalSystemCode
	return r
}

// Detailed Description of the given entity.
func (r ChannelApiDeleteAmenitiesMappingRequest) Description(description []string) ChannelApiDeleteAmenitiesMappingRequest {
	r.description = &description
	return r
}

func (r ChannelApiDeleteAmenitiesMappingRequest) StartDate(startDate string) ChannelApiDeleteAmenitiesMappingRequest {
	r.startDate = &startDate
	return r
}

func (r ChannelApiDeleteAmenitiesMappingRequest) EndDate(endDate string) ChannelApiDeleteAmenitiesMappingRequest {
	r.endDate = &endDate
	return r
}

func (r ChannelApiDeleteAmenitiesMappingRequest) Duration(duration string) ChannelApiDeleteAmenitiesMappingRequest {
	r.duration = &duration
	return r
}

// User defined logical group name for the amenities.
func (r ChannelApiDeleteAmenitiesMappingRequest) AmenityGroup(amenityGroup []string) ChannelApiDeleteAmenitiesMappingRequest {
	r.amenityGroup = &amenityGroup
	return r
}

// External system code.
func (r ChannelApiDeleteAmenitiesMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteAmenitiesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteAmenitiesMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteAmenitiesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteAmenitiesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAmenitiesMappingExecute(r)
}

/*
DeleteAmenitiesMapping Deletes channel amenities configuration

Use this API to delete channel amenities mapping <p><strong>OperationId:</strong>deleteAmenitiesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteAmenitiesMappingRequest
*/
func (a *ChannelApiService) DeleteAmenitiesMapping(ctx context.Context) ChannelApiDeleteAmenitiesMappingRequest {
	return ChannelApiDeleteAmenitiesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteAmenitiesMappingExecute(r ChannelApiDeleteAmenitiesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteAmenitiesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/amenities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemName", r.systemName, "")
	}
	if r.websiteURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "websiteURL", r.websiteURL, "")
	}
	if r.iconURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconURL", r.iconURL, "")
	}
	if r.localSystemCode != nil {
		t := *r.localSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", t, "multi")
		}
	}
	if r.externalSystemCode != nil {
		t := *r.externalSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.amenityGroup != nil {
		t := *r.amenityGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amenityGroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amenityGroup", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelAccountContractsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	id1 *[]string
	idExtension1 *[]int32
	idContext1 *[]string
	type1 *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelAccountContractsRequest) Authorization(authorization string) ChannelApiDeleteChannelAccountContractsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelAccountContractsRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelAccountContractsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelAccountContractsRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelAccountContractsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ChannelApiDeleteChannelAccountContractsRequest) Id(id string) ChannelApiDeleteChannelAccountContractsRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ChannelApiDeleteChannelAccountContractsRequest) IdExtension(idExtension int32) ChannelApiDeleteChannelAccountContractsRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ChannelApiDeleteChannelAccountContractsRequest) IdContext(idContext string) ChannelApiDeleteChannelAccountContractsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ChannelApiDeleteChannelAccountContractsRequest) Type_(type_ string) ChannelApiDeleteChannelAccountContractsRequest {
	r.type_ = &type_
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ChannelApiDeleteChannelAccountContractsRequest) Id1(id1 []string) ChannelApiDeleteChannelAccountContractsRequest {
	r.id1 = &id1
	return r
}

// Additional identifying value assigned by the creating system.
func (r ChannelApiDeleteChannelAccountContractsRequest) IdExtension1(idExtension1 []int32) ChannelApiDeleteChannelAccountContractsRequest {
	r.idExtension1 = &idExtension1
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ChannelApiDeleteChannelAccountContractsRequest) IdContext1(idContext1 []string) ChannelApiDeleteChannelAccountContractsRequest {
	r.idContext1 = &idContext1
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ChannelApiDeleteChannelAccountContractsRequest) Type1(type1 []string) ChannelApiDeleteChannelAccountContractsRequest {
	r.type1 = &type1
	return r
}

// External system code.
func (r ChannelApiDeleteChannelAccountContractsRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelAccountContractsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelAccountContractsRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelAccountContractsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelAccountContractsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelAccountContractsExecute(r)
}

/*
DeleteChannelAccountContracts Deletes channel account contracts.

This API deletes channel account contracts. <p><strong>OperationId:</strong>deleteChannelAccountContracts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelAccountContractsRequest
*/
func (a *ChannelApiService) DeleteChannelAccountContracts(ctx context.Context) ChannelApiDeleteChannelAccountContractsRequest {
	return ChannelApiDeleteChannelAccountContractsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelAccountContractsExecute(r ChannelApiDeleteChannelAccountContractsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelAccountContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/account/contracts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.id1 != nil {
		t := *r.id1
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id1", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id1", t, "multi")
		}
	}
	if r.idExtension1 != nil {
		t := *r.idExtension1
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension1", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension1", t, "multi")
		}
	}
	if r.idContext1 != nil {
		t := *r.idContext1
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext1", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext1", t, "multi")
		}
	}
	if r.type1 != nil {
		t := *r.type1
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type1", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type1", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelBillingStatementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	id *[]string
	idExtension *[]int32
	idContext *[]string
	type_ *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelBillingStatementsRequest) Authorization(authorization string) ChannelApiDeleteChannelBillingStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelBillingStatementsRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelBillingStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelBillingStatementsRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelBillingStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ChannelApiDeleteChannelBillingStatementsRequest) Id(id []string) ChannelApiDeleteChannelBillingStatementsRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r ChannelApiDeleteChannelBillingStatementsRequest) IdExtension(idExtension []int32) ChannelApiDeleteChannelBillingStatementsRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ChannelApiDeleteChannelBillingStatementsRequest) IdContext(idContext []string) ChannelApiDeleteChannelBillingStatementsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ChannelApiDeleteChannelBillingStatementsRequest) Type_(type_ []string) ChannelApiDeleteChannelBillingStatementsRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r ChannelApiDeleteChannelBillingStatementsRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelBillingStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelBillingStatementsRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelBillingStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelBillingStatementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelBillingStatementsExecute(r)
}

/*
DeleteChannelBillingStatements Deletes channel billing statements.

This API deletes channel billing statements. <p><strong>OperationId:</strong>deleteChannelBillingStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelBillingStatementsRequest
*/
func (a *ChannelApiService) DeleteChannelBillingStatements(ctx context.Context) ChannelApiDeleteChannelBillingStatementsRequest {
	return ChannelApiDeleteChannelBillingStatementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelBillingStatementsExecute(r ChannelApiDeleteChannelBillingStatementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelBillingStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idExtension != nil {
		t := *r.idExtension
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", t, "multi")
		}
	}
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelCardTypeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	cardTypeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelCardType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelCardTypeMappingRequest) Authorization(authorization string) ChannelApiDeleteChannelCardTypeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelCardTypeMappingRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelCardTypeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelCardTypeMappingRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelCardTypeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ChannelApiDeleteChannelCardTypeMappingRequest) ChannelCardType(channelCardType string) ChannelApiDeleteChannelCardTypeMappingRequest {
	r.channelCardType = &channelCardType
	return r
}

// External system code.
func (r ChannelApiDeleteChannelCardTypeMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelCardTypeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelCardTypeMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelCardTypeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelCardTypeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelCardTypeMappingExecute(r)
}

/*
DeleteChannelCardTypeMapping Deletes channel credit card mapping for a hotel

Use this API to delete channel mapping for OPERA credit cards to channel for a given hotel id. <p><strong>OperationId:</strong>deleteChannelCardTypeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardTypeCode Unique ID that identifies a channel.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiDeleteChannelCardTypeMappingRequest
*/
func (a *ChannelApiService) DeleteChannelCardTypeMapping(ctx context.Context, cardTypeCode string, channelCode string, hotelId string) ChannelApiDeleteChannelCardTypeMappingRequest {
	return ChannelApiDeleteChannelCardTypeMappingRequest{
		ApiService: a,
		ctx: ctx,
		cardTypeCode: cardTypeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelCardTypeMappingExecute(r ChannelApiDeleteChannelCardTypeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelCardTypeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/cardType/{cardTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cardTypeCode"+"}", url.PathEscape(parameterValueToString(r.cardTypeCode, "cardTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cardTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("cardTypeCode must have at least 1 elements")
	}
	if strlen(r.cardTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("cardTypeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.channelCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelCardType", r.channelCardType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelCarriersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	bookingChannelCodes *[]string
	carriers *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Booking channel code of carrier.
func (r ChannelApiDeleteChannelCarriersRequest) BookingChannelCodes(bookingChannelCodes []string) ChannelApiDeleteChannelCarriersRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

// Code of carrier.
func (r ChannelApiDeleteChannelCarriersRequest) Carriers(carriers []string) ChannelApiDeleteChannelCarriersRequest {
	r.carriers = &carriers
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelCarriersRequest) Authorization(authorization string) ChannelApiDeleteChannelCarriersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelCarriersRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelCarriersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelCarriersRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelCarriersRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChannelApiDeleteChannelCarriersRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelCarriersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelCarriersRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelCarriersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelCarriersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelCarriersExecute(r)
}

/*
DeleteChannelCarriers Deletes sub channel configuration

Use this API to delete sub-channel (carrier) configuration for a given channel code. <p><strong>OperationId:</strong>deleteChannelCarriers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelCarriersRequest
*/
func (a *ChannelApiService) DeleteChannelCarriers(ctx context.Context) ChannelApiDeleteChannelCarriersRequest {
	return ChannelApiDeleteChannelCarriersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelCarriersExecute(r ChannelApiDeleteChannelCarriersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelCarriers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/subChannels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	{
		t := *r.carriers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "carriers", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "carriers", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelErrorsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	bookingChannelCode *[]string
	error_ *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelErrorsRequest) Authorization(authorization string) ChannelApiDeleteChannelErrorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelErrorsRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelErrorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelErrorsRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelErrorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Booking channel code of error.
func (r ChannelApiDeleteChannelErrorsRequest) BookingChannelCode(bookingChannelCode []string) ChannelApiDeleteChannelErrorsRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

// Code of error.
func (r ChannelApiDeleteChannelErrorsRequest) Error_(error_ []string) ChannelApiDeleteChannelErrorsRequest {
	r.error_ = &error_
	return r
}

// External system code.
func (r ChannelApiDeleteChannelErrorsRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelErrorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelErrorsRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelErrorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelErrorsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelErrorsExecute(r)
}

/*
DeleteChannelErrors Deletes channel error codes

Use this API to delete channel error code mapping configurations. <p><strong>OperationId:</strong>deleteChannelErrors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelErrorsRequest
*/
func (a *ChannelApiService) DeleteChannelErrors(ctx context.Context) ChannelApiDeleteChannelErrorsRequest {
	return ChannelApiDeleteChannelErrorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelErrorsExecute(r ChannelApiDeleteChannelErrorsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelErrors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/errorCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bookingChannelCode != nil {
		t := *r.bookingChannelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", t, "multi")
		}
	}
	if r.error_ != nil {
		t := *r.error_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "error", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "error", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelGuaranteeCodeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	guaranteeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelGuaranteeCodeMappingRequest) Authorization(authorization string) ChannelApiDeleteChannelGuaranteeCodeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelGuaranteeCodeMappingRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelGuaranteeCodeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelGuaranteeCodeMappingRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelGuaranteeCodeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChannelApiDeleteChannelGuaranteeCodeMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelGuaranteeCodeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelGuaranteeCodeMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelGuaranteeCodeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelGuaranteeCodeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelGuaranteeCodeMappingExecute(r)
}

/*
DeleteChannelGuaranteeCodeMapping Deletes channel guarantee code mapping for a hotel

Use this API to delete channel guarantee code mapping to OPERA guarantee code for a given property. <p><strong>OperationId:</strong>deleteChannelGuaranteeCodeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guaranteeCode Guarantee Code.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiDeleteChannelGuaranteeCodeMappingRequest
*/
func (a *ChannelApiService) DeleteChannelGuaranteeCodeMapping(ctx context.Context, guaranteeCode string, channelCode string, hotelId string) ChannelApiDeleteChannelGuaranteeCodeMappingRequest {
	return ChannelApiDeleteChannelGuaranteeCodeMappingRequest{
		ApiService: a,
		ctx: ctx,
		guaranteeCode: guaranteeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelGuaranteeCodeMappingExecute(r ChannelApiDeleteChannelGuaranteeCodeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelGuaranteeCodeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/guarantees/{guaranteeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"guaranteeCode"+"}", url.PathEscape(parameterValueToString(r.guaranteeCode, "guaranteeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.guaranteeCode) < 1 {
		return localVarReturnValue, nil, reportError("guaranteeCode must have at least 1 elements")
	}
	if strlen(r.guaranteeCode) > 2000 {
		return localVarReturnValue, nil, reportError("guaranteeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelHotelLettersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	code *string
	description *string
	hotelId *[]string
	code1 *string
	description1 *string
	letterType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelHotelLettersRequest) Authorization(authorization string) ChannelApiDeleteChannelHotelLettersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelHotelLettersRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelHotelLettersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelHotelLettersRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelHotelLettersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Code.
func (r ChannelApiDeleteChannelHotelLettersRequest) Code(code string) ChannelApiDeleteChannelHotelLettersRequest {
	r.code = &code
	return r
}

// description.
func (r ChannelApiDeleteChannelHotelLettersRequest) Description(description string) ChannelApiDeleteChannelHotelLettersRequest {
	r.description = &description
	return r
}

// Hotel code which the hotel letters belong to.
func (r ChannelApiDeleteChannelHotelLettersRequest) HotelId(hotelId []string) ChannelApiDeleteChannelHotelLettersRequest {
	r.hotelId = &hotelId
	return r
}

// Code.
func (r ChannelApiDeleteChannelHotelLettersRequest) Code1(code1 string) ChannelApiDeleteChannelHotelLettersRequest {
	r.code1 = &code1
	return r
}

// description.
func (r ChannelApiDeleteChannelHotelLettersRequest) Description1(description1 string) ChannelApiDeleteChannelHotelLettersRequest {
	r.description1 = &description1
	return r
}

// Represents Inquiry Letter Type.
func (r ChannelApiDeleteChannelHotelLettersRequest) LetterType(letterType []string) ChannelApiDeleteChannelHotelLettersRequest {
	r.letterType = &letterType
	return r
}

// External system code.
func (r ChannelApiDeleteChannelHotelLettersRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelHotelLettersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelHotelLettersRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelHotelLettersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelHotelLettersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelHotelLettersExecute(r)
}

/*
DeleteChannelHotelLetters Deletes channel property confirmation letter mapping

Use this API to delete channel property confirmation letter configuration. <p><strong>OperationId:</strong>deleteChannelHotelLetters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelHotelLettersRequest
*/
func (a *ChannelApiService) DeleteChannelHotelLetters(ctx context.Context) ChannelApiDeleteChannelHotelLettersRequest {
	return ChannelApiDeleteChannelHotelLettersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelHotelLettersExecute(r ChannelApiDeleteChannelHotelLettersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelHotelLetters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/confirmationLetters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code1", r.code1, "")
	}
	if r.description1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description1", r.description1, "")
	}
	if r.letterType != nil {
		t := *r.letterType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "letterType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "letterType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelMarketingTextRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	beginDate *[]string
	bookingChannelCode *[]string
	endDate *[]string
	globalTextYN *[]bool
	hotelId *[]string
	marketingText *[]string
	policyDetail *[]string
	policyType *[]string
	transactionType *[]string
	newHotelId *[]string
	newTransactionType *[]string
	newPolicyType *[]string
	newPolicyDetail *[]string
	newBeginDate *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelMarketingTextRequest) Authorization(authorization string) ChannelApiDeleteChannelMarketingTextRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelMarketingTextRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelMarketingTextRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelMarketingTextRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelMarketingTextRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) BeginDate(beginDate []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.beginDate = &beginDate
	return r
}

// The code that identifies a Booking Channel.
func (r ChannelApiDeleteChannelMarketingTextRequest) BookingChannelCode(bookingChannelCode []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) EndDate(endDate []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.endDate = &endDate
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) GlobalTextYN(globalTextYN []bool) ChannelApiDeleteChannelMarketingTextRequest {
	r.globalTextYN = &globalTextYN
	return r
}

// The code that identifies a Hotel.
func (r ChannelApiDeleteChannelMarketingTextRequest) HotelId(hotelId []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.hotelId = &hotelId
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) MarketingText(marketingText []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.marketingText = &marketingText
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) PolicyDetail(policyDetail []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.policyDetail = &policyDetail
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) PolicyType(policyType []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.policyType = &policyType
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) TransactionType(transactionType []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.transactionType = &transactionType
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) NewHotelId(newHotelId []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.newHotelId = &newHotelId
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) NewTransactionType(newTransactionType []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.newTransactionType = &newTransactionType
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) NewPolicyType(newPolicyType []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.newPolicyType = &newPolicyType
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) NewPolicyDetail(newPolicyDetail []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.newPolicyDetail = &newPolicyDetail
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) NewBeginDate(newBeginDate []string) ChannelApiDeleteChannelMarketingTextRequest {
	r.newBeginDate = &newBeginDate
	return r
}

// External system code.
func (r ChannelApiDeleteChannelMarketingTextRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelMarketingTextRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelMarketingTextRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelMarketingTextRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelMarketingTextRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelMarketingTextExecute(r)
}

/*
DeleteChannelMarketingText Deletes channel marketing messages

Use this API to delete channel mapping for marketing messages. <p><strong>OperationId:</strong>deleteChannelMarketingText</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelMarketingTextRequest
*/
func (a *ChannelApiService) DeleteChannelMarketingText(ctx context.Context) ChannelApiDeleteChannelMarketingTextRequest {
	return ChannelApiDeleteChannelMarketingTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelMarketingTextExecute(r ChannelApiDeleteChannelMarketingTextRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelMarketingText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/marketingText"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.beginDate != nil {
		t := *r.beginDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", t, "multi")
		}
	}
	if r.bookingChannelCode != nil {
		t := *r.bookingChannelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", t, "multi")
		}
	}
	if r.endDate != nil {
		t := *r.endDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", t, "multi")
		}
	}
	if r.globalTextYN != nil {
		t := *r.globalTextYN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "globalTextYN", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "globalTextYN", t, "multi")
		}
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.marketingText != nil {
		t := *r.marketingText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketingText", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketingText", t, "multi")
		}
	}
	if r.policyDetail != nil {
		t := *r.policyDetail
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policyDetail", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policyDetail", t, "multi")
		}
	}
	if r.policyType != nil {
		t := *r.policyType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policyType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policyType", t, "multi")
		}
	}
	if r.transactionType != nil {
		t := *r.transactionType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionType", t, "multi")
		}
	}
	if r.newHotelId != nil {
		t := *r.newHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "newHotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "newHotelId", t, "multi")
		}
	}
	if r.newTransactionType != nil {
		t := *r.newTransactionType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "newTransactionType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "newTransactionType", t, "multi")
		}
	}
	if r.newPolicyType != nil {
		t := *r.newPolicyType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "newPolicyType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "newPolicyType", t, "multi")
		}
	}
	if r.newPolicyDetail != nil {
		t := *r.newPolicyDetail
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "newPolicyDetail", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "newPolicyDetail", t, "multi")
		}
	}
	if r.newBeginDate != nil {
		t := *r.newBeginDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "newBeginDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "newBeginDate", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelNegotiatedRateRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	bookingChannelCode *string
	channelRatePlanCode *string
	hotelId *string
	id *[]string
	idContext *[]string
	type_ *[]string
	externalSystem *string
	language *string
	nameType *string
	namePrefix *string
	givenName *string
	middleName *string
	surname *string
	nameSuffix *string
	nameTitle *string
	nameTitleSuffix *int32
	envelopeGreeting *string
	salutation *string
	accessCode *[]string
	end *[]string
	start *[]string
	newAccessCode *string
	channelRatePlanCodeOrder *int32
	startDate *string
	endDate *string
	duration *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelNegotiatedRateRequest) Authorization(authorization string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelNegotiatedRateRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelNegotiatedRateRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Booking Channel Code.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) BookingChannelCode(bookingChannelCode string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

// Channel Room Type.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) ChannelRatePlanCode(channelRatePlanCode string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.channelRatePlanCode = &channelRatePlanCode
	return r
}

// Hotel Code.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) HotelId(hotelId string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) Id(id []string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ChannelApiDeleteChannelNegotiatedRateRequest) IdContext(idContext []string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) Type_(type_ []string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.type_ = &type_
	return r
}

// When name type is external, indicates the external system the name belongs to.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) ExternalSystem(externalSystem string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.externalSystem = &externalSystem
	return r
}

// Language code associated with an alternate name.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) Language(language string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.language = &language
	return r
}

// Person&#39;s name in an external system.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) NameType(nameType string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.nameType = &nameType
	return r
}

// Salutation of honorific (e.g. Mr., Mrs., Ms., Miss, Dr.)
func (r ChannelApiDeleteChannelNegotiatedRateRequest) NamePrefix(namePrefix string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.namePrefix = &namePrefix
	return r
}

// Given name, first name or names.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) GivenName(givenName string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.givenName = &givenName
	return r
}

// The middle name of the person name.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) MiddleName(middleName string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.middleName = &middleName
	return r
}

// Family name, last name. May also be used for full name if the sending system does not have the ability to separate a full name into its parts, e.g. the surname element may be used to pass the full name.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) Surname(surname string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.surname = &surname
	return r
}

// Hold various name suffixes and letters (e.g. Jr., Sr., III, Ret., Esq.)
func (r ChannelApiDeleteChannelNegotiatedRateRequest) NameSuffix(nameSuffix string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.nameSuffix = &nameSuffix
	return r
}

// Degree or honors (e.g., Ph.D., M.D.)
func (r ChannelApiDeleteChannelNegotiatedRateRequest) NameTitle(nameTitle string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.nameTitle = &nameTitle
	return r
}

// Title Suffix. Must be populated if ADVANCED_TITLE is on.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) NameTitleSuffix(nameTitleSuffix int32) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.nameTitleSuffix = &nameTitleSuffix
	return r
}

// Envelope Greeting of the profile
func (r ChannelApiDeleteChannelNegotiatedRateRequest) EnvelopeGreeting(envelopeGreeting string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.envelopeGreeting = &envelopeGreeting
	return r
}

// Salutation of the profile
func (r ChannelApiDeleteChannelNegotiatedRateRequest) Salutation(salutation string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.salutation = &salutation
	return r
}

func (r ChannelApiDeleteChannelNegotiatedRateRequest) AccessCode(accessCode []string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.accessCode = &accessCode
	return r
}

// The ending value of the date range.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) End(end []string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) Start(start []string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.start = &start
	return r
}

func (r ChannelApiDeleteChannelNegotiatedRateRequest) NewAccessCode(newAccessCode string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.newAccessCode = &newAccessCode
	return r
}

func (r ChannelApiDeleteChannelNegotiatedRateRequest) ChannelRatePlanCodeOrder(channelRatePlanCodeOrder int32) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.channelRatePlanCodeOrder = &channelRatePlanCodeOrder
	return r
}

func (r ChannelApiDeleteChannelNegotiatedRateRequest) StartDate(startDate string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.startDate = &startDate
	return r
}

func (r ChannelApiDeleteChannelNegotiatedRateRequest) EndDate(endDate string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.endDate = &endDate
	return r
}

func (r ChannelApiDeleteChannelNegotiatedRateRequest) Duration(duration string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.duration = &duration
	return r
}

// External system code.
func (r ChannelApiDeleteChannelNegotiatedRateRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelNegotiatedRateRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelNegotiatedRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelNegotiatedRateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelNegotiatedRateExecute(r)
}

/*
DeleteChannelNegotiatedRate Deletes channel negotiate rate

Use this API to update channel's negotiated rate code mapping including negotiated profile, negotiate rate access code, start date, end date, and sequence. <p><strong>OperationId:</strong>deleteChannelNegotiatedRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelNegotiatedRateRequest
*/
func (a *ChannelApiService) DeleteChannelNegotiatedRate(ctx context.Context) ChannelApiDeleteChannelNegotiatedRateRequest {
	return ChannelApiDeleteChannelNegotiatedRateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelNegotiatedRateExecute(r ChannelApiDeleteChannelNegotiatedRateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelNegotiatedRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/negotiatedRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bookingChannelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", r.bookingChannelCode, "")
	}
	if r.channelRatePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", r.channelRatePlanCode, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.externalSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystem", r.externalSystem, "")
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	if r.nameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameType", r.nameType, "")
	}
	if r.namePrefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namePrefix", r.namePrefix, "")
	}
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
	}
	if r.middleName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "middleName", r.middleName, "")
	}
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
	}
	if r.nameSuffix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameSuffix", r.nameSuffix, "")
	}
	if r.nameTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTitle", r.nameTitle, "")
	}
	if r.nameTitleSuffix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTitleSuffix", r.nameTitleSuffix, "")
	}
	if r.envelopeGreeting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "envelopeGreeting", r.envelopeGreeting, "")
	}
	if r.salutation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "salutation", r.salutation, "")
	}
	if r.accessCode != nil {
		t := *r.accessCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accessCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accessCode", t, "multi")
		}
	}
	if r.end != nil {
		t := *r.end
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end", t, "multi")
		}
	}
	if r.start != nil {
		t := *r.start
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start", t, "multi")
		}
	}
	if r.newAccessCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newAccessCode", r.newAccessCode, "")
	}
	if r.channelRatePlanCodeOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCodeOrder", r.channelRatePlanCodeOrder, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelOrgMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	tenantCode string
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	chainCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelOrgMappingRequest) Authorization(authorization string) ChannelApiDeleteChannelOrgMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelOrgMappingRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelOrgMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelOrgMappingRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelOrgMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Chain code for which channel code and org code are mapped.
func (r ChannelApiDeleteChannelOrgMappingRequest) ChainCode(chainCode string) ChannelApiDeleteChannelOrgMappingRequest {
	r.chainCode = &chainCode
	return r
}

// External system code.
func (r ChannelApiDeleteChannelOrgMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelOrgMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelOrgMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelOrgMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelOrgMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelOrgMappingExecute(r)
}

/*
DeleteChannelOrgMapping Deletes channel tenants mapping.

This API deletes channel tenants mapping. <p><strong>OperationId:</strong>deleteChannelOrgMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantCode Tenant Code.
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiDeleteChannelOrgMappingRequest
*/
func (a *ChannelApiService) DeleteChannelOrgMapping(ctx context.Context, tenantCode string, channelCode string) ChannelApiDeleteChannelOrgMappingRequest {
	return ChannelApiDeleteChannelOrgMappingRequest{
		ApiService: a,
		ctx: ctx,
		tenantCode: tenantCode,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelOrgMappingExecute(r ChannelApiDeleteChannelOrgMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelOrgMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/tenants/{tenantCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantCode"+"}", url.PathEscape(parameterValueToString(r.tenantCode, "tenantCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.tenantCode) < 1 {
		return localVarReturnValue, nil, reportError("tenantCode must have at least 1 elements")
	}
	if strlen(r.tenantCode) > 2000 {
		return localVarReturnValue, nil, reportError("tenantCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	if r.chainCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainCode", r.chainCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelRateCategoriesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	bookingChannelCodes *[]string
	rateCategories *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Booking channel code of rate category.
func (r ChannelApiDeleteChannelRateCategoriesRequest) BookingChannelCodes(bookingChannelCodes []string) ChannelApiDeleteChannelRateCategoriesRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

// Code of rate category.
func (r ChannelApiDeleteChannelRateCategoriesRequest) RateCategories(rateCategories []string) ChannelApiDeleteChannelRateCategoriesRequest {
	r.rateCategories = &rateCategories
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelRateCategoriesRequest) Authorization(authorization string) ChannelApiDeleteChannelRateCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelRateCategoriesRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelRateCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelRateCategoriesRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelRateCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChannelApiDeleteChannelRateCategoriesRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelRateCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelRateCategoriesRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelRateCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelRateCategoriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRateCategoriesExecute(r)
}

/*
DeleteChannelRateCategories Deletes given channel's rate categories

Use this API to delete channel rate categories for a given channel. <p><strong>OperationId:</strong>deleteChannelRateCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelRateCategoriesRequest
*/
func (a *ChannelApiService) DeleteChannelRateCategories(ctx context.Context) ChannelApiDeleteChannelRateCategoriesRequest {
	return ChannelApiDeleteChannelRateCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRateCategoriesExecute(r ChannelApiDeleteChannelRateCategoriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRateCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rateCategories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	{
		t := *r.rateCategories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategories", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategories", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelRateLevelsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	bookingChannelCodes *[]string
	rateLevels *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Booking channel code of rate level.
func (r ChannelApiDeleteChannelRateLevelsRequest) BookingChannelCodes(bookingChannelCodes []string) ChannelApiDeleteChannelRateLevelsRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

// Code of rate level.
func (r ChannelApiDeleteChannelRateLevelsRequest) RateLevels(rateLevels []string) ChannelApiDeleteChannelRateLevelsRequest {
	r.rateLevels = &rateLevels
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelRateLevelsRequest) Authorization(authorization string) ChannelApiDeleteChannelRateLevelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelRateLevelsRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelRateLevelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelRateLevelsRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelRateLevelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChannelApiDeleteChannelRateLevelsRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelRateLevelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelRateLevelsRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelRateLevelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelRateLevelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRateLevelsExecute(r)
}

/*
DeleteChannelRateLevels Deletes channel rate level

Use this API to delete channel rate level code's description. <p><strong>OperationId:</strong>deleteChannelRateLevels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelRateLevelsRequest
*/
func (a *ChannelApiService) DeleteChannelRateLevels(ctx context.Context) ChannelApiDeleteChannelRateLevelsRequest {
	return ChannelApiDeleteChannelRateLevelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRateLevelsExecute(r ChannelApiDeleteChannelRateLevelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRateLevels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rateLevels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	{
		t := *r.rateLevels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateLevels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateLevels", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelRateMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	bookingChannelCode *[]string
	channelRatePlanCode *[]string
	hasChannelNegotiatedRates *[]bool
	hasNegotiatedRates *[]bool
	hotelId *[]string
	ratePlanCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelRateMappingRequest) Authorization(authorization string) ChannelApiDeleteChannelRateMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelRateMappingRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelRateMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelRateMappingRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelRateMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Booking Channel Code.
func (r ChannelApiDeleteChannelRateMappingRequest) BookingChannelCode(bookingChannelCode []string) ChannelApiDeleteChannelRateMappingRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

// Channel Room Type.
func (r ChannelApiDeleteChannelRateMappingRequest) ChannelRatePlanCode(channelRatePlanCode []string) ChannelApiDeleteChannelRateMappingRequest {
	r.channelRatePlanCode = &channelRatePlanCode
	return r
}

// True if the mapping has channel negotiated rates, otherwise false.
func (r ChannelApiDeleteChannelRateMappingRequest) HasChannelNegotiatedRates(hasChannelNegotiatedRates []bool) ChannelApiDeleteChannelRateMappingRequest {
	r.hasChannelNegotiatedRates = &hasChannelNegotiatedRates
	return r
}

// True if this channel rate plan code has negotiated rates, otherwise false
func (r ChannelApiDeleteChannelRateMappingRequest) HasNegotiatedRates(hasNegotiatedRates []bool) ChannelApiDeleteChannelRateMappingRequest {
	r.hasNegotiatedRates = &hasNegotiatedRates
	return r
}

// Hotel Code.
func (r ChannelApiDeleteChannelRateMappingRequest) HotelId(hotelId []string) ChannelApiDeleteChannelRateMappingRequest {
	r.hotelId = &hotelId
	return r
}

// Room Type.
func (r ChannelApiDeleteChannelRateMappingRequest) RatePlanCode(ratePlanCode []string) ChannelApiDeleteChannelRateMappingRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// External system code.
func (r ChannelApiDeleteChannelRateMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelRateMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelRateMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelRateMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelRateMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRateMappingExecute(r)
}

/*
DeleteChannelRateMapping Deletes channel property rate mapping

Use this API to delete channel property rate mapping including channel rate code, start date, end date, rate level, channel rate description. <p><strong>OperationId:</strong>deleteChannelRateMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelRateMappingRequest
*/
func (a *ChannelApiService) DeleteChannelRateMapping(ctx context.Context) ChannelApiDeleteChannelRateMappingRequest {
	return ChannelApiDeleteChannelRateMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRateMappingExecute(r ChannelApiDeleteChannelRateMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRateMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bookingChannelCode != nil {
		t := *r.bookingChannelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", t, "multi")
		}
	}
	if r.channelRatePlanCode != nil {
		t := *r.channelRatePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", t, "multi")
		}
	}
	if r.hasChannelNegotiatedRates != nil {
		t := *r.hasChannelNegotiatedRates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hasChannelNegotiatedRates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hasChannelNegotiatedRates", t, "multi")
		}
	}
	if r.hasNegotiatedRates != nil {
		t := *r.hasNegotiatedRates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hasNegotiatedRates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hasNegotiatedRates", t, "multi")
		}
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelRatesGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	code *string
	description *string
	code1 *string
	description1 *string
	globalDescType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) Authorization(authorization string) ChannelApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property mapping with Rate plan code or Room type
func (r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) HotelId(hotelId []string) ChannelApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.hotelId = &hotelId
	return r
}

// Code.
func (r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) Code(code string) ChannelApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.code = &code
	return r
}

// description.
func (r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) Description(description string) ChannelApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.description = &description
	return r
}

// Code.
func (r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) Code1(code1 string) ChannelApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.code1 = &code1
	return r
}

// description.
func (r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) Description1(description1 string) ChannelApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.description1 = &description1
	return r
}

// Either Room Type or Rate Plan Code
func (r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) GlobalDescType(globalDescType []string) ChannelApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.globalDescType = &globalDescType
	return r
}

// External system code.
func (r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelRatesGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRatesGlobalDescriptionsExecute(r)
}

/*
DeleteChannelRatesGlobalDescriptions Deletes global rate descriptions

Use this API to delete global rate description for given hotel id and rate code. <p><strong>OperationId:</strong>deleteChannelRatesGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelRatesGlobalDescriptionsRequest
*/
func (a *ChannelApiService) DeleteChannelRatesGlobalDescriptions(ctx context.Context) ChannelApiDeleteChannelRatesGlobalDescriptionsRequest {
	return ChannelApiDeleteChannelRatesGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRatesGlobalDescriptionsExecute(r ChannelApiDeleteChannelRatesGlobalDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRatesGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.code1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code1", r.code1, "")
	}
	if r.description1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description1", r.description1, "")
	}
	if r.globalDescType != nil {
		t := *r.globalDescType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "globalDescType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "globalDescType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelRoomMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	roomTypeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	beginDate *string
	channelRoomType *string
	endDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelRoomMappingRequest) Authorization(authorization string) ChannelApiDeleteChannelRoomMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelRoomMappingRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelRoomMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelRoomMappingRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelRoomMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Begin Date.
func (r ChannelApiDeleteChannelRoomMappingRequest) BeginDate(beginDate string) ChannelApiDeleteChannelRoomMappingRequest {
	r.beginDate = &beginDate
	return r
}

// Channel Room Type.
func (r ChannelApiDeleteChannelRoomMappingRequest) ChannelRoomType(channelRoomType string) ChannelApiDeleteChannelRoomMappingRequest {
	r.channelRoomType = &channelRoomType
	return r
}

// End date of the hotel-channel room type mapping.
func (r ChannelApiDeleteChannelRoomMappingRequest) EndDate(endDate string) ChannelApiDeleteChannelRoomMappingRequest {
	r.endDate = &endDate
	return r
}

// External system code.
func (r ChannelApiDeleteChannelRoomMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelRoomMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelRoomMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelRoomMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelRoomMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRoomMappingExecute(r)
}

/*
DeleteChannelRoomMapping Deletes channel property room mapping

Use this API to delete channel room mapping to OPERA hotel's room mapping including channel room type code, start date, end date, room order. <p><strong>OperationId:</strong>deleteChannelRoomMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeCode Room Type Code.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiDeleteChannelRoomMappingRequest
*/
func (a *ChannelApiService) DeleteChannelRoomMapping(ctx context.Context, roomTypeCode string, channelCode string, hotelId string) ChannelApiDeleteChannelRoomMappingRequest {
	return ChannelApiDeleteChannelRoomMappingRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeCode: roomTypeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRoomMappingExecute(r ChannelApiDeleteChannelRoomMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRoomMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/rooms/{roomTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeCode"+"}", url.PathEscape(parameterValueToString(r.roomTypeCode, "roomTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have at least 1 elements")
	}
	if strlen(r.roomTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.beginDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", r.beginDate, "")
	}
	if r.channelRoomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomType", r.channelRoomType, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelRoomTypesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	bookingChannelCodes *[]string
	roomTypes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Booking channel code of room type.
func (r ChannelApiDeleteChannelRoomTypesRequest) BookingChannelCodes(bookingChannelCodes []string) ChannelApiDeleteChannelRoomTypesRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

// Code of room type.
func (r ChannelApiDeleteChannelRoomTypesRequest) RoomTypes(roomTypes []string) ChannelApiDeleteChannelRoomTypesRequest {
	r.roomTypes = &roomTypes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelRoomTypesRequest) Authorization(authorization string) ChannelApiDeleteChannelRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelRoomTypesRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelRoomTypesRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChannelApiDeleteChannelRoomTypesRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelRoomTypesRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelRoomTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRoomTypesExecute(r)
}

/*
DeleteChannelRoomTypes Delete channel configuration

Use this API to delete channel configuration. <p><strong>OperationId:</strong>deleteChannelRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelRoomTypesRequest
*/
func (a *ChannelApiService) DeleteChannelRoomTypes(ctx context.Context) ChannelApiDeleteChannelRoomTypesRequest {
	return ChannelApiDeleteChannelRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRoomTypesExecute(r ChannelApiDeleteChannelRoomTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/roomTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	{
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	code *string
	description *string
	code1 *string
	description1 *string
	globalDescType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) Authorization(authorization string) ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) XAppKey(xAppKey string) ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) XHotelid(xHotelid string) ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property mapping with Rate plan code or Room type
func (r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) HotelId(hotelId []string) ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.hotelId = &hotelId
	return r
}

// Code.
func (r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) Code(code string) ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.code = &code
	return r
}

// description.
func (r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) Description(description string) ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.description = &description
	return r
}

// Code.
func (r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) Code1(code1 string) ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.code1 = &code1
	return r
}

// description.
func (r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) Description1(description1 string) ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.description1 = &description1
	return r
}

// Either Room Type or Rate Plan Code
func (r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) GlobalDescType(globalDescType []string) ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.globalDescType = &globalDescType
	return r
}

// External system code.
func (r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteChannelRoomsGlobalDescriptionsExecute(r)
}

/*
DeleteChannelRoomsGlobalDescriptions Deletes global room descriptions

Use this API to delete global room description for given hotel id and room type code. <p><strong>OperationId:</strong>deleteChannelRoomsGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest
*/
func (a *ChannelApiService) DeleteChannelRoomsGlobalDescriptions(ctx context.Context) ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest {
	return ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteChannelRoomsGlobalDescriptionsExecute(r ChannelApiDeleteChannelRoomsGlobalDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteChannelRoomsGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.code1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code1", r.code1, "")
	}
	if r.description1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description1", r.description1, "")
	}
	if r.globalDescType != nil {
		t := *r.globalDescType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "globalDescType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "globalDescType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteCreditCardsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	systemCode *string
	systemSubType *string
	systemType *string
	systemName *string
	websiteURL *string
	iconURL *string
	localSystemCode *[]string
	externalSystemCode *[]string
	description *[]string
	startDate *string
	endDate *string
	duration *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteCreditCardsMappingRequest) Authorization(authorization string) ChannelApiDeleteCreditCardsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteCreditCardsMappingRequest) XAppKey(xAppKey string) ChannelApiDeleteCreditCardsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteCreditCardsMappingRequest) XHotelid(xHotelid string) ChannelApiDeleteCreditCardsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether code is inactive or not.
func (r ChannelApiDeleteCreditCardsMappingRequest) Inactive(inactive bool) ChannelApiDeleteCreditCardsMappingRequest {
	r.inactive = &inactive
	return r
}

// External system code such as TRAVELOCITY, EXPEDIA, etc.
func (r ChannelApiDeleteCreditCardsMappingRequest) SystemCode(systemCode string) ChannelApiDeleteCreditCardsMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system subtype such as GDS, WEB, etc.
func (r ChannelApiDeleteCreditCardsMappingRequest) SystemSubType(systemSubType string) ChannelApiDeleteCreditCardsMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system type such as CHANNEL, OXI, etc.
func (r ChannelApiDeleteCreditCardsMappingRequest) SystemType(systemType string) ChannelApiDeleteCreditCardsMappingRequest {
	r.systemType = &systemType
	return r
}

// External system name.
func (r ChannelApiDeleteCreditCardsMappingRequest) SystemName(systemName string) ChannelApiDeleteCreditCardsMappingRequest {
	r.systemName = &systemName
	return r
}

// Cannel Website URL
func (r ChannelApiDeleteCreditCardsMappingRequest) WebsiteURL(websiteURL string) ChannelApiDeleteCreditCardsMappingRequest {
	r.websiteURL = &websiteURL
	return r
}

// Channel Icon URL
func (r ChannelApiDeleteCreditCardsMappingRequest) IconURL(iconURL string) ChannelApiDeleteCreditCardsMappingRequest {
	r.iconURL = &iconURL
	return r
}

// Code used inside the OPERA System
func (r ChannelApiDeleteCreditCardsMappingRequest) LocalSystemCode(localSystemCode []string) ChannelApiDeleteCreditCardsMappingRequest {
	r.localSystemCode = &localSystemCode
	return r
}

// Code used in the External System
func (r ChannelApiDeleteCreditCardsMappingRequest) ExternalSystemCode(externalSystemCode []string) ChannelApiDeleteCreditCardsMappingRequest {
	r.externalSystemCode = &externalSystemCode
	return r
}

// Detailed Description of the given entity.
func (r ChannelApiDeleteCreditCardsMappingRequest) Description(description []string) ChannelApiDeleteCreditCardsMappingRequest {
	r.description = &description
	return r
}

func (r ChannelApiDeleteCreditCardsMappingRequest) StartDate(startDate string) ChannelApiDeleteCreditCardsMappingRequest {
	r.startDate = &startDate
	return r
}

func (r ChannelApiDeleteCreditCardsMappingRequest) EndDate(endDate string) ChannelApiDeleteCreditCardsMappingRequest {
	r.endDate = &endDate
	return r
}

func (r ChannelApiDeleteCreditCardsMappingRequest) Duration(duration string) ChannelApiDeleteCreditCardsMappingRequest {
	r.duration = &duration
	return r
}

// External system code.
func (r ChannelApiDeleteCreditCardsMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteCreditCardsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteCreditCardsMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteCreditCardsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteCreditCardsMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCreditCardsMappingExecute(r)
}

/*
DeleteCreditCardsMapping Deletes channel credit card mapping

Use this API to delete channel credit card code mapping to OPERA credit card code. <p><strong>OperationId:</strong>deleteCreditCardsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteCreditCardsMappingRequest
*/
func (a *ChannelApiService) DeleteCreditCardsMapping(ctx context.Context) ChannelApiDeleteCreditCardsMappingRequest {
	return ChannelApiDeleteCreditCardsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteCreditCardsMappingExecute(r ChannelApiDeleteCreditCardsMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteCreditCardsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/cardTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemName", r.systemName, "")
	}
	if r.websiteURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "websiteURL", r.websiteURL, "")
	}
	if r.iconURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconURL", r.iconURL, "")
	}
	if r.localSystemCode != nil {
		t := *r.localSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", t, "multi")
		}
	}
	if r.externalSystemCode != nil {
		t := *r.externalSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteCurrenciesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	systemCode *string
	systemSubType *string
	systemType *string
	systemName *string
	websiteURL *string
	iconURL *string
	localSystemCode *[]string
	externalSystemCode *[]string
	description *[]string
	startDate *string
	endDate *string
	duration *string
	lanyonDecimalPosition *[]int32
	channelDecimalPosition *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteCurrenciesMappingRequest) Authorization(authorization string) ChannelApiDeleteCurrenciesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteCurrenciesMappingRequest) XAppKey(xAppKey string) ChannelApiDeleteCurrenciesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteCurrenciesMappingRequest) XHotelid(xHotelid string) ChannelApiDeleteCurrenciesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether code is inactive or not.
func (r ChannelApiDeleteCurrenciesMappingRequest) Inactive(inactive bool) ChannelApiDeleteCurrenciesMappingRequest {
	r.inactive = &inactive
	return r
}

// External system code such as TRAVELOCITY, EXPEDIA, etc.
func (r ChannelApiDeleteCurrenciesMappingRequest) SystemCode(systemCode string) ChannelApiDeleteCurrenciesMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system subtype such as GDS, WEB, etc.
func (r ChannelApiDeleteCurrenciesMappingRequest) SystemSubType(systemSubType string) ChannelApiDeleteCurrenciesMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system type such as CHANNEL, OXI, etc.
func (r ChannelApiDeleteCurrenciesMappingRequest) SystemType(systemType string) ChannelApiDeleteCurrenciesMappingRequest {
	r.systemType = &systemType
	return r
}

// External system name.
func (r ChannelApiDeleteCurrenciesMappingRequest) SystemName(systemName string) ChannelApiDeleteCurrenciesMappingRequest {
	r.systemName = &systemName
	return r
}

// Cannel Website URL
func (r ChannelApiDeleteCurrenciesMappingRequest) WebsiteURL(websiteURL string) ChannelApiDeleteCurrenciesMappingRequest {
	r.websiteURL = &websiteURL
	return r
}

// Channel Icon URL
func (r ChannelApiDeleteCurrenciesMappingRequest) IconURL(iconURL string) ChannelApiDeleteCurrenciesMappingRequest {
	r.iconURL = &iconURL
	return r
}

// Code used inside the OPERA System
func (r ChannelApiDeleteCurrenciesMappingRequest) LocalSystemCode(localSystemCode []string) ChannelApiDeleteCurrenciesMappingRequest {
	r.localSystemCode = &localSystemCode
	return r
}

// Code used in the External System
func (r ChannelApiDeleteCurrenciesMappingRequest) ExternalSystemCode(externalSystemCode []string) ChannelApiDeleteCurrenciesMappingRequest {
	r.externalSystemCode = &externalSystemCode
	return r
}

// Detailed Description of the given entity.
func (r ChannelApiDeleteCurrenciesMappingRequest) Description(description []string) ChannelApiDeleteCurrenciesMappingRequest {
	r.description = &description
	return r
}

func (r ChannelApiDeleteCurrenciesMappingRequest) StartDate(startDate string) ChannelApiDeleteCurrenciesMappingRequest {
	r.startDate = &startDate
	return r
}

func (r ChannelApiDeleteCurrenciesMappingRequest) EndDate(endDate string) ChannelApiDeleteCurrenciesMappingRequest {
	r.endDate = &endDate
	return r
}

func (r ChannelApiDeleteCurrenciesMappingRequest) Duration(duration string) ChannelApiDeleteCurrenciesMappingRequest {
	r.duration = &duration
	return r
}

// Number of decimal positions used by the currency.
func (r ChannelApiDeleteCurrenciesMappingRequest) LanyonDecimalPosition(lanyonDecimalPosition []int32) ChannelApiDeleteCurrenciesMappingRequest {
	r.lanyonDecimalPosition = &lanyonDecimalPosition
	return r
}

// Number of decimal positions used by the currency as per the channel.
func (r ChannelApiDeleteCurrenciesMappingRequest) ChannelDecimalPosition(channelDecimalPosition []int32) ChannelApiDeleteCurrenciesMappingRequest {
	r.channelDecimalPosition = &channelDecimalPosition
	return r
}

// External system code.
func (r ChannelApiDeleteCurrenciesMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteCurrenciesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteCurrenciesMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteCurrenciesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteCurrenciesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCurrenciesMappingExecute(r)
}

/*
DeleteCurrenciesMapping Deletes channel currency code mapping

Use this API to delete channel mapping to OPERA currency codes. <p><strong>OperationId:</strong>deleteCurrenciesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteCurrenciesMappingRequest
*/
func (a *ChannelApiService) DeleteCurrenciesMapping(ctx context.Context) ChannelApiDeleteCurrenciesMappingRequest {
	return ChannelApiDeleteCurrenciesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteCurrenciesMappingExecute(r ChannelApiDeleteCurrenciesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteCurrenciesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemName", r.systemName, "")
	}
	if r.websiteURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "websiteURL", r.websiteURL, "")
	}
	if r.iconURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconURL", r.iconURL, "")
	}
	if r.localSystemCode != nil {
		t := *r.localSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", t, "multi")
		}
	}
	if r.externalSystemCode != nil {
		t := *r.externalSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.lanyonDecimalPosition != nil {
		t := *r.lanyonDecimalPosition
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "lanyonDecimalPosition", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "lanyonDecimalPosition", t, "multi")
		}
	}
	if r.channelDecimalPosition != nil {
		t := *r.channelDecimalPosition
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelDecimalPosition", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelDecimalPosition", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteDistributionTemplatesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	codes *[]string
	code *[]string
	hotelId *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteDistributionTemplatesRequest) Authorization(authorization string) ChannelApiDeleteDistributionTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteDistributionTemplatesRequest) XAppKey(xAppKey string) ChannelApiDeleteDistributionTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteDistributionTemplatesRequest) XHotelid(xHotelid string) ChannelApiDeleteDistributionTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChannelApiDeleteDistributionTemplatesRequest) Codes(codes []string) ChannelApiDeleteDistributionTemplatesRequest {
	r.codes = &codes
	return r
}

// Configuration code.
func (r ChannelApiDeleteDistributionTemplatesRequest) Code(code []string) ChannelApiDeleteDistributionTemplatesRequest {
	r.code = &code
	return r
}

// Hotel where the code is configured.
func (r ChannelApiDeleteDistributionTemplatesRequest) HotelId(hotelId []string) ChannelApiDeleteDistributionTemplatesRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r ChannelApiDeleteDistributionTemplatesRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteDistributionTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteDistributionTemplatesRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteDistributionTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteDistributionTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteDistributionTemplatesExecute(r)
}

/*
DeleteDistributionTemplates Deletes rate templates configurations

Use this API to delete existing distribution rate template. <p><strong>OperationId:</strong>deleteDistributionTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteDistributionTemplatesRequest
*/
func (a *ChannelApiService) DeleteDistributionTemplates(ctx context.Context) ChannelApiDeleteDistributionTemplatesRequest {
	return ChannelApiDeleteDistributionTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteDistributionTemplatesExecute(r ChannelApiDeleteDistributionTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteDistributionTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/distributionTemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteGuaranteesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	systemCode *string
	systemSubType *string
	systemType *string
	systemName *string
	websiteURL *string
	iconURL *string
	localSystemCode *[]string
	externalSystemCode *[]string
	description *[]string
	startDate *string
	endDate *string
	duration *string
	requirementCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteGuaranteesMappingRequest) Authorization(authorization string) ChannelApiDeleteGuaranteesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteGuaranteesMappingRequest) XAppKey(xAppKey string) ChannelApiDeleteGuaranteesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteGuaranteesMappingRequest) XHotelid(xHotelid string) ChannelApiDeleteGuaranteesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether code is inactive or not.
func (r ChannelApiDeleteGuaranteesMappingRequest) Inactive(inactive bool) ChannelApiDeleteGuaranteesMappingRequest {
	r.inactive = &inactive
	return r
}

// External system code such as TRAVELOCITY, EXPEDIA, etc.
func (r ChannelApiDeleteGuaranteesMappingRequest) SystemCode(systemCode string) ChannelApiDeleteGuaranteesMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system subtype such as GDS, WEB, etc.
func (r ChannelApiDeleteGuaranteesMappingRequest) SystemSubType(systemSubType string) ChannelApiDeleteGuaranteesMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system type such as CHANNEL, OXI, etc.
func (r ChannelApiDeleteGuaranteesMappingRequest) SystemType(systemType string) ChannelApiDeleteGuaranteesMappingRequest {
	r.systemType = &systemType
	return r
}

// External system name.
func (r ChannelApiDeleteGuaranteesMappingRequest) SystemName(systemName string) ChannelApiDeleteGuaranteesMappingRequest {
	r.systemName = &systemName
	return r
}

// Cannel Website URL
func (r ChannelApiDeleteGuaranteesMappingRequest) WebsiteURL(websiteURL string) ChannelApiDeleteGuaranteesMappingRequest {
	r.websiteURL = &websiteURL
	return r
}

// Channel Icon URL
func (r ChannelApiDeleteGuaranteesMappingRequest) IconURL(iconURL string) ChannelApiDeleteGuaranteesMappingRequest {
	r.iconURL = &iconURL
	return r
}

// Code used inside the OPERA System
func (r ChannelApiDeleteGuaranteesMappingRequest) LocalSystemCode(localSystemCode []string) ChannelApiDeleteGuaranteesMappingRequest {
	r.localSystemCode = &localSystemCode
	return r
}

// Code used in the External System
func (r ChannelApiDeleteGuaranteesMappingRequest) ExternalSystemCode(externalSystemCode []string) ChannelApiDeleteGuaranteesMappingRequest {
	r.externalSystemCode = &externalSystemCode
	return r
}

// Detailed Description of the given entity.
func (r ChannelApiDeleteGuaranteesMappingRequest) Description(description []string) ChannelApiDeleteGuaranteesMappingRequest {
	r.description = &description
	return r
}

func (r ChannelApiDeleteGuaranteesMappingRequest) StartDate(startDate string) ChannelApiDeleteGuaranteesMappingRequest {
	r.startDate = &startDate
	return r
}

func (r ChannelApiDeleteGuaranteesMappingRequest) EndDate(endDate string) ChannelApiDeleteGuaranteesMappingRequest {
	r.endDate = &endDate
	return r
}

func (r ChannelApiDeleteGuaranteesMappingRequest) Duration(duration string) ChannelApiDeleteGuaranteesMappingRequest {
	r.duration = &duration
	return r
}

// Requirement code of guarantee.
func (r ChannelApiDeleteGuaranteesMappingRequest) RequirementCode(requirementCode []string) ChannelApiDeleteGuaranteesMappingRequest {
	r.requirementCode = &requirementCode
	return r
}

// External system code.
func (r ChannelApiDeleteGuaranteesMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteGuaranteesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteGuaranteesMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteGuaranteesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteGuaranteesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteGuaranteesMappingExecute(r)
}

/*
DeleteGuaranteesMapping Deletes channel guarantee code mapping

Use this API to delete channel's guarantee codes mapping to OPERA guarantee codes. <p><strong>OperationId:</strong>deleteGuaranteesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteGuaranteesMappingRequest
*/
func (a *ChannelApiService) DeleteGuaranteesMapping(ctx context.Context) ChannelApiDeleteGuaranteesMappingRequest {
	return ChannelApiDeleteGuaranteesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteGuaranteesMappingExecute(r ChannelApiDeleteGuaranteesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteGuaranteesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/guarantees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemName", r.systemName, "")
	}
	if r.websiteURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "websiteURL", r.websiteURL, "")
	}
	if r.iconURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconURL", r.iconURL, "")
	}
	if r.localSystemCode != nil {
		t := *r.localSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", t, "multi")
		}
	}
	if r.externalSystemCode != nil {
		t := *r.externalSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.requirementCode != nil {
		t := *r.requirementCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "requirementCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "requirementCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteHotelsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	systemCode *string
	systemSubType *string
	systemType *string
	systemName *string
	websiteURL *string
	iconURL *string
	localSystemCode *[]string
	externalSystemCode *[]string
	description *[]string
	startDate *string
	endDate *string
	duration *string
	city *[]string
	roomLimit *[]int32
	bookingLimit *[]int32
	hotelChainId *[]string
	chainCode *[]string
	prevailingRates *[]bool
	aRIEnabled *[]bool
	addOnLicense *[]string
	available *bool
	defaultRateCode *string
	defaultRateCode1 *[]string
	lowRevenueThreshold *[]int32
	highRevenueThreshold *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteHotelsMappingRequest) Authorization(authorization string) ChannelApiDeleteHotelsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteHotelsMappingRequest) XAppKey(xAppKey string) ChannelApiDeleteHotelsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteHotelsMappingRequest) XHotelid(xHotelid string) ChannelApiDeleteHotelsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether code is inactive or not.
func (r ChannelApiDeleteHotelsMappingRequest) Inactive(inactive bool) ChannelApiDeleteHotelsMappingRequest {
	r.inactive = &inactive
	return r
}

// External system code such as TRAVELOCITY, EXPEDIA, etc.
func (r ChannelApiDeleteHotelsMappingRequest) SystemCode(systemCode string) ChannelApiDeleteHotelsMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system subtype such as GDS, WEB, etc.
func (r ChannelApiDeleteHotelsMappingRequest) SystemSubType(systemSubType string) ChannelApiDeleteHotelsMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system type such as CHANNEL, OXI, etc.
func (r ChannelApiDeleteHotelsMappingRequest) SystemType(systemType string) ChannelApiDeleteHotelsMappingRequest {
	r.systemType = &systemType
	return r
}

// External system name.
func (r ChannelApiDeleteHotelsMappingRequest) SystemName(systemName string) ChannelApiDeleteHotelsMappingRequest {
	r.systemName = &systemName
	return r
}

// Cannel Website URL
func (r ChannelApiDeleteHotelsMappingRequest) WebsiteURL(websiteURL string) ChannelApiDeleteHotelsMappingRequest {
	r.websiteURL = &websiteURL
	return r
}

// Channel Icon URL
func (r ChannelApiDeleteHotelsMappingRequest) IconURL(iconURL string) ChannelApiDeleteHotelsMappingRequest {
	r.iconURL = &iconURL
	return r
}

// Code used inside the OPERA System
func (r ChannelApiDeleteHotelsMappingRequest) LocalSystemCode(localSystemCode []string) ChannelApiDeleteHotelsMappingRequest {
	r.localSystemCode = &localSystemCode
	return r
}

// Code used in the External System
func (r ChannelApiDeleteHotelsMappingRequest) ExternalSystemCode(externalSystemCode []string) ChannelApiDeleteHotelsMappingRequest {
	r.externalSystemCode = &externalSystemCode
	return r
}

// Detailed Description of the given entity.
func (r ChannelApiDeleteHotelsMappingRequest) Description(description []string) ChannelApiDeleteHotelsMappingRequest {
	r.description = &description
	return r
}

func (r ChannelApiDeleteHotelsMappingRequest) StartDate(startDate string) ChannelApiDeleteHotelsMappingRequest {
	r.startDate = &startDate
	return r
}

func (r ChannelApiDeleteHotelsMappingRequest) EndDate(endDate string) ChannelApiDeleteHotelsMappingRequest {
	r.endDate = &endDate
	return r
}

func (r ChannelApiDeleteHotelsMappingRequest) Duration(duration string) ChannelApiDeleteHotelsMappingRequest {
	r.duration = &duration
	return r
}

// City code of the channel hotel.
func (r ChannelApiDeleteHotelsMappingRequest) City(city []string) ChannelApiDeleteHotelsMappingRequest {
	r.city = &city
	return r
}

// Maximum room limit for the channel hotel reservation.
func (r ChannelApiDeleteHotelsMappingRequest) RoomLimit(roomLimit []int32) ChannelApiDeleteHotelsMappingRequest {
	r.roomLimit = &roomLimit
	return r
}

// Booking limit used by ADS interface for booking limit upload. Available if channel type is ADS and ADS ARI is enabled.
func (r ChannelApiDeleteHotelsMappingRequest) BookingLimit(bookingLimit []int32) ChannelApiDeleteHotelsMappingRequest {
	r.bookingLimit = &bookingLimit
	return r
}

// Hotel chain ID of channel-hotel mapping. Only available for UA channel. It may not be modified if in myfidelio environment, and user is for a specific hotel.
func (r ChannelApiDeleteHotelsMappingRequest) HotelChainId(hotelChainId []string) ChannelApiDeleteHotelsMappingRequest {
	r.hotelChainId = &hotelChainId
	return r
}

// Chain code for the channel-hotel mapping.
func (r ChannelApiDeleteHotelsMappingRequest) ChainCode(chainCode []string) ChannelApiDeleteHotelsMappingRequest {
	r.chainCode = &chainCode
	return r
}

// Prevailing rates flag of channel-hotel mapping. Available if PREVAILING_RATE_BY_LOS parameter is on.
func (r ChannelApiDeleteHotelsMappingRequest) PrevailingRates(prevailingRates []bool) ChannelApiDeleteHotelsMappingRequest {
	r.prevailingRates = &prevailingRates
	return r
}

// ADS ARI enabled flag of channel-hotel mapping. Available only if channel type is ADS.
func (r ChannelApiDeleteHotelsMappingRequest) ARIEnabled(aRIEnabled []bool) ChannelApiDeleteHotelsMappingRequest {
	r.aRIEnabled = &aRIEnabled
	return r
}

// External system Add-on license. This is mandatory when Channel Type is ADS.
func (r ChannelApiDeleteHotelsMappingRequest) AddOnLicense(addOnLicense []string) ChannelApiDeleteHotelsMappingRequest {
	r.addOnLicense = &addOnLicense
	return r
}

// Flag indicating if channel resort mapping is available.
func (r ChannelApiDeleteHotelsMappingRequest) Available(available bool) ChannelApiDeleteHotelsMappingRequest {
	r.available = &available
	return r
}

// Default rate code to be used to calculate the total revenue.
func (r ChannelApiDeleteHotelsMappingRequest) DefaultRateCode(defaultRateCode string) ChannelApiDeleteHotelsMappingRequest {
	r.defaultRateCode = &defaultRateCode
	return r
}

// Default rate code of channel hotel.
func (r ChannelApiDeleteHotelsMappingRequest) DefaultRateCode1(defaultRateCode1 []string) ChannelApiDeleteHotelsMappingRequest {
	r.defaultRateCode1 = &defaultRateCode1
	return r
}

// Low revenue threshold.
func (r ChannelApiDeleteHotelsMappingRequest) LowRevenueThreshold(lowRevenueThreshold []int32) ChannelApiDeleteHotelsMappingRequest {
	r.lowRevenueThreshold = &lowRevenueThreshold
	return r
}

// High revenue threshold.
func (r ChannelApiDeleteHotelsMappingRequest) HighRevenueThreshold(highRevenueThreshold []int32) ChannelApiDeleteHotelsMappingRequest {
	r.highRevenueThreshold = &highRevenueThreshold
	return r
}

// External system code.
func (r ChannelApiDeleteHotelsMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteHotelsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteHotelsMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteHotelsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteHotelsMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteHotelsMappingExecute(r)
}

/*
DeleteHotelsMapping Deletes channel hotel mapping

Use this API to delete channel mapping to OPERA hotel id including channel hotel code, room sell limit per reservation, city code, end date. <p><strong>OperationId:</strong>deleteHotelsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteHotelsMappingRequest
*/
func (a *ChannelApiService) DeleteHotelsMapping(ctx context.Context) ChannelApiDeleteHotelsMappingRequest {
	return ChannelApiDeleteHotelsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteHotelsMappingExecute(r ChannelApiDeleteHotelsMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteHotelsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/hotels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemName", r.systemName, "")
	}
	if r.websiteURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "websiteURL", r.websiteURL, "")
	}
	if r.iconURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconURL", r.iconURL, "")
	}
	if r.localSystemCode != nil {
		t := *r.localSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCode", t, "multi")
		}
	}
	if r.externalSystemCode != nil {
		t := *r.externalSystemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.city != nil {
		t := *r.city
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "city", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "city", t, "multi")
		}
	}
	if r.roomLimit != nil {
		t := *r.roomLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomLimit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomLimit", t, "multi")
		}
	}
	if r.bookingLimit != nil {
		t := *r.bookingLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingLimit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingLimit", t, "multi")
		}
	}
	if r.hotelChainId != nil {
		t := *r.hotelChainId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelChainId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelChainId", t, "multi")
		}
	}
	if r.chainCode != nil {
		t := *r.chainCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "chainCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "chainCode", t, "multi")
		}
	}
	if r.prevailingRates != nil {
		t := *r.prevailingRates
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prevailingRates", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prevailingRates", t, "multi")
		}
	}
	if r.aRIEnabled != nil {
		t := *r.aRIEnabled
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "aRIEnabled", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "aRIEnabled", t, "multi")
		}
	}
	if r.addOnLicense != nil {
		t := *r.addOnLicense
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "addOnLicense", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "addOnLicense", t, "multi")
		}
	}
	if r.available != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "available", r.available, "")
	}
	if r.defaultRateCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultRateCode", r.defaultRateCode, "")
	}
	if r.defaultRateCode1 != nil {
		t := *r.defaultRateCode1
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "defaultRateCode1", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "defaultRateCode1", t, "multi")
		}
	}
	if r.lowRevenueThreshold != nil {
		t := *r.lowRevenueThreshold
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "lowRevenueThreshold", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "lowRevenueThreshold", t, "multi")
		}
	}
	if r.highRevenueThreshold != nil {
		t := *r.highRevenueThreshold
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "highRevenueThreshold", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "highRevenueThreshold", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiDeleteTotalPricingElementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	code *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiDeleteTotalPricingElementsRequest) Authorization(authorization string) ChannelApiDeleteTotalPricingElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiDeleteTotalPricingElementsRequest) XAppKey(xAppKey string) ChannelApiDeleteTotalPricingElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiDeleteTotalPricingElementsRequest) XHotelid(xHotelid string) ChannelApiDeleteTotalPricingElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code that associated with Transaction Code and Total Pricing Element
func (r ChannelApiDeleteTotalPricingElementsRequest) HotelId(hotelId []string) ChannelApiDeleteTotalPricingElementsRequest {
	r.hotelId = &hotelId
	return r
}

// Code.
func (r ChannelApiDeleteTotalPricingElementsRequest) Code(code string) ChannelApiDeleteTotalPricingElementsRequest {
	r.code = &code
	return r
}

// description.
func (r ChannelApiDeleteTotalPricingElementsRequest) Description(description string) ChannelApiDeleteTotalPricingElementsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChannelApiDeleteTotalPricingElementsRequest) XExternalsystem(xExternalsystem string) ChannelApiDeleteTotalPricingElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiDeleteTotalPricingElementsRequest) AcceptLanguage(acceptLanguage string) ChannelApiDeleteTotalPricingElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiDeleteTotalPricingElementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTotalPricingElementsExecute(r)
}

/*
DeleteTotalPricingElements Deletes total pricing tax and fee types

Use this API to delete global distribution channels tax and fee configurations. <p><strong>OperationId:</strong>deleteTotalPricingElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiDeleteTotalPricingElementsRequest
*/
func (a *ChannelApiService) DeleteTotalPricingElements(ctx context.Context) ChannelApiDeleteTotalPricingElementsRequest {
	return ChannelApiDeleteTotalPricingElementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) DeleteTotalPricingElementsExecute(r ChannelApiDeleteTotalPricingElementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.DeleteTotalPricingElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/totalPricing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGenerateChannelBillingStatementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelBillingStatements *PutChannelBillingStatementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGenerateChannelBillingStatementsRequest) Authorization(authorization string) ChannelApiGenerateChannelBillingStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGenerateChannelBillingStatementsRequest) XAppKey(xAppKey string) ChannelApiGenerateChannelBillingStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGenerateChannelBillingStatementsRequest) XHotelid(xHotelid string) ChannelApiGenerateChannelBillingStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to Generate channel billing statements.
func (r ChannelApiGenerateChannelBillingStatementsRequest) ChannelBillingStatements(channelBillingStatements PutChannelBillingStatementsRequest) ChannelApiGenerateChannelBillingStatementsRequest {
	r.channelBillingStatements = &channelBillingStatements
	return r
}

// External system code.
func (r ChannelApiGenerateChannelBillingStatementsRequest) XExternalsystem(xExternalsystem string) ChannelApiGenerateChannelBillingStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGenerateChannelBillingStatementsRequest) AcceptLanguage(acceptLanguage string) ChannelApiGenerateChannelBillingStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGenerateChannelBillingStatementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.GenerateChannelBillingStatementsExecute(r)
}

/*
GenerateChannelBillingStatements This API generates channel billing statements.

This API generates channel billing statements. <p><strong>OperationId:</strong>generateChannelBillingStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGenerateChannelBillingStatementsRequest
*/
func (a *ChannelApiService) GenerateChannelBillingStatements(ctx context.Context) ChannelApiGenerateChannelBillingStatementsRequest {
	return ChannelApiGenerateChannelBillingStatementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) GenerateChannelBillingStatementsExecute(r ChannelApiGenerateChannelBillingStatementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GenerateChannelBillingStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements/generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelBillingStatements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetAmenitiesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	limit *int32
	offset *int32
	systemCode *string
	systemType *string
	systemSubType *string
	systemRateType *string
	localSystemCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetAmenitiesMappingRequest) Authorization(authorization string) ChannelApiGetAmenitiesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetAmenitiesMappingRequest) XAppKey(xAppKey string) ChannelApiGetAmenitiesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetAmenitiesMappingRequest) XHotelid(xHotelid string) ChannelApiGetAmenitiesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether searching for active or inactive codes.
func (r ChannelApiGetAmenitiesMappingRequest) Inactive(inactive bool) ChannelApiGetAmenitiesMappingRequest {
	r.inactive = &inactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetAmenitiesMappingRequest) Limit(limit int32) ChannelApiGetAmenitiesMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetAmenitiesMappingRequest) Offset(offset int32) ChannelApiGetAmenitiesMappingRequest {
	r.offset = &offset
	return r
}

// External system code to be searched. This is also known as Booking Channel Code for CHANNEL external system type.
func (r ChannelApiGetAmenitiesMappingRequest) SystemCode(systemCode string) ChannelApiGetAmenitiesMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system type to be searched. Possible values are CHANNEL, OXI, etc.
func (r ChannelApiGetAmenitiesMappingRequest) SystemType(systemType string) ChannelApiGetAmenitiesMappingRequest {
	r.systemType = &systemType
	return r
}

// External system sub type to be searched. Possible values are GDS, WEB, etc.
func (r ChannelApiGetAmenitiesMappingRequest) SystemSubType(systemSubType string) ChannelApiGetAmenitiesMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system rate type to be searched. Possible values are DAILY, MAX_WEEKLY, etc.
func (r ChannelApiGetAmenitiesMappingRequest) SystemRateType(systemRateType string) ChannelApiGetAmenitiesMappingRequest {
	r.systemRateType = &systemRateType
	return r
}

func (r ChannelApiGetAmenitiesMappingRequest) LocalSystemCodes(localSystemCodes []string) ChannelApiGetAmenitiesMappingRequest {
	r.localSystemCodes = &localSystemCodes
	return r
}

// External system code.
func (r ChannelApiGetAmenitiesMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiGetAmenitiesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetAmenitiesMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetAmenitiesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetAmenitiesMappingRequest) Execute() (*AmenitiesMapping, *http.Response, error) {
	return r.ApiService.GetAmenitiesMappingExecute(r)
}

/*
GetAmenitiesMapping Gets channel amenities configuration

Use this API to get channel amenities mapping. <p><strong>OperationId:</strong>getAmenitiesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetAmenitiesMappingRequest
*/
func (a *ChannelApiService) GetAmenitiesMapping(ctx context.Context) ChannelApiGetAmenitiesMappingRequest {
	return ChannelApiGetAmenitiesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AmenitiesMapping
func (a *ChannelApiService) GetAmenitiesMappingExecute(r ChannelApiGetAmenitiesMappingRequest) (*AmenitiesMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AmenitiesMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetAmenitiesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/amenities/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemRateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemRateType", r.systemRateType, "")
	}
	if r.localSystemCodes != nil {
		t := *r.localSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *[]bool
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelRequest) Authorization(authorization string) ChannelApiGetChannelRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelRequest) XAppKey(xAppKey string) ChannelApiGetChannelRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelRequest) XHotelid(xHotelid string) ChannelApiGetChannelRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether fetch should include inactive codes or not.
func (r ChannelApiGetChannelRequest) IncludeInactive(includeInactive []bool) ChannelApiGetChannelRequest {
	r.includeInactive = &includeInactive
	return r
}

// Simple type for external system instructions that can be used in requests for partial operations.
func (r ChannelApiGetChannelRequest) FetchInstructions(fetchInstructions []string) ChannelApiGetChannelRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ChannelApiGetChannelRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelRequest) Execute() (*Channel, *http.Response, error) {
	return r.ApiService.GetChannelExecute(r)
}

/*
GetChannel Gets channel detail

This API retrieves channel information for the given channel code. <p><strong>OperationId:</strong>getChannel</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiGetChannelRequest
*/
func (a *ChannelApiService) GetChannel(ctx context.Context, channelCode string) ChannelApiGetChannelRequest {
	return ChannelApiGetChannelRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Channel
func (a *ChannelApiService) GetChannelExecute(r ChannelApiGetChannelRequest) (*Channel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Channel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	if r.includeInactive != nil {
		t := *r.includeInactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", t, "multi")
		}
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelAccountRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	accountProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	markAsRecentlyAccessed *bool
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelAccountRequest) Authorization(authorization string) ChannelApiGetChannelAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelAccountRequest) XAppKey(xAppKey string) ChannelApiGetChannelAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelAccountRequest) XHotelid(xHotelid string) ChannelApiGetChannelAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Providing this flag marks the billing account as recently accessed.
func (r ChannelApiGetChannelAccountRequest) MarkAsRecentlyAccessed(markAsRecentlyAccessed bool) ChannelApiGetChannelAccountRequest {
	r.markAsRecentlyAccessed = &markAsRecentlyAccessed
	return r
}

// Channel account indicators information.
func (r ChannelApiGetChannelAccountRequest) FetchInstructions(fetchInstructions []string) ChannelApiGetChannelAccountRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ChannelApiGetChannelAccountRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelAccountRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelAccountRequest) Execute() (*ChannelAccount, *http.Response, error) {
	return r.ApiService.GetChannelAccountExecute(r)
}

/*
GetChannelAccount Gets channel accounts

Use this API to get existing channel account for a given OPERA profile id. <p><strong>OperationId:</strong>getChannelAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountProfileId Unique ID that identifies an account profile.
 @return ChannelApiGetChannelAccountRequest
*/
func (a *ChannelApiService) GetChannelAccount(ctx context.Context, accountProfileId string) ChannelApiGetChannelAccountRequest {
	return ChannelApiGetChannelAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountProfileId: accountProfileId,
	}
}

// Execute executes the request
//  @return ChannelAccount
func (a *ChannelApiService) GetChannelAccountExecute(r ChannelApiGetChannelAccountRequest) (*ChannelAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts/{accountProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountProfileId"+"}", url.PathEscape(parameterValueToString(r.accountProfileId, "accountProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountProfileId) < 1 {
		return localVarReturnValue, nil, reportError("accountProfileId must have at least 1 elements")
	}
	if strlen(r.accountProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("accountProfileId must have less than 2000 elements")
	}

	if r.markAsRecentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRecentlyAccessed", r.markAsRecentlyAccessed, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelAccountContractElementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	contractId string
	accountProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	attributeName *[]string
	orderType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelAccountContractElementsRequest) Authorization(authorization string) ChannelApiGetChannelAccountContractElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelAccountContractElementsRequest) XAppKey(xAppKey string) ChannelApiGetChannelAccountContractElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelAccountContractElementsRequest) XHotelid(xHotelid string) ChannelApiGetChannelAccountContractElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetChannelAccountContractElementsRequest) Limit(limit int32) ChannelApiGetChannelAccountContractElementsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetChannelAccountContractElementsRequest) Offset(offset int32) ChannelApiGetChannelAccountContractElementsRequest {
	r.offset = &offset
	return r
}

func (r ChannelApiGetChannelAccountContractElementsRequest) AttributeName(attributeName []string) ChannelApiGetChannelAccountContractElementsRequest {
	r.attributeName = &attributeName
	return r
}

func (r ChannelApiGetChannelAccountContractElementsRequest) OrderType(orderType []string) ChannelApiGetChannelAccountContractElementsRequest {
	r.orderType = &orderType
	return r
}

// External system code.
func (r ChannelApiGetChannelAccountContractElementsRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelAccountContractElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelAccountContractElementsRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelAccountContractElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelAccountContractElementsRequest) Execute() (*ChannelAccountContractElements, *http.Response, error) {
	return r.ApiService.GetChannelAccountContractElementsExecute(r)
}

/*
GetChannelAccountContractElements Gets channel account contracts for given profile Id.

Use this API to get existing cannel account contract for a given OPERA profile id. <p><strong>OperationId:</strong>getChannelAccountContractElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId Contract Id.
 @param accountProfileId Unique ID that identifies an account profile.
 @return ChannelApiGetChannelAccountContractElementsRequest
*/
func (a *ChannelApiService) GetChannelAccountContractElements(ctx context.Context, contractId string, accountProfileId string) ChannelApiGetChannelAccountContractElementsRequest {
	return ChannelApiGetChannelAccountContractElementsRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
		accountProfileId: accountProfileId,
	}
}

// Execute executes the request
//  @return ChannelAccountContractElements
func (a *ChannelApiService) GetChannelAccountContractElementsExecute(r ChannelApiGetChannelAccountContractElementsRequest) (*ChannelAccountContractElements, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelAccountContractElements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelAccountContractElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts/{accountProfileId}/contracts/{contractId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountProfileId"+"}", url.PathEscape(parameterValueToString(r.accountProfileId, "accountProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.contractId) < 1 {
		return localVarReturnValue, nil, reportError("contractId must have at least 1 elements")
	}
	if strlen(r.contractId) > 2000 {
		return localVarReturnValue, nil, reportError("contractId must have less than 2000 elements")
	}
	if strlen(r.accountProfileId) < 1 {
		return localVarReturnValue, nil, reportError("accountProfileId must have at least 1 elements")
	}
	if strlen(r.accountProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("accountProfileId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelAccountsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	excludeInactive *bool
	limit *int32
	offset *int32
	hotelId *[]string
	accountType *string
	accountName *string
	accountCode *string
	contractExpInDays *int32
	attributeName *[]string
	orderType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelAccountsRequest) Authorization(authorization string) ChannelApiGetChannelAccountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelAccountsRequest) XAppKey(xAppKey string) ChannelApiGetChannelAccountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelAccountsRequest) XHotelid(xHotelid string) ChannelApiGetChannelAccountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicator that tells whether to include inactive channel accounts or not.
func (r ChannelApiGetChannelAccountsRequest) ExcludeInactive(excludeInactive bool) ChannelApiGetChannelAccountsRequest {
	r.excludeInactive = &excludeInactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetChannelAccountsRequest) Limit(limit int32) ChannelApiGetChannelAccountsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetChannelAccountsRequest) Offset(offset int32) ChannelApiGetChannelAccountsRequest {
	r.offset = &offset
	return r
}

func (r ChannelApiGetChannelAccountsRequest) HotelId(hotelId []string) ChannelApiGetChannelAccountsRequest {
	r.hotelId = &hotelId
	return r
}

// Represents channel account TEMPLATE type.
func (r ChannelApiGetChannelAccountsRequest) AccountType(accountType string) ChannelApiGetChannelAccountsRequest {
	r.accountType = &accountType
	return r
}

// Account Name for which details need to be fetched.
func (r ChannelApiGetChannelAccountsRequest) AccountName(accountName string) ChannelApiGetChannelAccountsRequest {
	r.accountName = &accountName
	return r
}

// Account Code/No for which details need to be fetched.
func (r ChannelApiGetChannelAccountsRequest) AccountCode(accountCode string) ChannelApiGetChannelAccountsRequest {
	r.accountCode = &accountCode
	return r
}

// To fetch channel accounts which expires in no., of days.
func (r ChannelApiGetChannelAccountsRequest) ContractExpInDays(contractExpInDays int32) ChannelApiGetChannelAccountsRequest {
	r.contractExpInDays = &contractExpInDays
	return r
}

func (r ChannelApiGetChannelAccountsRequest) AttributeName(attributeName []string) ChannelApiGetChannelAccountsRequest {
	r.attributeName = &attributeName
	return r
}

func (r ChannelApiGetChannelAccountsRequest) OrderType(orderType []string) ChannelApiGetChannelAccountsRequest {
	r.orderType = &orderType
	return r
}

// External system code.
func (r ChannelApiGetChannelAccountsRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelAccountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelAccountsRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelAccountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelAccountsRequest) Execute() (*ChannelAccountsSummary, *http.Response, error) {
	return r.ApiService.GetChannelAccountsExecute(r)
}

/*
GetChannelAccounts This API retrieves channel accounts.

This API retrieves channel accounts. <p><strong>OperationId:</strong>getChannelAccounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetChannelAccountsRequest
*/
func (a *ChannelApiService) GetChannelAccounts(ctx context.Context) ChannelApiGetChannelAccountsRequest {
	return ChannelApiGetChannelAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelAccountsSummary
func (a *ChannelApiService) GetChannelAccountsExecute(r ChannelApiGetChannelAccountsRequest) (*ChannelAccountsSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelAccountsSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeInactive", r.excludeInactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "")
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	if r.accountCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountCode", r.accountCode, "")
	}
	if r.contractExpInDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractExpInDays", r.contractExpInDays, "")
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelBillingStatementRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	statementId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	idType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelBillingStatementRequest) Authorization(authorization string) ChannelApiGetChannelBillingStatementRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelBillingStatementRequest) XAppKey(xAppKey string) ChannelApiGetChannelBillingStatementRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelBillingStatementRequest) XHotelid(xHotelid string) ChannelApiGetChannelBillingStatementRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ChannelApiGetChannelBillingStatementRequest) IdContext(idContext string) ChannelApiGetChannelBillingStatementRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ChannelApiGetChannelBillingStatementRequest) IdType(idType string) ChannelApiGetChannelBillingStatementRequest {
	r.idType = &idType
	return r
}

// External system code.
func (r ChannelApiGetChannelBillingStatementRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelBillingStatementRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelBillingStatementRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelBillingStatementRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelBillingStatementRequest) Execute() (*ChannelBillingStatement, *http.Response, error) {
	return r.ApiService.GetChannelBillingStatementExecute(r)
}

/*
GetChannelBillingStatement Retrieves channel billing statement for a given statement Id

This API retrieves channel billing statement for a given statement Id. <p><strong>OperationId:</strong>getChannelBillingStatement</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param statementId Statement Id.
 @return ChannelApiGetChannelBillingStatementRequest
*/
func (a *ChannelApiService) GetChannelBillingStatement(ctx context.Context, statementId string) ChannelApiGetChannelBillingStatementRequest {
	return ChannelApiGetChannelBillingStatementRequest{
		ApiService: a,
		ctx: ctx,
		statementId: statementId,
	}
}

// Execute executes the request
//  @return ChannelBillingStatement
func (a *ChannelApiService) GetChannelBillingStatementExecute(r ChannelApiGetChannelBillingStatementRequest) (*ChannelBillingStatement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelBillingStatement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelBillingStatement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements/{statementId}"
	localVarPath = strings.Replace(localVarPath, "{"+"statementId"+"}", url.PathEscape(parameterValueToString(r.statementId, "statementId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.statementId) < 1 {
		return localVarReturnValue, nil, reportError("statementId must have at least 1 elements")
	}
	if strlen(r.statementId) > 2000 {
		return localVarReturnValue, nil, reportError("statementId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelBillingStatementDetailsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	statementId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	contractId *string
	contractIdType *string
	attributeName *[]string
	orderType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelBillingStatementDetailsRequest) Authorization(authorization string) ChannelApiGetChannelBillingStatementDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelBillingStatementDetailsRequest) XAppKey(xAppKey string) ChannelApiGetChannelBillingStatementDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelBillingStatementDetailsRequest) XHotelid(xHotelid string) ChannelApiGetChannelBillingStatementDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetChannelBillingStatementDetailsRequest) Limit(limit int32) ChannelApiGetChannelBillingStatementDetailsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetChannelBillingStatementDetailsRequest) Offset(offset int32) ChannelApiGetChannelBillingStatementDetailsRequest {
	r.offset = &offset
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ChannelApiGetChannelBillingStatementDetailsRequest) ContractId(contractId string) ChannelApiGetChannelBillingStatementDetailsRequest {
	r.contractId = &contractId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ChannelApiGetChannelBillingStatementDetailsRequest) ContractIdType(contractIdType string) ChannelApiGetChannelBillingStatementDetailsRequest {
	r.contractIdType = &contractIdType
	return r
}

func (r ChannelApiGetChannelBillingStatementDetailsRequest) AttributeName(attributeName []string) ChannelApiGetChannelBillingStatementDetailsRequest {
	r.attributeName = &attributeName
	return r
}

func (r ChannelApiGetChannelBillingStatementDetailsRequest) OrderType(orderType []string) ChannelApiGetChannelBillingStatementDetailsRequest {
	r.orderType = &orderType
	return r
}

// External system code.
func (r ChannelApiGetChannelBillingStatementDetailsRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelBillingStatementDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelBillingStatementDetailsRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelBillingStatementDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelBillingStatementDetailsRequest) Execute() (*ChannelBillingStatementDetails, *http.Response, error) {
	return r.ApiService.GetChannelBillingStatementDetailsExecute(r)
}

/*
GetChannelBillingStatementDetails Retrieves channel billing statement details for a given statement Id

This API retrieves channel billing statement details for a given statement Id. <p><strong>OperationId:</strong>getChannelBillingStatementDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param statementId Statement Id.
 @return ChannelApiGetChannelBillingStatementDetailsRequest
*/
func (a *ChannelApiService) GetChannelBillingStatementDetails(ctx context.Context, statementId string) ChannelApiGetChannelBillingStatementDetailsRequest {
	return ChannelApiGetChannelBillingStatementDetailsRequest{
		ApiService: a,
		ctx: ctx,
		statementId: statementId,
	}
}

// Execute executes the request
//  @return ChannelBillingStatementDetails
func (a *ChannelApiService) GetChannelBillingStatementDetailsExecute(r ChannelApiGetChannelBillingStatementDetailsRequest) (*ChannelBillingStatementDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelBillingStatementDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelBillingStatementDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements/{statementId}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"statementId"+"}", url.PathEscape(parameterValueToString(r.statementId, "statementId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.statementId) < 1 {
		return localVarReturnValue, nil, reportError("statementId must have at least 1 elements")
	}
	if strlen(r.statementId) > 2000 {
		return localVarReturnValue, nil, reportError("statementId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.contractId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractId", r.contractId, "")
	}
	if r.contractIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractIdType", r.contractIdType, "")
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelBillingStatementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	includeLocked *bool
	limit *int32
	offset *int32
	statementId *string
	statementIdType *string
	beginDate *string
	endDate *string
	profileId *[]string
	profileIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelBillingStatementsRequest) Authorization(authorization string) ChannelApiGetChannelBillingStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelBillingStatementsRequest) XAppKey(xAppKey string) ChannelApiGetChannelBillingStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelBillingStatementsRequest) XHotelid(xHotelid string) ChannelApiGetChannelBillingStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether search results should include locked statements or not. By default, locked statements will be included.
func (r ChannelApiGetChannelBillingStatementsRequest) IncludeLocked(includeLocked bool) ChannelApiGetChannelBillingStatementsRequest {
	r.includeLocked = &includeLocked
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetChannelBillingStatementsRequest) Limit(limit int32) ChannelApiGetChannelBillingStatementsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetChannelBillingStatementsRequest) Offset(offset int32) ChannelApiGetChannelBillingStatementsRequest {
	r.offset = &offset
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ChannelApiGetChannelBillingStatementsRequest) StatementId(statementId string) ChannelApiGetChannelBillingStatementsRequest {
	r.statementId = &statementId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ChannelApiGetChannelBillingStatementsRequest) StatementIdType(statementIdType string) ChannelApiGetChannelBillingStatementsRequest {
	r.statementIdType = &statementIdType
	return r
}

// Begin date of the statement.
func (r ChannelApiGetChannelBillingStatementsRequest) BeginDate(beginDate string) ChannelApiGetChannelBillingStatementsRequest {
	r.beginDate = &beginDate
	return r
}

// End date of the statement.
func (r ChannelApiGetChannelBillingStatementsRequest) EndDate(endDate string) ChannelApiGetChannelBillingStatementsRequest {
	r.endDate = &endDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ChannelApiGetChannelBillingStatementsRequest) ProfileId(profileId []string) ChannelApiGetChannelBillingStatementsRequest {
	r.profileId = &profileId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ChannelApiGetChannelBillingStatementsRequest) ProfileIdType(profileIdType []string) ChannelApiGetChannelBillingStatementsRequest {
	r.profileIdType = &profileIdType
	return r
}

// External system code.
func (r ChannelApiGetChannelBillingStatementsRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelBillingStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelBillingStatementsRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelBillingStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelBillingStatementsRequest) Execute() (*ChannelBillingStatementSummaries, *http.Response, error) {
	return r.ApiService.GetChannelBillingStatementsExecute(r)
}

/*
GetChannelBillingStatements Retrieves channel billing statements.

This API retrieves channel billing statements. <p><strong>OperationId:</strong>getChannelBillingStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetChannelBillingStatementsRequest
*/
func (a *ChannelApiService) GetChannelBillingStatements(ctx context.Context) ChannelApiGetChannelBillingStatementsRequest {
	return ChannelApiGetChannelBillingStatementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelBillingStatementSummaries
func (a *ChannelApiService) GetChannelBillingStatementsExecute(r ChannelApiGetChannelBillingStatementsRequest) (*ChannelBillingStatementSummaries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelBillingStatementSummaries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelBillingStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLocked", r.includeLocked, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.statementId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementId", r.statementId, "")
	}
	if r.statementIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementIdType", r.statementIdType, "")
	}
	if r.beginDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", r.beginDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.profileId != nil {
		t := *r.profileId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", t, "multi")
		}
	}
	if r.profileIdType != nil {
		t := *r.profileIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelCardTypeMappingsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	bookingChannelCodes *[]string
	cardTypes *[]string
	channelCardTypes *[]string
	includeInactive *bool
	fetchUnmapped *bool
	fetchMapped *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r ChannelApiGetChannelCardTypeMappingsRequest) HotelIds(hotelIds []string) ChannelApiGetChannelCardTypeMappingsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelCardTypeMappingsRequest) Authorization(authorization string) ChannelApiGetChannelCardTypeMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelCardTypeMappingsRequest) XAppKey(xAppKey string) ChannelApiGetChannelCardTypeMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelCardTypeMappingsRequest) XHotelid(xHotelid string) ChannelApiGetChannelCardTypeMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetChannelCardTypeMappingsRequest) Limit(limit int32) ChannelApiGetChannelCardTypeMappingsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetChannelCardTypeMappingsRequest) Offset(offset int32) ChannelApiGetChannelCardTypeMappingsRequest {
	r.offset = &offset
	return r
}

func (r ChannelApiGetChannelCardTypeMappingsRequest) BookingChannelCodes(bookingChannelCodes []string) ChannelApiGetChannelCardTypeMappingsRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

func (r ChannelApiGetChannelCardTypeMappingsRequest) CardTypes(cardTypes []string) ChannelApiGetChannelCardTypeMappingsRequest {
	r.cardTypes = &cardTypes
	return r
}

func (r ChannelApiGetChannelCardTypeMappingsRequest) ChannelCardTypes(channelCardTypes []string) ChannelApiGetChannelCardTypeMappingsRequest {
	r.channelCardTypes = &channelCardTypes
	return r
}

// Indicates whether search includes inactive mapping.
func (r ChannelApiGetChannelCardTypeMappingsRequest) IncludeInactive(includeInactive bool) ChannelApiGetChannelCardTypeMappingsRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates whether unmapped channel-hotel card types should be fetched.
func (r ChannelApiGetChannelCardTypeMappingsRequest) FetchUnmapped(fetchUnmapped bool) ChannelApiGetChannelCardTypeMappingsRequest {
	r.fetchUnmapped = &fetchUnmapped
	return r
}

// Indicates whether mapped channel-hotel card types should be fetched.
func (r ChannelApiGetChannelCardTypeMappingsRequest) FetchMapped(fetchMapped bool) ChannelApiGetChannelCardTypeMappingsRequest {
	r.fetchMapped = &fetchMapped
	return r
}

// External system code.
func (r ChannelApiGetChannelCardTypeMappingsRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelCardTypeMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelCardTypeMappingsRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelCardTypeMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelCardTypeMappingsRequest) Execute() (*ChannelCardTypeMappingDetails, *http.Response, error) {
	return r.ApiService.GetChannelCardTypeMappingsExecute(r)
}

/*
GetChannelCardTypeMappings Gets channel credit card mapping for a hotel

Use this API to get channel mapping for OPERA credit cards to channel for a given hotel id. <p><strong>OperationId:</strong>getChannelCardTypeMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetChannelCardTypeMappingsRequest
*/
func (a *ChannelApiService) GetChannelCardTypeMappings(ctx context.Context) ChannelApiGetChannelCardTypeMappingsRequest {
	return ChannelApiGetChannelCardTypeMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelCardTypeMappingDetails
func (a *ChannelApiService) GetChannelCardTypeMappingsExecute(r ChannelApiGetChannelCardTypeMappingsRequest) (*ChannelCardTypeMappingDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelCardTypeMappingDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelCardTypeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/cardType/mappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.bookingChannelCodes != nil {
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	if r.cardTypes != nil {
		t := *r.cardTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cardTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cardTypes", t, "multi")
		}
	}
	if r.channelCardTypes != nil {
		t := *r.channelCardTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelCardTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelCardTypes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.fetchUnmapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchUnmapped", r.fetchUnmapped, "")
	}
	if r.fetchMapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchMapped", r.fetchMapped, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelGuaranteeCodeMappingsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	limit *int32
	offset *int32
	bookingChannelCodes *[]string
	guaranteeCode *[]string
	channelGuaranteeCode *[]string
	includeInactive *bool
	fetchUnmapped *bool
	fetchMapped *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) Authorization(authorization string) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) XAppKey(xAppKey string) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) XHotelid(xHotelid string) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) HotelIds(hotelIds []string) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) Limit(limit int32) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) Offset(offset int32) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.offset = &offset
	return r
}

func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) BookingChannelCodes(bookingChannelCodes []string) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) GuaranteeCode(guaranteeCode []string) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) ChannelGuaranteeCode(channelGuaranteeCode []string) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.channelGuaranteeCode = &channelGuaranteeCode
	return r
}

// Indicates whether search includes inactive mapping.
func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) IncludeInactive(includeInactive bool) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates whether unmapped channel-hotel guarantee code should be fetched.
func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) FetchUnmapped(fetchUnmapped bool) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.fetchUnmapped = &fetchUnmapped
	return r
}

// Indicates whether mapped channel-hotel guarantee code should be fetched.
func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) FetchMapped(fetchMapped bool) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.fetchMapped = &fetchMapped
	return r
}

// External system code.
func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelGuaranteeCodeMappingsRequest) Execute() (*ChannelGuaranteeCodeMappingDetails, *http.Response, error) {
	return r.ApiService.GetChannelGuaranteeCodeMappingsExecute(r)
}

/*
GetChannelGuaranteeCodeMappings Gets channel guarantee code mappings

Use this API  to get the list of the channel guarantee code mappings to the OPERA guarantee codes. <p><strong>OperationId:</strong>getChannelGuaranteeCodeMappings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiGetChannelGuaranteeCodeMappingsRequest
*/
func (a *ChannelApiService) GetChannelGuaranteeCodeMappings(ctx context.Context, hotelId string) ChannelApiGetChannelGuaranteeCodeMappingsRequest {
	return ChannelApiGetChannelGuaranteeCodeMappingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelGuaranteeCodeMappingDetails
func (a *ChannelApiService) GetChannelGuaranteeCodeMappingsExecute(r ChannelApiGetChannelGuaranteeCodeMappingsRequest) (*ChannelGuaranteeCodeMappingDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelGuaranteeCodeMappingDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelGuaranteeCodeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/guarantees"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.bookingChannelCodes != nil {
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	if r.guaranteeCode != nil {
		t := *r.guaranteeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", t, "multi")
		}
	}
	if r.channelGuaranteeCode != nil {
		t := *r.channelGuaranteeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelGuaranteeCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelGuaranteeCode", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.fetchUnmapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchUnmapped", r.fetchUnmapped, "")
	}
	if r.fetchMapped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchMapped", r.fetchMapped, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelHotelCodeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	channelHotelCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelHotelCodeMappingRequest) Authorization(authorization string) ChannelApiGetChannelHotelCodeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelHotelCodeMappingRequest) XAppKey(xAppKey string) ChannelApiGetChannelHotelCodeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelHotelCodeMappingRequest) XHotelid(xHotelid string) ChannelApiGetChannelHotelCodeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// OPERA hotel code for which mapped channel hotel code should be fetched.
func (r ChannelApiGetChannelHotelCodeMappingRequest) HotelId(hotelId string) ChannelApiGetChannelHotelCodeMappingRequest {
	r.hotelId = &hotelId
	return r
}

// Channel hotel code for which mapped OPERA hotel code should be fetched.
func (r ChannelApiGetChannelHotelCodeMappingRequest) ChannelHotelCode(channelHotelCode string) ChannelApiGetChannelHotelCodeMappingRequest {
	r.channelHotelCode = &channelHotelCode
	return r
}

// External system code.
func (r ChannelApiGetChannelHotelCodeMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelHotelCodeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelHotelCodeMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelHotelCodeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelHotelCodeMappingRequest) Execute() (*ChannelHotelCodeMapping, *http.Response, error) {
	return r.ApiService.GetChannelHotelCodeMappingExecute(r)
}

/*
GetChannelHotelCodeMapping Get channel hotel mappings

Use this API to get the channel mappings to the OPERA hotel id, including hotel details for channel hotel code, room sell limit per reservation, city code and end date. <p><strong>OperationId:</strong>getChannelHotelCodeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiGetChannelHotelCodeMappingRequest
*/
func (a *ChannelApiService) GetChannelHotelCodeMapping(ctx context.Context, channelCode string) ChannelApiGetChannelHotelCodeMappingRequest {
	return ChannelApiGetChannelHotelCodeMappingRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return ChannelHotelCodeMapping
func (a *ChannelApiService) GetChannelHotelCodeMappingExecute(r ChannelApiGetChannelHotelCodeMappingRequest) (*ChannelHotelCodeMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelHotelCodeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelHotelCodeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/hotels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.channelHotelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelHotelCode", r.channelHotelCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelHotelLettersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelCode *[]string
	hotelIds *[]string
	language *string
	letterType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelHotelLettersRequest) Authorization(authorization string) ChannelApiGetChannelHotelLettersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelHotelLettersRequest) XAppKey(xAppKey string) ChannelApiGetChannelHotelLettersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelHotelLettersRequest) XHotelid(xHotelid string) ChannelApiGetChannelHotelLettersRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChannelApiGetChannelHotelLettersRequest) ChannelCode(channelCode []string) ChannelApiGetChannelHotelLettersRequest {
	r.channelCode = &channelCode
	return r
}

func (r ChannelApiGetChannelHotelLettersRequest) HotelIds(hotelIds []string) ChannelApiGetChannelHotelLettersRequest {
	r.hotelIds = &hotelIds
	return r
}

// Language code associated with the hotel letters.
func (r ChannelApiGetChannelHotelLettersRequest) Language(language string) ChannelApiGetChannelHotelLettersRequest {
	r.language = &language
	return r
}

// Represents Inquiry Letter Type.
func (r ChannelApiGetChannelHotelLettersRequest) LetterType(letterType string) ChannelApiGetChannelHotelLettersRequest {
	r.letterType = &letterType
	return r
}

// External system code.
func (r ChannelApiGetChannelHotelLettersRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelHotelLettersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelHotelLettersRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelHotelLettersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelHotelLettersRequest) Execute() (*FetchedChannelHotelLetters, *http.Response, error) {
	return r.ApiService.GetChannelHotelLettersExecute(r)
}

/*
GetChannelHotelLetters Gets channel property confirmation letter mapping

Use this API to get channel property confirmation letter configuration <p><strong>OperationId:</strong>getChannelHotelLetters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetChannelHotelLettersRequest
*/
func (a *ChannelApiService) GetChannelHotelLetters(ctx context.Context) ChannelApiGetChannelHotelLettersRequest {
	return ChannelApiGetChannelHotelLettersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchedChannelHotelLetters
func (a *ChannelApiService) GetChannelHotelLettersExecute(r ChannelApiGetChannelHotelLettersRequest) (*FetchedChannelHotelLetters, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchedChannelHotelLetters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelHotelLetters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/confirmationLetters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelCode != nil {
		t := *r.channelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", t, "multi")
		}
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	if r.letterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "letterType", r.letterType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelMarketingTextRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionType *string
	policyType *string
	policyDetail *string
	beginDate *string
	filterHotelIds *[]string
	bookingChannelCode *[]string
	transactionTypes *[]string
	policyTypesPolicyType *[]string
	policyDetailPolicyDetail *[]string
	showGlobal *bool
	includeInactive *bool
	fetchInstructions *[]string
	hotelIds *[]string
	channelCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelMarketingTextRequest) Authorization(authorization string) ChannelApiGetChannelMarketingTextRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelMarketingTextRequest) XAppKey(xAppKey string) ChannelApiGetChannelMarketingTextRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelMarketingTextRequest) XHotelid(xHotelid string) ChannelApiGetChannelMarketingTextRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChannelApiGetChannelMarketingTextRequest) TransactionType(transactionType string) ChannelApiGetChannelMarketingTextRequest {
	r.transactionType = &transactionType
	return r
}

func (r ChannelApiGetChannelMarketingTextRequest) PolicyType(policyType string) ChannelApiGetChannelMarketingTextRequest {
	r.policyType = &policyType
	return r
}

func (r ChannelApiGetChannelMarketingTextRequest) PolicyDetail(policyDetail string) ChannelApiGetChannelMarketingTextRequest {
	r.policyDetail = &policyDetail
	return r
}

func (r ChannelApiGetChannelMarketingTextRequest) BeginDate(beginDate string) ChannelApiGetChannelMarketingTextRequest {
	r.beginDate = &beginDate
	return r
}

func (r ChannelApiGetChannelMarketingTextRequest) FilterHotelIds(filterHotelIds []string) ChannelApiGetChannelMarketingTextRequest {
	r.filterHotelIds = &filterHotelIds
	return r
}

func (r ChannelApiGetChannelMarketingTextRequest) BookingChannelCode(bookingChannelCode []string) ChannelApiGetChannelMarketingTextRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

func (r ChannelApiGetChannelMarketingTextRequest) TransactionTypes(transactionTypes []string) ChannelApiGetChannelMarketingTextRequest {
	r.transactionTypes = &transactionTypes
	return r
}

func (r ChannelApiGetChannelMarketingTextRequest) PolicyTypesPolicyType(policyTypesPolicyType []string) ChannelApiGetChannelMarketingTextRequest {
	r.policyTypesPolicyType = &policyTypesPolicyType
	return r
}

func (r ChannelApiGetChannelMarketingTextRequest) PolicyDetailPolicyDetail(policyDetailPolicyDetail []string) ChannelApiGetChannelMarketingTextRequest {
	r.policyDetailPolicyDetail = &policyDetailPolicyDetail
	return r
}

func (r ChannelApiGetChannelMarketingTextRequest) ShowGlobal(showGlobal bool) ChannelApiGetChannelMarketingTextRequest {
	r.showGlobal = &showGlobal
	return r
}

// Include or not include inactive channel marketing text.
func (r ChannelApiGetChannelMarketingTextRequest) IncludeInactive(includeInactive bool) ChannelApiGetChannelMarketingTextRequest {
	r.includeInactive = &includeInactive
	return r
}

// Simple type for channel fetch instruction.
func (r ChannelApiGetChannelMarketingTextRequest) FetchInstructions(fetchInstructions []string) ChannelApiGetChannelMarketingTextRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Hotel code.
func (r ChannelApiGetChannelMarketingTextRequest) HotelIds(hotelIds []string) ChannelApiGetChannelMarketingTextRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ChannelApiGetChannelMarketingTextRequest) ChannelCode(channelCode []string) ChannelApiGetChannelMarketingTextRequest {
	r.channelCode = &channelCode
	return r
}

// External system code.
func (r ChannelApiGetChannelMarketingTextRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelMarketingTextRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelMarketingTextRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelMarketingTextRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelMarketingTextRequest) Execute() (*ChannelMarketingTextsInfo, *http.Response, error) {
	return r.ApiService.GetChannelMarketingTextExecute(r)
}

/*
GetChannelMarketingText Gets channel marketing messages

Use this API to get channel mapping for marketing messages. <p><strong>OperationId:</strong>getChannelMarketingText</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetChannelMarketingTextRequest
*/
func (a *ChannelApiService) GetChannelMarketingText(ctx context.Context) ChannelApiGetChannelMarketingTextRequest {
	return ChannelApiGetChannelMarketingTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelMarketingTextsInfo
func (a *ChannelApiService) GetChannelMarketingTextExecute(r ChannelApiGetChannelMarketingTextRequest) (*ChannelMarketingTextsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelMarketingTextsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelMarketingText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/marketingText"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionType", r.transactionType, "")
	}
	if r.policyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyType", r.policyType, "")
	}
	if r.policyDetail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyDetail", r.policyDetail, "")
	}
	if r.beginDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", r.beginDate, "")
	}
	if r.filterHotelIds != nil {
		t := *r.filterHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterHotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterHotelIds", t, "multi")
		}
	}
	if r.bookingChannelCode != nil {
		t := *r.bookingChannelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", t, "multi")
		}
	}
	if r.transactionTypes != nil {
		t := *r.transactionTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionTypes", t, "multi")
		}
	}
	if r.policyTypesPolicyType != nil {
		t := *r.policyTypesPolicyType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policyTypesPolicyType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policyTypesPolicyType", t, "multi")
		}
	}
	if r.policyDetailPolicyDetail != nil {
		t := *r.policyDetailPolicyDetail
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policyDetailPolicyDetail", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policyDetailPolicyDetail", t, "multi")
		}
	}
	if r.showGlobal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showGlobal", r.showGlobal, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.channelCode != nil {
		t := *r.channelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelNegotiatedRateRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	hotelId *string
	bookingChannelCode *string
	channelRatePlanCode *string
	accessCode *string
	uniqueId *[]string
	uniqueIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelNegotiatedRateRequest) Authorization(authorization string) ChannelApiGetChannelNegotiatedRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelNegotiatedRateRequest) XAppKey(xAppKey string) ChannelApiGetChannelNegotiatedRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelNegotiatedRateRequest) XHotelid(xHotelid string) ChannelApiGetChannelNegotiatedRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetChannelNegotiatedRateRequest) Limit(limit int32) ChannelApiGetChannelNegotiatedRateRequest {
	r.limit = &limit
	return r
}

func (r ChannelApiGetChannelNegotiatedRateRequest) HotelId(hotelId string) ChannelApiGetChannelNegotiatedRateRequest {
	r.hotelId = &hotelId
	return r
}

func (r ChannelApiGetChannelNegotiatedRateRequest) BookingChannelCode(bookingChannelCode string) ChannelApiGetChannelNegotiatedRateRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

func (r ChannelApiGetChannelNegotiatedRateRequest) ChannelRatePlanCode(channelRatePlanCode string) ChannelApiGetChannelNegotiatedRateRequest {
	r.channelRatePlanCode = &channelRatePlanCode
	return r
}

func (r ChannelApiGetChannelNegotiatedRateRequest) AccessCode(accessCode string) ChannelApiGetChannelNegotiatedRateRequest {
	r.accessCode = &accessCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ChannelApiGetChannelNegotiatedRateRequest) UniqueId(uniqueId []string) ChannelApiGetChannelNegotiatedRateRequest {
	r.uniqueId = &uniqueId
	return r
}

func (r ChannelApiGetChannelNegotiatedRateRequest) UniqueIdType(uniqueIdType []string) ChannelApiGetChannelNegotiatedRateRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// External system code.
func (r ChannelApiGetChannelNegotiatedRateRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelNegotiatedRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelNegotiatedRateRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelNegotiatedRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelNegotiatedRateRequest) Execute() (*ChannelNegotiatedRateDetails, *http.Response, error) {
	return r.ApiService.GetChannelNegotiatedRateExecute(r)
}

/*
GetChannelNegotiatedRate Gets channel negotiate rate

Use this API to update channel's negotiated rate code mapping including negotiated profile, negotiate rate access code, start date, end date, and sequence. <p><strong>OperationId:</strong>getChannelNegotiatedRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetChannelNegotiatedRateRequest
*/
func (a *ChannelApiService) GetChannelNegotiatedRate(ctx context.Context) ChannelApiGetChannelNegotiatedRateRequest {
	return ChannelApiGetChannelNegotiatedRateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelNegotiatedRateDetails
func (a *ChannelApiService) GetChannelNegotiatedRateExecute(r ChannelApiGetChannelNegotiatedRateRequest) (*ChannelNegotiatedRateDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelNegotiatedRateDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelNegotiatedRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/negotiatedRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.bookingChannelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", r.bookingChannelCode, "")
	}
	if r.channelRatePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", r.channelRatePlanCode, "")
	}
	if r.accessCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessCode", r.accessCode, "")
	}
	if r.uniqueId != nil {
		t := *r.uniqueId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueId", t, "multi")
		}
	}
	if r.uniqueIdType != nil {
		t := *r.uniqueIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelOrgMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	tenantCode string
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	chainCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelOrgMappingRequest) Authorization(authorization string) ChannelApiGetChannelOrgMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelOrgMappingRequest) XAppKey(xAppKey string) ChannelApiGetChannelOrgMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelOrgMappingRequest) XHotelid(xHotelid string) ChannelApiGetChannelOrgMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Chain code for which channel code and org code are mapped.
func (r ChannelApiGetChannelOrgMappingRequest) ChainCode(chainCode string) ChannelApiGetChannelOrgMappingRequest {
	r.chainCode = &chainCode
	return r
}

// External system code.
func (r ChannelApiGetChannelOrgMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelOrgMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelOrgMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelOrgMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelOrgMappingRequest) Execute() (*ChannelOrgMappingsDetails, *http.Response, error) {
	return r.ApiService.GetChannelOrgMappingExecute(r)
}

/*
GetChannelOrgMapping Retrieves channel tenants mapping.

This API retrieves channel tenants mapping. <p><strong>OperationId:</strong>getChannelOrgMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantCode Tenant Code.
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiGetChannelOrgMappingRequest
*/
func (a *ChannelApiService) GetChannelOrgMapping(ctx context.Context, tenantCode string, channelCode string) ChannelApiGetChannelOrgMappingRequest {
	return ChannelApiGetChannelOrgMappingRequest{
		ApiService: a,
		ctx: ctx,
		tenantCode: tenantCode,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return ChannelOrgMappingsDetails
func (a *ChannelApiService) GetChannelOrgMappingExecute(r ChannelApiGetChannelOrgMappingRequest) (*ChannelOrgMappingsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelOrgMappingsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelOrgMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/tenants/{tenantCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantCode"+"}", url.PathEscape(parameterValueToString(r.tenantCode, "tenantCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.tenantCode) < 1 {
		return localVarReturnValue, nil, reportError("tenantCode must have at least 1 elements")
	}
	if strlen(r.tenantCode) > 2000 {
		return localVarReturnValue, nil, reportError("tenantCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	if r.chainCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainCode", r.chainCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelParametersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	parameterNameWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelParametersRequest) Authorization(authorization string) ChannelApiGetChannelParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelParametersRequest) XAppKey(xAppKey string) ChannelApiGetChannelParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelParametersRequest) XHotelid(xHotelid string) ChannelApiGetChannelParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Parameter for wild card search on channel parameters.
func (r ChannelApiGetChannelParametersRequest) ParameterNameWildCard(parameterNameWildCard string) ChannelApiGetChannelParametersRequest {
	r.parameterNameWildCard = &parameterNameWildCard
	return r
}

// External system code.
func (r ChannelApiGetChannelParametersRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelParametersRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelParametersRequest) Execute() (*ChannelParameterMapping, *http.Response, error) {
	return r.ApiService.GetChannelParametersExecute(r)
}

/*
GetChannelParameters Retrieves channel parameters.

Use this API to get list of channel parameters and their settings. <p><strong>OperationId:</strong>getChannelParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiGetChannelParametersRequest
*/
func (a *ChannelApiService) GetChannelParameters(ctx context.Context, channelCode string, hotelId string) ChannelApiGetChannelParametersRequest {
	return ChannelApiGetChannelParametersRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelParameterMapping
func (a *ChannelApiService) GetChannelParametersExecute(r ChannelApiGetChannelParametersRequest) (*ChannelParameterMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelParameterMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/parameters"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.parameterNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parameterNameWildCard", r.parameterNameWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelPoliciesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	requestType *string
	startDate *string
	endDate *string
	duration *string
	channelRatePlanCode *[]string
	channelRoomTypeCode *[]string
	ratePlanCode *[]string
	roomTypeCode *[]string
	corporateId *string
	corporateIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelPoliciesRequest) Authorization(authorization string) ChannelApiGetChannelPoliciesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelPoliciesRequest) XAppKey(xAppKey string) ChannelApiGetChannelPoliciesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelPoliciesRequest) XHotelid(xHotelid string) ChannelApiGetChannelPoliciesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChannelApiGetChannelPoliciesRequest) RequestType(requestType string) ChannelApiGetChannelPoliciesRequest {
	r.requestType = &requestType
	return r
}

func (r ChannelApiGetChannelPoliciesRequest) StartDate(startDate string) ChannelApiGetChannelPoliciesRequest {
	r.startDate = &startDate
	return r
}

func (r ChannelApiGetChannelPoliciesRequest) EndDate(endDate string) ChannelApiGetChannelPoliciesRequest {
	r.endDate = &endDate
	return r
}

func (r ChannelApiGetChannelPoliciesRequest) Duration(duration string) ChannelApiGetChannelPoliciesRequest {
	r.duration = &duration
	return r
}

func (r ChannelApiGetChannelPoliciesRequest) ChannelRatePlanCode(channelRatePlanCode []string) ChannelApiGetChannelPoliciesRequest {
	r.channelRatePlanCode = &channelRatePlanCode
	return r
}

func (r ChannelApiGetChannelPoliciesRequest) ChannelRoomTypeCode(channelRoomTypeCode []string) ChannelApiGetChannelPoliciesRequest {
	r.channelRoomTypeCode = &channelRoomTypeCode
	return r
}

func (r ChannelApiGetChannelPoliciesRequest) RatePlanCode(ratePlanCode []string) ChannelApiGetChannelPoliciesRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

func (r ChannelApiGetChannelPoliciesRequest) RoomTypeCode(roomTypeCode []string) ChannelApiGetChannelPoliciesRequest {
	r.roomTypeCode = &roomTypeCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ChannelApiGetChannelPoliciesRequest) CorporateId(corporateId string) ChannelApiGetChannelPoliciesRequest {
	r.corporateId = &corporateId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ChannelApiGetChannelPoliciesRequest) CorporateIdType(corporateIdType string) ChannelApiGetChannelPoliciesRequest {
	r.corporateIdType = &corporateIdType
	return r
}

// External system code.
func (r ChannelApiGetChannelPoliciesRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelPoliciesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelPoliciesRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelPoliciesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelPoliciesRequest) Execute() (*ChannelPolicies, *http.Response, error) {
	return r.ApiService.GetChannelPoliciesExecute(r)
}

/*
GetChannelPolicies Retrieves the channel policies

Use this API to retrieve channel policies mapping. <p><strong>OperationId:</strong>getChannelPolicies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiGetChannelPoliciesRequest
*/
func (a *ChannelApiService) GetChannelPolicies(ctx context.Context, channelCode string, hotelId string) ChannelApiGetChannelPoliciesRequest {
	return ChannelApiGetChannelPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelPolicies
func (a *ChannelApiService) GetChannelPoliciesExecute(r ChannelApiGetChannelPoliciesRequest) (*ChannelPolicies, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelPolicies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.requestType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requestType", r.requestType, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.channelRatePlanCode != nil {
		t := *r.channelRatePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", t, "multi")
		}
	}
	if r.channelRoomTypeCode != nil {
		t := *r.channelRoomTypeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomTypeCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomTypeCode", t, "multi")
		}
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	if r.roomTypeCode != nil {
		t := *r.roomTypeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCode", t, "multi")
		}
	}
	if r.corporateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "corporateId", r.corporateId, "")
	}
	if r.corporateIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "corporateIdType", r.corporateIdType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelRateCodeGlobalDescRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelRateCodeGlobalDescRequest) Authorization(authorization string) ChannelApiGetChannelRateCodeGlobalDescRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelRateCodeGlobalDescRequest) XAppKey(xAppKey string) ChannelApiGetChannelRateCodeGlobalDescRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelRateCodeGlobalDescRequest) XHotelid(xHotelid string) ChannelApiGetChannelRateCodeGlobalDescRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChannelApiGetChannelRateCodeGlobalDescRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelRateCodeGlobalDescRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelRateCodeGlobalDescRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelRateCodeGlobalDescRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelRateCodeGlobalDescRequest) Execute() (*ChannelEnhancedGlobalDescription, *http.Response, error) {
	return r.ApiService.GetChannelRateCodeGlobalDescExecute(r)
}

/*
GetChannelRateCodeGlobalDesc Gets global rate descriptions

Use this API to get global rate description for given hotel id and rate code. <p><strong>OperationId:</strong>getChannelRateCodeGlobalDesc</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiGetChannelRateCodeGlobalDescRequest
*/
func (a *ChannelApiService) GetChannelRateCodeGlobalDesc(ctx context.Context, ratePlanCode string, hotelId string) ChannelApiGetChannelRateCodeGlobalDescRequest {
	return ChannelApiGetChannelRateCodeGlobalDescRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelEnhancedGlobalDescription
func (a *ChannelApiService) GetChannelRateCodeGlobalDescExecute(r ChannelApiGetChannelRateCodeGlobalDescRequest) (*ChannelEnhancedGlobalDescription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelEnhancedGlobalDescription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRateCodeGlobalDesc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rates/{ratePlanCode}/globalDescription"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelRateMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelId *[]string
	channelCode *[]string
	ratePlanCodes *[]string
	channelRatePlanCodes *[]string
	ratePlanCategories *[]string
	channelRatePlanCategories *[]string
	includeUnmappedRatePlans *bool
	onlyUnmappedRatePlans *bool
	includeInactiveMappings *bool
	onlyNegotiatedRates *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelRateMappingRequest) Authorization(authorization string) ChannelApiGetChannelRateMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelRateMappingRequest) XAppKey(xAppKey string) ChannelApiGetChannelRateMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelRateMappingRequest) XHotelid(xHotelid string) ChannelApiGetChannelRateMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetChannelRateMappingRequest) Limit(limit int32) ChannelApiGetChannelRateMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetChannelRateMappingRequest) Offset(offset int32) ChannelApiGetChannelRateMappingRequest {
	r.offset = &offset
	return r
}

func (r ChannelApiGetChannelRateMappingRequest) HotelId(hotelId []string) ChannelApiGetChannelRateMappingRequest {
	r.hotelId = &hotelId
	return r
}

func (r ChannelApiGetChannelRateMappingRequest) ChannelCode(channelCode []string) ChannelApiGetChannelRateMappingRequest {
	r.channelCode = &channelCode
	return r
}

func (r ChannelApiGetChannelRateMappingRequest) RatePlanCodes(ratePlanCodes []string) ChannelApiGetChannelRateMappingRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ChannelApiGetChannelRateMappingRequest) ChannelRatePlanCodes(channelRatePlanCodes []string) ChannelApiGetChannelRateMappingRequest {
	r.channelRatePlanCodes = &channelRatePlanCodes
	return r
}

func (r ChannelApiGetChannelRateMappingRequest) RatePlanCategories(ratePlanCategories []string) ChannelApiGetChannelRateMappingRequest {
	r.ratePlanCategories = &ratePlanCategories
	return r
}

func (r ChannelApiGetChannelRateMappingRequest) ChannelRatePlanCategories(channelRatePlanCategories []string) ChannelApiGetChannelRateMappingRequest {
	r.channelRatePlanCategories = &channelRatePlanCategories
	return r
}

// Flag whether to include unmapped rate codes.
func (r ChannelApiGetChannelRateMappingRequest) IncludeUnmappedRatePlans(includeUnmappedRatePlans bool) ChannelApiGetChannelRateMappingRequest {
	r.includeUnmappedRatePlans = &includeUnmappedRatePlans
	return r
}

// Flag whether to include unmapped rate codes only.
func (r ChannelApiGetChannelRateMappingRequest) OnlyUnmappedRatePlans(onlyUnmappedRatePlans bool) ChannelApiGetChannelRateMappingRequest {
	r.onlyUnmappedRatePlans = &onlyUnmappedRatePlans
	return r
}

// Flag whether to include inactive mappings.
func (r ChannelApiGetChannelRateMappingRequest) IncludeInactiveMappings(includeInactiveMappings bool) ChannelApiGetChannelRateMappingRequest {
	r.includeInactiveMappings = &includeInactiveMappings
	return r
}

// Flag whether to include negotiated rate mappings only.
func (r ChannelApiGetChannelRateMappingRequest) OnlyNegotiatedRates(onlyNegotiatedRates bool) ChannelApiGetChannelRateMappingRequest {
	r.onlyNegotiatedRates = &onlyNegotiatedRates
	return r
}

// External system code.
func (r ChannelApiGetChannelRateMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelRateMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelRateMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelRateMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelRateMappingRequest) Execute() (*ChannelRateMappings, *http.Response, error) {
	return r.ApiService.GetChannelRateMappingExecute(r)
}

/*
GetChannelRateMapping Gets channel property rate mapping

Use this API to get channel property rate mapping including channel rate code, start date, end date, rate level, channel rate description. <p><strong>OperationId:</strong>getChannelRateMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetChannelRateMappingRequest
*/
func (a *ChannelApiService) GetChannelRateMapping(ctx context.Context) ChannelApiGetChannelRateMappingRequest {
	return ChannelApiGetChannelRateMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelRateMappings
func (a *ChannelApiService) GetChannelRateMappingExecute(r ChannelApiGetChannelRateMappingRequest) (*ChannelRateMappings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelRateMappings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRateMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.channelCode != nil {
		t := *r.channelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", t, "multi")
		}
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.channelRatePlanCodes != nil {
		t := *r.channelRatePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCodes", t, "multi")
		}
	}
	if r.ratePlanCategories != nil {
		t := *r.ratePlanCategories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCategories", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCategories", t, "multi")
		}
	}
	if r.channelRatePlanCategories != nil {
		t := *r.channelRatePlanCategories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCategories", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCategories", t, "multi")
		}
	}
	if r.includeUnmappedRatePlans != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUnmappedRatePlans", r.includeUnmappedRatePlans, "")
	}
	if r.onlyUnmappedRatePlans != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyUnmappedRatePlans", r.onlyUnmappedRatePlans, "")
	}
	if r.includeInactiveMappings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveMappings", r.includeInactiveMappings, "")
	}
	if r.onlyNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyNegotiatedRates", r.onlyNegotiatedRates, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelRateRoomSeqRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	ratePlanCode *string
	roomType *string
	channelRatePlanCode *string
	channelRoomType *string
	channelRateRoomParameterName *[]string
	channelRateRoomParameterValue *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelRateRoomSeqRequest) Authorization(authorization string) ChannelApiGetChannelRateRoomSeqRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelRateRoomSeqRequest) XAppKey(xAppKey string) ChannelApiGetChannelRateRoomSeqRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelRateRoomSeqRequest) XHotelid(xHotelid string) ChannelApiGetChannelRateRoomSeqRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetChannelRateRoomSeqRequest) Limit(limit int32) ChannelApiGetChannelRateRoomSeqRequest {
	r.limit = &limit
	return r
}

// Hotel Rate Plan Code.
func (r ChannelApiGetChannelRateRoomSeqRequest) RatePlanCode(ratePlanCode string) ChannelApiGetChannelRateRoomSeqRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Hotel Room Type.
func (r ChannelApiGetChannelRateRoomSeqRequest) RoomType(roomType string) ChannelApiGetChannelRateRoomSeqRequest {
	r.roomType = &roomType
	return r
}

// Channel Rate Plan Code.
func (r ChannelApiGetChannelRateRoomSeqRequest) ChannelRatePlanCode(channelRatePlanCode string) ChannelApiGetChannelRateRoomSeqRequest {
	r.channelRatePlanCode = &channelRatePlanCode
	return r
}

// Channel Room Type.
func (r ChannelApiGetChannelRateRoomSeqRequest) ChannelRoomType(channelRoomType string) ChannelApiGetChannelRateRoomSeqRequest {
	r.channelRoomType = &channelRoomType
	return r
}

// Enumaration of the different parameters Channel Rate Room accepts.
func (r ChannelApiGetChannelRateRoomSeqRequest) ChannelRateRoomParameterName(channelRateRoomParameterName []string) ChannelApiGetChannelRateRoomSeqRequest {
	r.channelRateRoomParameterName = &channelRateRoomParameterName
	return r
}

func (r ChannelApiGetChannelRateRoomSeqRequest) ChannelRateRoomParameterValue(channelRateRoomParameterValue []string) ChannelApiGetChannelRateRoomSeqRequest {
	r.channelRateRoomParameterValue = &channelRateRoomParameterValue
	return r
}

// External system code.
func (r ChannelApiGetChannelRateRoomSeqRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelRateRoomSeqRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelRateRoomSeqRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelRateRoomSeqRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelRateRoomSeqRequest) Execute() (*ChannelRateRoomSequenceDetails, *http.Response, error) {
	return r.ApiService.GetChannelRateRoomSeqExecute(r)
}

/*
GetChannelRateRoomSeq Gets channel property rateroom sequence

Use this API to get sequence for given channel property rate room mapping. <p><strong>OperationId:</strong>getChannelRateRoomSeq</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiGetChannelRateRoomSeqRequest
*/
func (a *ChannelApiService) GetChannelRateRoomSeq(ctx context.Context, channelCode string) ChannelApiGetChannelRateRoomSeqRequest {
	return ChannelApiGetChannelRateRoomSeqRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return ChannelRateRoomSequenceDetails
func (a *ChannelApiService) GetChannelRateRoomSeqExecute(r ChannelApiGetChannelRateRoomSeqRequest) (*ChannelRateRoomSequenceDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelRateRoomSequenceDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRateRoomSeq")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/rateRoomSequences"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	if r.channelRatePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRatePlanCode", r.channelRatePlanCode, "")
	}
	if r.channelRoomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomType", r.channelRoomType, "")
	}
	if r.channelRateRoomParameterName != nil {
		t := *r.channelRateRoomParameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRateRoomParameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRateRoomParameterName", t, "multi")
		}
	}
	if r.channelRateRoomParameterValue != nil {
		t := *r.channelRateRoomParameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRateRoomParameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRateRoomParameterValue", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelRatesGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	ratePlanCodes *[]string
	roomTypes *[]string
	globalDescriptionType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelRatesGlobalDescriptionsRequest) Authorization(authorization string) ChannelApiGetChannelRatesGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelRatesGlobalDescriptionsRequest) XAppKey(xAppKey string) ChannelApiGetChannelRatesGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelRatesGlobalDescriptionsRequest) XHotelid(xHotelid string) ChannelApiGetChannelRatesGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChannelApiGetChannelRatesGlobalDescriptionsRequest) HotelIds(hotelIds []string) ChannelApiGetChannelRatesGlobalDescriptionsRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ChannelApiGetChannelRatesGlobalDescriptionsRequest) RatePlanCodes(ratePlanCodes []string) ChannelApiGetChannelRatesGlobalDescriptionsRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ChannelApiGetChannelRatesGlobalDescriptionsRequest) RoomTypes(roomTypes []string) ChannelApiGetChannelRatesGlobalDescriptionsRequest {
	r.roomTypes = &roomTypes
	return r
}

// Either Room Type or Rate Plan Code
func (r ChannelApiGetChannelRatesGlobalDescriptionsRequest) GlobalDescriptionType(globalDescriptionType string) ChannelApiGetChannelRatesGlobalDescriptionsRequest {
	r.globalDescriptionType = &globalDescriptionType
	return r
}

// External system code.
func (r ChannelApiGetChannelRatesGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelRatesGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelRatesGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelRatesGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelRatesGlobalDescriptionsRequest) Execute() (*ChannelGlobalDescriptions, *http.Response, error) {
	return r.ApiService.GetChannelRatesGlobalDescriptionsExecute(r)
}

/*
GetChannelRatesGlobalDescriptions Gets global rate descriptions

Use this API to get global rate description for given hotel id. <p><strong>OperationId:</strong>getChannelRatesGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetChannelRatesGlobalDescriptionsRequest
*/
func (a *ChannelApiService) GetChannelRatesGlobalDescriptions(ctx context.Context) ChannelApiGetChannelRatesGlobalDescriptionsRequest {
	return ChannelApiGetChannelRatesGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelGlobalDescriptions
func (a *ChannelApiService) GetChannelRatesGlobalDescriptionsExecute(r ChannelApiGetChannelRatesGlobalDescriptionsRequest) (*ChannelGlobalDescriptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelGlobalDescriptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRatesGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.globalDescriptionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "globalDescriptionType", r.globalDescriptionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelRoomMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	limit *int32
	offset *int32
	bookingChannelCodes *[]string
	roomTypes *[]string
	channelRoomTypes *[]string
	includeInactiveMappings *bool
	includeUnmappedRoomTypes *bool
	onlyUnmappedRoomTypes *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelRoomMappingRequest) Authorization(authorization string) ChannelApiGetChannelRoomMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelRoomMappingRequest) XAppKey(xAppKey string) ChannelApiGetChannelRoomMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelRoomMappingRequest) XHotelid(xHotelid string) ChannelApiGetChannelRoomMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r ChannelApiGetChannelRoomMappingRequest) HotelIds(hotelIds []string) ChannelApiGetChannelRoomMappingRequest {
	r.hotelIds = &hotelIds
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetChannelRoomMappingRequest) Limit(limit int32) ChannelApiGetChannelRoomMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetChannelRoomMappingRequest) Offset(offset int32) ChannelApiGetChannelRoomMappingRequest {
	r.offset = &offset
	return r
}

func (r ChannelApiGetChannelRoomMappingRequest) BookingChannelCodes(bookingChannelCodes []string) ChannelApiGetChannelRoomMappingRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

func (r ChannelApiGetChannelRoomMappingRequest) RoomTypes(roomTypes []string) ChannelApiGetChannelRoomMappingRequest {
	r.roomTypes = &roomTypes
	return r
}

func (r ChannelApiGetChannelRoomMappingRequest) ChannelRoomTypes(channelRoomTypes []string) ChannelApiGetChannelRoomMappingRequest {
	r.channelRoomTypes = &channelRoomTypes
	return r
}

// Flag whether to include inactive mappings or not.
func (r ChannelApiGetChannelRoomMappingRequest) IncludeInactiveMappings(includeInactiveMappings bool) ChannelApiGetChannelRoomMappingRequest {
	r.includeInactiveMappings = &includeInactiveMappings
	return r
}

// Flag whether to include unmapped room types or not.
func (r ChannelApiGetChannelRoomMappingRequest) IncludeUnmappedRoomTypes(includeUnmappedRoomTypes bool) ChannelApiGetChannelRoomMappingRequest {
	r.includeUnmappedRoomTypes = &includeUnmappedRoomTypes
	return r
}

// Flag whether to include mapped room types only.
func (r ChannelApiGetChannelRoomMappingRequest) OnlyUnmappedRoomTypes(onlyUnmappedRoomTypes bool) ChannelApiGetChannelRoomMappingRequest {
	r.onlyUnmappedRoomTypes = &onlyUnmappedRoomTypes
	return r
}

// External system code.
func (r ChannelApiGetChannelRoomMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelRoomMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelRoomMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelRoomMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelRoomMappingRequest) Execute() (*ChannelRoomMappingsSummary, *http.Response, error) {
	return r.ApiService.GetChannelRoomMappingExecute(r)
}

/*
GetChannelRoomMapping Gets channel property room mapping

Use this API to get channel room mapping to OPERA hotel's room mapping including channel room type code, start date, end date, room order. <p><strong>OperationId:</strong>getChannelRoomMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiGetChannelRoomMappingRequest
*/
func (a *ChannelApiService) GetChannelRoomMapping(ctx context.Context, hotelId string) ChannelApiGetChannelRoomMappingRequest {
	return ChannelApiGetChannelRoomMappingRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelRoomMappingsSummary
func (a *ChannelApiService) GetChannelRoomMappingExecute(r ChannelApiGetChannelRoomMappingRequest) (*ChannelRoomMappingsSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelRoomMappingsSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRoomMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.bookingChannelCodes != nil {
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.channelRoomTypes != nil {
		t := *r.channelRoomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomTypes", t, "multi")
		}
	}
	if r.includeInactiveMappings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveMappings", r.includeInactiveMappings, "")
	}
	if r.includeUnmappedRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUnmappedRoomTypes", r.includeUnmappedRoomTypes, "")
	}
	if r.onlyUnmappedRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyUnmappedRoomTypes", r.onlyUnmappedRoomTypes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelRoomMappingByIdRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	roomTypeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	beginDate *string
	channelRoomType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelRoomMappingByIdRequest) Authorization(authorization string) ChannelApiGetChannelRoomMappingByIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelRoomMappingByIdRequest) XAppKey(xAppKey string) ChannelApiGetChannelRoomMappingByIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelRoomMappingByIdRequest) XHotelid(xHotelid string) ChannelApiGetChannelRoomMappingByIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Begin Date.
func (r ChannelApiGetChannelRoomMappingByIdRequest) BeginDate(beginDate string) ChannelApiGetChannelRoomMappingByIdRequest {
	r.beginDate = &beginDate
	return r
}

// Channel Room Type.
func (r ChannelApiGetChannelRoomMappingByIdRequest) ChannelRoomType(channelRoomType string) ChannelApiGetChannelRoomMappingByIdRequest {
	r.channelRoomType = &channelRoomType
	return r
}

// External system code.
func (r ChannelApiGetChannelRoomMappingByIdRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelRoomMappingByIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelRoomMappingByIdRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelRoomMappingByIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelRoomMappingByIdRequest) Execute() (*ChannelRoomMapping, *http.Response, error) {
	return r.ApiService.GetChannelRoomMappingByIdExecute(r)
}

/*
GetChannelRoomMappingById Gets channel room mapping by room type

This API retrieves channel room mapping by room type. <p><strong>OperationId:</strong>getChannelRoomMappingById</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeCode Room Type Code.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiGetChannelRoomMappingByIdRequest
*/
func (a *ChannelApiService) GetChannelRoomMappingById(ctx context.Context, roomTypeCode string, channelCode string, hotelId string) ChannelApiGetChannelRoomMappingByIdRequest {
	return ChannelApiGetChannelRoomMappingByIdRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeCode: roomTypeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelRoomMapping
func (a *ChannelApiService) GetChannelRoomMappingByIdExecute(r ChannelApiGetChannelRoomMappingByIdRequest) (*ChannelRoomMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelRoomMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRoomMappingById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/rooms/{roomTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeCode"+"}", url.PathEscape(parameterValueToString(r.roomTypeCode, "roomTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have at least 1 elements")
	}
	if strlen(r.roomTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.beginDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", r.beginDate, "")
	}
	if r.channelRoomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomType", r.channelRoomType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelRoomTypeGlobalDescRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	roomType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelRoomTypeGlobalDescRequest) Authorization(authorization string) ChannelApiGetChannelRoomTypeGlobalDescRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelRoomTypeGlobalDescRequest) XAppKey(xAppKey string) ChannelApiGetChannelRoomTypeGlobalDescRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelRoomTypeGlobalDescRequest) XHotelid(xHotelid string) ChannelApiGetChannelRoomTypeGlobalDescRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChannelApiGetChannelRoomTypeGlobalDescRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelRoomTypeGlobalDescRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelRoomTypeGlobalDescRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelRoomTypeGlobalDescRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelRoomTypeGlobalDescRequest) Execute() (*ChannelEnhancedGlobalDescription, *http.Response, error) {
	return r.ApiService.GetChannelRoomTypeGlobalDescExecute(r)
}

/*
GetChannelRoomTypeGlobalDesc Gets global room descriptions

Use this API to get global room description for given hotel id and room type code. <p><strong>OperationId:</strong>getChannelRoomTypeGlobalDesc</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomType Room type.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiGetChannelRoomTypeGlobalDescRequest
*/
func (a *ChannelApiService) GetChannelRoomTypeGlobalDesc(ctx context.Context, roomType string, hotelId string) ChannelApiGetChannelRoomTypeGlobalDescRequest {
	return ChannelApiGetChannelRoomTypeGlobalDescRequest{
		ApiService: a,
		ctx: ctx,
		roomType: roomType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelEnhancedGlobalDescription
func (a *ChannelApiService) GetChannelRoomTypeGlobalDescExecute(r ChannelApiGetChannelRoomTypeGlobalDescRequest) (*ChannelEnhancedGlobalDescription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelEnhancedGlobalDescription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRoomTypeGlobalDesc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/{roomType}/globalDescription"
	localVarPath = strings.Replace(localVarPath, "{"+"roomType"+"}", url.PathEscape(parameterValueToString(r.roomType, "roomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomType) < 1 {
		return localVarReturnValue, nil, reportError("roomType must have at least 1 elements")
	}
	if strlen(r.roomType) > 2000 {
		return localVarReturnValue, nil, reportError("roomType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelRoomsGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	ratePlanCodes *[]string
	roomTypes *[]string
	globalDescriptionType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelRoomsGlobalDescriptionsRequest) Authorization(authorization string) ChannelApiGetChannelRoomsGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelRoomsGlobalDescriptionsRequest) XAppKey(xAppKey string) ChannelApiGetChannelRoomsGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelRoomsGlobalDescriptionsRequest) XHotelid(xHotelid string) ChannelApiGetChannelRoomsGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChannelApiGetChannelRoomsGlobalDescriptionsRequest) HotelIds(hotelIds []string) ChannelApiGetChannelRoomsGlobalDescriptionsRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ChannelApiGetChannelRoomsGlobalDescriptionsRequest) RatePlanCodes(ratePlanCodes []string) ChannelApiGetChannelRoomsGlobalDescriptionsRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ChannelApiGetChannelRoomsGlobalDescriptionsRequest) RoomTypes(roomTypes []string) ChannelApiGetChannelRoomsGlobalDescriptionsRequest {
	r.roomTypes = &roomTypes
	return r
}

// Either Room Type or Rate Plan Code
func (r ChannelApiGetChannelRoomsGlobalDescriptionsRequest) GlobalDescriptionType(globalDescriptionType string) ChannelApiGetChannelRoomsGlobalDescriptionsRequest {
	r.globalDescriptionType = &globalDescriptionType
	return r
}

// External system code.
func (r ChannelApiGetChannelRoomsGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelRoomsGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelRoomsGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelRoomsGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelRoomsGlobalDescriptionsRequest) Execute() (*ChannelGlobalDescriptions, *http.Response, error) {
	return r.ApiService.GetChannelRoomsGlobalDescriptionsExecute(r)
}

/*
GetChannelRoomsGlobalDescriptions Gets global room descriptions

Use this API to get global room description for given hotel id and room type code. <p><strong>OperationId:</strong>getChannelRoomsGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetChannelRoomsGlobalDescriptionsRequest
*/
func (a *ChannelApiService) GetChannelRoomsGlobalDescriptions(ctx context.Context) ChannelApiGetChannelRoomsGlobalDescriptionsRequest {
	return ChannelApiGetChannelRoomsGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelGlobalDescriptions
func (a *ChannelApiService) GetChannelRoomsGlobalDescriptionsExecute(r ChannelApiGetChannelRoomsGlobalDescriptionsRequest) (*ChannelGlobalDescriptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelGlobalDescriptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRoomsGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.globalDescriptionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "globalDescriptionType", r.globalDescriptionType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetChannelsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	limit *int32
	offset *int32
	channelCode *string
	systemType *string
	systemSubType *string
	systemRateType *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelsRequest) Authorization(authorization string) ChannelApiGetChannelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetChannelsRequest) XAppKey(xAppKey string) ChannelApiGetChannelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelsRequest) XHotelid(xHotelid string) ChannelApiGetChannelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether searching for active or inactive codes.
func (r ChannelApiGetChannelsRequest) Inactive(inactive bool) ChannelApiGetChannelsRequest {
	r.inactive = &inactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetChannelsRequest) Limit(limit int32) ChannelApiGetChannelsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetChannelsRequest) Offset(offset int32) ChannelApiGetChannelsRequest {
	r.offset = &offset
	return r
}

// External system code to be searched. This is also known as Booking Channel Code for CHANNEL external system type.
func (r ChannelApiGetChannelsRequest) ChannelCode(channelCode string) ChannelApiGetChannelsRequest {
	r.channelCode = &channelCode
	return r
}

// External system type to be searched. Possible values are CHANNEL, OXI, etc.
func (r ChannelApiGetChannelsRequest) SystemType(systemType string) ChannelApiGetChannelsRequest {
	r.systemType = &systemType
	return r
}

// External system sub type to be searched. Possible values are GDS, WEB, etc.
func (r ChannelApiGetChannelsRequest) SystemSubType(systemSubType string) ChannelApiGetChannelsRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system rate type to be searched. Possible values are DAILY, MAX_WEEKLY, etc.
func (r ChannelApiGetChannelsRequest) SystemRateType(systemRateType string) ChannelApiGetChannelsRequest {
	r.systemRateType = &systemRateType
	return r
}

// Flag whether to include inactive channel or not.
func (r ChannelApiGetChannelsRequest) IncludeInactive(includeInactive bool) ChannelApiGetChannelsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ChannelApiGetChannelsRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelsRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelsRequest) Execute() (*Channels, *http.Response, error) {
	return r.ApiService.GetChannelsExecute(r)
}

/*
GetChannels Gets list of channels

Use this API to get list of channels from OPERA. <p><strong>OperationId:</strong>getChannels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetChannelsRequest
*/
func (a *ChannelApiService) GetChannels(ctx context.Context) ChannelApiGetChannelsRequest {
	return ChannelApiGetChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Channels
func (a *ChannelApiService) GetChannelsExecute(r ChannelApiGetChannelsRequest) (*Channels, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Channels
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.channelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelCode", r.channelCode, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemRateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemRateType", r.systemRateType, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetCreditCardsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	limit *int32
	offset *int32
	systemCode *string
	systemType *string
	systemSubType *string
	systemRateType *string
	localSystemCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetCreditCardsMappingRequest) Authorization(authorization string) ChannelApiGetCreditCardsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetCreditCardsMappingRequest) XAppKey(xAppKey string) ChannelApiGetCreditCardsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetCreditCardsMappingRequest) XHotelid(xHotelid string) ChannelApiGetCreditCardsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether searching for active or inactive codes.
func (r ChannelApiGetCreditCardsMappingRequest) Inactive(inactive bool) ChannelApiGetCreditCardsMappingRequest {
	r.inactive = &inactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetCreditCardsMappingRequest) Limit(limit int32) ChannelApiGetCreditCardsMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetCreditCardsMappingRequest) Offset(offset int32) ChannelApiGetCreditCardsMappingRequest {
	r.offset = &offset
	return r
}

// External system code to be searched. This is also known as Booking Channel Code for CHANNEL external system type.
func (r ChannelApiGetCreditCardsMappingRequest) SystemCode(systemCode string) ChannelApiGetCreditCardsMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system type to be searched. Possible values are CHANNEL, OXI, etc.
func (r ChannelApiGetCreditCardsMappingRequest) SystemType(systemType string) ChannelApiGetCreditCardsMappingRequest {
	r.systemType = &systemType
	return r
}

// External system sub type to be searched. Possible values are GDS, WEB, etc.
func (r ChannelApiGetCreditCardsMappingRequest) SystemSubType(systemSubType string) ChannelApiGetCreditCardsMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system rate type to be searched. Possible values are DAILY, MAX_WEEKLY, etc.
func (r ChannelApiGetCreditCardsMappingRequest) SystemRateType(systemRateType string) ChannelApiGetCreditCardsMappingRequest {
	r.systemRateType = &systemRateType
	return r
}

func (r ChannelApiGetCreditCardsMappingRequest) LocalSystemCodes(localSystemCodes []string) ChannelApiGetCreditCardsMappingRequest {
	r.localSystemCodes = &localSystemCodes
	return r
}

// Indicates whether to include inactive guarantees or not.
func (r ChannelApiGetCreditCardsMappingRequest) IncludeInactive(includeInactive bool) ChannelApiGetCreditCardsMappingRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ChannelApiGetCreditCardsMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiGetCreditCardsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetCreditCardsMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetCreditCardsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetCreditCardsMappingRequest) Execute() (*CreditCardsMapping, *http.Response, error) {
	return r.ApiService.GetCreditCardsMappingExecute(r)
}

/*
GetCreditCardsMapping Gets channel credit card mapping

Use this API to get channel credit card code mapping to OPERA credit card code. <p><strong>OperationId:</strong>getCreditCardsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetCreditCardsMappingRequest
*/
func (a *ChannelApiService) GetCreditCardsMapping(ctx context.Context) ChannelApiGetCreditCardsMappingRequest {
	return ChannelApiGetCreditCardsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreditCardsMapping
func (a *ChannelApiService) GetCreditCardsMappingExecute(r ChannelApiGetCreditCardsMappingRequest) (*CreditCardsMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditCardsMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetCreditCardsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/cardTypes/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemRateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemRateType", r.systemRateType, "")
	}
	if r.localSystemCodes != nil {
		t := *r.localSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetCurrenciesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	limit *int32
	offset *int32
	systemCode *string
	systemType *string
	systemSubType *string
	systemRateType *string
	localSystemCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetCurrenciesMappingRequest) Authorization(authorization string) ChannelApiGetCurrenciesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetCurrenciesMappingRequest) XAppKey(xAppKey string) ChannelApiGetCurrenciesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetCurrenciesMappingRequest) XHotelid(xHotelid string) ChannelApiGetCurrenciesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether searching for active or inactive codes.
func (r ChannelApiGetCurrenciesMappingRequest) Inactive(inactive bool) ChannelApiGetCurrenciesMappingRequest {
	r.inactive = &inactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetCurrenciesMappingRequest) Limit(limit int32) ChannelApiGetCurrenciesMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetCurrenciesMappingRequest) Offset(offset int32) ChannelApiGetCurrenciesMappingRequest {
	r.offset = &offset
	return r
}

// External system code to be searched. This is also known as Booking Channel Code for CHANNEL external system type.
func (r ChannelApiGetCurrenciesMappingRequest) SystemCode(systemCode string) ChannelApiGetCurrenciesMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system type to be searched. Possible values are CHANNEL, OXI, etc.
func (r ChannelApiGetCurrenciesMappingRequest) SystemType(systemType string) ChannelApiGetCurrenciesMappingRequest {
	r.systemType = &systemType
	return r
}

// External system sub type to be searched. Possible values are GDS, WEB, etc.
func (r ChannelApiGetCurrenciesMappingRequest) SystemSubType(systemSubType string) ChannelApiGetCurrenciesMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system rate type to be searched. Possible values are DAILY, MAX_WEEKLY, etc.
func (r ChannelApiGetCurrenciesMappingRequest) SystemRateType(systemRateType string) ChannelApiGetCurrenciesMappingRequest {
	r.systemRateType = &systemRateType
	return r
}

func (r ChannelApiGetCurrenciesMappingRequest) LocalSystemCodes(localSystemCodes []string) ChannelApiGetCurrenciesMappingRequest {
	r.localSystemCodes = &localSystemCodes
	return r
}

// Indicates whether to include inactive guarantees or not.
func (r ChannelApiGetCurrenciesMappingRequest) IncludeInactive(includeInactive bool) ChannelApiGetCurrenciesMappingRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ChannelApiGetCurrenciesMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiGetCurrenciesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetCurrenciesMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetCurrenciesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetCurrenciesMappingRequest) Execute() (*CurrenciesMapping, *http.Response, error) {
	return r.ApiService.GetCurrenciesMappingExecute(r)
}

/*
GetCurrenciesMapping Gets channel currency code mapping

Use this API to update channel mapping to OPERA currency codes. <p><strong>OperationId:</strong>getCurrenciesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetCurrenciesMappingRequest
*/
func (a *ChannelApiService) GetCurrenciesMapping(ctx context.Context) ChannelApiGetCurrenciesMappingRequest {
	return ChannelApiGetCurrenciesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CurrenciesMapping
func (a *ChannelApiService) GetCurrenciesMappingExecute(r ChannelApiGetCurrenciesMappingRequest) (*CurrenciesMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CurrenciesMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetCurrenciesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/currencies/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemRateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemRateType", r.systemRateType, "")
	}
	if r.localSystemCodes != nil {
		t := *r.localSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetDistributionTemplatesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	isChain *bool
	hotelIds *[]string
	codes *[]string
	types *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetDistributionTemplatesRequest) Authorization(authorization string) ChannelApiGetDistributionTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetDistributionTemplatesRequest) XAppKey(xAppKey string) ChannelApiGetDistributionTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetDistributionTemplatesRequest) XHotelid(xHotelid string) ChannelApiGetDistributionTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Filter chain level distribution templates by chain.
func (r ChannelApiGetDistributionTemplatesRequest) IsChain(isChain bool) ChannelApiGetDistributionTemplatesRequest {
	r.isChain = &isChain
	return r
}

func (r ChannelApiGetDistributionTemplatesRequest) HotelIds(hotelIds []string) ChannelApiGetDistributionTemplatesRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ChannelApiGetDistributionTemplatesRequest) Codes(codes []string) ChannelApiGetDistributionTemplatesRequest {
	r.codes = &codes
	return r
}

func (r ChannelApiGetDistributionTemplatesRequest) Types(types []string) ChannelApiGetDistributionTemplatesRequest {
	r.types = &types
	return r
}

// Indicates whether search includes inactive distribution templates.
func (r ChannelApiGetDistributionTemplatesRequest) IncludeInactive(includeInactive bool) ChannelApiGetDistributionTemplatesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ChannelApiGetDistributionTemplatesRequest) XExternalsystem(xExternalsystem string) ChannelApiGetDistributionTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetDistributionTemplatesRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetDistributionTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetDistributionTemplatesRequest) Execute() (*DistributionTemplates, *http.Response, error) {
	return r.ApiService.GetDistributionTemplatesExecute(r)
}

/*
GetDistributionTemplates Retrieves distribution templates

This API retrieves distribution templates. <p><strong>OperationId:</strong>getDistributionTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetDistributionTemplatesRequest
*/
func (a *ChannelApiService) GetDistributionTemplates(ctx context.Context) ChannelApiGetDistributionTemplatesRequest {
	return ChannelApiGetDistributionTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DistributionTemplates
func (a *ChannelApiService) GetDistributionTemplatesExecute(r ChannelApiGetDistributionTemplatesRequest) (*DistributionTemplates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DistributionTemplates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetDistributionTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/distributionTemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isChain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isChain", r.isChain, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetGuaranteesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	limit *int32
	offset *int32
	systemCode *string
	systemType *string
	systemSubType *string
	systemRateType *string
	localSystemCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetGuaranteesMappingRequest) Authorization(authorization string) ChannelApiGetGuaranteesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetGuaranteesMappingRequest) XAppKey(xAppKey string) ChannelApiGetGuaranteesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetGuaranteesMappingRequest) XHotelid(xHotelid string) ChannelApiGetGuaranteesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether searching for active or inactive codes.
func (r ChannelApiGetGuaranteesMappingRequest) Inactive(inactive bool) ChannelApiGetGuaranteesMappingRequest {
	r.inactive = &inactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetGuaranteesMappingRequest) Limit(limit int32) ChannelApiGetGuaranteesMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetGuaranteesMappingRequest) Offset(offset int32) ChannelApiGetGuaranteesMappingRequest {
	r.offset = &offset
	return r
}

// External system code to be searched. This is also known as Booking Channel Code for CHANNEL external system type.
func (r ChannelApiGetGuaranteesMappingRequest) SystemCode(systemCode string) ChannelApiGetGuaranteesMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system type to be searched. Possible values are CHANNEL, OXI, etc.
func (r ChannelApiGetGuaranteesMappingRequest) SystemType(systemType string) ChannelApiGetGuaranteesMappingRequest {
	r.systemType = &systemType
	return r
}

// External system sub type to be searched. Possible values are GDS, WEB, etc.
func (r ChannelApiGetGuaranteesMappingRequest) SystemSubType(systemSubType string) ChannelApiGetGuaranteesMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system rate type to be searched. Possible values are DAILY, MAX_WEEKLY, etc.
func (r ChannelApiGetGuaranteesMappingRequest) SystemRateType(systemRateType string) ChannelApiGetGuaranteesMappingRequest {
	r.systemRateType = &systemRateType
	return r
}

func (r ChannelApiGetGuaranteesMappingRequest) LocalSystemCodes(localSystemCodes []string) ChannelApiGetGuaranteesMappingRequest {
	r.localSystemCodes = &localSystemCodes
	return r
}

// Indicates whether to include inactive guarantees or not.
func (r ChannelApiGetGuaranteesMappingRequest) IncludeInactive(includeInactive bool) ChannelApiGetGuaranteesMappingRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ChannelApiGetGuaranteesMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiGetGuaranteesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetGuaranteesMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetGuaranteesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetGuaranteesMappingRequest) Execute() (*GuaranteesMapping, *http.Response, error) {
	return r.ApiService.GetGuaranteesMappingExecute(r)
}

/*
GetGuaranteesMapping Gets channel guarantee code mapping for a hotel

Use this API to get channel guarantee code mapping to OPERA guarantee code for a given hotel. <p><strong>OperationId:</strong>getGuaranteesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetGuaranteesMappingRequest
*/
func (a *ChannelApiService) GetGuaranteesMapping(ctx context.Context) ChannelApiGetGuaranteesMappingRequest {
	return ChannelApiGetGuaranteesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GuaranteesMapping
func (a *ChannelApiService) GetGuaranteesMappingExecute(r ChannelApiGetGuaranteesMappingRequest) (*GuaranteesMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuaranteesMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetGuaranteesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/guarantees/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemRateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemRateType", r.systemRateType, "")
	}
	if r.localSystemCodes != nil {
		t := *r.localSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetHotelsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	limit *int32
	offset *int32
	systemCode *string
	systemType *string
	systemSubType *string
	systemRateType *string
	localSystemCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetHotelsMappingRequest) Authorization(authorization string) ChannelApiGetHotelsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetHotelsMappingRequest) XAppKey(xAppKey string) ChannelApiGetHotelsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetHotelsMappingRequest) XHotelid(xHotelid string) ChannelApiGetHotelsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether searching for active or inactive codes.
func (r ChannelApiGetHotelsMappingRequest) Inactive(inactive bool) ChannelApiGetHotelsMappingRequest {
	r.inactive = &inactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetHotelsMappingRequest) Limit(limit int32) ChannelApiGetHotelsMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetHotelsMappingRequest) Offset(offset int32) ChannelApiGetHotelsMappingRequest {
	r.offset = &offset
	return r
}

// External system code to be searched. This is also known as Booking Channel Code for CHANNEL external system type.
func (r ChannelApiGetHotelsMappingRequest) SystemCode(systemCode string) ChannelApiGetHotelsMappingRequest {
	r.systemCode = &systemCode
	return r
}

// External system type to be searched. Possible values are CHANNEL, OXI, etc.
func (r ChannelApiGetHotelsMappingRequest) SystemType(systemType string) ChannelApiGetHotelsMappingRequest {
	r.systemType = &systemType
	return r
}

// External system sub type to be searched. Possible values are GDS, WEB, etc.
func (r ChannelApiGetHotelsMappingRequest) SystemSubType(systemSubType string) ChannelApiGetHotelsMappingRequest {
	r.systemSubType = &systemSubType
	return r
}

// External system rate type to be searched. Possible values are DAILY, MAX_WEEKLY, etc.
func (r ChannelApiGetHotelsMappingRequest) SystemRateType(systemRateType string) ChannelApiGetHotelsMappingRequest {
	r.systemRateType = &systemRateType
	return r
}

func (r ChannelApiGetHotelsMappingRequest) LocalSystemCodes(localSystemCodes []string) ChannelApiGetHotelsMappingRequest {
	r.localSystemCodes = &localSystemCodes
	return r
}

// Indicates whether to include inactive guarantees or not.
func (r ChannelApiGetHotelsMappingRequest) IncludeInactive(includeInactive bool) ChannelApiGetHotelsMappingRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ChannelApiGetHotelsMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiGetHotelsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetHotelsMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetHotelsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetHotelsMappingRequest) Execute() (*PropertiesMapping, *http.Response, error) {
	return r.ApiService.GetHotelsMappingExecute(r)
}

/*
GetHotelsMapping Gets channel hotel mapping

Use this API to get channel mapping to OPERA hotel id including channel hotel code, room sell limit per reservation, city code, end date. <p><strong>OperationId:</strong>getHotelsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiGetHotelsMappingRequest
*/
func (a *ChannelApiService) GetHotelsMapping(ctx context.Context) ChannelApiGetHotelsMappingRequest {
	return ChannelApiGetHotelsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PropertiesMapping
func (a *ChannelApiService) GetHotelsMappingExecute(r ChannelApiGetHotelsMappingRequest) (*PropertiesMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PropertiesMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetHotelsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/hotels/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.systemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemCode", r.systemCode, "")
	}
	if r.systemType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemType", r.systemType, "")
	}
	if r.systemSubType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemSubType", r.systemSubType, "")
	}
	if r.systemRateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "systemRateType", r.systemRateType, "")
	}
	if r.localSystemCodes != nil {
		t := *r.localSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "localSystemCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetStatementDetailsStatisticsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	statementId string
	authorization *string
	xAppKey *string
	xHotelid *string
	contractId *string
	contractIdType *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetStatementDetailsStatisticsRequest) Authorization(authorization string) ChannelApiGetStatementDetailsStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetStatementDetailsStatisticsRequest) XAppKey(xAppKey string) ChannelApiGetStatementDetailsStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetStatementDetailsStatisticsRequest) XHotelid(xHotelid string) ChannelApiGetStatementDetailsStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ChannelApiGetStatementDetailsStatisticsRequest) ContractId(contractId string) ChannelApiGetStatementDetailsStatisticsRequest {
	r.contractId = &contractId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ChannelApiGetStatementDetailsStatisticsRequest) ContractIdType(contractIdType string) ChannelApiGetStatementDetailsStatisticsRequest {
	r.contractIdType = &contractIdType
	return r
}

// Type for statement details statistics instructions that can be used in requests for partial operations.
func (r ChannelApiGetStatementDetailsStatisticsRequest) FetchInstructions(fetchInstructions []string) ChannelApiGetStatementDetailsStatisticsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ChannelApiGetStatementDetailsStatisticsRequest) XExternalsystem(xExternalsystem string) ChannelApiGetStatementDetailsStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetStatementDetailsStatisticsRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetStatementDetailsStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetStatementDetailsStatisticsRequest) Execute() (*StatementDetailsStatistics, *http.Response, error) {
	return r.ApiService.GetStatementDetailsStatisticsExecute(r)
}

/*
GetStatementDetailsStatistics Retrieves billing statement details statistics.

This API retrieves billing statement details statistics. <p><strong>OperationId:</strong>getStatementDetailsStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param statementId Statement Id.
 @return ChannelApiGetStatementDetailsStatisticsRequest
*/
func (a *ChannelApiService) GetStatementDetailsStatistics(ctx context.Context, statementId string) ChannelApiGetStatementDetailsStatisticsRequest {
	return ChannelApiGetStatementDetailsStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		statementId: statementId,
	}
}

// Execute executes the request
//  @return StatementDetailsStatistics
func (a *ChannelApiService) GetStatementDetailsStatisticsExecute(r ChannelApiGetStatementDetailsStatisticsRequest) (*StatementDetailsStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatementDetailsStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetStatementDetailsStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements/{statementId}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"statementId"+"}", url.PathEscape(parameterValueToString(r.statementId, "statementId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.statementId) < 1 {
		return localVarReturnValue, nil, reportError("statementId must have at least 1 elements")
	}
	if strlen(r.statementId) > 2000 {
		return localVarReturnValue, nil, reportError("statementId must have less than 2000 elements")
	}

	if r.contractId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractId", r.contractId, "")
	}
	if r.contractIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractIdType", r.contractIdType, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiGetTotalPricingElementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	limit *int32
	offset *int32
	elementCodes *[]string
	transactionCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetTotalPricingElementsRequest) Authorization(authorization string) ChannelApiGetTotalPricingElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiGetTotalPricingElementsRequest) XAppKey(xAppKey string) ChannelApiGetTotalPricingElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetTotalPricingElementsRequest) XHotelid(xHotelid string) ChannelApiGetTotalPricingElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r ChannelApiGetTotalPricingElementsRequest) HotelIds(hotelIds []string) ChannelApiGetTotalPricingElementsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetTotalPricingElementsRequest) Limit(limit int32) ChannelApiGetTotalPricingElementsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetTotalPricingElementsRequest) Offset(offset int32) ChannelApiGetTotalPricingElementsRequest {
	r.offset = &offset
	return r
}

func (r ChannelApiGetTotalPricingElementsRequest) ElementCodes(elementCodes []string) ChannelApiGetTotalPricingElementsRequest {
	r.elementCodes = &elementCodes
	return r
}

func (r ChannelApiGetTotalPricingElementsRequest) TransactionCodes(transactionCodes []string) ChannelApiGetTotalPricingElementsRequest {
	r.transactionCodes = &transactionCodes
	return r
}

// External system code.
func (r ChannelApiGetTotalPricingElementsRequest) XExternalsystem(xExternalsystem string) ChannelApiGetTotalPricingElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetTotalPricingElementsRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetTotalPricingElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetTotalPricingElementsRequest) Execute() (*TotalPricingElements, *http.Response, error) {
	return r.ApiService.GetTotalPricingElementsExecute(r)
}

/*
GetTotalPricingElements Gets total pricing tax and fee types

Use this API to get global distribution channels tax and fee configurations. <p><strong>OperationId:</strong>getTotalPricingElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiGetTotalPricingElementsRequest
*/
func (a *ChannelApiService) GetTotalPricingElements(ctx context.Context, hotelId string) ChannelApiGetTotalPricingElementsRequest {
	return ChannelApiGetTotalPricingElementsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TotalPricingElements
func (a *ChannelApiService) GetTotalPricingElementsExecute(r ChannelApiGetTotalPricingElementsRequest) (*TotalPricingElements, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TotalPricingElements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetTotalPricingElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/totalPricing"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.elementCodes != nil {
		t := *r.elementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "elementCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "elementCodes", t, "multi")
		}
	}
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiManageChannelRoomMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRoomMappings *ManageChannelRoomMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiManageChannelRoomMappingRequest) Authorization(authorization string) ChannelApiManageChannelRoomMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiManageChannelRoomMappingRequest) XAppKey(xAppKey string) ChannelApiManageChannelRoomMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiManageChannelRoomMappingRequest) XHotelid(xHotelid string) ChannelApiManageChannelRoomMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create, edit or delete channel room type mapping.
func (r ChannelApiManageChannelRoomMappingRequest) ChannelRoomMappings(channelRoomMappings ManageChannelRoomMappingRequest) ChannelApiManageChannelRoomMappingRequest {
	r.channelRoomMappings = &channelRoomMappings
	return r
}

// External system code.
func (r ChannelApiManageChannelRoomMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiManageChannelRoomMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiManageChannelRoomMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiManageChannelRoomMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiManageChannelRoomMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ManageChannelRoomMappingExecute(r)
}

/*
ManageChannelRoomMapping Updates channel room configuration

Use this API to update channel room description <p><strong>OperationId:</strong>manageChannelRoomMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiManageChannelRoomMappingRequest
*/
func (a *ChannelApiService) ManageChannelRoomMapping(ctx context.Context) ChannelApiManageChannelRoomMappingRequest {
	return ChannelApiManageChannelRoomMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) ManageChannelRoomMappingExecute(r ChannelApiManageChannelRoomMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.ManageChannelRoomMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRoomMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostAmenitiesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	amenities *PutAmenitiesMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostAmenitiesMappingRequest) Authorization(authorization string) ChannelApiPostAmenitiesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostAmenitiesMappingRequest) XAppKey(xAppKey string) ChannelApiPostAmenitiesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostAmenitiesMappingRequest) XHotelid(xHotelid string) ChannelApiPostAmenitiesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new external system amenities.
func (r ChannelApiPostAmenitiesMappingRequest) Amenities(amenities PutAmenitiesMappingRequest) ChannelApiPostAmenitiesMappingRequest {
	r.amenities = &amenities
	return r
}

// External system code.
func (r ChannelApiPostAmenitiesMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPostAmenitiesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostAmenitiesMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostAmenitiesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostAmenitiesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAmenitiesMappingExecute(r)
}

/*
PostAmenitiesMapping Adds channel amenities configuration

Use this API to add channel amenities mapping <p><strong>OperationId:</strong>postAmenitiesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostAmenitiesMappingRequest
*/
func (a *ChannelApiService) PostAmenitiesMapping(ctx context.Context) ChannelApiPostAmenitiesMappingRequest {
	return ChannelApiPostAmenitiesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostAmenitiesMappingExecute(r ChannelApiPostAmenitiesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostAmenitiesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/amenities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.amenities
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelAccountContractsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	accountProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelAccountContracts *PutChannelAccountContractsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelAccountContractsRequest) Authorization(authorization string) ChannelApiPostChannelAccountContractsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelAccountContractsRequest) XAppKey(xAppKey string) ChannelApiPostChannelAccountContractsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelAccountContractsRequest) XHotelid(xHotelid string) ChannelApiPostChannelAccountContractsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create the channel account contracts.
func (r ChannelApiPostChannelAccountContractsRequest) ChannelAccountContracts(channelAccountContracts PutChannelAccountContractsRequest) ChannelApiPostChannelAccountContractsRequest {
	r.channelAccountContracts = &channelAccountContracts
	return r
}

// External system code.
func (r ChannelApiPostChannelAccountContractsRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelAccountContractsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelAccountContractsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelAccountContractsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelAccountContractsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelAccountContractsExecute(r)
}

/*
PostChannelAccountContracts Adds channel account contracts for given profile Id.

This API adds channel account contracts for given profile Id. <p><strong>OperationId:</strong>postChannelAccountContracts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountProfileId Unique ID that identifies an account profile.
 @return ChannelApiPostChannelAccountContractsRequest
*/
func (a *ChannelApiService) PostChannelAccountContracts(ctx context.Context, accountProfileId string) ChannelApiPostChannelAccountContractsRequest {
	return ChannelApiPostChannelAccountContractsRequest{
		ApiService: a,
		ctx: ctx,
		accountProfileId: accountProfileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelAccountContractsExecute(r ChannelApiPostChannelAccountContractsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelAccountContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts/{accountProfileId}/contracts"
	localVarPath = strings.Replace(localVarPath, "{"+"accountProfileId"+"}", url.PathEscape(parameterValueToString(r.accountProfileId, "accountProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountProfileId) < 1 {
		return localVarReturnValue, nil, reportError("accountProfileId must have at least 1 elements")
	}
	if strlen(r.accountProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("accountProfileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelAccountContracts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelAccountsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelAccounts *PostChannelAccountsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelAccountsRequest) Authorization(authorization string) ChannelApiPostChannelAccountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelAccountsRequest) XAppKey(xAppKey string) ChannelApiPostChannelAccountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelAccountsRequest) XHotelid(xHotelid string) ChannelApiPostChannelAccountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create the channel accounts.
func (r ChannelApiPostChannelAccountsRequest) ChannelAccounts(channelAccounts PostChannelAccountsRequest) ChannelApiPostChannelAccountsRequest {
	r.channelAccounts = &channelAccounts
	return r
}

// External system code.
func (r ChannelApiPostChannelAccountsRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelAccountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelAccountsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelAccountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelAccountsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelAccountsExecute(r)
}

/*
PostChannelAccounts Adds channel accounts.

This API adds channel accounts. <p><strong>OperationId:</strong>postChannelAccounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostChannelAccountsRequest
*/
func (a *ChannelApiService) PostChannelAccounts(ctx context.Context) ChannelApiPostChannelAccountsRequest {
	return ChannelApiPostChannelAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelAccountsExecute(r ChannelApiPostChannelAccountsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelAccounts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelBillingStatementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelBillingStatements *PutChannelBillingStatementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelBillingStatementsRequest) Authorization(authorization string) ChannelApiPostChannelBillingStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelBillingStatementsRequest) XAppKey(xAppKey string) ChannelApiPostChannelBillingStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelBillingStatementsRequest) XHotelid(xHotelid string) ChannelApiPostChannelBillingStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create channel billing statements.
func (r ChannelApiPostChannelBillingStatementsRequest) ChannelBillingStatements(channelBillingStatements PutChannelBillingStatementsRequest) ChannelApiPostChannelBillingStatementsRequest {
	r.channelBillingStatements = &channelBillingStatements
	return r
}

// External system code.
func (r ChannelApiPostChannelBillingStatementsRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelBillingStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelBillingStatementsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelBillingStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelBillingStatementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelBillingStatementsExecute(r)
}

/*
PostChannelBillingStatements Adds channel billing statements.

This API adds channel billing statements. <p><strong>OperationId:</strong>postChannelBillingStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostChannelBillingStatementsRequest
*/
func (a *ChannelApiService) PostChannelBillingStatements(ctx context.Context) ChannelApiPostChannelBillingStatementsRequest {
	return ChannelApiPostChannelBillingStatementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelBillingStatementsExecute(r ChannelApiPostChannelBillingStatementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelBillingStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelBillingStatements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelCardTypeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	cardTypeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelCardTypeMappings *PutChannelCardTypeMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelCardTypeMappingRequest) Authorization(authorization string) ChannelApiPostChannelCardTypeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelCardTypeMappingRequest) XAppKey(xAppKey string) ChannelApiPostChannelCardTypeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelCardTypeMappingRequest) XHotelid(xHotelid string) ChannelApiPostChannelCardTypeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new channel-hotel card type mapping.
func (r ChannelApiPostChannelCardTypeMappingRequest) ChannelCardTypeMappings(channelCardTypeMappings PutChannelCardTypeMappingRequest) ChannelApiPostChannelCardTypeMappingRequest {
	r.channelCardTypeMappings = &channelCardTypeMappings
	return r
}

// External system code.
func (r ChannelApiPostChannelCardTypeMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelCardTypeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelCardTypeMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelCardTypeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelCardTypeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelCardTypeMappingExecute(r)
}

/*
PostChannelCardTypeMapping Adds channel credit card mapping for a hotel

Use this API to add channel mapping for OPERA credit cards to channel for a given hotel id <p><strong>OperationId:</strong>postChannelCardTypeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardTypeCode Unique ID that identifies a channel.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiPostChannelCardTypeMappingRequest
*/
func (a *ChannelApiService) PostChannelCardTypeMapping(ctx context.Context, cardTypeCode string, channelCode string, hotelId string) ChannelApiPostChannelCardTypeMappingRequest {
	return ChannelApiPostChannelCardTypeMappingRequest{
		ApiService: a,
		ctx: ctx,
		cardTypeCode: cardTypeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelCardTypeMappingExecute(r ChannelApiPostChannelCardTypeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelCardTypeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/cardType/{cardTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cardTypeCode"+"}", url.PathEscape(parameterValueToString(r.cardTypeCode, "cardTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cardTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("cardTypeCode must have at least 1 elements")
	}
	if strlen(r.cardTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("cardTypeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelCardTypeMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelCarriersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelCarriers *PutChannelCarriersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelCarriersRequest) Authorization(authorization string) ChannelApiPostChannelCarriersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelCarriersRequest) XAppKey(xAppKey string) ChannelApiPostChannelCarriersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelCarriersRequest) XHotelid(xHotelid string) ChannelApiPostChannelCarriersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel carriers.
func (r ChannelApiPostChannelCarriersRequest) ChannelCarriers(channelCarriers PutChannelCarriersRequest) ChannelApiPostChannelCarriersRequest {
	r.channelCarriers = &channelCarriers
	return r
}

// External system code.
func (r ChannelApiPostChannelCarriersRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelCarriersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelCarriersRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelCarriersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelCarriersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelCarriersExecute(r)
}

/*
PostChannelCarriers Adds sub channel configuration

Use this API to add sub-channel (carrier) configuration for a given channel code <p><strong>OperationId:</strong>postChannelCarriers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPostChannelCarriersRequest
*/
func (a *ChannelApiService) PostChannelCarriers(ctx context.Context, channelCode string) ChannelApiPostChannelCarriersRequest {
	return ChannelApiPostChannelCarriersRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelCarriersExecute(r ChannelApiPostChannelCarriersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelCarriers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/subChannels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelCarriers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelErrorsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelErrors *PutChannelErrorsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelErrorsRequest) Authorization(authorization string) ChannelApiPostChannelErrorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelErrorsRequest) XAppKey(xAppKey string) ChannelApiPostChannelErrorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelErrorsRequest) XHotelid(xHotelid string) ChannelApiPostChannelErrorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel errors.
func (r ChannelApiPostChannelErrorsRequest) ChannelErrors(channelErrors PutChannelErrorsRequest) ChannelApiPostChannelErrorsRequest {
	r.channelErrors = &channelErrors
	return r
}

// External system code.
func (r ChannelApiPostChannelErrorsRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelErrorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelErrorsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelErrorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelErrorsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelErrorsExecute(r)
}

/*
PostChannelErrors Adds channel error codes

Use this API to add channel error code mapping configurations <p><strong>OperationId:</strong>postChannelErrors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPostChannelErrorsRequest
*/
func (a *ChannelApiService) PostChannelErrors(ctx context.Context, channelCode string) ChannelApiPostChannelErrorsRequest {
	return ChannelApiPostChannelErrorsRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelErrorsExecute(r ChannelApiPostChannelErrorsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelErrors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/errorCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelErrors
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelGuaranteeCodeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	guaranteeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGuaranteeCodeMappings *PutChannelGuaranteeCodeMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelGuaranteeCodeMappingRequest) Authorization(authorization string) ChannelApiPostChannelGuaranteeCodeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelGuaranteeCodeMappingRequest) XAppKey(xAppKey string) ChannelApiPostChannelGuaranteeCodeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelGuaranteeCodeMappingRequest) XHotelid(xHotelid string) ChannelApiPostChannelGuaranteeCodeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new channel-hotel guarantee code mapping.
func (r ChannelApiPostChannelGuaranteeCodeMappingRequest) ChannelGuaranteeCodeMappings(channelGuaranteeCodeMappings PutChannelGuaranteeCodeMappingRequest) ChannelApiPostChannelGuaranteeCodeMappingRequest {
	r.channelGuaranteeCodeMappings = &channelGuaranteeCodeMappings
	return r
}

// External system code.
func (r ChannelApiPostChannelGuaranteeCodeMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelGuaranteeCodeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelGuaranteeCodeMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelGuaranteeCodeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelGuaranteeCodeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelGuaranteeCodeMappingExecute(r)
}

/*
PostChannelGuaranteeCodeMapping Adds channel guarantee code mapping for a hotel

Use this API to add channel guarantee code mapping to OPERA guarantee code for a given hotel <p><strong>OperationId:</strong>postChannelGuaranteeCodeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guaranteeCode Guarantee Code.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiPostChannelGuaranteeCodeMappingRequest
*/
func (a *ChannelApiService) PostChannelGuaranteeCodeMapping(ctx context.Context, guaranteeCode string, channelCode string, hotelId string) ChannelApiPostChannelGuaranteeCodeMappingRequest {
	return ChannelApiPostChannelGuaranteeCodeMappingRequest{
		ApiService: a,
		ctx: ctx,
		guaranteeCode: guaranteeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelGuaranteeCodeMappingExecute(r ChannelApiPostChannelGuaranteeCodeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelGuaranteeCodeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/guarantees/{guaranteeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"guaranteeCode"+"}", url.PathEscape(parameterValueToString(r.guaranteeCode, "guaranteeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.guaranteeCode) < 1 {
		return localVarReturnValue, nil, reportError("guaranteeCode must have at least 1 elements")
	}
	if strlen(r.guaranteeCode) > 2000 {
		return localVarReturnValue, nil, reportError("guaranteeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGuaranteeCodeMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelHotelLettersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelHotelLettersToBeCreated *PostChannelHotelLettersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelHotelLettersRequest) Authorization(authorization string) ChannelApiPostChannelHotelLettersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelHotelLettersRequest) XAppKey(xAppKey string) ChannelApiPostChannelHotelLettersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelHotelLettersRequest) XHotelid(xHotelid string) ChannelApiPostChannelHotelLettersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new Hotel Letters associated with the Channels
func (r ChannelApiPostChannelHotelLettersRequest) ChannelHotelLettersToBeCreated(channelHotelLettersToBeCreated PostChannelHotelLettersRequest) ChannelApiPostChannelHotelLettersRequest {
	r.channelHotelLettersToBeCreated = &channelHotelLettersToBeCreated
	return r
}

// External system code.
func (r ChannelApiPostChannelHotelLettersRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelHotelLettersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelHotelLettersRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelHotelLettersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelHotelLettersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelHotelLettersExecute(r)
}

/*
PostChannelHotelLetters Adds channel property confirmation letter mapping

Use this API to add channel property confirmation letter configuration <p><strong>OperationId:</strong>postChannelHotelLetters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostChannelHotelLettersRequest
*/
func (a *ChannelApiService) PostChannelHotelLetters(ctx context.Context) ChannelApiPostChannelHotelLettersRequest {
	return ChannelApiPostChannelHotelLettersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelHotelLettersExecute(r ChannelApiPostChannelHotelLettersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelHotelLetters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/confirmationLetters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelHotelLettersToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelMarketingTextRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelMarketingText *PostChannelMarketingTextRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelMarketingTextRequest) Authorization(authorization string) ChannelApiPostChannelMarketingTextRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelMarketingTextRequest) XAppKey(xAppKey string) ChannelApiPostChannelMarketingTextRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelMarketingTextRequest) XHotelid(xHotelid string) ChannelApiPostChannelMarketingTextRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel marketing texts.
func (r ChannelApiPostChannelMarketingTextRequest) ChannelMarketingText(channelMarketingText PostChannelMarketingTextRequest) ChannelApiPostChannelMarketingTextRequest {
	r.channelMarketingText = &channelMarketingText
	return r
}

// External system code.
func (r ChannelApiPostChannelMarketingTextRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelMarketingTextRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelMarketingTextRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelMarketingTextRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelMarketingTextRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelMarketingTextExecute(r)
}

/*
PostChannelMarketingText Adds channel marketing messages

Use this API to add channel mapping for marketing messages <p><strong>OperationId:</strong>postChannelMarketingText</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostChannelMarketingTextRequest
*/
func (a *ChannelApiService) PostChannelMarketingText(ctx context.Context) ChannelApiPostChannelMarketingTextRequest {
	return ChannelApiPostChannelMarketingTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelMarketingTextExecute(r ChannelApiPostChannelMarketingTextRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelMarketingText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/marketingText"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelMarketingText
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelNegotiatedRateRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelNegotiatedRates *PutChannelNegotiatedRateRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelNegotiatedRateRequest) Authorization(authorization string) ChannelApiPostChannelNegotiatedRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelNegotiatedRateRequest) XAppKey(xAppKey string) ChannelApiPostChannelNegotiatedRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelNegotiatedRateRequest) XHotelid(xHotelid string) ChannelApiPostChannelNegotiatedRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Negotiated channel rates.
func (r ChannelApiPostChannelNegotiatedRateRequest) ChannelNegotiatedRates(channelNegotiatedRates PutChannelNegotiatedRateRequest) ChannelApiPostChannelNegotiatedRateRequest {
	r.channelNegotiatedRates = &channelNegotiatedRates
	return r
}

// External system code.
func (r ChannelApiPostChannelNegotiatedRateRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelNegotiatedRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelNegotiatedRateRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelNegotiatedRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelNegotiatedRateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelNegotiatedRateExecute(r)
}

/*
PostChannelNegotiatedRate Adds channel negotiate rate

Use this API to add channel's negotiated rate code mapping with an OPERA profile for a given hotel id <p><strong>OperationId:</strong>postChannelNegotiatedRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostChannelNegotiatedRateRequest
*/
func (a *ChannelApiService) PostChannelNegotiatedRate(ctx context.Context) ChannelApiPostChannelNegotiatedRateRequest {
	return ChannelApiPostChannelNegotiatedRateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelNegotiatedRateExecute(r ChannelApiPostChannelNegotiatedRateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelNegotiatedRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/negotiatedRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelNegotiatedRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelOrgMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelOrgMapping *PostChannelOrgMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelOrgMappingRequest) Authorization(authorization string) ChannelApiPostChannelOrgMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelOrgMappingRequest) XAppKey(xAppKey string) ChannelApiPostChannelOrgMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelOrgMappingRequest) XHotelid(xHotelid string) ChannelApiPostChannelOrgMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Create Channel to ORG and CRO Mapping.
func (r ChannelApiPostChannelOrgMappingRequest) ChannelOrgMapping(channelOrgMapping PostChannelOrgMappingRequest) ChannelApiPostChannelOrgMappingRequest {
	r.channelOrgMapping = &channelOrgMapping
	return r
}

// External system code.
func (r ChannelApiPostChannelOrgMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelOrgMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelOrgMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelOrgMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelOrgMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelOrgMappingExecute(r)
}

/*
PostChannelOrgMapping Adds channel tenants.

This API adds channel tenants. <p><strong>OperationId:</strong>postChannelOrgMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPostChannelOrgMappingRequest
*/
func (a *ChannelApiService) PostChannelOrgMapping(ctx context.Context, channelCode string) ChannelApiPostChannelOrgMappingRequest {
	return ChannelApiPostChannelOrgMappingRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelOrgMappingExecute(r ChannelApiPostChannelOrgMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelOrgMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/tenants"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelOrgMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelRateCategoriesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateCategories *PutChannelRateCategoriesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelRateCategoriesRequest) Authorization(authorization string) ChannelApiPostChannelRateCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelRateCategoriesRequest) XAppKey(xAppKey string) ChannelApiPostChannelRateCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelRateCategoriesRequest) XHotelid(xHotelid string) ChannelApiPostChannelRateCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel rate categories.
func (r ChannelApiPostChannelRateCategoriesRequest) ChannelRateCategories(channelRateCategories PutChannelRateCategoriesRequest) ChannelApiPostChannelRateCategoriesRequest {
	r.channelRateCategories = &channelRateCategories
	return r
}

// External system code.
func (r ChannelApiPostChannelRateCategoriesRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelRateCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelRateCategoriesRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelRateCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelRateCategoriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRateCategoriesExecute(r)
}

/*
PostChannelRateCategories Adds given channel's rate categories

Use this API to add channel rate categories for a given channel. <p><strong>OperationId:</strong>postChannelRateCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPostChannelRateCategoriesRequest
*/
func (a *ChannelApiService) PostChannelRateCategories(ctx context.Context, channelCode string) ChannelApiPostChannelRateCategoriesRequest {
	return ChannelApiPostChannelRateCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRateCategoriesExecute(r ChannelApiPostChannelRateCategoriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRateCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/rateCategories"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateCategories
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelRateLevelsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateLevels *PutChannelRateLevelsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelRateLevelsRequest) Authorization(authorization string) ChannelApiPostChannelRateLevelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelRateLevelsRequest) XAppKey(xAppKey string) ChannelApiPostChannelRateLevelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelRateLevelsRequest) XHotelid(xHotelid string) ChannelApiPostChannelRateLevelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel rate levels.
func (r ChannelApiPostChannelRateLevelsRequest) ChannelRateLevels(channelRateLevels PutChannelRateLevelsRequest) ChannelApiPostChannelRateLevelsRequest {
	r.channelRateLevels = &channelRateLevels
	return r
}

// External system code.
func (r ChannelApiPostChannelRateLevelsRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelRateLevelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelRateLevelsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelRateLevelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelRateLevelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRateLevelsExecute(r)
}

/*
PostChannelRateLevels Adds channel rate level

Use this API to add channel rate level configurations <p><strong>OperationId:</strong>postChannelRateLevels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPostChannelRateLevelsRequest
*/
func (a *ChannelApiService) PostChannelRateLevels(ctx context.Context, channelCode string) ChannelApiPostChannelRateLevelsRequest {
	return ChannelApiPostChannelRateLevelsRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRateLevelsExecute(r ChannelApiPostChannelRateLevelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRateLevels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/rateLevels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateLevels
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelRateMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateMapping *PutChannelRateMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelRateMappingRequest) Authorization(authorization string) ChannelApiPostChannelRateMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelRateMappingRequest) XAppKey(xAppKey string) ChannelApiPostChannelRateMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelRateMappingRequest) XHotelid(xHotelid string) ChannelApiPostChannelRateMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel rate mappings.
func (r ChannelApiPostChannelRateMappingRequest) ChannelRateMapping(channelRateMapping PutChannelRateMappingRequest) ChannelApiPostChannelRateMappingRequest {
	r.channelRateMapping = &channelRateMapping
	return r
}

// External system code.
func (r ChannelApiPostChannelRateMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelRateMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelRateMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelRateMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelRateMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRateMappingExecute(r)
}

/*
PostChannelRateMapping Adds channel property rate mapping

Use this API to add channel property rate mapping with OPERA hotel rate <p><strong>OperationId:</strong>postChannelRateMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostChannelRateMappingRequest
*/
func (a *ChannelApiService) PostChannelRateMapping(ctx context.Context) ChannelApiPostChannelRateMappingRequest {
	return ChannelApiPostChannelRateMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRateMappingExecute(r ChannelApiPostChannelRateMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRateMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelRatesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRates *PostChannelRatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelRatesRequest) Authorization(authorization string) ChannelApiPostChannelRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelRatesRequest) XAppKey(xAppKey string) ChannelApiPostChannelRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelRatesRequest) XHotelid(xHotelid string) ChannelApiPostChannelRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for distributing channel rates.
func (r ChannelApiPostChannelRatesRequest) ChannelRates(channelRates PostChannelRatesRequest) ChannelApiPostChannelRatesRequest {
	r.channelRates = &channelRates
	return r
}

// External system code.
func (r ChannelApiPostChannelRatesRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelRatesRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRatesExecute(r)
}

/*
PostChannelRates Distributes channel rate mappings to channel room types

Use this API to link (distribute) channel a rate code to channel room types. <p><strong>OperationId:</strong>postChannelRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiPostChannelRatesRequest
*/
func (a *ChannelApiService) PostChannelRates(ctx context.Context, hotelId string) ChannelApiPostChannelRatesRequest {
	return ChannelApiPostChannelRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRatesExecute(r ChannelApiPostChannelRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/rates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelRatesGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGlobalDescriptions *PutChannelRatesGlobalDescriptionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelRatesGlobalDescriptionsRequest) Authorization(authorization string) ChannelApiPostChannelRatesGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelRatesGlobalDescriptionsRequest) XAppKey(xAppKey string) ChannelApiPostChannelRatesGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelRatesGlobalDescriptionsRequest) XHotelid(xHotelid string) ChannelApiPostChannelRatesGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new Global Descriptions of the GDS Channels
func (r ChannelApiPostChannelRatesGlobalDescriptionsRequest) ChannelGlobalDescriptions(channelGlobalDescriptions PutChannelRatesGlobalDescriptionsRequest) ChannelApiPostChannelRatesGlobalDescriptionsRequest {
	r.channelGlobalDescriptions = &channelGlobalDescriptions
	return r
}

// External system code.
func (r ChannelApiPostChannelRatesGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelRatesGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelRatesGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelRatesGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelRatesGlobalDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRatesGlobalDescriptionsExecute(r)
}

/*
PostChannelRatesGlobalDescriptions Adds global room descriptions

Use this API to adds global room description for given hotel id and room type code <p><strong>OperationId:</strong>postChannelRatesGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostChannelRatesGlobalDescriptionsRequest
*/
func (a *ChannelApiService) PostChannelRatesGlobalDescriptions(ctx context.Context) ChannelApiPostChannelRatesGlobalDescriptionsRequest {
	return ChannelApiPostChannelRatesGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRatesGlobalDescriptionsExecute(r ChannelApiPostChannelRatesGlobalDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRatesGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGlobalDescriptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelRoomMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRoomMappings *ManageChannelRoomMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelRoomMappingRequest) Authorization(authorization string) ChannelApiPostChannelRoomMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelRoomMappingRequest) XAppKey(xAppKey string) ChannelApiPostChannelRoomMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelRoomMappingRequest) XHotelid(xHotelid string) ChannelApiPostChannelRoomMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Channel Room Mapping creation.
func (r ChannelApiPostChannelRoomMappingRequest) ChannelRoomMappings(channelRoomMappings ManageChannelRoomMappingRequest) ChannelApiPostChannelRoomMappingRequest {
	r.channelRoomMappings = &channelRoomMappings
	return r
}

// External system code.
func (r ChannelApiPostChannelRoomMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelRoomMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelRoomMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelRoomMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelRoomMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRoomMappingExecute(r)
}

/*
PostChannelRoomMapping Adds channel property room mapping

Use this API to add channel room mapping to OPERA hotel's room. <p><strong>OperationId:</strong>postChannelRoomMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostChannelRoomMappingRequest
*/
func (a *ChannelApiService) PostChannelRoomMapping(ctx context.Context) ChannelApiPostChannelRoomMappingRequest {
	return ChannelApiPostChannelRoomMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRoomMappingExecute(r ChannelApiPostChannelRoomMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRoomMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRoomMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelRoomTypeRateRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelRoomType string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRates *PostChannelRatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelRoomTypeRateRequest) Authorization(authorization string) ChannelApiPostChannelRoomTypeRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelRoomTypeRateRequest) XAppKey(xAppKey string) ChannelApiPostChannelRoomTypeRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelRoomTypeRateRequest) XHotelid(xHotelid string) ChannelApiPostChannelRoomTypeRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for distributing channel rates.
func (r ChannelApiPostChannelRoomTypeRateRequest) ChannelRates(channelRates PostChannelRatesRequest) ChannelApiPostChannelRoomTypeRateRequest {
	r.channelRates = &channelRates
	return r
}

// External system code.
func (r ChannelApiPostChannelRoomTypeRateRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelRoomTypeRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelRoomTypeRateRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelRoomTypeRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelRoomTypeRateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRoomTypeRateExecute(r)
}

/*
PostChannelRoomTypeRate Distributes channel room rate mappings.

Use this API to link (distribute) channel a room type to channel rate codes. <p><strong>OperationId:</strong>postChannelRoomTypeRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelRoomType Channel Room Type.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiPostChannelRoomTypeRateRequest
*/
func (a *ChannelApiService) PostChannelRoomTypeRate(ctx context.Context, channelRoomType string, channelCode string, hotelId string) ChannelApiPostChannelRoomTypeRateRequest {
	return ChannelApiPostChannelRoomTypeRateRequest{
		ApiService: a,
		ctx: ctx,
		channelRoomType: channelRoomType,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRoomTypeRateExecute(r ChannelApiPostChannelRoomTypeRateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRoomTypeRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/rooms/{channelRoomType}/rates"
	localVarPath = strings.Replace(localVarPath, "{"+"channelRoomType"+"}", url.PathEscape(parameterValueToString(r.channelRoomType, "channelRoomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelRoomType) < 1 {
		return localVarReturnValue, nil, reportError("channelRoomType must have at least 1 elements")
	}
	if strlen(r.channelRoomType) > 2000 {
		return localVarReturnValue, nil, reportError("channelRoomType must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelRoomTypesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRoomTypes *PutChannelRoomTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelRoomTypesRequest) Authorization(authorization string) ChannelApiPostChannelRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelRoomTypesRequest) XAppKey(xAppKey string) ChannelApiPostChannelRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelRoomTypesRequest) XHotelid(xHotelid string) ChannelApiPostChannelRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channel room types.
func (r ChannelApiPostChannelRoomTypesRequest) ChannelRoomTypes(channelRoomTypes PutChannelRoomTypesRequest) ChannelApiPostChannelRoomTypesRequest {
	r.channelRoomTypes = &channelRoomTypes
	return r
}

// External system code.
func (r ChannelApiPostChannelRoomTypesRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelRoomTypesRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelRoomTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRoomTypesExecute(r)
}

/*
PostChannelRoomTypes Adds channel room

Use this API to add channel room configuration <p><strong>OperationId:</strong>postChannelRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPostChannelRoomTypesRequest
*/
func (a *ChannelApiService) PostChannelRoomTypes(ctx context.Context, channelCode string) ChannelApiPostChannelRoomTypesRequest {
	return ChannelApiPostChannelRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRoomTypesExecute(r ChannelApiPostChannelRoomTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/roomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRoomTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelRoomsGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGlobalDescriptions *PutChannelRatesGlobalDescriptionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelRoomsGlobalDescriptionsRequest) Authorization(authorization string) ChannelApiPostChannelRoomsGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelRoomsGlobalDescriptionsRequest) XAppKey(xAppKey string) ChannelApiPostChannelRoomsGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelRoomsGlobalDescriptionsRequest) XHotelid(xHotelid string) ChannelApiPostChannelRoomsGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new Global Descriptions of the GDS Channels
func (r ChannelApiPostChannelRoomsGlobalDescriptionsRequest) ChannelGlobalDescriptions(channelGlobalDescriptions PutChannelRatesGlobalDescriptionsRequest) ChannelApiPostChannelRoomsGlobalDescriptionsRequest {
	r.channelGlobalDescriptions = &channelGlobalDescriptions
	return r
}

// External system code.
func (r ChannelApiPostChannelRoomsGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelRoomsGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelRoomsGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelRoomsGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelRoomsGlobalDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelRoomsGlobalDescriptionsExecute(r)
}

/*
PostChannelRoomsGlobalDescriptions Adds global rate descriptions

Use this API to add global rate description for given hotel id and rate code <p><strong>OperationId:</strong>postChannelRoomsGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostChannelRoomsGlobalDescriptionsRequest
*/
func (a *ChannelApiService) PostChannelRoomsGlobalDescriptions(ctx context.Context) ChannelApiPostChannelRoomsGlobalDescriptionsRequest {
	return ChannelApiPostChannelRoomsGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelRoomsGlobalDescriptionsExecute(r ChannelApiPostChannelRoomsGlobalDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannelRoomsGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGlobalDescriptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostChannelsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channels *PutChannelsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostChannelsRequest) Authorization(authorization string) ChannelApiPostChannelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostChannelsRequest) XAppKey(xAppKey string) ChannelApiPostChannelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostChannelsRequest) XHotelid(xHotelid string) ChannelApiPostChannelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating channels.
func (r ChannelApiPostChannelsRequest) Channels(channels PutChannelsRequest) ChannelApiPostChannelsRequest {
	r.channels = &channels
	return r
}

// External system code.
func (r ChannelApiPostChannelsRequest) XExternalsystem(xExternalsystem string) ChannelApiPostChannelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostChannelsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostChannelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostChannelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChannelsExecute(r)
}

/*
PostChannels Adds new channel

Use this API to add new channel code in OPERA <p><strong>OperationId:</strong>postChannels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostChannelsRequest
*/
func (a *ChannelApiService) PostChannels(ctx context.Context) ChannelApiPostChannelsRequest {
	return ChannelApiPostChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostChannelsExecute(r ChannelApiPostChannelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channels
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostCreditCardsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	creditCards *PutCreditCardsMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostCreditCardsMappingRequest) Authorization(authorization string) ChannelApiPostCreditCardsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostCreditCardsMappingRequest) XAppKey(xAppKey string) ChannelApiPostCreditCardsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostCreditCardsMappingRequest) XHotelid(xHotelid string) ChannelApiPostCreditCardsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating external system credit cards.
func (r ChannelApiPostCreditCardsMappingRequest) CreditCards(creditCards PutCreditCardsMappingRequest) ChannelApiPostCreditCardsMappingRequest {
	r.creditCards = &creditCards
	return r
}

// External system code.
func (r ChannelApiPostCreditCardsMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPostCreditCardsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostCreditCardsMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostCreditCardsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostCreditCardsMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCreditCardsMappingExecute(r)
}

/*
PostCreditCardsMapping Adds channel credit card mapping

Use this API to add channel mapping for OPERA Credit cards <p><strong>OperationId:</strong>postCreditCardsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostCreditCardsMappingRequest
*/
func (a *ChannelApiService) PostCreditCardsMapping(ctx context.Context) ChannelApiPostCreditCardsMappingRequest {
	return ChannelApiPostCreditCardsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostCreditCardsMappingExecute(r ChannelApiPostCreditCardsMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostCreditCardsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/cardTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditCards
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostCurrenciesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencies *PutCurrenciesMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostCurrenciesMappingRequest) Authorization(authorization string) ChannelApiPostCurrenciesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostCurrenciesMappingRequest) XAppKey(xAppKey string) ChannelApiPostCurrenciesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostCurrenciesMappingRequest) XHotelid(xHotelid string) ChannelApiPostCurrenciesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating external system currencies.
func (r ChannelApiPostCurrenciesMappingRequest) Currencies(currencies PutCurrenciesMappingRequest) ChannelApiPostCurrenciesMappingRequest {
	r.currencies = &currencies
	return r
}

// External system code.
func (r ChannelApiPostCurrenciesMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPostCurrenciesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostCurrenciesMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostCurrenciesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostCurrenciesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCurrenciesMappingExecute(r)
}

/*
PostCurrenciesMapping Adds channel currency code mapping

Use this API to add channel currency code mapping to OPERA currency codes. <p><strong>OperationId:</strong>postCurrenciesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostCurrenciesMappingRequest
*/
func (a *ChannelApiService) PostCurrenciesMapping(ctx context.Context) ChannelApiPostCurrenciesMappingRequest {
	return ChannelApiPostCurrenciesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostCurrenciesMappingExecute(r ChannelApiPostCurrenciesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostCurrenciesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.currencies
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostDistributionTemplatesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	distributionTemplates *PutDistributionTemplatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostDistributionTemplatesRequest) Authorization(authorization string) ChannelApiPostDistributionTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostDistributionTemplatesRequest) XAppKey(xAppKey string) ChannelApiPostDistributionTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostDistributionTemplatesRequest) XHotelid(xHotelid string) ChannelApiPostDistributionTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating chain or property level distribution templates.
func (r ChannelApiPostDistributionTemplatesRequest) DistributionTemplates(distributionTemplates PutDistributionTemplatesRequest) ChannelApiPostDistributionTemplatesRequest {
	r.distributionTemplates = &distributionTemplates
	return r
}

// External system code.
func (r ChannelApiPostDistributionTemplatesRequest) XExternalsystem(xExternalsystem string) ChannelApiPostDistributionTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostDistributionTemplatesRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostDistributionTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostDistributionTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostDistributionTemplatesExecute(r)
}

/*
PostDistributionTemplates Adds rate templates configurations

Use this API to add a distribution rate template. <p><strong>OperationId:</strong>postDistributionTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostDistributionTemplatesRequest
*/
func (a *ChannelApiService) PostDistributionTemplates(ctx context.Context) ChannelApiPostDistributionTemplatesRequest {
	return ChannelApiPostDistributionTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostDistributionTemplatesExecute(r ChannelApiPostDistributionTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostDistributionTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/distributionTemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.distributionTemplates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostGuaranteesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	guarantees *PutGuaranteesMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostGuaranteesMappingRequest) Authorization(authorization string) ChannelApiPostGuaranteesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostGuaranteesMappingRequest) XAppKey(xAppKey string) ChannelApiPostGuaranteesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostGuaranteesMappingRequest) XHotelid(xHotelid string) ChannelApiPostGuaranteesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new external system guarantees.
func (r ChannelApiPostGuaranteesMappingRequest) Guarantees(guarantees PutGuaranteesMappingRequest) ChannelApiPostGuaranteesMappingRequest {
	r.guarantees = &guarantees
	return r
}

// External system code.
func (r ChannelApiPostGuaranteesMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPostGuaranteesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostGuaranteesMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostGuaranteesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostGuaranteesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostGuaranteesMappingExecute(r)
}

/*
PostGuaranteesMapping Adds channel guarantee code mapping

Use this API to add channel's guarantee codes mapping to OPERA guarantee codes. <p><strong>OperationId:</strong>postGuaranteesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostGuaranteesMappingRequest
*/
func (a *ChannelApiService) PostGuaranteesMapping(ctx context.Context) ChannelApiPostGuaranteesMappingRequest {
	return ChannelApiPostGuaranteesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostGuaranteesMappingExecute(r ChannelApiPostGuaranteesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostGuaranteesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/guarantees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guarantees
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostHotelsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	properties *PutHotelsMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostHotelsMappingRequest) Authorization(authorization string) ChannelApiPostHotelsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostHotelsMappingRequest) XAppKey(xAppKey string) ChannelApiPostHotelsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostHotelsMappingRequest) XHotelid(xHotelid string) ChannelApiPostHotelsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating external system properties.
func (r ChannelApiPostHotelsMappingRequest) Properties(properties PutHotelsMappingRequest) ChannelApiPostHotelsMappingRequest {
	r.properties = &properties
	return r
}

// External system code.
func (r ChannelApiPostHotelsMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPostHotelsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostHotelsMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostHotelsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostHotelsMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHotelsMappingExecute(r)
}

/*
PostHotelsMapping Adds channel hotel mapping

Use this API to add channel mapping to OPERA hotel id including channel hotel code, room sell limit per reservation, city code, end date. <p><strong>OperationId:</strong>postHotelsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostHotelsMappingRequest
*/
func (a *ChannelApiService) PostHotelsMapping(ctx context.Context) ChannelApiPostHotelsMappingRequest {
	return ChannelApiPostHotelsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostHotelsMappingExecute(r ChannelApiPostHotelsMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostHotelsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/hotels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.properties
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPostTotalPricingElementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	totalPricingElements *PutTotalPricingElementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPostTotalPricingElementsRequest) Authorization(authorization string) ChannelApiPostTotalPricingElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPostTotalPricingElementsRequest) XAppKey(xAppKey string) ChannelApiPostTotalPricingElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPostTotalPricingElementsRequest) XHotelid(xHotelid string) ChannelApiPostTotalPricingElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create the total pricing elements of GDS channel.
func (r ChannelApiPostTotalPricingElementsRequest) TotalPricingElements(totalPricingElements PutTotalPricingElementsRequest) ChannelApiPostTotalPricingElementsRequest {
	r.totalPricingElements = &totalPricingElements
	return r
}

// External system code.
func (r ChannelApiPostTotalPricingElementsRequest) XExternalsystem(xExternalsystem string) ChannelApiPostTotalPricingElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPostTotalPricingElementsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPostTotalPricingElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPostTotalPricingElementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTotalPricingElementsExecute(r)
}

/*
PostTotalPricingElements Adds total pricing tax and fee types

Use this API to add global distribution channels tax and fee configurations. <p><strong>OperationId:</strong>postTotalPricingElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPostTotalPricingElementsRequest
*/
func (a *ChannelApiService) PostTotalPricingElements(ctx context.Context) ChannelApiPostTotalPricingElementsRequest {
	return ChannelApiPostTotalPricingElementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PostTotalPricingElementsExecute(r ChannelApiPostTotalPricingElementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PostTotalPricingElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/totalPricing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.totalPricingElements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPublishChannelAvailabilityRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelAvailability *PublishChannelAvailabilityRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPublishChannelAvailabilityRequest) Authorization(authorization string) ChannelApiPublishChannelAvailabilityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPublishChannelAvailabilityRequest) XAppKey(xAppKey string) ChannelApiPublishChannelAvailabilityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPublishChannelAvailabilityRequest) XHotelid(xHotelid string) ChannelApiPublishChannelAvailabilityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for publishing rate availability to channels.
func (r ChannelApiPublishChannelAvailabilityRequest) ChannelAvailability(channelAvailability PublishChannelAvailabilityRequest) ChannelApiPublishChannelAvailabilityRequest {
	r.channelAvailability = &channelAvailability
	return r
}

// External system code.
func (r ChannelApiPublishChannelAvailabilityRequest) XExternalsystem(xExternalsystem string) ChannelApiPublishChannelAvailabilityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPublishChannelAvailabilityRequest) AcceptLanguage(acceptLanguage string) ChannelApiPublishChannelAvailabilityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPublishChannelAvailabilityRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PublishChannelAvailabilityExecute(r)
}

/*
PublishChannelAvailability Publishes channel availability.

This API changes publishes channel availability. <p><strong>OperationId:</strong>publishChannelAvailability</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPublishChannelAvailabilityRequest
*/
func (a *ChannelApiService) PublishChannelAvailability(ctx context.Context) ChannelApiPublishChannelAvailabilityRequest {
	return ChannelApiPublishChannelAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PublishChannelAvailabilityExecute(r ChannelApiPublishChannelAvailabilityRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PublishChannelAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/availability/publish"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelAvailability
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPublishChannelRatePlansRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRatePlans *PublishChannelRatePlansRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPublishChannelRatePlansRequest) Authorization(authorization string) ChannelApiPublishChannelRatePlansRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPublishChannelRatePlansRequest) XAppKey(xAppKey string) ChannelApiPublishChannelRatePlansRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPublishChannelRatePlansRequest) XHotelid(xHotelid string) ChannelApiPublishChannelRatePlansRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for publishing rate codes to GDS.
func (r ChannelApiPublishChannelRatePlansRequest) ChannelRatePlans(channelRatePlans PublishChannelRatePlansRequest) ChannelApiPublishChannelRatePlansRequest {
	r.channelRatePlans = &channelRatePlans
	return r
}

// External system code.
func (r ChannelApiPublishChannelRatePlansRequest) XExternalsystem(xExternalsystem string) ChannelApiPublishChannelRatePlansRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPublishChannelRatePlansRequest) AcceptLanguage(acceptLanguage string) ChannelApiPublishChannelRatePlansRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPublishChannelRatePlansRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PublishChannelRatePlansExecute(r)
}

/*
PublishChannelRatePlans Publishes channel rate plan codes

This API changes the channel rate plans for given channel code. <p><strong>OperationId:</strong>publishChannelRatePlans</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPublishChannelRatePlansRequest
*/
func (a *ChannelApiService) PublishChannelRatePlans(ctx context.Context, channelCode string) ChannelApiPublishChannelRatePlansRequest {
	return ChannelApiPublishChannelRatePlansRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PublishChannelRatePlansExecute(r ChannelApiPublishChannelRatePlansRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PublishChannelRatePlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/ratePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRatePlans
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPublishChannelRestrictionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRestrictions *PublishChannelRestrictionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPublishChannelRestrictionsRequest) Authorization(authorization string) ChannelApiPublishChannelRestrictionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPublishChannelRestrictionsRequest) XAppKey(xAppKey string) ChannelApiPublishChannelRestrictionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPublishChannelRestrictionsRequest) XHotelid(xHotelid string) ChannelApiPublishChannelRestrictionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for publishing rate restrictions to channels.
func (r ChannelApiPublishChannelRestrictionsRequest) ChannelRestrictions(channelRestrictions PublishChannelRestrictionsRequest) ChannelApiPublishChannelRestrictionsRequest {
	r.channelRestrictions = &channelRestrictions
	return r
}

// External system code.
func (r ChannelApiPublishChannelRestrictionsRequest) XExternalsystem(xExternalsystem string) ChannelApiPublishChannelRestrictionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPublishChannelRestrictionsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPublishChannelRestrictionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPublishChannelRestrictionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PublishChannelRestrictionsExecute(r)
}

/*
PublishChannelRestrictions Publishes channel restrictions

This API changes the channel restrictions. <p><strong>OperationId:</strong>publishChannelRestrictions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPublishChannelRestrictionsRequest
*/
func (a *ChannelApiService) PublishChannelRestrictions(ctx context.Context) ChannelApiPublishChannelRestrictionsRequest {
	return ChannelApiPublishChannelRestrictionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PublishChannelRestrictionsExecute(r ChannelApiPublishChannelRestrictionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PublishChannelRestrictions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/restrictions/publish"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRestrictions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPublishHotelChannelRatePlansRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRatePlans *PublishChannelRatePlansRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPublishHotelChannelRatePlansRequest) Authorization(authorization string) ChannelApiPublishHotelChannelRatePlansRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPublishHotelChannelRatePlansRequest) XAppKey(xAppKey string) ChannelApiPublishHotelChannelRatePlansRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPublishHotelChannelRatePlansRequest) XHotelid(xHotelid string) ChannelApiPublishHotelChannelRatePlansRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for publishing rate codes to GDS.
func (r ChannelApiPublishHotelChannelRatePlansRequest) ChannelRatePlans(channelRatePlans PublishChannelRatePlansRequest) ChannelApiPublishHotelChannelRatePlansRequest {
	r.channelRatePlans = &channelRatePlans
	return r
}

// External system code.
func (r ChannelApiPublishHotelChannelRatePlansRequest) XExternalsystem(xExternalsystem string) ChannelApiPublishHotelChannelRatePlansRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPublishHotelChannelRatePlansRequest) AcceptLanguage(acceptLanguage string) ChannelApiPublishHotelChannelRatePlansRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPublishHotelChannelRatePlansRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PublishHotelChannelRatePlansExecute(r)
}

/*
PublishHotelChannelRatePlans Publishes channel hotel rate plan codes

This API changes the channel rate plans for given Hotel Id. <p><strong>OperationId:</strong>publishHotelChannelRatePlans</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiPublishHotelChannelRatePlansRequest
*/
func (a *ChannelApiService) PublishHotelChannelRatePlans(ctx context.Context, hotelId string) ChannelApiPublishHotelChannelRatePlansRequest {
	return ChannelApiPublishHotelChannelRatePlansRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PublishHotelChannelRatePlansExecute(r ChannelApiPublishHotelChannelRatePlansRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PublishHotelChannelRatePlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/ratePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRatePlans
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutAmenitiesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	amenities *PutAmenitiesMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutAmenitiesMappingRequest) Authorization(authorization string) ChannelApiPutAmenitiesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutAmenitiesMappingRequest) XAppKey(xAppKey string) ChannelApiPutAmenitiesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutAmenitiesMappingRequest) XHotelid(xHotelid string) ChannelApiPutAmenitiesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing external system amenities.
func (r ChannelApiPutAmenitiesMappingRequest) Amenities(amenities PutAmenitiesMappingRequest) ChannelApiPutAmenitiesMappingRequest {
	r.amenities = &amenities
	return r
}

// External system code.
func (r ChannelApiPutAmenitiesMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPutAmenitiesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutAmenitiesMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutAmenitiesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutAmenitiesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAmenitiesMappingExecute(r)
}

/*
PutAmenitiesMapping Updates channel amenities configuration

Use this API to update channel amenities mapping <p><strong>OperationId:</strong>putAmenitiesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutAmenitiesMappingRequest
*/
func (a *ChannelApiService) PutAmenitiesMapping(ctx context.Context) ChannelApiPutAmenitiesMappingRequest {
	return ChannelApiPutAmenitiesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutAmenitiesMappingExecute(r ChannelApiPutAmenitiesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutAmenitiesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/amenities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.amenities
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelAccountContractsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	accountProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelAccountContracts *PutChannelAccountContractsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelAccountContractsRequest) Authorization(authorization string) ChannelApiPutChannelAccountContractsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelAccountContractsRequest) XAppKey(xAppKey string) ChannelApiPutChannelAccountContractsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelAccountContractsRequest) XHotelid(xHotelid string) ChannelApiPutChannelAccountContractsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change the channel account contracts.
func (r ChannelApiPutChannelAccountContractsRequest) ChannelAccountContracts(channelAccountContracts PutChannelAccountContractsRequest) ChannelApiPutChannelAccountContractsRequest {
	r.channelAccountContracts = &channelAccountContracts
	return r
}

// External system code.
func (r ChannelApiPutChannelAccountContractsRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelAccountContractsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelAccountContractsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelAccountContractsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelAccountContractsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelAccountContractsExecute(r)
}

/*
PutChannelAccountContracts Updates channel account contracts for given profile Id.

Use this API to update existing cannel account contract for a given OPERA profile id <p><strong>OperationId:</strong>putChannelAccountContracts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountProfileId Unique ID that identifies an account profile.
 @return ChannelApiPutChannelAccountContractsRequest
*/
func (a *ChannelApiService) PutChannelAccountContracts(ctx context.Context, accountProfileId string) ChannelApiPutChannelAccountContractsRequest {
	return ChannelApiPutChannelAccountContractsRequest{
		ApiService: a,
		ctx: ctx,
		accountProfileId: accountProfileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelAccountContractsExecute(r ChannelApiPutChannelAccountContractsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelAccountContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts/{accountProfileId}/contracts"
	localVarPath = strings.Replace(localVarPath, "{"+"accountProfileId"+"}", url.PathEscape(parameterValueToString(r.accountProfileId, "accountProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountProfileId) < 1 {
		return localVarReturnValue, nil, reportError("accountProfileId must have at least 1 elements")
	}
	if strlen(r.accountProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("accountProfileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelAccountContracts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelAccountsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelAccountsToChange *UNKNOWN_BASE_TYPE
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelAccountsRequest) Authorization(authorization string) ChannelApiPutChannelAccountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelAccountsRequest) XAppKey(xAppKey string) ChannelApiPutChannelAccountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelAccountsRequest) XHotelid(xHotelid string) ChannelApiPutChannelAccountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Channel account information to create a new channel account.
func (r ChannelApiPutChannelAccountsRequest) ChannelAccountsToChange(channelAccountsToChange UNKNOWN_BASE_TYPE) ChannelApiPutChannelAccountsRequest {
	r.channelAccountsToChange = &channelAccountsToChange
	return r
}

// External system code.
func (r ChannelApiPutChannelAccountsRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelAccountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelAccountsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelAccountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelAccountsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelAccountsExecute(r)
}

/*
PutChannelAccounts Updates channel accounts

Use this API to update existing channel account for a given OPERA profile id <p><strong>OperationId:</strong>putChannelAccounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutChannelAccountsRequest
*/
func (a *ChannelApiService) PutChannelAccounts(ctx context.Context) ChannelApiPutChannelAccountsRequest {
	return ChannelApiPutChannelAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelAccountsExecute(r ChannelApiPutChannelAccountsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelAccountsToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelBillingStatementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelBillingStatements *PutChannelBillingStatementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelBillingStatementsRequest) Authorization(authorization string) ChannelApiPutChannelBillingStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelBillingStatementsRequest) XAppKey(xAppKey string) ChannelApiPutChannelBillingStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelBillingStatementsRequest) XHotelid(xHotelid string) ChannelApiPutChannelBillingStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to Change channel billing statements.
func (r ChannelApiPutChannelBillingStatementsRequest) ChannelBillingStatements(channelBillingStatements PutChannelBillingStatementsRequest) ChannelApiPutChannelBillingStatementsRequest {
	r.channelBillingStatements = &channelBillingStatements
	return r
}

// External system code.
func (r ChannelApiPutChannelBillingStatementsRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelBillingStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelBillingStatementsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelBillingStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelBillingStatementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelBillingStatementsExecute(r)
}

/*
PutChannelBillingStatements Updates channel billing statement details

Use this API to update channels billing statements for a given OPERA statement id <p><strong>OperationId:</strong>putChannelBillingStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutChannelBillingStatementsRequest
*/
func (a *ChannelApiService) PutChannelBillingStatements(ctx context.Context) ChannelApiPutChannelBillingStatementsRequest {
	return ChannelApiPutChannelBillingStatementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelBillingStatementsExecute(r ChannelApiPutChannelBillingStatementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelBillingStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/billingStatements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelBillingStatements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelCardTypeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	cardTypeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelCardTypeMappings *PutChannelCardTypeMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelCardTypeMappingRequest) Authorization(authorization string) ChannelApiPutChannelCardTypeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelCardTypeMappingRequest) XAppKey(xAppKey string) ChannelApiPutChannelCardTypeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelCardTypeMappingRequest) XHotelid(xHotelid string) ChannelApiPutChannelCardTypeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing information of an existing channel-hotel card type mapping.
func (r ChannelApiPutChannelCardTypeMappingRequest) ChannelCardTypeMappings(channelCardTypeMappings PutChannelCardTypeMappingRequest) ChannelApiPutChannelCardTypeMappingRequest {
	r.channelCardTypeMappings = &channelCardTypeMappings
	return r
}

// External system code.
func (r ChannelApiPutChannelCardTypeMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelCardTypeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelCardTypeMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelCardTypeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelCardTypeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelCardTypeMappingExecute(r)
}

/*
PutChannelCardTypeMapping Updates channel credit card mapping for a hotel

Use this API to update channel mapping for OPERA credit cards to channel for a given hotel id <p><strong>OperationId:</strong>putChannelCardTypeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardTypeCode Unique ID that identifies a channel.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiPutChannelCardTypeMappingRequest
*/
func (a *ChannelApiService) PutChannelCardTypeMapping(ctx context.Context, cardTypeCode string, channelCode string, hotelId string) ChannelApiPutChannelCardTypeMappingRequest {
	return ChannelApiPutChannelCardTypeMappingRequest{
		ApiService: a,
		ctx: ctx,
		cardTypeCode: cardTypeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelCardTypeMappingExecute(r ChannelApiPutChannelCardTypeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelCardTypeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/cardType/{cardTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cardTypeCode"+"}", url.PathEscape(parameterValueToString(r.cardTypeCode, "cardTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cardTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("cardTypeCode must have at least 1 elements")
	}
	if strlen(r.cardTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("cardTypeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelCardTypeMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelCarriersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelCarriers *PutChannelCarriersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelCarriersRequest) Authorization(authorization string) ChannelApiPutChannelCarriersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelCarriersRequest) XAppKey(xAppKey string) ChannelApiPutChannelCarriersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelCarriersRequest) XHotelid(xHotelid string) ChannelApiPutChannelCarriersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing details of channel carriers.
func (r ChannelApiPutChannelCarriersRequest) ChannelCarriers(channelCarriers PutChannelCarriersRequest) ChannelApiPutChannelCarriersRequest {
	r.channelCarriers = &channelCarriers
	return r
}

// External system code.
func (r ChannelApiPutChannelCarriersRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelCarriersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelCarriersRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelCarriersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelCarriersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelCarriersExecute(r)
}

/*
PutChannelCarriers Updates sub channel configuration

Use this API to update sub-channel (carrier) configuration for a given channel code <p><strong>OperationId:</strong>putChannelCarriers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPutChannelCarriersRequest
*/
func (a *ChannelApiService) PutChannelCarriers(ctx context.Context, channelCode string) ChannelApiPutChannelCarriersRequest {
	return ChannelApiPutChannelCarriersRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelCarriersExecute(r ChannelApiPutChannelCarriersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelCarriers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/subChannels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelCarriers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelErrorsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelErrors *PutChannelErrorsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelErrorsRequest) Authorization(authorization string) ChannelApiPutChannelErrorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelErrorsRequest) XAppKey(xAppKey string) ChannelApiPutChannelErrorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelErrorsRequest) XHotelid(xHotelid string) ChannelApiPutChannelErrorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing details of channel errors.
func (r ChannelApiPutChannelErrorsRequest) ChannelErrors(channelErrors PutChannelErrorsRequest) ChannelApiPutChannelErrorsRequest {
	r.channelErrors = &channelErrors
	return r
}

// External system code.
func (r ChannelApiPutChannelErrorsRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelErrorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelErrorsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelErrorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelErrorsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelErrorsExecute(r)
}

/*
PutChannelErrors Updates channel error codes

Use this API to update channel error code mapping configurations <p><strong>OperationId:</strong>putChannelErrors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPutChannelErrorsRequest
*/
func (a *ChannelApiService) PutChannelErrors(ctx context.Context, channelCode string) ChannelApiPutChannelErrorsRequest {
	return ChannelApiPutChannelErrorsRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelErrorsExecute(r ChannelApiPutChannelErrorsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelErrors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/errorCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelErrors
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelGuaranteeCodeMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	guaranteeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGuaranteeCodeMappings *PutChannelGuaranteeCodeMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelGuaranteeCodeMappingRequest) Authorization(authorization string) ChannelApiPutChannelGuaranteeCodeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelGuaranteeCodeMappingRequest) XAppKey(xAppKey string) ChannelApiPutChannelGuaranteeCodeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelGuaranteeCodeMappingRequest) XHotelid(xHotelid string) ChannelApiPutChannelGuaranteeCodeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing information of an existing channel-hotel guarantee code mapping.
func (r ChannelApiPutChannelGuaranteeCodeMappingRequest) ChannelGuaranteeCodeMappings(channelGuaranteeCodeMappings PutChannelGuaranteeCodeMappingRequest) ChannelApiPutChannelGuaranteeCodeMappingRequest {
	r.channelGuaranteeCodeMappings = &channelGuaranteeCodeMappings
	return r
}

// External system code.
func (r ChannelApiPutChannelGuaranteeCodeMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelGuaranteeCodeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelGuaranteeCodeMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelGuaranteeCodeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelGuaranteeCodeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelGuaranteeCodeMappingExecute(r)
}

/*
PutChannelGuaranteeCodeMapping Updates channel guarantee code mapping for a hotel

Use this API to update channel guarantee code mapping to OPERA guarantee code for a given hotel <p><strong>OperationId:</strong>putChannelGuaranteeCodeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guaranteeCode Guarantee Code.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiPutChannelGuaranteeCodeMappingRequest
*/
func (a *ChannelApiService) PutChannelGuaranteeCodeMapping(ctx context.Context, guaranteeCode string, channelCode string, hotelId string) ChannelApiPutChannelGuaranteeCodeMappingRequest {
	return ChannelApiPutChannelGuaranteeCodeMappingRequest{
		ApiService: a,
		ctx: ctx,
		guaranteeCode: guaranteeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelGuaranteeCodeMappingExecute(r ChannelApiPutChannelGuaranteeCodeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelGuaranteeCodeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/guarantees/{guaranteeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"guaranteeCode"+"}", url.PathEscape(parameterValueToString(r.guaranteeCode, "guaranteeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.guaranteeCode) < 1 {
		return localVarReturnValue, nil, reportError("guaranteeCode must have at least 1 elements")
	}
	if strlen(r.guaranteeCode) > 2000 {
		return localVarReturnValue, nil, reportError("guaranteeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGuaranteeCodeMappings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelHotelLettersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelHotelLettersToBeChanged *PutChannelHotelLettersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelHotelLettersRequest) Authorization(authorization string) ChannelApiPutChannelHotelLettersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelHotelLettersRequest) XAppKey(xAppKey string) ChannelApiPutChannelHotelLettersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelHotelLettersRequest) XHotelid(xHotelid string) ChannelApiPutChannelHotelLettersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to update existing Hotel Letters associated with the Booking Channels
func (r ChannelApiPutChannelHotelLettersRequest) ChannelHotelLettersToBeChanged(channelHotelLettersToBeChanged PutChannelHotelLettersRequest) ChannelApiPutChannelHotelLettersRequest {
	r.channelHotelLettersToBeChanged = &channelHotelLettersToBeChanged
	return r
}

// External system code.
func (r ChannelApiPutChannelHotelLettersRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelHotelLettersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelHotelLettersRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelHotelLettersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelHotelLettersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelHotelLettersExecute(r)
}

/*
PutChannelHotelLetters Updates channel property confirmation letter mapping

Use this API to update channel property confirmation letter configuration <p><strong>OperationId:</strong>putChannelHotelLetters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutChannelHotelLettersRequest
*/
func (a *ChannelApiService) PutChannelHotelLetters(ctx context.Context) ChannelApiPutChannelHotelLettersRequest {
	return ChannelApiPutChannelHotelLettersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelHotelLettersExecute(r ChannelApiPutChannelHotelLettersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelHotelLetters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/confirmationLetters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelHotelLettersToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelMarketingTextRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelMarketingTextToChange *PutChannelMarketingTextRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelMarketingTextRequest) Authorization(authorization string) ChannelApiPutChannelMarketingTextRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelMarketingTextRequest) XAppKey(xAppKey string) ChannelApiPutChannelMarketingTextRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelMarketingTextRequest) XHotelid(xHotelid string) ChannelApiPutChannelMarketingTextRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing channel marketing texts.
func (r ChannelApiPutChannelMarketingTextRequest) ChannelMarketingTextToChange(channelMarketingTextToChange PutChannelMarketingTextRequest) ChannelApiPutChannelMarketingTextRequest {
	r.channelMarketingTextToChange = &channelMarketingTextToChange
	return r
}

// External system code.
func (r ChannelApiPutChannelMarketingTextRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelMarketingTextRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelMarketingTextRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelMarketingTextRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelMarketingTextRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelMarketingTextExecute(r)
}

/*
PutChannelMarketingText Updates channel marketing messages

Use this API to update channel mapping for marketing messages <p><strong>OperationId:</strong>putChannelMarketingText</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutChannelMarketingTextRequest
*/
func (a *ChannelApiService) PutChannelMarketingText(ctx context.Context) ChannelApiPutChannelMarketingTextRequest {
	return ChannelApiPutChannelMarketingTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelMarketingTextExecute(r ChannelApiPutChannelMarketingTextRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelMarketingText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/marketingText"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelMarketingTextToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelNegotiatedRateRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelNegotiatedRates *PutChannelNegotiatedRateRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelNegotiatedRateRequest) Authorization(authorization string) ChannelApiPutChannelNegotiatedRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelNegotiatedRateRequest) XAppKey(xAppKey string) ChannelApiPutChannelNegotiatedRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelNegotiatedRateRequest) XHotelid(xHotelid string) ChannelApiPutChannelNegotiatedRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Negotiated channel rates.
func (r ChannelApiPutChannelNegotiatedRateRequest) ChannelNegotiatedRates(channelNegotiatedRates PutChannelNegotiatedRateRequest) ChannelApiPutChannelNegotiatedRateRequest {
	r.channelNegotiatedRates = &channelNegotiatedRates
	return r
}

// External system code.
func (r ChannelApiPutChannelNegotiatedRateRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelNegotiatedRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelNegotiatedRateRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelNegotiatedRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelNegotiatedRateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelNegotiatedRateExecute(r)
}

/*
PutChannelNegotiatedRate Updates channel negotiate rate

Use this API to update channel's negotiated rate code mapping including negotiated profile, negotiate rate access code, start date, end date, and sequence. <p><strong>OperationId:</strong>putChannelNegotiatedRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutChannelNegotiatedRateRequest
*/
func (a *ChannelApiService) PutChannelNegotiatedRate(ctx context.Context) ChannelApiPutChannelNegotiatedRateRequest {
	return ChannelApiPutChannelNegotiatedRateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelNegotiatedRateExecute(r ChannelApiPutChannelNegotiatedRateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelNegotiatedRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/negotiatedRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelNegotiatedRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelOrgMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	tenantCode string
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelOrgMapping *PostChannelOrgMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelOrgMappingRequest) Authorization(authorization string) ChannelApiPutChannelOrgMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelOrgMappingRequest) XAppKey(xAppKey string) ChannelApiPutChannelOrgMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelOrgMappingRequest) XHotelid(xHotelid string) ChannelApiPutChannelOrgMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Change Channel to ORG and CRO Mapping.
func (r ChannelApiPutChannelOrgMappingRequest) ChannelOrgMapping(channelOrgMapping PostChannelOrgMappingRequest) ChannelApiPutChannelOrgMappingRequest {
	r.channelOrgMapping = &channelOrgMapping
	return r
}

// External system code.
func (r ChannelApiPutChannelOrgMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelOrgMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelOrgMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelOrgMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelOrgMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelOrgMappingExecute(r)
}

/*
PutChannelOrgMapping Updates channel tenants mapping.

This API changes channel tenants mapping. <p><strong>OperationId:</strong>putChannelOrgMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantCode Tenant Code.
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPutChannelOrgMappingRequest
*/
func (a *ChannelApiService) PutChannelOrgMapping(ctx context.Context, tenantCode string, channelCode string) ChannelApiPutChannelOrgMappingRequest {
	return ChannelApiPutChannelOrgMappingRequest{
		ApiService: a,
		ctx: ctx,
		tenantCode: tenantCode,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelOrgMappingExecute(r ChannelApiPutChannelOrgMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelOrgMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/tenants/{tenantCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantCode"+"}", url.PathEscape(parameterValueToString(r.tenantCode, "tenantCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.tenantCode) < 1 {
		return localVarReturnValue, nil, reportError("tenantCode must have at least 1 elements")
	}
	if strlen(r.tenantCode) > 2000 {
		return localVarReturnValue, nil, reportError("tenantCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelOrgMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelParametersRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeChannelParameters *PutChannelParametersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelParametersRequest) Authorization(authorization string) ChannelApiPutChannelParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelParametersRequest) XAppKey(xAppKey string) ChannelApiPutChannelParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelParametersRequest) XHotelid(xHotelid string) ChannelApiPutChannelParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying channel parameter(s).
func (r ChannelApiPutChannelParametersRequest) ChangeChannelParameters(changeChannelParameters PutChannelParametersRequest) ChannelApiPutChannelParametersRequest {
	r.changeChannelParameters = &changeChannelParameters
	return r
}

// External system code.
func (r ChannelApiPutChannelParametersRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelParametersRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelParametersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelParametersExecute(r)
}

/*
PutChannelParameters Updates channel control settings

Use this API to active/inactive channel controls. It also allows to update channel control settings. <p><strong>OperationId:</strong>putChannelParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPutChannelParametersRequest
*/
func (a *ChannelApiService) PutChannelParameters(ctx context.Context, channelCode string) ChannelApiPutChannelParametersRequest {
	return ChannelApiPutChannelParametersRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelParametersExecute(r ChannelApiPutChannelParametersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/parameters"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeChannelParameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelRateCategoriesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateCategories *PutChannelRateCategoriesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelRateCategoriesRequest) Authorization(authorization string) ChannelApiPutChannelRateCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelRateCategoriesRequest) XAppKey(xAppKey string) ChannelApiPutChannelRateCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelRateCategoriesRequest) XHotelid(xHotelid string) ChannelApiPutChannelRateCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing details of channel rate categories.
func (r ChannelApiPutChannelRateCategoriesRequest) ChannelRateCategories(channelRateCategories PutChannelRateCategoriesRequest) ChannelApiPutChannelRateCategoriesRequest {
	r.channelRateCategories = &channelRateCategories
	return r
}

// External system code.
func (r ChannelApiPutChannelRateCategoriesRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelRateCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelRateCategoriesRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelRateCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelRateCategoriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRateCategoriesExecute(r)
}

/*
PutChannelRateCategories Updates given channel's rate categories

Use this API to update channel rate categories for a given channel. <p><strong>OperationId:</strong>putChannelRateCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPutChannelRateCategoriesRequest
*/
func (a *ChannelApiService) PutChannelRateCategories(ctx context.Context, channelCode string) ChannelApiPutChannelRateCategoriesRequest {
	return ChannelApiPutChannelRateCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRateCategoriesExecute(r ChannelApiPutChannelRateCategoriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRateCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/rateCategories"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateCategories
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelRateLevelsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateLevels *PutChannelRateLevelsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelRateLevelsRequest) Authorization(authorization string) ChannelApiPutChannelRateLevelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelRateLevelsRequest) XAppKey(xAppKey string) ChannelApiPutChannelRateLevelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelRateLevelsRequest) XHotelid(xHotelid string) ChannelApiPutChannelRateLevelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing details of channel rate levels.
func (r ChannelApiPutChannelRateLevelsRequest) ChannelRateLevels(channelRateLevels PutChannelRateLevelsRequest) ChannelApiPutChannelRateLevelsRequest {
	r.channelRateLevels = &channelRateLevels
	return r
}

// External system code.
func (r ChannelApiPutChannelRateLevelsRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelRateLevelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelRateLevelsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelRateLevelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelRateLevelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRateLevelsExecute(r)
}

/*
PutChannelRateLevels Updates channel rate level

Use this API to update channel rate level code's description <p><strong>OperationId:</strong>putChannelRateLevels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPutChannelRateLevelsRequest
*/
func (a *ChannelApiService) PutChannelRateLevels(ctx context.Context, channelCode string) ChannelApiPutChannelRateLevelsRequest {
	return ChannelApiPutChannelRateLevelsRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRateLevelsExecute(r ChannelApiPutChannelRateLevelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRateLevels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/rateLevels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateLevels
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelRateMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateMapping *PutChannelRateMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelRateMappingRequest) Authorization(authorization string) ChannelApiPutChannelRateMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelRateMappingRequest) XAppKey(xAppKey string) ChannelApiPutChannelRateMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelRateMappingRequest) XHotelid(xHotelid string) ChannelApiPutChannelRateMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing channel rate mappings.
func (r ChannelApiPutChannelRateMappingRequest) ChannelRateMapping(channelRateMapping PutChannelRateMappingRequest) ChannelApiPutChannelRateMappingRequest {
	r.channelRateMapping = &channelRateMapping
	return r
}

// External system code.
func (r ChannelApiPutChannelRateMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelRateMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelRateMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelRateMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelRateMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRateMappingExecute(r)
}

/*
PutChannelRateMapping Updates channel property rate mapping

Use this API to update channel property rate mapping including channel rate code, start date, end date, rate level, channel rate description. <p><strong>OperationId:</strong>putChannelRateMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutChannelRateMappingRequest
*/
func (a *ChannelApiService) PutChannelRateMapping(ctx context.Context) ChannelApiPutChannelRateMappingRequest {
	return ChannelApiPutChannelRateMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRateMappingExecute(r ChannelApiPutChannelRateMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRateMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelRateRoomSeqRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRateRoomSequence *PutChannelRateRoomSeqRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelRateRoomSeqRequest) Authorization(authorization string) ChannelApiPutChannelRateRoomSeqRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelRateRoomSeqRequest) XAppKey(xAppKey string) ChannelApiPutChannelRateRoomSeqRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelRateRoomSeqRequest) XHotelid(xHotelid string) ChannelApiPutChannelRateRoomSeqRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing sequence for channel rate rooms.
func (r ChannelApiPutChannelRateRoomSeqRequest) ChannelRateRoomSequence(channelRateRoomSequence PutChannelRateRoomSeqRequest) ChannelApiPutChannelRateRoomSeqRequest {
	r.channelRateRoomSequence = &channelRateRoomSequence
	return r
}

// External system code.
func (r ChannelApiPutChannelRateRoomSeqRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelRateRoomSeqRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelRateRoomSeqRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelRateRoomSeqRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelRateRoomSeqRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRateRoomSeqExecute(r)
}

/*
PutChannelRateRoomSeq Updates channel property rateroom sequence

Use this API to update sequence for given channel property rate room mapping  <p><strong>OperationId:</strong>putChannelRateRoomSeq</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutChannelRateRoomSeqRequest
*/
func (a *ChannelApiService) PutChannelRateRoomSeq(ctx context.Context) ChannelApiPutChannelRateRoomSeqRequest {
	return ChannelApiPutChannelRateRoomSeqRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRateRoomSeqExecute(r ChannelApiPutChannelRateRoomSeqRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRateRoomSeq")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates/roomSequence"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRateRoomSequence
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelRatesGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGlobalDescriptions *PutChannelRatesGlobalDescriptionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelRatesGlobalDescriptionsRequest) Authorization(authorization string) ChannelApiPutChannelRatesGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelRatesGlobalDescriptionsRequest) XAppKey(xAppKey string) ChannelApiPutChannelRatesGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelRatesGlobalDescriptionsRequest) XHotelid(xHotelid string) ChannelApiPutChannelRatesGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to update existing Global Descriptions of the GDS Channels
func (r ChannelApiPutChannelRatesGlobalDescriptionsRequest) ChannelGlobalDescriptions(channelGlobalDescriptions PutChannelRatesGlobalDescriptionsRequest) ChannelApiPutChannelRatesGlobalDescriptionsRequest {
	r.channelGlobalDescriptions = &channelGlobalDescriptions
	return r
}

// External system code.
func (r ChannelApiPutChannelRatesGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelRatesGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelRatesGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelRatesGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelRatesGlobalDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRatesGlobalDescriptionsExecute(r)
}

/*
PutChannelRatesGlobalDescriptions Updates global rate descriptions

Use this API to update global rate description for given hotel id and rate code <p><strong>OperationId:</strong>putChannelRatesGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutChannelRatesGlobalDescriptionsRequest
*/
func (a *ChannelApiService) PutChannelRatesGlobalDescriptions(ctx context.Context) ChannelApiPutChannelRatesGlobalDescriptionsRequest {
	return ChannelApiPutChannelRatesGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRatesGlobalDescriptionsExecute(r ChannelApiPutChannelRatesGlobalDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRatesGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rates/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGlobalDescriptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelRoomMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	roomTypeCode string
	channelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRoomMapping *PutChannelRoomMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelRoomMappingRequest) Authorization(authorization string) ChannelApiPutChannelRoomMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelRoomMappingRequest) XAppKey(xAppKey string) ChannelApiPutChannelRoomMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelRoomMappingRequest) XHotelid(xHotelid string) ChannelApiPutChannelRoomMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Channel Room Mapping.
func (r ChannelApiPutChannelRoomMappingRequest) ChannelRoomMapping(channelRoomMapping PutChannelRoomMappingRequest) ChannelApiPutChannelRoomMappingRequest {
	r.channelRoomMapping = &channelRoomMapping
	return r
}

// External system code.
func (r ChannelApiPutChannelRoomMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelRoomMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelRoomMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelRoomMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelRoomMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRoomMappingExecute(r)
}

/*
PutChannelRoomMapping Updates channel property room mapping

Use this API to update channel room mapping to OPERA hotel's room mapping including channel room type code, start date, end date, room order. <p><strong>OperationId:</strong>putChannelRoomMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeCode Room Type Code.
 @param channelCode Unique ID that identifies a channel.
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiPutChannelRoomMappingRequest
*/
func (a *ChannelApiService) PutChannelRoomMapping(ctx context.Context, roomTypeCode string, channelCode string, hotelId string) ChannelApiPutChannelRoomMappingRequest {
	return ChannelApiPutChannelRoomMappingRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeCode: roomTypeCode,
		channelCode: channelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRoomMappingExecute(r ChannelApiPutChannelRoomMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRoomMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/channels/{channelCode}/rooms/{roomTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeCode"+"}", url.PathEscape(parameterValueToString(r.roomTypeCode, "roomTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have at least 1 elements")
	}
	if strlen(r.roomTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRoomMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelRoomTypesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelRoomTypes *PutChannelRoomTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelRoomTypesRequest) Authorization(authorization string) ChannelApiPutChannelRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelRoomTypesRequest) XAppKey(xAppKey string) ChannelApiPutChannelRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelRoomTypesRequest) XHotelid(xHotelid string) ChannelApiPutChannelRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing details of channel room types.
func (r ChannelApiPutChannelRoomTypesRequest) ChannelRoomTypes(channelRoomTypes PutChannelRoomTypesRequest) ChannelApiPutChannelRoomTypesRequest {
	r.channelRoomTypes = &channelRoomTypes
	return r
}

// External system code.
func (r ChannelApiPutChannelRoomTypesRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelRoomTypesRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelRoomTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRoomTypesExecute(r)
}

/*
PutChannelRoomTypes Updates channel room

Use this API to update channel room description <p><strong>OperationId:</strong>putChannelRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPutChannelRoomTypesRequest
*/
func (a *ChannelApiService) PutChannelRoomTypes(ctx context.Context, channelCode string) ChannelApiPutChannelRoomTypesRequest {
	return ChannelApiPutChannelRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRoomTypesExecute(r ChannelApiPutChannelRoomTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/roomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelRoomTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelRoomsGlobalDescriptionsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGlobalDescriptions *PutChannelRatesGlobalDescriptionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelRoomsGlobalDescriptionsRequest) Authorization(authorization string) ChannelApiPutChannelRoomsGlobalDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelRoomsGlobalDescriptionsRequest) XAppKey(xAppKey string) ChannelApiPutChannelRoomsGlobalDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelRoomsGlobalDescriptionsRequest) XHotelid(xHotelid string) ChannelApiPutChannelRoomsGlobalDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to update existing Global Descriptions of the GDS Channels
func (r ChannelApiPutChannelRoomsGlobalDescriptionsRequest) ChannelGlobalDescriptions(channelGlobalDescriptions PutChannelRatesGlobalDescriptionsRequest) ChannelApiPutChannelRoomsGlobalDescriptionsRequest {
	r.channelGlobalDescriptions = &channelGlobalDescriptions
	return r
}

// External system code.
func (r ChannelApiPutChannelRoomsGlobalDescriptionsRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelRoomsGlobalDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelRoomsGlobalDescriptionsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelRoomsGlobalDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelRoomsGlobalDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelRoomsGlobalDescriptionsExecute(r)
}

/*
PutChannelRoomsGlobalDescriptions Updates global room descriptions

Use this API to update global room description for given hotel id and room type code <p><strong>OperationId:</strong>putChannelRoomsGlobalDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutChannelRoomsGlobalDescriptionsRequest
*/
func (a *ChannelApiService) PutChannelRoomsGlobalDescriptions(ctx context.Context) ChannelApiPutChannelRoomsGlobalDescriptionsRequest {
	return ChannelApiPutChannelRoomsGlobalDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelRoomsGlobalDescriptionsExecute(r ChannelApiPutChannelRoomsGlobalDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannelRoomsGlobalDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms/globalDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGlobalDescriptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutChannelsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channels *PutChannelsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutChannelsRequest) Authorization(authorization string) ChannelApiPutChannelsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutChannelsRequest) XAppKey(xAppKey string) ChannelApiPutChannelsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutChannelsRequest) XHotelid(xHotelid string) ChannelApiPutChannelsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing details of channels.
func (r ChannelApiPutChannelsRequest) Channels(channels PutChannelsRequest) ChannelApiPutChannelsRequest {
	r.channels = &channels
	return r
}

// External system code.
func (r ChannelApiPutChannelsRequest) XExternalsystem(xExternalsystem string) ChannelApiPutChannelsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutChannelsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutChannelsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutChannelsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChannelsExecute(r)
}

/*
PutChannels Update channel configuration

Use this API to update channel configuration <p><strong>OperationId:</strong>putChannels</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutChannelsRequest
*/
func (a *ChannelApiService) PutChannels(ctx context.Context) ChannelApiPutChannelsRequest {
	return ChannelApiPutChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutChannelsExecute(r ChannelApiPutChannelsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channels
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutCreditCardsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	creditCards *PutCreditCardsMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutCreditCardsMappingRequest) Authorization(authorization string) ChannelApiPutCreditCardsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutCreditCardsMappingRequest) XAppKey(xAppKey string) ChannelApiPutCreditCardsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutCreditCardsMappingRequest) XHotelid(xHotelid string) ChannelApiPutCreditCardsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing external system credit cards.
func (r ChannelApiPutCreditCardsMappingRequest) CreditCards(creditCards PutCreditCardsMappingRequest) ChannelApiPutCreditCardsMappingRequest {
	r.creditCards = &creditCards
	return r
}

// External system code.
func (r ChannelApiPutCreditCardsMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPutCreditCardsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutCreditCardsMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutCreditCardsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutCreditCardsMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCreditCardsMappingExecute(r)
}

/*
PutCreditCardsMapping Updates channel credit card mapping

Use this API to update channel credit card code mapping to OPERA credit card code <p><strong>OperationId:</strong>putCreditCardsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutCreditCardsMappingRequest
*/
func (a *ChannelApiService) PutCreditCardsMapping(ctx context.Context) ChannelApiPutCreditCardsMappingRequest {
	return ChannelApiPutCreditCardsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutCreditCardsMappingExecute(r ChannelApiPutCreditCardsMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutCreditCardsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/cardTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditCards
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutCurrenciesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencies *PutCurrenciesMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutCurrenciesMappingRequest) Authorization(authorization string) ChannelApiPutCurrenciesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutCurrenciesMappingRequest) XAppKey(xAppKey string) ChannelApiPutCurrenciesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutCurrenciesMappingRequest) XHotelid(xHotelid string) ChannelApiPutCurrenciesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing external system currencies.
func (r ChannelApiPutCurrenciesMappingRequest) Currencies(currencies PutCurrenciesMappingRequest) ChannelApiPutCurrenciesMappingRequest {
	r.currencies = &currencies
	return r
}

// External system code.
func (r ChannelApiPutCurrenciesMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPutCurrenciesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutCurrenciesMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutCurrenciesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutCurrenciesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCurrenciesMappingExecute(r)
}

/*
PutCurrenciesMapping Updates channel currency code mapping

Use this API to update channel mapping to OPERA currency codes <p><strong>OperationId:</strong>putCurrenciesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutCurrenciesMappingRequest
*/
func (a *ChannelApiService) PutCurrenciesMapping(ctx context.Context) ChannelApiPutCurrenciesMappingRequest {
	return ChannelApiPutCurrenciesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutCurrenciesMappingExecute(r ChannelApiPutCurrenciesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutCurrenciesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.currencies
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutDistributionTemplatesRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	distributionTemplates *PutDistributionTemplatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutDistributionTemplatesRequest) Authorization(authorization string) ChannelApiPutDistributionTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutDistributionTemplatesRequest) XAppKey(xAppKey string) ChannelApiPutDistributionTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutDistributionTemplatesRequest) XHotelid(xHotelid string) ChannelApiPutDistributionTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying chain or property level distribution templates.
func (r ChannelApiPutDistributionTemplatesRequest) DistributionTemplates(distributionTemplates PutDistributionTemplatesRequest) ChannelApiPutDistributionTemplatesRequest {
	r.distributionTemplates = &distributionTemplates
	return r
}

// External system code.
func (r ChannelApiPutDistributionTemplatesRequest) XExternalsystem(xExternalsystem string) ChannelApiPutDistributionTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutDistributionTemplatesRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutDistributionTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutDistributionTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutDistributionTemplatesExecute(r)
}

/*
PutDistributionTemplates Updates rate templates configurations

Use this API to update existing distribution rate template <p><strong>OperationId:</strong>putDistributionTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutDistributionTemplatesRequest
*/
func (a *ChannelApiService) PutDistributionTemplates(ctx context.Context) ChannelApiPutDistributionTemplatesRequest {
	return ChannelApiPutDistributionTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutDistributionTemplatesExecute(r ChannelApiPutDistributionTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutDistributionTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/distributionTemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.distributionTemplates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutGuaranteesMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	guarantees *PutGuaranteesMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutGuaranteesMappingRequest) Authorization(authorization string) ChannelApiPutGuaranteesMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutGuaranteesMappingRequest) XAppKey(xAppKey string) ChannelApiPutGuaranteesMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutGuaranteesMappingRequest) XHotelid(xHotelid string) ChannelApiPutGuaranteesMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing external system guarantees.
func (r ChannelApiPutGuaranteesMappingRequest) Guarantees(guarantees PutGuaranteesMappingRequest) ChannelApiPutGuaranteesMappingRequest {
	r.guarantees = &guarantees
	return r
}

// External system code.
func (r ChannelApiPutGuaranteesMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPutGuaranteesMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutGuaranteesMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutGuaranteesMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutGuaranteesMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutGuaranteesMappingExecute(r)
}

/*
PutGuaranteesMapping Updates channel guarantee code mapping

Use this API to update channel's guarantee codes mapping to OPERA guarantee codes <p><strong>OperationId:</strong>putGuaranteesMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutGuaranteesMappingRequest
*/
func (a *ChannelApiService) PutGuaranteesMapping(ctx context.Context) ChannelApiPutGuaranteesMappingRequest {
	return ChannelApiPutGuaranteesMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutGuaranteesMappingExecute(r ChannelApiPutGuaranteesMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutGuaranteesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/guarantees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guarantees
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutHotelsMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	properties *PutHotelsMappingRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutHotelsMappingRequest) Authorization(authorization string) ChannelApiPutHotelsMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutHotelsMappingRequest) XAppKey(xAppKey string) ChannelApiPutHotelsMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutHotelsMappingRequest) XHotelid(xHotelid string) ChannelApiPutHotelsMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing external system properties.
func (r ChannelApiPutHotelsMappingRequest) Properties(properties PutHotelsMappingRequest) ChannelApiPutHotelsMappingRequest {
	r.properties = &properties
	return r
}

// External system code.
func (r ChannelApiPutHotelsMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiPutHotelsMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutHotelsMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutHotelsMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutHotelsMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutHotelsMappingExecute(r)
}

/*
PutHotelsMapping Updates channel hotel mapping

Use this API to update channel mapping to OPERA hotel id including channel hotel code, room sell limit per reservation, city code, end date <p><strong>OperationId:</strong>putHotelsMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutHotelsMappingRequest
*/
func (a *ChannelApiService) PutHotelsMapping(ctx context.Context) ChannelApiPutHotelsMappingRequest {
	return ChannelApiPutHotelsMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutHotelsMappingExecute(r ChannelApiPutHotelsMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutHotelsMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/hotels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.properties
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutRateGlobalDescriptionRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	channelRateCode string
	channelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGlobalDescription *PutRoomDescriptionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutRateGlobalDescriptionRequest) Authorization(authorization string) ChannelApiPutRateGlobalDescriptionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutRateGlobalDescriptionRequest) XAppKey(xAppKey string) ChannelApiPutRateGlobalDescriptionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutRateGlobalDescriptionRequest) XHotelid(xHotelid string) ChannelApiPutRateGlobalDescriptionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing channel rate codes global description.
func (r ChannelApiPutRateGlobalDescriptionRequest) ChannelGlobalDescription(channelGlobalDescription PutRoomDescriptionRequest) ChannelApiPutRateGlobalDescriptionRequest {
	r.channelGlobalDescription = &channelGlobalDescription
	return r
}

// External system code.
func (r ChannelApiPutRateGlobalDescriptionRequest) XExternalsystem(xExternalsystem string) ChannelApiPutRateGlobalDescriptionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutRateGlobalDescriptionRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutRateGlobalDescriptionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutRateGlobalDescriptionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRateGlobalDescriptionExecute(r)
}

/*
PutRateGlobalDescription Updates global descriptions for a rate

Use this API to update OPERA rate's global description for global distribution type channels <p><strong>OperationId:</strong>putRateGlobalDescription</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelRateCode Channel Rate Code.
 @param channelCode Unique ID that identifies a channel.
 @return ChannelApiPutRateGlobalDescriptionRequest
*/
func (a *ChannelApiService) PutRateGlobalDescription(ctx context.Context, channelRateCode string, channelCode string) ChannelApiPutRateGlobalDescriptionRequest {
	return ChannelApiPutRateGlobalDescriptionRequest{
		ApiService: a,
		ctx: ctx,
		channelRateCode: channelRateCode,
		channelCode: channelCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutRateGlobalDescriptionExecute(r ChannelApiPutRateGlobalDescriptionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutRateGlobalDescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channelCode}/rates/{channelRateCode}/globalDescription"
	localVarPath = strings.Replace(localVarPath, "{"+"channelRateCode"+"}", url.PathEscape(parameterValueToString(r.channelRateCode, "channelRateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelRateCode) < 1 {
		return localVarReturnValue, nil, reportError("channelRateCode must have at least 1 elements")
	}
	if strlen(r.channelRateCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelRateCode must have less than 2000 elements")
	}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGlobalDescription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutRoomDescriptionRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	channelGlobalDescription *PutRoomDescriptionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutRoomDescriptionRequest) Authorization(authorization string) ChannelApiPutRoomDescriptionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutRoomDescriptionRequest) XAppKey(xAppKey string) ChannelApiPutRoomDescriptionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutRoomDescriptionRequest) XHotelid(xHotelid string) ChannelApiPutRoomDescriptionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Room Mapping description.
func (r ChannelApiPutRoomDescriptionRequest) ChannelGlobalDescription(channelGlobalDescription PutRoomDescriptionRequest) ChannelApiPutRoomDescriptionRequest {
	r.channelGlobalDescription = &channelGlobalDescription
	return r
}

// External system code.
func (r ChannelApiPutRoomDescriptionRequest) XExternalsystem(xExternalsystem string) ChannelApiPutRoomDescriptionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutRoomDescriptionRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutRoomDescriptionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutRoomDescriptionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoomDescriptionExecute(r)
}

/*
PutRoomDescription Update global descriptions for a room

Use this API to update OPERA room's global description for global distribution type channels <p><strong>OperationId:</strong>putRoomDescription</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutRoomDescriptionRequest
*/
func (a *ChannelApiService) PutRoomDescription(ctx context.Context) ChannelApiPutRoomDescriptionRequest {
	return ChannelApiPutRoomDescriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutRoomDescriptionExecute(r ChannelApiPutRoomDescriptionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutRoomDescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/rooms/globalDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.channelGlobalDescription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChannelApiPutTotalPricingElementsRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	totalPricingElements *PutTotalPricingElementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiPutTotalPricingElementsRequest) Authorization(authorization string) ChannelApiPutTotalPricingElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChannelApiPutTotalPricingElementsRequest) XAppKey(xAppKey string) ChannelApiPutTotalPricingElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiPutTotalPricingElementsRequest) XHotelid(xHotelid string) ChannelApiPutTotalPricingElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change the total pricing elements of GDS channel.
func (r ChannelApiPutTotalPricingElementsRequest) TotalPricingElements(totalPricingElements PutTotalPricingElementsRequest) ChannelApiPutTotalPricingElementsRequest {
	r.totalPricingElements = &totalPricingElements
	return r
}

// External system code.
func (r ChannelApiPutTotalPricingElementsRequest) XExternalsystem(xExternalsystem string) ChannelApiPutTotalPricingElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiPutTotalPricingElementsRequest) AcceptLanguage(acceptLanguage string) ChannelApiPutTotalPricingElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiPutTotalPricingElementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTotalPricingElementsExecute(r)
}

/*
PutTotalPricingElements Updates total pricing tax and fee types

Use this API to update global distribution channels tax and fee configurations <p><strong>OperationId:</strong>putTotalPricingElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChannelApiPutTotalPricingElementsRequest
*/
func (a *ChannelApiService) PutTotalPricingElements(ctx context.Context) ChannelApiPutTotalPricingElementsRequest {
	return ChannelApiPutTotalPricingElementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChannelApiService) PutTotalPricingElementsExecute(r ChannelApiPutTotalPricingElementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.PutTotalPricingElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/totalPricing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.totalPricingElements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
