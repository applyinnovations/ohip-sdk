/*
OPERA Cloud Channel Configuration API

APIs to cater for Channel Management functionality in OPERA Cloud. <br /><br /> Channel Management allows a property to configure and administer channels such as OTAs, and web channels, covering functionality such as channel configuration, availability, inventory and restrictions.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package chl

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ChannelApiService ChannelApi service
type ChannelApiService service

type ChannelApiGetChannelRoomMappingRequest struct {
	ctx context.Context
	ApiService *ChannelApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	bookingChannelCodes *[]string
	roomTypes *[]string
	channelRoomTypes *[]string
	includeInactiveMappings *bool
	includeUnmappedRoomTypes *bool
	onlyUnmappedRoomTypes *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChannelApiGetChannelRoomMappingRequest) Authorization(authorization string) ChannelApiGetChannelRoomMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ChannelApiGetChannelRoomMappingRequest) XAppKey(xAppKey string) ChannelApiGetChannelRoomMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChannelApiGetChannelRoomMappingRequest) XHotelid(xHotelid string) ChannelApiGetChannelRoomMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChannelApiGetChannelRoomMappingRequest) Limit(limit int32) ChannelApiGetChannelRoomMappingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChannelApiGetChannelRoomMappingRequest) Offset(offset int32) ChannelApiGetChannelRoomMappingRequest {
	r.offset = &offset
	return r
}

func (r ChannelApiGetChannelRoomMappingRequest) BookingChannelCodes(bookingChannelCodes []string) ChannelApiGetChannelRoomMappingRequest {
	r.bookingChannelCodes = &bookingChannelCodes
	return r
}

func (r ChannelApiGetChannelRoomMappingRequest) RoomTypes(roomTypes []string) ChannelApiGetChannelRoomMappingRequest {
	r.roomTypes = &roomTypes
	return r
}

func (r ChannelApiGetChannelRoomMappingRequest) ChannelRoomTypes(channelRoomTypes []string) ChannelApiGetChannelRoomMappingRequest {
	r.channelRoomTypes = &channelRoomTypes
	return r
}

// Flag whether to include inactive mappings or not.
func (r ChannelApiGetChannelRoomMappingRequest) IncludeInactiveMappings(includeInactiveMappings bool) ChannelApiGetChannelRoomMappingRequest {
	r.includeInactiveMappings = &includeInactiveMappings
	return r
}

// Flag whether to include unmapped room types or not.
func (r ChannelApiGetChannelRoomMappingRequest) IncludeUnmappedRoomTypes(includeUnmappedRoomTypes bool) ChannelApiGetChannelRoomMappingRequest {
	r.includeUnmappedRoomTypes = &includeUnmappedRoomTypes
	return r
}

// Flag whether to include mapped room types only.
func (r ChannelApiGetChannelRoomMappingRequest) OnlyUnmappedRoomTypes(onlyUnmappedRoomTypes bool) ChannelApiGetChannelRoomMappingRequest {
	r.onlyUnmappedRoomTypes = &onlyUnmappedRoomTypes
	return r
}

// External system code.
func (r ChannelApiGetChannelRoomMappingRequest) XExternalsystem(xExternalsystem string) ChannelApiGetChannelRoomMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChannelApiGetChannelRoomMappingRequest) AcceptLanguage(acceptLanguage string) ChannelApiGetChannelRoomMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChannelApiGetChannelRoomMappingRequest) Execute() (*ChannelRoomMappingsSummary, *http.Response, error) {
	return r.ApiService.GetChannelRoomMappingExecute(r)
}

/*
GetChannelRoomMapping Gets channel property room mapping

Use this API to get channel room mapping to OPERA hotel's room mapping including channel room type code, start date, end date, room order. <p><strong>OperationId:</strong>getChannelRoomMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return ChannelApiGetChannelRoomMappingRequest
*/
func (a *ChannelApiService) GetChannelRoomMapping(ctx context.Context, hotelId string) ChannelApiGetChannelRoomMappingRequest {
	return ChannelApiGetChannelRoomMappingRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChannelRoomMappingsSummary
func (a *ChannelApiService) GetChannelRoomMappingExecute(r ChannelApiGetChannelRoomMappingRequest) (*ChannelRoomMappingsSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelRoomMappingsSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChannelApiService.GetChannelRoomMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/mapping"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.bookingChannelCodes != nil {
		t := *r.bookingChannelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCodes", t, "multi")
		}
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.channelRoomTypes != nil {
		t := *r.channelRoomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelRoomTypes", t, "multi")
		}
	}
	if r.includeInactiveMappings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveMappings", r.includeInactiveMappings, "")
	}
	if r.includeUnmappedRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUnmappedRoomTypes", r.includeUnmappedRoomTypes, "")
	}
	if r.onlyUnmappedRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyUnmappedRoomTypes", r.onlyUnmappedRoomTypes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
