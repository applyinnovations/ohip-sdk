/*
OPERA Cloud Front Desk Configuration API

APIs to cater for Front Desk Configuration in OPERA Cloud. Here you can find operations to get, post, put and delete front desk codes such as commission codes, transaction groups, codes & subgroups, articles, payment methods and credit card types.<br /><br /> Compatible with OPERA Cloud release 24.4.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2024 Oracle and/or its affiliates.</p>

API version: 24.4
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fofcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HotelConfigAPIService HotelConfigAPI service
type HotelConfigAPIService service

type HotelConfigAPIChangeTrackItActionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	actionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	trackItActionsToBeChanged *TrackItActionsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIChangeTrackItActionsRequest) Authorization(authorization string) HotelConfigAPIChangeTrackItActionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIChangeTrackItActionsRequest) XAppKey(xAppKey string) HotelConfigAPIChangeTrackItActionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIChangeTrackItActionsRequest) XHotelid(xHotelid string) HotelConfigAPIChangeTrackItActionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Track it Actions.
func (r HotelConfigAPIChangeTrackItActionsRequest) TrackItActionsToBeChanged(trackItActionsToBeChanged TrackItActionsToBeChanged) HotelConfigAPIChangeTrackItActionsRequest {
	r.trackItActionsToBeChanged = &trackItActionsToBeChanged
	return r
}

// External system code.
func (r HotelConfigAPIChangeTrackItActionsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIChangeTrackItActionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIChangeTrackItActionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIChangeTrackItActionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIChangeTrackItActionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeTrackItActionsExecute(r)
}

/*
ChangeTrackItActions Change Track it Actions

Use this API to update Track it Actions. <p><strong>OperationId:</strong>changeTrackItActions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionCode Unique Code of action.
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIChangeTrackItActionsRequest
*/
func (a *HotelConfigAPIService) ChangeTrackItActions(ctx context.Context, actionCode string, hotelId string) HotelConfigAPIChangeTrackItActionsRequest {
	return HotelConfigAPIChangeTrackItActionsRequest{
		ApiService: a,
		ctx: ctx,
		actionCode: actionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) ChangeTrackItActionsExecute(r HotelConfigAPIChangeTrackItActionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.ChangeTrackItActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItActions/{actionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionCode"+"}", url.PathEscape(parameterValueToString(r.actionCode, "actionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.actionCode) < 1 {
		return localVarReturnValue, nil, reportError("actionCode must have at least 1 elements")
	}
	if strlen(r.actionCode) > 2000 {
		return localVarReturnValue, nil, reportError("actionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.trackItActionsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIChangeTrackItLocationsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	locationCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	trackItLocationsToBeChanged *TrackItLocationsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIChangeTrackItLocationsRequest) Authorization(authorization string) HotelConfigAPIChangeTrackItLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIChangeTrackItLocationsRequest) XAppKey(xAppKey string) HotelConfigAPIChangeTrackItLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIChangeTrackItLocationsRequest) XHotelid(xHotelid string) HotelConfigAPIChangeTrackItLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Track it Locations.
func (r HotelConfigAPIChangeTrackItLocationsRequest) TrackItLocationsToBeChanged(trackItLocationsToBeChanged TrackItLocationsToBeChanged) HotelConfigAPIChangeTrackItLocationsRequest {
	r.trackItLocationsToBeChanged = &trackItLocationsToBeChanged
	return r
}

// External system code.
func (r HotelConfigAPIChangeTrackItLocationsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIChangeTrackItLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIChangeTrackItLocationsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIChangeTrackItLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIChangeTrackItLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeTrackItLocationsExecute(r)
}

/*
ChangeTrackItLocations Change Track it Locations

Use this API to update Track it Locations. <p><strong>OperationId:</strong>changeTrackItLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locationCode Unique Code of location.
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIChangeTrackItLocationsRequest
*/
func (a *HotelConfigAPIService) ChangeTrackItLocations(ctx context.Context, locationCode string, hotelId string) HotelConfigAPIChangeTrackItLocationsRequest {
	return HotelConfigAPIChangeTrackItLocationsRequest{
		ApiService: a,
		ctx: ctx,
		locationCode: locationCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) ChangeTrackItLocationsExecute(r HotelConfigAPIChangeTrackItLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.ChangeTrackItLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItLocations/{locationCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"locationCode"+"}", url.PathEscape(parameterValueToString(r.locationCode, "locationCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.locationCode) < 1 {
		return localVarReturnValue, nil, reportError("locationCode must have at least 1 elements")
	}
	if strlen(r.locationCode) > 2000 {
		return localVarReturnValue, nil, reportError("locationCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.trackItLocationsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIChangeTrackItTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	typeCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	trackItTypesToBeChanged *TrackItTypesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIChangeTrackItTypesRequest) Authorization(authorization string) HotelConfigAPIChangeTrackItTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIChangeTrackItTypesRequest) XAppKey(xAppKey string) HotelConfigAPIChangeTrackItTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIChangeTrackItTypesRequest) XHotelid(xHotelid string) HotelConfigAPIChangeTrackItTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Track it Types.
func (r HotelConfigAPIChangeTrackItTypesRequest) TrackItTypesToBeChanged(trackItTypesToBeChanged TrackItTypesToBeChanged) HotelConfigAPIChangeTrackItTypesRequest {
	r.trackItTypesToBeChanged = &trackItTypesToBeChanged
	return r
}

// External system code.
func (r HotelConfigAPIChangeTrackItTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIChangeTrackItTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIChangeTrackItTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIChangeTrackItTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIChangeTrackItTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeTrackItTypesExecute(r)
}

/*
ChangeTrackItTypes Change Track it Types

Use this API to update Track it Types. <p><strong>OperationId:</strong>changeTrackItTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeCode Unique Code of track it type.
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIChangeTrackItTypesRequest
*/
func (a *HotelConfigAPIService) ChangeTrackItTypes(ctx context.Context, typeCode string, hotelId string) HotelConfigAPIChangeTrackItTypesRequest {
	return HotelConfigAPIChangeTrackItTypesRequest{
		ApiService: a,
		ctx: ctx,
		typeCode: typeCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) ChangeTrackItTypesExecute(r HotelConfigAPIChangeTrackItTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.ChangeTrackItTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItTypes/{typeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"typeCode"+"}", url.PathEscape(parameterValueToString(r.typeCode, "typeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.typeCode) < 1 {
		return localVarReturnValue, nil, reportError("typeCode must have at least 1 elements")
	}
	if strlen(r.typeCode) > 2000 {
		return localVarReturnValue, nil, reportError("typeCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.trackItTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPICopyTrackItActionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	sourceHotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyTrackItActions *CopyTrackItActions
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPICopyTrackItActionsRequest) Authorization(authorization string) HotelConfigAPICopyTrackItActionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPICopyTrackItActionsRequest) XAppKey(xAppKey string) HotelConfigAPICopyTrackItActionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPICopyTrackItActionsRequest) XHotelid(xHotelid string) HotelConfigAPICopyTrackItActionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of Track it Actions to be copied.
func (r HotelConfigAPICopyTrackItActionsRequest) CopyTrackItActions(copyTrackItActions CopyTrackItActions) HotelConfigAPICopyTrackItActionsRequest {
	r.copyTrackItActions = &copyTrackItActions
	return r
}

// External system code.
func (r HotelConfigAPICopyTrackItActionsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPICopyTrackItActionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPICopyTrackItActionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPICopyTrackItActionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPICopyTrackItActionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyTrackItActionsExecute(r)
}

/*
CopyTrackItActions  Copy Track it Actions

Copy Track it Actions. <p><strong>OperationId:</strong>copyTrackItActions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceHotelId Unique ID of source hotel.
 @return HotelConfigAPICopyTrackItActionsRequest
*/
func (a *HotelConfigAPIService) CopyTrackItActions(ctx context.Context, sourceHotelId string) HotelConfigAPICopyTrackItActionsRequest {
	return HotelConfigAPICopyTrackItActionsRequest{
		ApiService: a,
		ctx: ctx,
		sourceHotelId: sourceHotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) CopyTrackItActionsExecute(r HotelConfigAPICopyTrackItActionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.CopyTrackItActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{sourceHotelId}/trackItActions/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceHotelId"+"}", url.PathEscape(parameterValueToString(r.sourceHotelId, "sourceHotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceHotelId) < 1 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have at least 1 elements")
	}
	if strlen(r.sourceHotelId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyTrackItActions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPICopyTrackItLocationsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	sourceHotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyTrackItLocations *CopyTrackItLocations
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPICopyTrackItLocationsRequest) Authorization(authorization string) HotelConfigAPICopyTrackItLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPICopyTrackItLocationsRequest) XAppKey(xAppKey string) HotelConfigAPICopyTrackItLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPICopyTrackItLocationsRequest) XHotelid(xHotelid string) HotelConfigAPICopyTrackItLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of Track it Locations to be copied.
func (r HotelConfigAPICopyTrackItLocationsRequest) CopyTrackItLocations(copyTrackItLocations CopyTrackItLocations) HotelConfigAPICopyTrackItLocationsRequest {
	r.copyTrackItLocations = &copyTrackItLocations
	return r
}

// External system code.
func (r HotelConfigAPICopyTrackItLocationsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPICopyTrackItLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPICopyTrackItLocationsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPICopyTrackItLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPICopyTrackItLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyTrackItLocationsExecute(r)
}

/*
CopyTrackItLocations  Copy Track it Locations

Copy Track it Locations. <p><strong>OperationId:</strong>copyTrackItLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceHotelId Unique ID of source hotel.
 @return HotelConfigAPICopyTrackItLocationsRequest
*/
func (a *HotelConfigAPIService) CopyTrackItLocations(ctx context.Context, sourceHotelId string) HotelConfigAPICopyTrackItLocationsRequest {
	return HotelConfigAPICopyTrackItLocationsRequest{
		ApiService: a,
		ctx: ctx,
		sourceHotelId: sourceHotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) CopyTrackItLocationsExecute(r HotelConfigAPICopyTrackItLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.CopyTrackItLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{sourceHotelId}/trackItLocations/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceHotelId"+"}", url.PathEscape(parameterValueToString(r.sourceHotelId, "sourceHotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceHotelId) < 1 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have at least 1 elements")
	}
	if strlen(r.sourceHotelId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyTrackItLocations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPICopyTrackItTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	sourceHotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyTrackItTypes *CopyTrackItTypes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPICopyTrackItTypesRequest) Authorization(authorization string) HotelConfigAPICopyTrackItTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPICopyTrackItTypesRequest) XAppKey(xAppKey string) HotelConfigAPICopyTrackItTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPICopyTrackItTypesRequest) XHotelid(xHotelid string) HotelConfigAPICopyTrackItTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of Track it Types to be copied.
func (r HotelConfigAPICopyTrackItTypesRequest) CopyTrackItTypes(copyTrackItTypes CopyTrackItTypes) HotelConfigAPICopyTrackItTypesRequest {
	r.copyTrackItTypes = &copyTrackItTypes
	return r
}

// External system code.
func (r HotelConfigAPICopyTrackItTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPICopyTrackItTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPICopyTrackItTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPICopyTrackItTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPICopyTrackItTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyTrackItTypesExecute(r)
}

/*
CopyTrackItTypes  Copy Track it Types

Copy Track it Types. <p><strong>OperationId:</strong>copyTrackItTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceHotelId Unique ID of source hotel.
 @return HotelConfigAPICopyTrackItTypesRequest
*/
func (a *HotelConfigAPIService) CopyTrackItTypes(ctx context.Context, sourceHotelId string) HotelConfigAPICopyTrackItTypesRequest {
	return HotelConfigAPICopyTrackItTypesRequest{
		ApiService: a,
		ctx: ctx,
		sourceHotelId: sourceHotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) CopyTrackItTypesExecute(r HotelConfigAPICopyTrackItTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.CopyTrackItTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{sourceHotelId}/trackItTypes/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceHotelId"+"}", url.PathEscape(parameterValueToString(r.sourceHotelId, "sourceHotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceHotelId) < 1 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have at least 1 elements")
	}
	if strlen(r.sourceHotelId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyTrackItTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIGetTrackItActionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	codes *[]string
	wildCard *string
	showInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIGetTrackItActionsRequest) Authorization(authorization string) HotelConfigAPIGetTrackItActionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIGetTrackItActionsRequest) XAppKey(xAppKey string) HotelConfigAPIGetTrackItActionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIGetTrackItActionsRequest) XHotelid(xHotelid string) HotelConfigAPIGetTrackItActionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r HotelConfigAPIGetTrackItActionsRequest) HotelIds(hotelIds []string) HotelConfigAPIGetTrackItActionsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Codes to be searched.
func (r HotelConfigAPIGetTrackItActionsRequest) Codes(codes []string) HotelConfigAPIGetTrackItActionsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r HotelConfigAPIGetTrackItActionsRequest) WildCard(wildCard string) HotelConfigAPIGetTrackItActionsRequest {
	r.wildCard = &wildCard
	return r
}

// If true this boolean will set the criteria to only return Inactive records.
func (r HotelConfigAPIGetTrackItActionsRequest) ShowInactive(showInactive bool) HotelConfigAPIGetTrackItActionsRequest {
	r.showInactive = &showInactive
	return r
}

// External system code.
func (r HotelConfigAPIGetTrackItActionsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIGetTrackItActionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIGetTrackItActionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIGetTrackItActionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIGetTrackItActionsRequest) Execute() (*TrackItActionsDetails, *http.Response, error) {
	return r.ApiService.GetTrackItActionsExecute(r)
}

/*
GetTrackItActions Get Track it Actions

Use this API to get Track it Actions. <p><strong>OperationId:</strong>getTrackItActions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIGetTrackItActionsRequest
*/
func (a *HotelConfigAPIService) GetTrackItActions(ctx context.Context, hotelId string) HotelConfigAPIGetTrackItActionsRequest {
	return HotelConfigAPIGetTrackItActionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TrackItActionsDetails
func (a *HotelConfigAPIService) GetTrackItActionsExecute(r HotelConfigAPIGetTrackItActionsRequest) (*TrackItActionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackItActionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.GetTrackItActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItActions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.showInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showInactive", r.showInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIGetTrackItLocationsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	codes *[]string
	wildCard *string
	showInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIGetTrackItLocationsRequest) Authorization(authorization string) HotelConfigAPIGetTrackItLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIGetTrackItLocationsRequest) XAppKey(xAppKey string) HotelConfigAPIGetTrackItLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIGetTrackItLocationsRequest) XHotelid(xHotelid string) HotelConfigAPIGetTrackItLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r HotelConfigAPIGetTrackItLocationsRequest) HotelIds(hotelIds []string) HotelConfigAPIGetTrackItLocationsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Codes to be searched.
func (r HotelConfigAPIGetTrackItLocationsRequest) Codes(codes []string) HotelConfigAPIGetTrackItLocationsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r HotelConfigAPIGetTrackItLocationsRequest) WildCard(wildCard string) HotelConfigAPIGetTrackItLocationsRequest {
	r.wildCard = &wildCard
	return r
}

// If true this boolean will set the criteria to only return Inactive records.
func (r HotelConfigAPIGetTrackItLocationsRequest) ShowInactive(showInactive bool) HotelConfigAPIGetTrackItLocationsRequest {
	r.showInactive = &showInactive
	return r
}

// External system code.
func (r HotelConfigAPIGetTrackItLocationsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIGetTrackItLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIGetTrackItLocationsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIGetTrackItLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIGetTrackItLocationsRequest) Execute() (*TrackItLocationsDetails, *http.Response, error) {
	return r.ApiService.GetTrackItLocationsExecute(r)
}

/*
GetTrackItLocations Get Track it Locations

Use this API to get Track it Locations. <p><strong>OperationId:</strong>getTrackItLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIGetTrackItLocationsRequest
*/
func (a *HotelConfigAPIService) GetTrackItLocations(ctx context.Context, hotelId string) HotelConfigAPIGetTrackItLocationsRequest {
	return HotelConfigAPIGetTrackItLocationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TrackItLocationsDetails
func (a *HotelConfigAPIService) GetTrackItLocationsExecute(r HotelConfigAPIGetTrackItLocationsRequest) (*TrackItLocationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackItLocationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.GetTrackItLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItLocations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.showInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showInactive", r.showInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIGetTrackItTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	codes *[]string
	wildCard *string
	showInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIGetTrackItTypesRequest) Authorization(authorization string) HotelConfigAPIGetTrackItTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIGetTrackItTypesRequest) XAppKey(xAppKey string) HotelConfigAPIGetTrackItTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIGetTrackItTypesRequest) XHotelid(xHotelid string) HotelConfigAPIGetTrackItTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r HotelConfigAPIGetTrackItTypesRequest) HotelIds(hotelIds []string) HotelConfigAPIGetTrackItTypesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Codes to be searched.
func (r HotelConfigAPIGetTrackItTypesRequest) Codes(codes []string) HotelConfigAPIGetTrackItTypesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r HotelConfigAPIGetTrackItTypesRequest) WildCard(wildCard string) HotelConfigAPIGetTrackItTypesRequest {
	r.wildCard = &wildCard
	return r
}

// If true this boolean will set the criteria to only return Inactive records.
func (r HotelConfigAPIGetTrackItTypesRequest) ShowInactive(showInactive bool) HotelConfigAPIGetTrackItTypesRequest {
	r.showInactive = &showInactive
	return r
}

// External system code.
func (r HotelConfigAPIGetTrackItTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIGetTrackItTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIGetTrackItTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIGetTrackItTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIGetTrackItTypesRequest) Execute() (*TrackItTypesDetails, *http.Response, error) {
	return r.ApiService.GetTrackItTypesExecute(r)
}

/*
GetTrackItTypes Get Track it Types

Use this API to get Track it Types. <p><strong>OperationId:</strong>getTrackItTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIGetTrackItTypesRequest
*/
func (a *HotelConfigAPIService) GetTrackItTypes(ctx context.Context, hotelId string) HotelConfigAPIGetTrackItTypesRequest {
	return HotelConfigAPIGetTrackItTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TrackItTypesDetails
func (a *HotelConfigAPIService) GetTrackItTypesExecute(r HotelConfigAPIGetTrackItTypesRequest) (*TrackItTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackItTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.GetTrackItTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.showInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showInactive", r.showInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIPostTrackItActionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	trackItActionsCriteria *TrackItActionsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIPostTrackItActionsRequest) Authorization(authorization string) HotelConfigAPIPostTrackItActionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIPostTrackItActionsRequest) XAppKey(xAppKey string) HotelConfigAPIPostTrackItActionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIPostTrackItActionsRequest) XHotelid(xHotelid string) HotelConfigAPIPostTrackItActionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Track it Actions.
func (r HotelConfigAPIPostTrackItActionsRequest) TrackItActionsCriteria(trackItActionsCriteria TrackItActionsCriteria) HotelConfigAPIPostTrackItActionsRequest {
	r.trackItActionsCriteria = &trackItActionsCriteria
	return r
}

// External system code.
func (r HotelConfigAPIPostTrackItActionsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIPostTrackItActionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIPostTrackItActionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIPostTrackItActionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIPostTrackItActionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTrackItActionsExecute(r)
}

/*
PostTrackItActions Create Track it Actions

Use this API to create Track it Actions. <p><strong>OperationId:</strong>postTrackItActions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIPostTrackItActionsRequest
*/
func (a *HotelConfigAPIService) PostTrackItActions(ctx context.Context, hotelId string) HotelConfigAPIPostTrackItActionsRequest {
	return HotelConfigAPIPostTrackItActionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) PostTrackItActionsExecute(r HotelConfigAPIPostTrackItActionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.PostTrackItActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItActions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.trackItActionsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIPostTrackItLocationsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	trackItLocationsCriteria *TrackItLocationsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIPostTrackItLocationsRequest) Authorization(authorization string) HotelConfigAPIPostTrackItLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIPostTrackItLocationsRequest) XAppKey(xAppKey string) HotelConfigAPIPostTrackItLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIPostTrackItLocationsRequest) XHotelid(xHotelid string) HotelConfigAPIPostTrackItLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Track it Locations.
func (r HotelConfigAPIPostTrackItLocationsRequest) TrackItLocationsCriteria(trackItLocationsCriteria TrackItLocationsCriteria) HotelConfigAPIPostTrackItLocationsRequest {
	r.trackItLocationsCriteria = &trackItLocationsCriteria
	return r
}

// External system code.
func (r HotelConfigAPIPostTrackItLocationsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIPostTrackItLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIPostTrackItLocationsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIPostTrackItLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIPostTrackItLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTrackItLocationsExecute(r)
}

/*
PostTrackItLocations Create Track it Locations

Use this API to create Track it Locations. <p><strong>OperationId:</strong>postTrackItLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIPostTrackItLocationsRequest
*/
func (a *HotelConfigAPIService) PostTrackItLocations(ctx context.Context, hotelId string) HotelConfigAPIPostTrackItLocationsRequest {
	return HotelConfigAPIPostTrackItLocationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) PostTrackItLocationsExecute(r HotelConfigAPIPostTrackItLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.PostTrackItLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItLocations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.trackItLocationsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIPostTrackItTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	trackItTypesCriteria *TrackItTypesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIPostTrackItTypesRequest) Authorization(authorization string) HotelConfigAPIPostTrackItTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIPostTrackItTypesRequest) XAppKey(xAppKey string) HotelConfigAPIPostTrackItTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIPostTrackItTypesRequest) XHotelid(xHotelid string) HotelConfigAPIPostTrackItTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Track it Types.
func (r HotelConfigAPIPostTrackItTypesRequest) TrackItTypesCriteria(trackItTypesCriteria TrackItTypesCriteria) HotelConfigAPIPostTrackItTypesRequest {
	r.trackItTypesCriteria = &trackItTypesCriteria
	return r
}

// External system code.
func (r HotelConfigAPIPostTrackItTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIPostTrackItTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIPostTrackItTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIPostTrackItTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIPostTrackItTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTrackItTypesExecute(r)
}

/*
PostTrackItTypes Create Track it Types

Use this API to create Track it Types. <p><strong>OperationId:</strong>postTrackItTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIPostTrackItTypesRequest
*/
func (a *HotelConfigAPIService) PostTrackItTypes(ctx context.Context, hotelId string) HotelConfigAPIPostTrackItTypesRequest {
	return HotelConfigAPIPostTrackItTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) PostTrackItTypesExecute(r HotelConfigAPIPostTrackItTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.PostTrackItTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.trackItTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIRemoveTrackItActionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	actionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIRemoveTrackItActionsRequest) Authorization(authorization string) HotelConfigAPIRemoveTrackItActionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIRemoveTrackItActionsRequest) XAppKey(xAppKey string) HotelConfigAPIRemoveTrackItActionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIRemoveTrackItActionsRequest) XHotelid(xHotelid string) HotelConfigAPIRemoveTrackItActionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigAPIRemoveTrackItActionsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIRemoveTrackItActionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIRemoveTrackItActionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIRemoveTrackItActionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIRemoveTrackItActionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveTrackItActionsExecute(r)
}

/*
RemoveTrackItActions Delete Track it Actions

Use this API to delete Track it Actions. <p><strong>OperationId:</strong>removeTrackItActions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionCode Unique Code of action.
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIRemoveTrackItActionsRequest
*/
func (a *HotelConfigAPIService) RemoveTrackItActions(ctx context.Context, actionCode string, hotelId string) HotelConfigAPIRemoveTrackItActionsRequest {
	return HotelConfigAPIRemoveTrackItActionsRequest{
		ApiService: a,
		ctx: ctx,
		actionCode: actionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) RemoveTrackItActionsExecute(r HotelConfigAPIRemoveTrackItActionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.RemoveTrackItActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItActions/{actionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionCode"+"}", url.PathEscape(parameterValueToString(r.actionCode, "actionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.actionCode) < 1 {
		return localVarReturnValue, nil, reportError("actionCode must have at least 1 elements")
	}
	if strlen(r.actionCode) > 2000 {
		return localVarReturnValue, nil, reportError("actionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIRemoveTrackItLocationsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	locationCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIRemoveTrackItLocationsRequest) Authorization(authorization string) HotelConfigAPIRemoveTrackItLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIRemoveTrackItLocationsRequest) XAppKey(xAppKey string) HotelConfigAPIRemoveTrackItLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIRemoveTrackItLocationsRequest) XHotelid(xHotelid string) HotelConfigAPIRemoveTrackItLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigAPIRemoveTrackItLocationsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIRemoveTrackItLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIRemoveTrackItLocationsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIRemoveTrackItLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIRemoveTrackItLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveTrackItLocationsExecute(r)
}

/*
RemoveTrackItLocations Delete Track it Locations

Use this API to delete Track it Locations. <p><strong>OperationId:</strong>removeTrackItLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locationCode Unique Code of location.
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIRemoveTrackItLocationsRequest
*/
func (a *HotelConfigAPIService) RemoveTrackItLocations(ctx context.Context, locationCode string, hotelId string) HotelConfigAPIRemoveTrackItLocationsRequest {
	return HotelConfigAPIRemoveTrackItLocationsRequest{
		ApiService: a,
		ctx: ctx,
		locationCode: locationCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) RemoveTrackItLocationsExecute(r HotelConfigAPIRemoveTrackItLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.RemoveTrackItLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItLocations/{locationCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"locationCode"+"}", url.PathEscape(parameterValueToString(r.locationCode, "locationCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.locationCode) < 1 {
		return localVarReturnValue, nil, reportError("locationCode must have at least 1 elements")
	}
	if strlen(r.locationCode) > 2000 {
		return localVarReturnValue, nil, reportError("locationCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIRemoveTrackItTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	typeCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIRemoveTrackItTypesRequest) Authorization(authorization string) HotelConfigAPIRemoveTrackItTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIRemoveTrackItTypesRequest) XAppKey(xAppKey string) HotelConfigAPIRemoveTrackItTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIRemoveTrackItTypesRequest) XHotelid(xHotelid string) HotelConfigAPIRemoveTrackItTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigAPIRemoveTrackItTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIRemoveTrackItTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIRemoveTrackItTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIRemoveTrackItTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIRemoveTrackItTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveTrackItTypesExecute(r)
}

/*
RemoveTrackItTypes Delete Track it Types

Use this API to delete Track it Types. <p><strong>OperationId:</strong>removeTrackItTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeCode Unique Code of track it type.
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIRemoveTrackItTypesRequest
*/
func (a *HotelConfigAPIService) RemoveTrackItTypes(ctx context.Context, typeCode string, hotelId string) HotelConfigAPIRemoveTrackItTypesRequest {
	return HotelConfigAPIRemoveTrackItTypesRequest{
		ApiService: a,
		ctx: ctx,
		typeCode: typeCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) RemoveTrackItTypesExecute(r HotelConfigAPIRemoveTrackItTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.RemoveTrackItTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItTypes/{typeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"typeCode"+"}", url.PathEscape(parameterValueToString(r.typeCode, "typeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.typeCode) < 1 {
		return localVarReturnValue, nil, reportError("typeCode must have at least 1 elements")
	}
	if strlen(r.typeCode) > 2000 {
		return localVarReturnValue, nil, reportError("typeCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
